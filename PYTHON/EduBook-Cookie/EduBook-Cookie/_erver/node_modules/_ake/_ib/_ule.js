* ArrayBindingPattern */:
      case 262 /* FunctionDeclaration */:
      case 218 /* FunctionExpression */:
      case 219 /* ArrowFunction */:
      case 174 /* MethodDeclaration */:
        return `${getNodeId(node)}#${getTypeId(declaredType)}`;
    }
    return void 0;
  }
  function isMatchingReference(source, target) {
    switch (target.kind) {
      case 217 /* ParenthesizedExpression */:
      case 235 /* NonNullExpression */:
        return isMatchingReference(source, target.expression);
      case 226 /* BinaryExpression */:
        return isAssignmentExpression(target) && isMatchingReference(source, target.left) || isBinaryExpression(target) && target.operatorToken.kind === 28 /* CommaToken */ && isMatchingReference(source, target.right);
    }
    switch (source.kind) {
      case 236 /* MetaProperty */:
        return target.kind === 236 /* MetaProperty */ && source.keywordToken === target.keywordToken && source.name.escapedText === target.name.escapedText;
      case 80 /* Identifier */:
      case 81 /* PrivateIdentifier */:
        return isThisInTypeQuery(source) ? target.kind === 110 /* ThisKeyword */ : target.kind === 80 /* Identifier */ && getResolvedSymbol(source) === getResolvedSymbol(target) || (isVariableDeclaration(target) || isBindingElement(target)) && getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source)) === getSymbolOfDeclaration(target);
      case 110 /* ThisKeyword */:
        return target.kind === 110 /* ThisKeyword */;
      case 108 /* SuperKeyword */:
        return target.kind === 108 /* SuperKeyword */;
      case 235 /* NonNullExpression */:
      case 217 /* ParenthesizedExpression */:
        return isMatchingReference(source.expression, target);
      case 211 /* PropertyAccessExpression */:
      case 212 /* ElementAccessExpression */:
        const sourcePropertyName = getAccessedPropertyName(source);
        const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : void 0;
        return sourcePropertyName !== void 0 && targetPropertyName !== void 0 && targetPropertyName === sourcePropertyName && isMatchingReference(source.expression, target.expression);
      case 166 /* QualifiedName */:
        return isAccessExpression(target) && source.right.escapedText === getAccessedPropertyName(target) && isMatchingReference(source.left, target.expression);
      case 226 /* BinaryExpression */:
        return isBinaryExpression(source) && source.operatorToken.kind === 28 /* CommaToken */ && isMatchingReference(source.right, target);
    }
    return false;
  }
  function getAccessedPropertyName(access) {
    if (isPropertyAccessExpression(access)) {
      return access.name.escapedText;
    }
    if (isElementAccessExpression(access)) {
      return tryGetElementAccessExpressionName(access);
    }
    if (isBindingElement(access)) {
      const name = getDestructuringPropertyName(access);
      return name ? escapeLeadingUnderscores(name) : void 0;
    }
    if (isParameter(access)) {
      return "" + access.parent.parameters.indexOf(access);
    }
    return void 0;
  }
  function tryGetNameFromType(type) {
    return type.flags & 8192 /* UniqueESSymbol */ ? type.escapedName : type.flags & 384 /* StringOrNumberLiteral */ ? escapeLeadingUnderscores("" + type.value) : void 0;
  }
  function tryGetElementAccessExpressionName(node) {
    return isStringOrNumericLiteralLike(node.argumentExpression) ? escapeLeadingUnderscores(node.argumentExpression.text) : isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : void 0;
  }
  function tryGetNameFromEntityNameExpression(node) {
    const symbol = resolveEntityName(
      node,
      111551 /* Value */,
      /*ignoreErrors*/
      true
    );
    if (!symbol || !(isConstantVariable(symbol) || symbol.flags & 8 /* EnumMember */))
      return void 0;
    const declaration = symbol.valueDeclaration;
    if (declaration === void 0)
      return void 0;
    const type = tryGetTypeFromEffectiveTypeNode(declaration);
    if (type) {
      const name = tryGetNameFromType(type);
      if (name !== void 0) {
        return name;
      }
    }
    if (hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node)) {
      const initializer = getEffectiveInitializer(declaration);
      if (initializer) {
        const initializerType = isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration) : getTypeOfExpression(initializer);
        return initializerType && tryGetNameFromType(initializerType);
      }
      if (isEnumMember(declaration)) {
        return getTextOfPropertyName(declaration.name);
      }
    }
    return void 0;
  }
  function containsMatchingReference(source, target) {
    while (isAccessExpression(source)) {
      source = source.expression;
      if (isMatchingReference(source, target)) {
        return true;
      }
    }
    return false;
  }
  function optionalChainContainsReference(source, target) {
    while (isOptionalChain(source)) {
      source = source.expression;
      if (isMatchingReference(source, target)) {
        return true;
      }
    }
    return false;
  }
  function isDiscriminantProperty(type, name) {
    if (type && type.flags & 1048576 /* Union */) {
      const prop = getUnionOrIntersectionProperty(type, name);
      if (prop && getCheckFlags(prop) & 2 /* SyntheticProperty */) {
        if (prop.links.isDiscriminantProperty === void 0) {
          prop.links.isDiscriminantProperty = (prop.links.checkFlags & 192 /* Discriminant */) === 192 /* Discriminant */ && !isGenericType(getTypeOfSymbol(prop));
        }
        return !!prop.links.isDiscriminantProperty;
      }
    }
    return false;
  }
  function findDiscriminantProperties(sourceProperties, target) {
    let result;
    for (const sourceProperty of sourceProperties) {
      if (isDiscriminantProperty(target, sourceProperty.escapedName)) {
        if (result) {
          result.push(sourceProperty);
          continue;
        }
        result = [sourceProperty];
      }
    }
    return result;
  }
  function mapTypesByKeyProperty(types, name) {
    const map2 = /* @__PURE__ */ new Map();
    let count = 0;
    for (const type of types) {
      if (type.flags & (524288 /* Object */ | 2097152 /* Intersection */ | 58982400 /* InstantiableNonPrimitive */)) {
        const discriminant = getTypeOfPropertyOfType(type, name);
        if (discriminant) {
          if (!isLiteralType(discriminant)) {
            return void 0;
          }
          let duplicate = false;
          forEachType(discriminant, (t) => {
            const id = getTypeId(getRegularTypeOfLiteralType(t));
            const existing = map2.get(id);
            if (!existing) {
              map2.set(id, type);
            } else if (existing !== unknownType) {
              map2.set(id, unknownType);
              duplicate = true;
            }
          });
          if (!duplicate)
            count++;
        }
      }
    }
    return count >= 10 && count * 2 >= types.length ? map2 : void 0;
  }
  function getKeyPropertyName(unionType) {
    const types = unionType.types;
    if (types.length < 10 || getObjectFlags(unionType) & 32768 /* PrimitiveUnion */ || countWhere(types, (t) => !!(t.flags & (524288 /* Object */ | 58982400 /* InstantiableNonPrimitive */))) < 10) {
      return void 0;
    }
    if (unionType.keyPropertyName === void 0) {
      const keyPropertyName = forEach(types, (t) => t.flags & (524288 /* Object */ | 58982400 /* InstantiableNonPrimitive */) ? forEach(getPropertiesOfType(t), (p) => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : void 0) : void 0);
      const mapByKeyProperty = keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName);
      unionType.keyPropertyName = mapByKeyProperty ? keyP