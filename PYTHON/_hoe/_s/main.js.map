  *
     * The following illustrates a client for the echo server example from {@link createServer}:
     *
     * ```js
     * // Assumes an echo server that is listening on port 8000.
     * const tls = require('node:tls');
     * const fs = require('node:fs');
     *
     * const options = {
     *   // Necessary only if the server requires client certificate authentication.
     *   key: fs.readFileSync('client-key.pem'),
     *   cert: fs.readFileSync('client-cert.pem'),
     *
     *   // Necessary only if the server uses a self-signed certificate.
     *   ca: [ fs.readFileSync('server-cert.pem') ],
     *
     *   // Necessary only if the server's cert isn't for "localhost".
     *   checkServerIdentity: () => { return null; },
     * };
     *
     * const socket = tls.connect(8000, options, () => {
     *   console.log('client connected',
     *               socket.authorized ? 'authorized' : 'unauthorized');
     *   process.stdin.pipe(socket);
     *   process.stdin.resume();
     * });
     * socket.setEncoding('utf8');
     * socket.on('data', (data) => {
     *   console.log(data);
     * });
     * socket.on('end', () => {
     *   console.log('server ends connection');
     * });
     * ```
     * @since v0.11.3
     */
    function connect(options: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;
    function connect(
        port: number,
        host?: string,
        options?: ConnectionOptions,
        secureConnectListener?: () => void,
    ): TLSSocket;
    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;
    /**
     * Creates a new secure pair object with two streams, one of which reads and writes
     * the encrypted data and the other of which reads and writes the cleartext data.
     * Generally, the encrypted stream is piped to/from an incoming encrypted data
     * stream and the cleartext one is used as a replacement for the initial encrypted
     * stream.
     *
     * `tls.createSecurePair()` returns a `tls.SecurePair` object with `cleartext` and`encrypted` stream properties.
     *
     * Using `cleartext` has the same API as {@link TLSSocket}.
     *
     * The `tls.createSecurePair()` method is now deprecated in favor of`tls.TLSSocket()`. For example, the code:
     *
     * ```js
     * pair = tls.createSecurePair(// ... );
     * pair.encrypted.pipe(socket);
     * socket.pipe(pair.encrypted);
     * ```
     *
     * can be replaced by:
     *
     * ```js
     * secureSocket = tls.TLSSocket(socket, options);
     * ```
     *
     * where `secureSocket` has the same API as `pair.cleartext`.
     * @since v0.3.2
     * @deprecated Since v0.11.3 - Use {@link TLSSocket} instead.
     * @param context A secure context object as returned by `tls.createSecureContext()`
     * @param isServer `true` to specify that this TLS connection should be opened as a server.
     * @param requestCert `true` to specify whether a server should request a certificate from a connecting client. Only applies when `isServer` is `true`.
     * @param rejectUnauthorized If not `false` a server automatically reject clients with invalid certificates. Only applies when `isServer` is `true`.
     */
    function createSecurePair(
        context?: SecureContext,
        isServer?: boolean,
        requestCert?: boolean,
        rejectUnauthorized?: boolean,
    ): SecurePair;
    /**
     * {@link createServer} sets the default value of the `honorCipherOrder` option
     * to `true`, other APIs that create secure contexts leave it unset.
     *
     * {@link createServer} uses a 128 bit truncated SHA1 hash value generated
     * from `process.argv` as the default value of the `sessionIdContext` option, other
     * APIs that create secure contexts have no default value.
     *
     * The `tls.createSecureContext()` method creates a `SecureContext` object. It is
     * usable as an argument to several `tls` APIs, such as `server.addContext()`,
     * but has no public methods. The {@link Server} constructor and the {@link createServer} method do not support the `secureContext` option.
     *
     * A key is _required_ for ciphers that use certificates. Either `key` or`pfx` can be used to provide it.
     *
     * If the `ca` option is not given, then Node.js will default to using [Mozilla's publicly trusted list of
     * CAs](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt).
     *
     * Custom DHE parameters are discouraged in favor of the new `dhparam: 'auto'`option. When set to `'auto'`, well-known DHE parameters of sufficient strength
     * will be selected automatically. Otherwise, if necessary, `openssl dhparam` can
     * be used to create custom parameters. The key length must be greater than or
     * equal to 1024 bits or else an error will be thrown. Although 1024 bits is
     * permissible, use 2048 bits or larger for stronger security.
     * @since v0.11.13
     */
    function createSecureContext(options?: SecureContextOptions): SecureContext;
    /**
     * Returns an array with the names of the supported TLS ciphers. The names are
     * lower-case for historical reasons, but must be uppercased to be used in
     * the `ciphers` option of {@link createSecureContext}.
     *
     * Not all supported ciphers are enabled by default. See `Modifying the default TLS cipher suite`.
     *
     * Cipher names that start with `'tls_'` are for TLSv1.3, all the others are for
     * TLSv1.2 and below.
     *
     * ```js
     * console.log(tls.getCiphers()); //