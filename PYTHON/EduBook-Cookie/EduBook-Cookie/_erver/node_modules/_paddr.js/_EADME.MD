 = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & 16777216 /* Optional */);
            targetPropType = removeMissingType(targetPropType, targetIsOptional);
            sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
            const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
            if (result && specificSource !== sourcePropType) {
              checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
            }
          }
        }
      }
    }
    return reportedError;
  }
  function* generateJsxAttributes(node) {
    if (!length(node.properties))
      return;
    for (const prop of node.properties) {
      if (isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name)))
        continue;
      yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) };
    }
  }
  function* generateJsxChildren(node, getInvalidTextDiagnostic) {
    if (!length(node.children))
      return;
    let memberOffset = 0;
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      const nameType = getNumberLiteralType(i - memberOffset);
      const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);
      if (elem) {
        yield elem;
      } else {
        memberOffset++;
      }
    }
  }
  function getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic) {
    switch (child.kind) {
      case 294 /* JsxExpression */:
        return { errorNode: child, innerExpression: child.expression, nameType };
      case 12 /* JsxText */:
        if (child.containsOnlyTriviaWhiteSpaces) {
          break;
        }
        return { errorNode: child, innerExpression: void 0, nameType, errorMessage: getInvalidTextDiagnostic() };
      case 284 /* JsxElement */:
      case 285 /* JsxSelfClosingElement */:
      case 288 /* JsxFragment */:
        return { errorNode: child, innerExpression: child, nameType };
      default:
        return Debug.assertNever(child, "Found invalid jsx child");
    }
  }
  function elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer) {
    let result = elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer);
    let invalidTextDiagnostic;
    if (isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent)) {
      const containingElement = node.parent.parent;
      const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
      const childrenPropName = childPropName === void 0 ? "children" : unescapeLeadingUnderscores(childPropName);
      const childrenNameType = getStringLiteralType(childrenPropName);
      const childrenTargetType = getIndexedAccessType(target, childrenNameType);
      const validChildren = getSemanticJsxChildren(containingElement.children);
      if (!length(validChildren)) {
        return result;
      }
      const moreThanOneRealChildren = length(validChildren) > 1;
      let arrayLikeTargetParts;
      let nonArrayLikeTargetParts;
      const iterableType = getGlobalIterableType(
        /*reportErrors*/
        false
      );
      if (iterableType !== emptyGenericType) {
        const anyIterable = createIterableType(anyType);
        arrayLikeTargetParts = filterType(childrenTargetType, (t) => isTypeAssignableTo(t, anyIterable));
        nonArrayLikeTargetParts = filterType(childrenTargetType, (t) => !isTypeAssignableTo(t, anyIterable));
      } else {
        arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType);
        nonArrayLikeTargetParts = filterType(childrenTargetType, (t) => !isArrayOrTupleLikeType(t));
      }
      if (moreThanOneRealChildren) {
        if (arrayLikeTargetParts !== neverType) {
          const realSource = createTupleType(checkJsxChildren(containingElement, 0 /* Normal */));
          const children = generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic);
          result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result;
        } else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
          result = true;
          const diag2 = error2(
            containingElement.openingElement.tagName,
            Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided,
            childrenPropName,
            typeToString(childrenTargetType)
          );
          if (errorOutputContainer && errorOutputContainer.skipLogging) {
            (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag2);
          }
        }
      } else {
        if (nonArrayLikeTargetParts !== neverType) {
          const child = validChildren[0];
          const elem = getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic);
          if (elem) {
            result = elaborateElementwise(
              function* () {
                yield elem;
              }(),
              source,
              target,
              relation,
              containingMessageChain,
              errorOutputContainer
            ) || result;
          }
        } else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
          result = true;
          const diag2 = error2(
            containingElement.openingElement.tagName,
            Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided,
            childrenPropName,
            typeToString(childrenTargetType)
          );
          if (errorOutputContainer && errorOutputContainer.skipLogging) {
            (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag2);
          }
        }
      }
    }
    return result;
    function getInvalidTextualChildDiagnostic() {
      if (!invalidTextDiagnostic) {
        const tagNameText = getTextOfNode(node.parent.tagName);
        const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
        const childrenPropName = childPropName === void 0 ? "children" : unescapeLeadingUnderscores(childPropName);
        const childrenTargetType = getIndexedAccessType(target, getStringLiteralType(childrenPropName));
        const diagnostic = Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
        invalidTextDiagnostic = { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) };
      }
      return invalidTextDiagnostic;
    }
  }
  function* generateLimitedTupleElements(node, target) {
    const len = length(node.elements);
    if (!len)
      return;
    for (let i = 0; i < len; i++) {
      if (isTupleLikeType(target) && !getPropertyOfType(target, "" + i))
        continue;
      const elem = node.elements[i];
      if (isOmittedExpression(elem))
        continue;
      const nameType = getNumberLiteralType(i);
      const checkNode = getEffectiveCheckNode(elem);
      yield { errorNode: checkNode, innerExpression: checkNode, nameType };
    }
  }
  function elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
    if (target.flags & (402784252 /* Primitive */ | 131072 /* Never */))
      return false;
    if (isTupleLikeType(source)) {
      return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
    }
    pushContextualType(
      node,
      target,
      /*isCache*/
      false
    );
    const tupleizedType = checkArrayLiteral(
      node,
      1 /* Contextual */,
      /*forceTuple*/
      true
    );
    popContextualTyp