 clauseStart, clauseEnd) {
      const defaultIndex = findIndex(switchStatement.caseBlock.clauses, (clause) => clause.kind === 297 /* DefaultClause */);
      const hasDefaultClause = clauseStart === clauseEnd || defaultIndex >= clauseStart && defaultIndex < clauseEnd;
      for (let i = 0; i < clauseStart; i++) {
        const clause = switchStatement.caseBlock.clauses[i];
        if (clause.kind === 296 /* CaseClause */) {
          type = narrowType(
            type,
            clause.expression,
            /*assumeTrue*/
            false
          );
        }
      }
      if (hasDefaultClause) {
        for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {
          const clause = switchStatement.caseBlock.clauses[i];
          if (clause.kind === 296 /* CaseClause */) {
            type = narrowType(
              type,
              clause.expression,
              /*assumeTrue*/
              false
            );
          }
        }
        return type;
      }
      const clauses = switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd);
      return getUnionType(map(clauses, (clause) => clause.kind === 296 /* CaseClause */ ? narrowType(
        type,
        clause.expression,
        /*assumeTrue*/
        true
      ) : neverType));
    }
    function isMatchingConstructorReference(expr) {
      return (isPropertyAccessExpression(expr) && idText(expr.name) === "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") && isMatchingReference(reference, expr.expression);
    }
    function narrowTypeByConstructor(type, operator, identifier, assumeTrue) {
      if (assumeTrue ? operator !== 35 /* EqualsEqualsToken */ && operator !== 37 /* EqualsEqualsEqualsToken */ : operator !== 36 /* ExclamationEqualsToken */ && operator !== 38 /* ExclamationEqualsEqualsToken */) {
        return type;
      }
      const identifierType = getTypeOfExpression(identifier);
      if (!isFunctionType(identifierType) && !isConstructorType(identifierType)) {
        return type;
      }
      const prototypeProperty = getPropertyOfType(identifierType, "prototype");
      if (!prototypeProperty) {
        return type;
      }
      const prototypeType = getTypeOfSymbol(prototypeProperty);
      const candidate = !isTypeAny(prototypeType) ? prototypeType : void 0;
      if (!candidate || candidate === globalObjectType || candidate === globalFunctionType) {
        return type;
      }
      if (isTypeAny(type)) {
        return candidate;
      }
      return filterType(type, (t) => isConstructedBy(t, candidate));
      function isConstructedBy(source, target) {
        if (source.flags & 524288 /* Object */ && getObjectFlags(source) & 1 /* Class */ || target.flags & 524288 /* Object */ && getObjectFlags(target) & 1 /* Class */) {
          return source.symbol === target.symbol;
        }
        return isTypeSubtypeOf(source, target);
      }
    }
    function narrowTypeByInstanceof(type, expr, assumeTrue) {
      const left = getReferenceCandidate(expr.left);
      if (!isMatchingReference(reference, left)) {
        if (assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference)) {
          return getAdjustedTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */);
        }
        return type;
      }
      const right = expr.right;
      const rightType = getTypeOfExpression(right);
      if (!isTypeDerivedFrom(rightType, globalObjectType)) {
        return type;
      }
      const signature = getEffectsSignature(expr);
      const predicate = signature && getTypePredicateOfSignature(signature);
      if (predicate && predicate.kind === 1 /* Identifier */ && predicate.parameterIndex === 0) {
        return getNarrowedType(
          type,
          predicate.type,
          assumeTrue,
          /*checkDerived*/
          true
        );
      }
      if (!isTypeDerivedFrom(rightType, globalFunctionType)) {
        return type;
      }
      const instanceType = mapType(rightType, getInstanceType);
      if (isTypeAny(type) && (instanceType === globalObjectType || instanceType === globalFunctionType) || !assumeTrue && !(instanceType.flags & 524288 /* Object */ && !isEmptyAnonymousObjectType(instanceType))) {
        return type;
      }
      return getNarrowedType(
        type,
        instanceType,
        assumeTrue,
        /*checkDerived*/
        true
      );
    }
    function getInstanceType(constructorType) {
      const prototypePropertyType = getTypeOfPropertyOfType(constructorType, "prototype");
      if (prototypePropertyType && !isTypeAny(prototypePropertyType)) {
        return prototypePropertyType;
      }
      const constructSignatures = getSignaturesOfType(constructorType, 1 /* Construct */);
      if (constructSignatures.length) {
        return getUnionType(map(constructSignatures, (signature) => getReturnTypeOfSignature(getErasedSignature(signature))));
      }
      return emptyObjectType;
    }
    function getNarrowedType(type, candidate, assumeTrue, checkDerived) {
      const key2 = type.flags & 1048576 /* Union */ ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : void 0;
      return getCachedType(key2) ?? setCachedType(key2, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived));
    }
    function getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived) {
      if (!assumeTrue) {
        if (type === candidate) {
          return neverType;
        }
        if (checkDerived) {
          return filterType(type, (t) => !isTypeDerivedFrom(t, candidate));
        }
        const trueType2 = getNarrowedType(
          type,
          candidate,
          /*assumeTrue*/
          true,
          /*checkDerived*/
          false
        );
        return filterType(type, (t) => !isTypeSubsetOf(t, trueType2));
      }
      if (type.flags & 3 /* AnyOrUnknown */) {
        return candidate;
      }
      if (type === candidate) {
        return candidate;
      }
      const isRelated = checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf;
      const keyPropertyName = type.flags & 1048576 /* Union */ ? getKeyPropertyName(type) : void 0;
      const narrowedType = mapType(candidate, (c) => {
        const discriminant = keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName);
        const matching = discriminant && getConstituentTypeForKeyType(type, discriminant);
        const directlyRelated = mapType(
          matching || type,
          checkDerived ? (t) => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType : (t) => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType
        );
        return directlyRelated.flags & 131072 /* Never */ ? mapType(type, (t) => maybeTypeOfKind(t, 465829888 /* Instantiable */) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) : directlyRelated;
      });
      return !(narrowedType.flags & 131072 /* Never */) ? narrowedType : isTypeSubtypeOf(candidate, type) ? candidate : isTypeAssignableTo(type, candidate) ? type : isTypeAssignableTo(candidate, type) ? candidate : getIntersectionType([type, candidate]);
    }
    function narrowTypeByCallExpression(type, callExpression, assumeTrue) {
      if (hasMatchingArgument(callExpression, reference)) {
        const signature = assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : void 0;
        const predicate = signature && getTypePredicateOfSignature(signature);
        if (predicate && (predicate.kind === 0 /* This */ || predicate.kind === 1 /* Identifier */)) {
          return narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue);
        }
      }
      if (containsMissingType(type) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression)) {
        const callAccess = callExpression.expression;
        if (isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText === "hasOwnProperty" && callExpression.arguments.length === 1) {
          const argument = callExpression.arguments[0];
          if (isStringLiteralLike(argument) && getAccessedPropertyName(reference) === escapeLeadingUnderscores(argument.text)) {
            return getTypeWithFacts(type, assumeTrue ? 524288 /* NEUndefined */ : 65536 /* EQUndefined */);
          }
        }
      }
      return type;
    }
    function narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue) {
      if (predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))) {
        const predicateArgument = getTypePredicateArgument(predicate, callExpression);
        if (predicateArgument) {
          if (isMatchingReference(reference, predicateArgument)) {
            return getNarrowedType(
              type,
              predicate.type,
              assumeTrue,
              /*checkDerived*/
              false
            );
          }
          if (strictNullChecks && optionalChainContainsReference(predicateArgument, reference) && (assumeTrue && !hasTypeFacts(predicate.type, 65536 /* EQUndefined */) || !assumeTrue && everyType(predicate.type, isNullableType))) {
            type = getAdjustedTypeWithFacts(type, 2097152 /* NEUndefinedOrNull */);
          }
          const access = getDiscriminantPropertyAccess(predicateArgument, type);
          if (access) {
            return narrowTypeByDiscriminant(type, access, (t) => getNarrowedType(
              t,
              predicate.type,
              assumeTrue,
              /*checkDerived*/
              false
            ));
          }
        }
      }
      return type;
    }
    function narrowType(type, expr, assumeTrue) {
      if (isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind === 61 /* QuestionQuestionToken */ || expr.parent.operatorToken.kind === 78 /* QuestionQuestionEqualsToken */) && expr.parent.left === expr) {
        return narrowTypeByOptionality(type, expr, assumeTrue);
      }
      switch (expr.kind) {
        case 80 /* Identifier */:
          if (!isMatchingReference(reference, expr) && inlineLevel < 5) {
            const symbol = getResolvedSymbol(expr);
            if (isConstantVariable(symbol)) {
              const declaration = symbol.valueDeclaration;
              if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {
                inlineLevel++;
                const result = narrowType(type, declaration.initializer, assumeTrue);
                inlineLevel--;
                return result;
              }
            }
          }
        case 110 /* ThisKeyword */:
        case 108 /* SuperKeyword */:
        case 211 /* PropertyAccessExpression */:
        case 212 /* ElementAccessExpression */:
          return narrowTypeByTruthiness(type, expr, assumeTrue);
        case 213 /* CallExpression */:
          return narrowTypeByCallExpression(type, expr, assumeTrue);
        case 217 /* ParenthesizedExpression */:
        case 235 /* NonNullExpression */:
          return narrowType(type, expr.expression, assumeTrue);
        case 226 /* BinaryExpression */:
          return narrowTypeByBinaryExpression(type, expr, assumeTrue);
        case 224 /* PrefixUnaryExpression */:
          if (expr.operator === 54 /* ExclamationToken */) {
            return narrowType(type, expr.operand, !assumeTrue);
          }
          break;
      }
      return type;
    }
    function narrowTypeByOptionality(type, expr, assumePresent) {
      if (isMatchingRefe