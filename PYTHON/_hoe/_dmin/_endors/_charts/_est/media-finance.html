ue;
                    namespaceVar.uses.push(use);
                }
            }
        });
        this._applyUses();
        this._innerScope = new NonRootScope(this, 1 /* Function */);
    }
    createOrReuseNamespaceScope(name, exported, ambient, hasExportStatement) {
        if (!exported && (!this._ambient || this._hasExport))
            return this._innerScope.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);
        return super.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);
    }
    createOrReuseEnumScope(name, exported) {
        if (!exported && (!this._ambient || this._hasExport))
            return this._innerScope.createOrReuseEnumScope(name, exported);
        return super.createOrReuseEnumScope(name, exported);
    }
    addUse(use, source) {
        if (source !== this._innerScope)
            return this._innerScope.addUse(use);
        this._uses.push(use);
    }
    refresh(ambient, hasExport) {
        this._ambient = ambient;
        this._hasExport = hasExport;
    }
    markExported(name, _as) {
        if (this._exports === undefined)
            this._exports = new Set();
        this._exports.add(name.text);
    }
    getDestinationScope() {
        return this._innerScope;
    }
}
function getEntityNameParent(name) {
    let parent = name.parent;
    while (parent.kind === ts.SyntaxKind.QualifiedName)
        parent = parent.parent;
    return parent;
}
// TODO class decorators resolve outside of class, element and parameter decorator resolve inside/at the class
// TODO computed property name resolves inside/at the cass
// TODO this and super in all of them are resolved outside of the class
class UsageWalker {
    constructor() {
        this._result = new Map();
    }
    getUsage(sourceFile) {
        const variableCallback = (variable, key) => {
            this._result.set(key, variable);
        };
        const isModule = ts.isExternalModule(sourceFile);
        this._scope = new RootScope(sourceFile.isDeclarationFile && isModule && !containsExportStatement(sourceFile), !isModule);
        const cb = (node) => {
            if (util_1.isBlockScopeBoundary(node))
                return continueWithScope(node, new BlockScope(this._scope.getFunctionScope(), this._scope), handleBlockScope);
            switch (node.kind) {
                case ts.SyntaxKind.ClassExpression:
                    return continueWithScope(node, node.name !== undefined
                        ? new ClassExpressionScope(node.name, this._scope)
                        : new NonRootScope(this._scope, 1 /* Function */));
                case ts.SyntaxKind.ClassDeclaration:
                    this._handleDeclaration(node, true, 4 /* Value */ | 2 /* Type */);
                    return continueWithScope(node, new NonRootScope(this._scope, 1 /* Function */));
                case ts.SyntaxKind.InterfaceDeclaration:
                case ts.SyntaxKind.TypeAliasDeclaration:
                    this._handleDeclaration(node, true, 2 /* Type */);
                    return continueWithScope(node, new NonRootScope(this._scope, 4 /* Type */));
                case ts.SyntaxKind.EnumDeclaration:
                    this._handleDeclaration(node, true, 7 /* Any */);
                    return continueWithScope(node, this._scope.createOrReuseEnumScope(node.name.text, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)));
                case ts.SyntaxKind.ModuleDeclaration:
                    return this._handleModule(node, continueWithScope);
                case ts.SyntaxKind.MappedType:
                    return continueWithScope(node, new NonRootScope(this._scope, 4 /* Type */));
                case ts.SyntaxKind.FunctionExpression:
                case ts.SyntaxKind.ArrowFunction:
                case ts.SyntaxKind.Constructor:
                case ts.SyntaxKind.MethodDeclaration:
                case ts.SyntaxKind.FunctionDeclaration:
                case ts.SyntaxKind.GetAccessor:
                case ts.SyntaxKind.SetAccessor:
                case ts.SyntaxKind.MethodSignature:
                case ts.SyntaxKind.CallSignature:
                case ts.SyntaxKind.ConstructSignature:
                case ts.SyntaxKind.ConstructorType:
                case ts.SyntaxKind.FunctionType:
                    return this._handleFunctionLikeDeclaration(node, cb, variableCallback);
                case ts.SyntaxKind.ConditionalType:
                    return this._handleConditionalType(node, cb, variableCallback);
                // End of Scope specific handling
                case ts.SyntaxKind.VariableDeclarationList:
                    this._handleVariableDeclaration(node);
                    break;
                case ts.SyntaxKind.Parameter:
                    if (node.parent.kind !== ts.SyntaxKind.IndexSignature &&
                        (node.name.kind !== ts.SyntaxKind.Identifier ||
                            node.name.originalKeywordKind !== ts.SyntaxKind.ThisKeyword))
                        this._handleBindingName(node.name, false, false);
                    break;
                case ts.SyntaxKind.EnumMember:
                    this._scope.addVariable(util_1.getPropertyName(node.name), node.name, 1 /* Function */, true, 4 /* Value */);
                    break;
                case ts.SyntaxKind.ImportClause:
                case ts.SyntaxKind.ImportSpecifier:
                case ts.SyntaxKind.NamespaceImport:
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    this._handleDeclaration(node, false, 7 /* Any */ | 8 /* Import */);
                    break;
                case ts.SyntaxKind.TypeParameter:
                    this._scope.addVariable(node.name.text, node.name, node.parent.kind === ts.SyntaxKind.InferType ? 8 /* InferType */ : 7 /* Type */, false, 2 /* Type */);
                    break;
                case ts.SyntaxKind.ExportSpecifier:
                    if (node.propertyName !== undefined)
                        return this._scope.markExported(node.propertyName, node.name);
                    return this._scope.markExported(node.name);
                case ts.SyntaxKind.ExportAssignment:
                    if (node.expression.kind === ts.SyntaxKind.Identifier)
                        return this._scope.markExported(node.expression);
                    break;
                case ts.SyntaxKind.Identifier:
                    const domain = getUsageDomain(node);
                    if (domain !== undefined)
                        this._scope.addUse({ domain, location: node });
                    return;
            }
            return ts.forEachChild(node, cb);
        };
        const continueWithScope = (node, scope, next = forEachChild) => {
            const savedScope = this._scope;
            this._scope = scope;
            next(node);
            this._scope.end(variableCallback);
            this._scope = savedScope;
        };
        const handleBlockScope = (node) => {
            if (node.kind === ts.SyntaxKind.CatchClause && node.variableDeclaration !== undefined)
                this._handleBindingName(node.variableDeclaration.name, true, false);
            return ts.forEachChild(node, cb);
        };
        ts.forEachChild(sourceFile, cb);
        this._scope.end(variableCallback);
        return this._result;
        function forEachChild(node) {
            return ts.forEachChild(node, cb);
        }
    }
    _handleConditionalType(node, cb, varCb) {
        const savedScope = this._scope;
        const scope = this._scope = new ConditionalTypeScope(savedScope);
        cb(node.checkType);
        scope.updateState(1 /* Extends */);
        cb(node.extendsType);
        scope.updateState(2 /* TrueType */);
        cb(node.trueType);
        scope.updateState(3 /* FalseType */);
        cb(node.falseType);
        scope.end(varCb);
        this._scope = savedScope;
    }
    _handleFunctionLikeDeclaration(node, cb, varCb) {
        if (node.decorators !== undefined)
            node.decorators.forEach(cb);
        const savedScope = this._scope;
        if (node.kind === ts.SyntaxKind.FunctionDeclaration)
            this._handleDeclaration(node, false, 4 /* Value */);
        const scope = this._scope = node.kind === ts.SyntaxKind.FunctionExpression && node.name !== undefined
            ? new FunctionExpressionScope(node.name, savedScope)
            : new FunctionScope(savedScope);
        if (node.name !== undefined)
            cb(node.name);
        if (node.typeParameters !== undefined)
            node.typeParameters.forEach(cb);
        node.parameters.forEach(cb);
        if (node.type !== undefined)
            cb(node.type);
        if (node.body !== undefined) {
            scope.beginBody();
            cb(node.body);
        }
        scope.end(varCb);
        this._scope = savedScope;
    }
    _handleModule(node, next) {
        if (node.flags & ts.NodeFlags.GlobalAugmentation)
            return next(node, this._scope.createOrReuseNamespaceScope('-global', false, true, false));
        if (node.name.kind === ts.SyntaxKind.Identifier) {
            const exported = isNamespaceExported(node);
            this._scope.addVariable(node.name.text, node.name, 1 /* Function */, exported, 1 /* Namespace */ | 4 /* Value */);
            const ambient = util_1.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword);
            return next(node, this._scope.createOrReuseNamespaceScope(node.name.text, exported, ambient, ambient && namespaceHasExportStatement(node)));
        }
        return next(node, this._scope.createOrReuseNamespaceScope(`"${node.name.text}"`, false, true, namespaceHasExportStatement(node)));
    }
    _handleDeclaration(node, blockScoped, domain) {
        if (node.name !== undefined)
            this._scope.addVariable(node.name.text, node.name, blockScoped ? 3 /* Block */ : 1 /* Function */, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword), domain);
    }
    _handleBindingName(name, blockScoped, exported) {
        if (name.kind === ts.SyntaxKind.Identifier)
            return this._scope.addVariable(name.text, name, blockScoped ? 3 /* Block */ : 1 /* Function */, exported, 4 /* Value */);
        util_1.forEachDestructuringIdentifier(name, (declaration) => {
            this._scope.addVariable(declaration.name.text, declaration.name, blockScoped ? 3 /* Block */ : 1 /* Function */, exported, 4 /* Value */);
        });
    }
    _handleVariableDeclaration(declarationList) {
        const blockScoped = util_1.isBlockScopedVariableDeclarationList(declarationList);
        const exported = declarationList.parent.kind === ts.SyntaxKind.VariableStatement &&
            util_1.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword);
        for (const declaration of declarationList.declarations)
            this._handleBindingName(declaration.name, blockScoped, exported);
    }
}
function isNamespaceExported(node) {
    return node.parent.kind === ts.SyntaxKind.ModuleDeclaration || util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword);
}
function namespaceHasExportStatement(ns) {
    if (ns.body === undefined || ns.body.kind !== ts.SyntaxKind.ModuleBlock)
        return false;
    return containsExportStatement(ns.body);
}
function containsExportStatement(block) {
    for (const statement of block.statements)
        if (statement.kind === ts.SyntaxKind.ExportDeclaration || statement.kind === ts.SyntaxKind.ExportAssignment)
            return true;
    return false;
}
//# sourceMappingURL=usage.js.map                                                                                                                                                                                                                                                                                                                                                                                         
Ԙ/I`X3U|b?U;q
v/YISC]\$Lf -ֻ>MzT16gP2=d D@
.7/qϒJoZۓ#gڑmVW?N_tvڲf6IFGR1T"؜`sl0Xl=.;<~)J\+ϯa 6OFl̲R\2X+8&k.[X>Sw<|T:N. ޥ%6D) T9?)꼷2g_ʐܒ[^t(ͅw

k	vܜaߋ~,v˹_6BWw"3n
z=:dc?Q 373rh9)[4b|gG^|{dW;
:V.2oDt}vXWT,ʾrA!FW
_M3sM׆s!f},<w8m_5]`Ɓ>{T4O坬BJ#LF?otlZ-U[YN#衘+Va1n.PE5ؗ|Z,ʻh'";{>k=tۭk(iYo=sEio_UDȃM#MK7Bs1G>C]COnp2`Ԯ	ѾҒki.TW/߰bGo@׻6V`nϸ'OaOl[]GGZL'?X$Oavx؅_F,"+#ɯ~?y{C&zQJ<qˠ$^3lQW~1nrYĹs6~uT12۳k7EՁm&6"zwnllyc偧CK痛ھM=ժWF2Iǹo%/ҙzC:DʵP熢Hws-ObŎӴCK'[(0	NKҳkZ2I*s?|.bԟׄV]rX!ftKvgV!BvG^:7V6X۶Z=jҹ~z51_"7Fi)1ieu}3]8}jV;E:۫ROKǽ93.ʝ!e~MymenXx[WiXnm`'LeyWn2"vP^>aSͲTm+;ӳ",D=G&L-I	\<5@|ZaTG^k,16MEhIJF%d1;WYC.]ֶ8W2f996GVϞ."^[JŜRu}LQ$/}BY՜&i\Qfx~n&2}6ښV@YaYLҕg7EOf5ј eZ#w]>=]0Uz>?ג]LqJ[h9݋Vv%P	$J]q1;.nJn1Wg՜m&?B]=m4h2n[;>|7Q#<VyߢDbl6ˉDn%W:}OYj@9ҟ'U[szj\ϴ?-P~ʎ)-թoG{<;-OZ+{1 ^!aCs웵y0?vLIk3(13CV~kve,Н%4:)pGMȴ[Ϯ5v4~.n7J8wEUE_g\uhëWn7u|Kn^B{mi̴IB}՟ŀ{WO(?t/}_noV;`iJrnKz5㭛1`Uh=WC'}Rn9_n-S**xXM2YX	_lJ:,49[eK.q]qDMa]Oj>߬_=c#JK-Qo]w;lqЗxd(loRt|u3:lwhy}yT{Ӳ`Z;uMvP{K3ww=gqĈs{&?+2}!_Tjc{tғ+m>z۹j/
;<3kxȑ}NzŃL-u|H,^¡r"n4if@;ࠕA+"+ָ̓S걶rvv*vA:;eTk=Pr9p{hpQ;<iS<Y-Y砳Z*:Q.]]\YD۟tWٵᔧNv6)萯i_[][80	4IH
Tbu?vl,YON0݁L-#R"OFz"GLFyW﷯=Ήe|rȗsx;ޞědgA#%R7RO1:T8q:<bķsvI?K?y17*/:tcpbvәMgD=RQ	><|KUQkUZ[ULUbuK^J^%ެ?}z!sClfΏ.'u]_ABgKT-s-'߷^h9q9>؃5>o=qf÷_:=tt<u&^<(]v35\449zovOL8.yV7ӋKm#Kt٫_go~[{cN?,.X<<ۃ?ߞ{eJ%W~xwHDh$^~kFf36ɉGhפ0+?$|˧->d=׻9lT
4Ѻk-?Gk~l5͡oj0z@ێ7g+]D} IpFz,?3.p^@x l|l
UO>)PSqW_!D-CP}|Vc8RV埕Yt&uJGz*CI]Wr?]{Gjz4Ǆw>;{	c0p+Wob۽6lN.X~B_&\zюӎ5XcFd_98QhxzwIao!U-waHn4)~pĽ8ܝ7܃0=3AJ	m><emi)]ÉXxhz:Ify&J)C(~NVaWm1у7%PY& SL&h$'_֞.k}bgҨt$P&"qu[m>>q}y^n]2j"z#6$'B{)taJ-%'ޥöոM;q0*p@?`ށm7F=5MN lw=8cUa}XD尋}&hy+LPE1PwhaS24̄)0q
0蓳vfa^&,6VwBWXVOϰno |R=Xmy_KŜP>IcA!&PQ9bʐk|e o;U5I"~%]CQPlJ/=4ґ8t\ҌBXI՝ԩWz57Z@rM+7GJ7 9{׶
vۘM0[8/%Q AUI/import type { Compilation } from 'webpack';
/**
 * @param {Object} compilation The webpack compilation.
 * @param {string} swDest The original swDest value.
 *
 * @return {string} If swDest was not absolute, the returns swDest as-is.
 * Otherwise, returns swDest relative to the compilation's output path.
 *
 * @private
 */
export declare function relativeToOutputPath(compilation: Compilation, swDest: string): string;
                                                                                           &Y4C߬Xl]SquճsҠH~fxsbP!fdPg
;⻵t(ϕ.G])EݜUԎ׀K6F鰧,9:#:M
J ؍35Kwԩ	xpZjh}ʂ/mԯB;Jp-WpxHZ 3&LĈJ)Q`vmQAlVsH09Y1/\8agҞ%E%
*+A@[$ؖ5x&phavVєW&#`-aB I}2%|:ҡwgGG$(f	^kY)8P_ɳo*ƨAF;|>5KDa	so]'2s;gWnB(A;S9O9ѦRDC5}.!˽ QI?RJ*4џ3g9xc	um9#0;I#Ä/ۥS=1hwO??O!POR<`O9}T 30EDOvKXmR<Ss\oS;,9B H=yC" |
LpǤQl+Zg<pOpS0fVc;t\1_}6GWZchH1ھ!ߡqͰV O rU"$qg>CyֵMoAs&l[) B9[`qX볳H*Ҵ4|ַ[ElAc[[A3,t((3C'H}Pf'͉ܚ'R ;8o^#χxMqq/^H̏KyWТ]/!Y;T9AsNR7dΆr/sda{9Cݒh
 "KE.?ń8L}JIqa>NBxrz)u<suxOY|.Bƾu{1E+V}wL4"	n%@vH#^ň]|x ay:s<d,<HupE%-י˧H-=n ,rMx%4L%Q
33G8qKa]P1TDhsw	]h<9R"N%}]1,^Fr*){Kn/!
8cGK^pܜgwD= 3!z҄ЫAĈK"S(AIUC7 ( j舨QQCQQQQQ;9/873W3^s?O1EMIQdrl-:QYp덂h[YF86B6dr ϓ)}[cVtb3	|)6@ Rmԣ__P&&۾s,Um8xNgE"P!ГD8,ʐ;bR!B/嚖[P!|T axFDndQyyϐT
WXUe*5TWS*\V`K!߳Aq dmFb2
HQ	[)$-!,rA6.(!ACB]|6Ϥڴ^! iJK}[
3Ba?0Gu;t$$]wfx qu:PI\5uF&jq~"= 2!,=N ?B]bgD9V;|O8ȀCr[ag4࿂j ڳ9@[dX
f䎀(T_?eA@8ŷ
uɝ:|ihxI2@CFݍ4+Au2ozr'!FDm9;oWa}bd[_TaA!PUn!G'Oq+д;@70}4:|+MEa'6GEG5!\wԅkk+ &݌+w$SY1ʩWa,umH&,yFib7^LJB)rW.0A^ -Uwy3{9)Q7˝fh8n̟0Q]T
]F櫱 )h'F4qϹ?ԴS
.ӭ+@-oW[ U7#pZ䧈I.j]>PDrFZءߺe@*ȑ`LT{D7T7
';?{/^!Q\ɂnw~t}2ߎ~mGǉP*	5bV6if<(
cd~qM0)j<嬨*VWT`ٳOC 
=,˒=Be wyu(-\UEh?QuzKw|&J&P~1 @wNL@ġޑ`5'"OLxT2hb+\.w1s[	JJNcP}3
2]05
A̷<XdM5R.\$$+8BTC