import type { AST_NODE_TYPES, TSESTree } from '@typescript-eslint/types';
import type * as ts from 'typescript';
import type { TSNode } from './ts-nodes';
export interface EstreeToTsNodeTypes {
    [AST_NODE_TYPES.AccessorProperty]: ts.PropertyDeclaration;
    [AST_NODE_TYPES.ArrayExpression]: ts.ArrayLiteralExpression;
    [AST_NODE_TYPES.ArrayPattern]: ts.ArrayLiteralExpression | ts.ArrayBindingPattern;
    [AST_NODE_TYPES.ArrowFunctionExpression]: ts.ArrowFunction;
    [AST_NODE_TYPES.AssignmentExpression]: ts.BinaryExpression;
    [AST_NODE_TYPES.AssignmentPattern]: ts.ShorthandPropertyAssignment | ts.BindingElement | ts.BinaryExpression | ts.ParameterDeclaration;
    [AST_NODE_TYPES.AwaitExpression]: ts.AwaitExpression;
    [AST_NODE_TYPES.BinaryExpression]: ts.BinaryExpression;
    [AST_NODE_TYPES.BlockStatement]: ts.Block;
    [AST_NODE_TYPES.BreakStatement]: ts.BreakStatement;
    [AST_NODE_TYPES.CallExpression]: ts.CallExpression;
    [AST_NODE_TYPES.CatchClause]: ts.CatchClause;
    [AST_NODE_TYPES.ChainExpression]: ts.CallExpression | ts.PropertyAccessExpression | ts.ElementAccessExpression | ts.NonNullExpression;
    [AST_NODE_TYPES.ClassBody]: ts.ClassDeclaration | ts.ClassExpression;
    [AST_NODE_TYPES.ClassDeclaration]: ts.ClassDeclaration;
    [AST_NODE_TYPES.ClassExpression]: ts.ClassExpression;
    [AST_NODE_TYPES.PropertyDefinition]: ts.PropertyDeclaration;
    [AST_NODE_TYPES.ConditionalExpression]: ts.ConditionalExpression;
    [AST_NODE_TYPES.ContinueStatement]: ts.ContinueStatement;
    [AST_NODE_TYPES.DebuggerStatement]: ts.DebuggerStatement;
    [AST_NODE_TYPES.Decorator]: ts.Decorator;
    [AST_NODE_TYPES.DoWhileStatement]: ts.DoStatement;
    [AST_NODE_TYPES.EmptyStatement]: ts.EmptyStatement;
    [AST_NODE_TYPES.ExportAllDeclaration]: ts.ExportDeclaration;
    [AST_NODE_TYPES.ExportDefaultDeclaration]: ts.ExportAssignment | ts.FunctionDeclaration | ts.VariableStatement | ts.ClassDeclaration | ts.ClassExpression | ts.TypeAliasDeclaration | ts.InterfaceDeclaration | ts.EnumDeclaration | ts.ModuleDeclaration;
    [AST_NODE_TYPES.ExportNamedDeclaration]: ts.ExportDeclaration | ts.FunctionDeclaration | ts.VariableStatement | ts.ClassDeclaration | ts.ClassExpression | ts.TypeAliasDeclaration | ts.InterfaceDeclaration | ts.EnumDeclaration | ts.ModuleDeclaration;
    [AST_NODE_TYPES.ExportSpecifier]: ts.ExportSpecifier;
    [AST_NODE_TYPES.ExpressionStatement]: ts.ExpressionStatement;
    [AST_NODE_TYPES.ForInStatement]: ts.ForInStatement;
    [AST_NODE_TYPES.ForOfStatement]: ts.ForOfStatement;
    [AST_NODE_TYPES.ForStatement]: ts.ForStatement;
    [AST_NODE_TYPES.FunctionDeclaration]: ts.FunctionDeclaration;
    [AST_NODE_TYPES.FunctionExpression]: ts.FunctionExpression | ts.ConstructorDeclaration | ts.GetAccessorDeclaration | ts.SetAccessorDeclaration | ts.MethodDeclaration;
    [AST_NODE_TYPES.Identifier]: ts.Identifier | ts.ConstructorDeclaration | ts.Token<ts.SyntaxKind.NewKeyword | ts.SyntaxKind.ImportKeyword>;
    [AST_NODE_TYPES.PrivateIdentifier]: ts.PrivateIdentifier;
    [AST_NODE_TYPES.IfStatement]: ts.IfStatement;
    [AST_NODE_TYPES.ImportAttribute]: ts.AssertEntry;
    [AST_NODE_TYPES.ImportDeclaration]: ts.ImportDeclaration;
    [AST_NODE_TYPES.ImportDefaultSpecifier]: ts.ImportClause;
    [AST_NODE_TYPES.ImportExpression]: ts.CallExpression;
    [AST_NODE_TYPES.ImportNamespaceSpecifier]: ts.NamespaceImport;
    [AST_NODE_TYPES.ImportSpecifier]: ts.ImportSpecifier;
    [AST_NODE_TYPES.JSXAttribute]: ts.JsxAttribute;
    [AST_NODE_TYPES.JSXClosingElement]: ts.JsxClosingElement;
    [AST_NODE_TYPES.JSXClosingFragment]: ts.JsxClosingFragment;
    [AST_NODE_TYPES.JSXElement]: ts.JsxElement | ts.JsxSelfClosingElement;
    [AST_NODE_TYPES.JSXEmptyExpression]: ts.JsxExpression;
    [AST_NODE_TYPES.JSXExpressionContainer]: ts.JsxExpression;
    [AST_NODE_TYPES.JSXFragment]: ts.JsxFragment;
  