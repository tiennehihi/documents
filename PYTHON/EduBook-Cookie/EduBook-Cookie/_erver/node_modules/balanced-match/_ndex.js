on, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
            return void 0;
          }
          if (accessFlags & 8 /* CacheSymbol */) {
            getNodeLinks(accessNode).resolvedSymbol = prop;
          }
          if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
            return autoType;
          }
        }
        const propType = accessFlags & 4 /* Writing */ ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop);
        return accessExpression && getAssignmentTargetKind(accessExpression) !== 1 /* Definite */ ? getFlowTypeOfReference(accessExpression, propType) : accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) : propType;
      }
      if (everyType(objectType, isTupleType) && isNumericLiteralName(propName)) {
        const index = +propName;
        if (accessNode && everyType(objectType, (t) => !t.target.hasRestElement) && !(accessFlags & 16 /* NoTupleBoundsCheck */)) {
          const indexNode = getIndexNodeForAccessExpression(accessNode);
          if (isTupleType(objectType)) {
            if (index < 0) {
              error2(indexNode, Diagnost