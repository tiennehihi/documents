e.declaration.nameType), type.mapper)) : void 0;
  }
  function getTemplateTypeFromMappedType(type) {
    return type.templateType || (type.templateType = type.declaration.type ? instantiateType(addOptionality(
      getTypeFromTypeNode(type.declaration.type),
      /*isProperty*/
      true,
      !!(getMappedTypeModifiers(type) & 4 /* IncludeOptional */)
    ), type.mapper) : errorType);
  }
  function getConstraintDeclarationForMappedType(type) {
    return getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
  }
  function isMappedTypeWithKeyofConstraintDeclaration(type) {
    const constraintDeclaration = getConstraintDeclarationForMappedType(type);
    return constraintDeclaration.kind === 198 /* TypeOperator */ && constraintDeclaration.operator === 143 /* KeyOfKeyword */;
  }
  function getModifiersTypeFromMappedType(type) {
    if (!type.modifiersType) {
      if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
        type.modifiersType = instantiateType(getTypeFromTypeNode(getConstraintDeclarationForMappedType(type).type), type.mapper);
      } else {
        const declaredType = getTypeFromMappedTypeNode(type.declaration);
        const constraint = getConstraintTypeFromMappedType(declaredType);
        const extendedConstraint = constraint && constraint.flags & 262144 /* TypeParameter */ ? getConstraintOfTypeParameter(constraint) : constraint;
        type.modifiersType = extendedConstraint && extendedConstraint.flags & 4194304 /* Index */ ? instantiateType(extendedConstraint.type, type.mapper) : unknownType;
      }
    }
    return type.modifiersType;
  }
  function getMappedTypeModifiers(type) {
    const declaration = type.declaration;
    return (declaration.readonlyToken ? declaration.readonlyToken.kind === 41 /* MinusToken */ ? 2 /* ExcludeReadonly */ : 1 /* IncludeReadonly */ : 0) | (declarat