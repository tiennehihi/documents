ode = getBaseTypeNodeOfClass(type);
      if (!baseTypeNode) {
        return type.resolvedBaseConstructorType = undefinedType;
      }
      if (!pushTypeResolution(type, 1 /* ResolvedBaseConstructorType */)) {
        return errorType;
      }
      const baseConstructorType = checkExpression(baseTypeNode.expression);
      if (extended && baseTypeNode !== extended) {
        Debug.assert(!extended.typeArguments);
        checkExpression(extended.expression);
      }
      if (baseConstructorType.flags & (524288 /* Object */ | 2097152 /* Intersection */)) {
        resolveStructuredTypeMembers(baseConstructorType);
      }
      if (!popTypeResolution()) {
        error2(type.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
        return type.resolvedBaseConstructorType = errorType;
      }
      if (!(baseConstructorType.flags & 1 /* Any */) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
        const err = error2(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
        if (baseConstructorType.flags & 262144 /* TypeParameter */) {
          const constraint = getConstraintFromTypeParameter(baseConstructorType);
          let ctorReturn = unknownType;
          if (constraint) {
            const ctorSig = getSignaturesOfType(constraint, 1 /* Construct */);
            if (ctorSig[0]) {
              ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
            }
          }
          if (baseConstructorType.symbol.declarations) {
            addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
          }
        }
        return type.resolvedBaseConstructorType = errorType;
      }
      type.resolvedBaseConstructorType = baseConstructorType;
    }
    return type.resolvedBaseConstructorType;
  }
  function getImplementsTypes(type) {
    let resolvedImplementsTypes = emptyArray;
    if (type.symbol.declarations) {
      for (const declaration of type.symbol.declarations) {
        const implementsTypeNodes = getEffectiveImplementsTypeNodes(declaration);
        if (!implementsTypeNodes)
          continue;
        for (const node of implementsTypeNodes) {
          const implementsType = getTypeFromTypeNode(node);
          if (!isErrorType(implementsType)) {
            if (resolvedImplementsTypes === emptyArray) {
              resolvedImplementsTypes = [implementsType];
            } else {
              resolvedImplementsTypes.push(implementsType);
            }
          }
        }
      }
    }
    return resolvedImplementsTypes;
  }
  function reportCircularBaseType(node, type) {
    error2(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(
      type,
      /*enclosingDeclaration*/
      void 0,
      2 /* WriteArrayAsGenericType */
    ));
  }
  function getBaseTypes(type) {
    if (!type.baseTypesResolved) {
      if (pushTypeResolution(type, 7 /* ResolvedBaseTypes */)) {
        if (type.objectFlags & 8 /* Tuple */) {
          type.resolvedBaseTypes = [getTupleBaseType(type)];
        } else if (type.symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
          if (type.symbol.flags & 32 /* Class */) {
            resolveBaseTypesOfClass(type);
          }
          if (type.symbol.flags & 64 /* Interface */) {
            resolveBaseTypesOfInterface(type);
          }
        } else {
          Debug.fail("type must be class or interface");
        }
        if (!popTypeResolution() && type.symbol.declarations) {
          for (const declaration of type.symbol.declarations) {
            if (declaration.kind === 263 /* ClassDeclaration */ || declaration.kind === 264 /* InterfaceDeclaration */) {
              reportCircularBaseType(declaration, type);
            }
          }
        }
      }
      type.baseTypesResolved = true;
    }
    return type.resolvedBaseTypes;
  }
  function getTupleBaseType(type) {
    const elementTypes = sameMap(type.typeParameters, (t, i) => type.elementFlags[i] & 8 /* Variadic */ ? getIndexedAccessType(t, numberType) : t);
    return createArrayType(getUnionType(elementTypes || emptyArray), type.readonly);
  }
  function resolveBaseTypesOfClass(type) {
    type.resolvedBaseTypes = resolvingEmptyArray;
    const baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
    if (!(baseConstructorType.flags & (524288 /* Object */ | 2097152 /* Intersection */ | 1 /* Any */))) {
      return type.resolvedBaseTypes = emptyArray;
    }
    const baseTypeNode = getBaseTypeNodeOfClass(type);
    let baseType;
    const originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : void 0;
    if (baseConstructorType.symbol && baseConstructorType.symbol.flags & 32 /* Class */ && areAllOuterTypeParametersApplied(originalBaseType)) {
      baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
    } else if (baseConstructorType.flags & 1 /* Any */) {
      baseType = baseConstructorType;
    } else {
      const constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
      if (!constructors.length) {
        error2(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
        return type.resolvedBaseTypes = emptyArray;
      }
      baseType = getReturnTypeOfSignature(constructors[0]);
    }
    if (isErrorType(baseType)) {
      return type.resolvedBaseTypes = emptyArray;
    }
    const reducedBaseType = getReducedType(baseType);
    if (!isValidBaseType(reducedBaseType)) {
      const elaboration = elaborateNeverIntersection(
        /*errorInfo*/
        void 0,
        baseType
      );
      const diagnostic = chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
      diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic));
      return type.resolvedBaseTypes = emptyArray;
    }
    if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
      error2(type.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(
        type,
        /*enclosingDeclaration*/
        void 0,
        2 /* WriteArrayAsGenericType */
      ));
      return type.resolvedBaseTypes = emptyArray;
    }
    if (type.resolvedBaseTypes === resolvingEmptyArray) {
      type.members = void 0;
    }
    return type.resolvedBaseTypes = [reducedBaseType];
  }
  function areAllOuterTypeParametersApplied(type) {
    const outerTypeParameters = type.outerTypeParameters;
    if (outerTypeParameters) {
      const last2 = outerTypeParameters.length - 1;
      const typeArguments = getTypeArguments(type);
      return outerTypeParameters[last2].symbol !== typeArguments[last2].symbol;
    }
    return true;
  }
  function isValidBaseType(type) {
    if (type.flags & 262144 /* TypeParameter */) {
      const constraint = getBaseConstraintOfType(type);
      if (constraint) {
        return isValidBaseType(constraint);
      }
    }
    return !!(type.flags & (524288 /* Object */ | 67108864 /* NonPrimitive */ | 1 /* Any */) && !isGenericMappedType(type) || type.flags & 2097152 /* Intersection */ && every(type.types, isValidBaseType));
  }
  function resolveBaseTypesOfInterface(type) {
    type.resolvedBaseTypes = type.resolvedBaseTypes || emptyArray;
    if (type.symbol.declarations) {
      for (const declaration of type.symbol.declarations) {
        if (declaration.kind === 264 /* InterfaceDeclaration */ && getInterfaceBaseTypeNodes(declaration)) {
          for (const node of getInterfaceBaseTypeNodes(declaration)) {
            const baseType = getReducedType(getTypeFromTypeNode(node));
            if (!isErrorType(baseType)) {
              if (isValidBaseType(baseType)) {
                if (type !== baseType && !hasBaseType(baseType, type)) {
                  if (type.resolvedBaseTypes === emptyArray) {
                    type.resolvedBaseTypes = [baseType];
                  } else {
                    type.resolvedBaseTypes.push(baseType);
                  }
                } else {
                  reportCircularBaseType(declaration, type);
                }
              } else {
                error2(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
              }
            }
          }
        }
      }
    }
  }
  function isThislessInterface(symbol) {
    if (!symbol.declarations) {
      return true;
    }
    for (const declaration of symbol.declarations) {
      if (declaration.kind === 264 /* InterfaceDeclaration */) {
        if (declaration.flags & 256 /* ContainsThis */) {
          return false;
        }
        const baseTypeNodes = getInterfaceBaseTypeNodes(declaration);
        if (baseTypeNodes) {
          for (const node of baseTypeNodes) {
            if (isEntityNameExpression(node.expression)) {
              const baseSymbol = resolveEntityName(
                node.expression,
                788968 /* Type */,
                /*ignoreErrors*/
                true
              );
              if (!baseSymbol || !(baseSymbol.flags & 64 /* Interface */) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {
                return false;
              }
            }
          }
        }
      }
    }
    return true;
  }
  function getDeclaredTypeOfClassOrInterface(symbol) {
    let links = getSymbolLinks(symbol);
    const originalLinks = links;
    if (!links.declaredType) {
      const kind = symbol.flags & 32 /* Class */ ? 1 /* Class */ : 2 /* Interface */;
      const merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
      if (merged) {
        symbol = merged;
        links = merged.links;
      }
      const type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol);
      const outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
      const localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
      if (outerTypeParameters || localTypeParameters || kind === 1 /* Class */ || !isThislessInterface(symbol)) {
        type.objectFlags |= 4 /* Reference */;
        type.typeParameters = concatenate(outerTypeParameters, localTypeParameters);
        type.outerTypeParameters = outerTypeParameters;
        type.localTypeParameters = localTypeParameters;
        type.instantiations = /* @__PURE__ */ new Map();
        type.instantiations.set(getTypeListId(type.typeParameters), type);
        type.target = type;
        type.resolvedTypeArguments = type.typeParameters;
        type.thisType = createTypeParameter(symbol);
        type.thisType.isThisType = true;
        type.thisType.constraint = type;
      }
    }
    return links.declaredType;
  }
  function getDeclaredTypeOfTypeAlias(symbol) {
    var _a;
    const links = getSymbolLinks(symbol);
    if (!links.declaredType) {
      if (!pushTypeResolution(symbol, 2 /* DeclaredType */)) {
        return errorType;
      }
      const declaration = Debug.checkDefined((_a = symbol.declarations) == null ? void 0 : _a.find(isTypeAlias), "Type alias symbol with no valid declaration found");
      const typeNode = isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
      let type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
      if (popTypeResolution()) {
        const typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
        if (typeParameters) {
          links.typeParameters = typeParameters;
          links.instantiations = /* @__PURE__ */ new Map();
          links.instantiations.set(getTypeListId(typeParameters), type);
        }
      } else {
        type = errorType;
        if (declaration.kind === 347 /* JSDocEnumTag */) {
          error2(declaration.typeExpression.type, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
        } else {
          error2(isNamedDeclaration(declaration) ? declaration.name || declaration : declaration, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
        }
      }
      links.declaredType = type;
    }
    return links.declaredType;
  }
  function getBaseTypeOfEnumLikeType(type) {
    return type.flags & 1056 /* EnumLike */ && type.symbol.flags & 8 /* EnumMember */ ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)) : type;
  }
  function getDeclaredTypeOfEnum(symbol) {
    const links = getSymbolLinks(symbol);
    if (!links.declaredType) {
      const memberTypeList = [];
      if (symbol.declarations) {
        for (const declaration of symbol.declarations) {
          if (declaration.kind === 266 /* EnumDeclaration */) {
            for (const member of declaration.members) {
              if (hasBindableName(member)) {
                const memberSymbol = getSymbolOfDeclaration(member);
                const value = getEnumMemberValue(member);
                const memberType = getFreshTypeOfLiteralType(
                  value !== void 0 ? getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) : createComputedEnumType(memberSymbol)
                );
                getSymbolLinks(memberSymbol).declaredType = memberType;
                memberTypeList.push(getRegularTypeOfLiteralType(memberType));
              }
            }
          }
        }
      }
      const enumType = memberTypeList.length ? getUnionType(
        memberTypeList,
        1 /* Literal */,
        symbol,
        /*aliasTypeArguments*/
        void 0
      ) : createComputedEnumType(symbol);
      if (enumType.flags & 1048576 /* Union */) {
        enumType.flags |= 1024 /* EnumLiteral */;
        enumType.symbol = symbol;
      }
      links.declaredType = enumType;
    }
    return links.declaredType;
  }
  function createComputedEnumType(symbol) {
    const regularType = createTypeWithSymbol(32 /* Enum */, symbol);
    const freshType = createTypeWithSymbol(32 /* Enum */, symbol);
    regularType.regularType = regularType;
    regularType.freshType = freshType;
    freshType.regularType = regularType;
    freshType.freshType = freshType;
    return regularType;
  }
  function getDeclaredTypeOfEnumMember(symbol) {
    const links = getSymbolLinks(symbol);
    if (!links.declaredType) {
      const enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
      if (!links.declaredType) {
        links.declaredType = enumType;
      }
    }
    return links.declaredType;
  }
  function getDeclaredTypeOfTypeParameter(symbol) {
    const links = getSymbolLinks(symbol);
    return links.declaredType || (links.declaredType = createTypeParameter(symbol));
  }
  function getDeclaredTypeOfAlias(symbol) {
    const links = getSymbolLinks(symbol);
    return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)));
  }
  function getDeclaredTypeOfSymbol(symbol) {
    return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
  }
  function tryGetDeclaredTypeOfSymbol(symbol) {
    if (symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
      return getDeclaredTypeOfClassOrInterface(symbol);
    }
    if (symbol.flags & 524288 /* TypeAlias */) {
      return getDeclaredTypeOfTypeAlias(symbol);
    }
    if (symbol.flags & 262144 /* TypeParameter */) {
      return getDeclaredTypeOfTypeParameter(symbol);
    }
    if (symbol.flags & 384 /* Enum */) {
      return getDeclaredTypeOfEnum(symbol);
    }
    if (symbol.flags & 8 /* EnumMember */) {
      return getDeclaredTypeOfEnumMember(symbol);
    }
    if (symbol.flags & 2097152 /* Alias */) {
      return getDeclaredTypeOfAlias(symbol);
    }
    return void 0;
  }
  function isThislessType(node) {
    switch (node.kind) {
      case 133 /* AnyKeyword */:
      case 159 /* UnknownKeyword */:
      case 154 /* StringKeyword */:
      case 150 /* NumberKeyword */:
      case 163 /* BigIntKeyword */:
      case 136 /* BooleanKeyword */:
      case 155 /* SymbolKeyword */:
      case 151 /* ObjectKeyword */:
      case 116 /* VoidKeyword */:
      case 157 /* UndefinedKeyword */:
      case 146 /* NeverKeyword */:
      case 201 /* LiteralType */:
        return true;
      case 188 /* ArrayType */:
        return isThislessType(node.elementType);
      case 183 /* TypeReference */:
        return !node.typeArguments || node.typeArguments.every(isThislessType);
    }
    return false;
  }
  function isThislessTypeParameter(node) {
    const constraint = getEffectiveConstraintOfTypeParameter(node);
    return !constraint || isThislessType(constraint);
  }
  function isThislessVariableLikeDeclaration(node) {
    const typeNode = getEffectiveTypeAnnotationNode(node);
    return typeNode ? isThislessType(typeNode) : !hasInitializer(node);
  }
  function isThislessFunctionLikeDeclaration(node) {
    const returnType = getEffectiveReturnTypeNode(node);
    const typeParameters = getEffectiveTypeParameterDeclarations(node);
    return (node.kind === 176 /* Constructor */ || !!returnType && isThislessType(returnType)) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter);
  }
  function isThisless(symbol) {
    if (symbol.declarations && symbol.declarations.length === 1) {
      const declaration = symbol.declarations[0];
      if (declaration) {
        switch (declaration.kind) {
          case 172 /* PropertyDeclaration */:
          case 171 /* PropertySignature */:
            return isThislessVariableLikeDeclaration(declaration);
          case 174 /* MethodDeclaration */:
          case 173 /* MethodSignature */:
          case 176 /* Constructor */:
          case 177 /* GetAccessor */:
          case 178 /* SetAccessor */:
            return isThislessFunctionLikeDeclaration(declaration);
        }
      }
    }
    return false;
  }
  function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {
    const result = createSymbolTable();
    for (const symbol of symbols) {
      result.set(symbol.escapedName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
    }
    return result;
  }
  function addInheritedMembers(symbols, baseSymbols) {
    for (const base of baseSymbols) {
      if (isStaticPrivateIdentifierProperty(base)) {
        continue;
      }
      const derived = symbols.get(base.escapedName);
      if (!derived || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) && !isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock(derived.valueDeclaration)) {
        symbols.set(base.escapedName, base);
        symbols.set(base.escapedName, base);
      }
    }
  }
  function isStaticPrivateIdentifierProperty(s) {
    return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration);
  }
  function resolveDeclaredMembers(type) {
    if (!type.declaredProperties) {
      const symbol = type.symbol;
      const members = getMembersOfSymbol(symbol);
      type.declaredProperties = getNamedMembers(members);
      type.declaredCallSignatures = emptyArray;
      type.declaredConstructSignatures = emptyArray;
      type.declaredIndexInfos = emptyArray;
      type.declaredCallSignatures = getSignaturesOfSymbol(members.get("__call" /* Call */));
      type.declaredConstructSignatures = getSignaturesOfSymbol(members.get("__new" /* New */));
      type.declaredIndexInfos = getIndexInfosOfSymbol(symbol);
    }
    return type;
  }
  function isLateBindableName(node) {
    if (!isComputedPropertyName(node) && !isElementAccessExpression(node)) {
      return false;
    }
    const expr = isComputedPropertyName(node) ? node.expression : node.argumentExpression;
    return isEntityNameExpression(expr) && isTypeUsableAsPropertyName(isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr));
  }
  function isLateBoundName(name) {
    return name.charCodeAt(0) === 95 /* _ */ && name.charCodeAt(1) === 95 /* _ */ && name.charCodeAt(2) === 64 /* at */;
  }
  function hasLateBindableName(node) {
    const name = getNameOfDeclaration(node);
    return !!name && isLateBindableName(name);
  }
  function hasBindableName(node) {
    return !hasDynamicName(node) || hasLateBindableName(node);
  }
  function isNonBindableDynamicName(node) {
    return isDynamicName(node) && !isLateBindableName(node);
  }
  function addDeclarationToLateBoundSymbol(symbol, member, symbolFlags) {
    Debug.assert(!!(getCheckFlags(symbol) & 4096 /* Late */), "Expected a late-bound symbol.");
    symbol.flags |= symbolFlags;
    getSymbolLinks(member.symbol).lateSymbol = symbol;
    if (!symbol.declarations) {
      symbol.declarations = [member];
    } else if (!member.symbol.isReplaceableByMethod) {
      symbol.declarations.push(member);
    }
    if (symbolFlags & 111551 /* Value */) {
      if (!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind) {
        symbol.valueDeclaration = member;
      }
    }
  }
  function lateBindMember(parent2, earlySymbols, lateSymbols, decl) {
    Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
    const links = getNodeLinks(decl);
    if (!links.resolvedSymbol) {
      links.resolvedSymbol = decl.symbol;
      const declName = isBinaryExpression(decl) ? decl.left : decl.name;
      const type = isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
      if (isTypeUsableAsPropertyName(type)) {
        const memberName = getPropertyNameFromType(type);
        const symbolFlags = decl.symbol.flags;
        let lateSymbol = lateSymbols.get(memberName);
        if (!lateSymbol)
          lateSymbols.set(memberName, lateSymbol = createSymbol(0 /* None */, memberName, 4096 /* Late */));
        const earlySymbol = earlySymbols && earlySymbols.get(memberName);
        if (!(parent2.flags & 32 /* Class */) && (lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) || earlySymbol)) {
          const declarations = earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
          const name = !(type.flags & 8192 /* UniqueESSymbol */) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName);
          forEach(declarations, (declaration) => error2(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name));
          error2(declName || decl, Diagnostics.Duplicate_property_0, name);
          lateSymbol = createSymbol(0 /* None */, memberName, 4096 /* Late */);
        }
        lateSymbol.links.nameType = type;
        addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
        if (lateSymbol.parent) {
          Debug.assert(lateSymbol.parent === parent2, "Existing symbol parent should match new one");
        } else {
          lateSymbol.parent = parent2;
        }
        return links.resolvedSymbol = lateSymbol;
      }
    }
    return links.resolvedSymbol;
  }
  function getResolvedMembersOrExportsOfSymbol(symbol, resolutionKind) {
    const links = getSymbolLinks(symbol);
    if (!links[resolutionKind]) {
      const isStatic2 = resolutionKind === "resolvedExports" /* resolvedExports */;
      const earlySymbols = !isStatic2 ? symbol.members : symbol.flags & 1536 /* Module */ ? getExportsOfModuleWorker(symbol).exports : symbol.exports;
      links[resolutionKind] = earlySymbols || emptySymbols;
      const lateSymbols = createSymbolTable();
      for (const decl of symbol.declarations || emptyArray) {
        const members = getMembersOfDeclaration(decl);
        if (members) {
          for (const member of members) {
            if (isStatic2 === hasStaticModifier(member)) {
              if (hasLateBindableName(member)) {
                lateBindMember(symbol, earlySymbols, lateSymbols, member);
              }
            }
          }
        }
      }
      const assignments = getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers;
      if (assignments) {
        const decls = arrayFrom(assignments.values());
        for (const member of decls) {
          const assignmentKind = getAssignmentDeclarationKind(member);
          const isInstanceMember = assignmentKind === 3 /* PrototypeProperty */ || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind === 9 /* ObjectDefinePrototypeProperty */ || assignmentKind === 6 /* Prototype */;
          if (isStatic2 === !isInstanceMember) {
            if (hasLateBindableName(member)) {
              lateBindMember(symbol, earlySymbols, lateSymbols, member);
            }
          }
        }
      }
      let resolved = combineSymbolTables(earlySymbols, lateSymbols);
      if (symbol.flags & 33554432 /* Transient */ && links.cjsExportMerged && symbol.declarations) {
        for (const decl of symbol.declarations) {
          const original = getSymbolLinks(decl.symbol)[resolutionKind];
          if (!resolved) {
            resolved = original;
            continue;
          }
          if (!original)
            continue;
          original.forEach((s, name) => {
            const existing = resolved.get(name);
            if (!existing)
              resolved.set(name, s);
            else if (existing === s)
              return;
            else
              resolved.set(name, mergeSymbol(existing, s));
          });
        }
      }
      links[resolutionKind] = resolved || emptySymbols;
    }
    return links[resolutionKind];
  }
  function getMembersOfSymbol(symbol) {
    return symbol.flags & 6256 /* LateBindingContainer */ ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedMembers" /* resolvedMembers */) : symbol.members || emptySymbols;
  }
  function getLateBoundSymbol(symbol) {
    if (symbol.flags & 106500 /* ClassMember */ && symbol.escapedName === "__computed" /* Computed */) {
      const links = getSymbolLinks(symbol);
      if (!links.lateSymbol && some(symbol.declarations, hasLateBindableName)) {
        const parent2 = getMergedSymbol(symbol.parent);
        if (some(symbol.declarations, hasStaticModifier)) {
          getExportsOfSymbol(parent2);
        } else {
          getMembersOfSymbol(parent2);
        }
      }
      return links.lateSymbol || (links.lateSymbol = symbol);
    }
    return symbol;
  }
  function getTypeWithThisArgument(type, thisArgument, needApparentType) {
    if (getObjectFlags(type) & 4 /* Reference */) {
      const target = type.target;
      const typeArguments = getTypeArguments(type);
      return length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType])) : type;
    } else if (type.flags & 2097152 /* Intersection */) {
      const types = sameMap(type.types, (t) => getTypeWithThisArgument(t, thisArgument, needApparentType));
      return types !== type.types ? getIntersectionType(types) : type;
    }
    return needApparentType ? getApparentType(type) : type;
  }
  function resolveObjectTypeMembers(type, source, typeParameters, typeArguments) {
    let mapper;
    let members;
    let callSignatures;
    let constructSignatures;
    let indexInfos;
    if (rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
      members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties);
      callSignatures = source.declaredCallSignatures;
      constructSignatures = source.declaredConstructSignatures;
      indexInfos = source.declaredIndexInfos;
    } else {
      mapper = createTypeMapper(typeParameters, typeArguments);
      members = createInstantiatedSymbolTable(
        source.declaredProperties,
        mapper,
        /*mappingThisOnly*/
        typeParameters.length === 1
      );
      callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
      constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
      indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
    }
    const baseTypes = getBaseTypes(source);
    if (baseTypes.length) {
      if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
        const symbolTable = createSymbolTable(source.declaredProperties);
        const sourceIndex = getIndexSymbol(source.symbol);
        if (sourceIndex) {
          symbolTable.set("__index" /* Index */, sourceIndex);
        }
        members = symbolTable;
      }
      setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
      const thisArgument = lastOrUndefined(typeArguments);
      for (const baseType of baseTypes) {
        const instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
        addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
        callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* Call */));
        constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* Construct */));
        const inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(
          stringType,
          anyType,
          /*isReadonly*/
          false
        )];
        indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, (info) => !findIndexInfo(indexInfos, info.keyType)));
      }
    }
    setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
  }
  function resolveClassOrInterfaceMembers(type) {
    resolveObjectTypeMembers(type, resolveDeclaredMembers(type), emptyArray, emptyArray);
  }
  function resolveTypeReferenceMembers(type) {
    const source = resolveDeclaredMembers(type.target);
    const typeParameters = concatenate(source.typeParameters, [source.thisType]);
    const typeArguments = getTypeArguments(type);
    const paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]);
    resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
  }
  function createSignature(declaration, typeParameters, thisParameter, parameters, resolvedReturnType, resolvedTypePredicate, minArgumentCount, flags) {
    const sig = new Signature14(checker, flags);
    sig.declaration = declaration;
    sig.typeParameters = typeParameters;
    sig.parameters = parameters;
    sig.thisParameter = thisParameter;
    sig.resolvedReturnType = resolvedReturnType;
    sig.resolvedTypePredicate = resolvedTypePredicate;
    sig.minArgumentCount = minArgumentCount;
    sig.resolvedMinArgumentCount = void 0;
    sig.target = void 0;
    sig.mapper = void 0;
    sig.compositeSignatures = void 0;
    sig.compositeKind = void 0;
    return sig;
  }
  function cloneSignature(sig) {
    const result = createSignature(
      sig.declaration,
      sig.typeParameters,
      sig.thisParameter,
      sig.parameters,
      /*resolvedReturnType*/
      void 0,
      /*resolvedTypePredicate*/
      void 0,
      sig.minArgumentCount,
      sig.flags & 167 /* PropagatingFlags */
    );
    result.target = sig.target;
    result.mapper = sig.mapper;
    result.compositeSignatures = sig.compositeSignatures;
    result.compositeKind = sig.compositeKind;
    return result;
  }
  function createUnionSignature(signature, unionSignatures) {
    const result = cloneSignature(signature);
    result.compositeSignatures = unionSignatures;
    result.compositeKind = 1048576 /* Union */;
    result.target = void 0;
    result.mapper = void 0;
    return result;
  }
  function getOptionalCallSignature(signature, callChainFlags) {
    if ((signature.flags & 24 /* CallChainFlags */) === callChainFlags) {
      return signature;
    }
    if (!signature.optionalCallSignatureCache) {
      signature.optionalCallSignatureCache = {};
    }
    const key = callChainFlags === 8 /* IsInnerCallChain */ ? "inner" : "outer";
    return signature.optionalCallSignatureCache[key] || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags));
  }
  function createOptionalCallSignature(signature, callChainFlags) {
    Debug.assert(callChainFlags === 8 /* IsInnerCallChain */ || callChainFlags === 16 /* IsOuterCallChain */, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.");
    const result = cloneSignature(signature);
    result.flags |= callChainFlags;
    return result;
  }
  function getExpandedParameters(sig, skipUnionExpanding) {
    if (signatureHasRestParameter(sig)) {
      const restIndex = sig.parameters.length - 1;
      const restName = sig.parameters[restIndex].escapedName;
      const restType = getTypeOfSymbol(sig.parameters[restIndex]);
      if (isTupleType(restType)) {
        return [expandSignatureParametersWithTupleMembers(restType, restIndex, restName)];
      } else if (!skipUnionExpanding && restType.flags & 1048576 /* Union */ && every(restType.types, isTupleType)) {
        return map(restType.types, (t) => expandSignatureParametersWithTupleMembers(t, restIndex, restName));
      }
    }
    return [sig.parameters];
    function expandSignatureParametersWithTupleMembers(restType, restIndex, restName) {
      const elementTypes = getTypeArguments(restType);
      const associatedNames = getUniqAssociatedNamesFromTupleType(restType, restName);
      const restParams = map(elementTypes, (t, i) => {
        const name = associatedNames && associatedNames[i] ? associatedNames[i] : getParameterNameAtPosition(sig, restIndex + i, restType);
        const flags = restType.target.elementFlags[i];
        const checkFlags = flags & 12 /* Variable */ ? 32768 /* RestParameter */ : flags & 2 /* Optional */ ? 16384 /* OptionalP