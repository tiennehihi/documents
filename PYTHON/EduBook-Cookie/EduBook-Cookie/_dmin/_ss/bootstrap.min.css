ionDeclarations = void 0;
      lexicalEnvironmentFunctionDeclarationsStack = void 0;
      onSubstituteNode = void 0;
      onEmitNode = void 0;
      emitHelpers = void 0;
      state = 3 /* Disposed */;
    }
  }
}
var nullTransformationContext = {
  factory,
  // eslint-disable-line object-shorthand
  getCompilerOptions: () => ({}),
  getEmitResolver: notImplemented,
  getEmitHost: notImplemented,
  getEmitHelperFactory: notImplemented,
  startLexicalEnvironment: noop,
  resumeLexicalEnvironment: noop,
  suspendLexicalEnvironment: noop,
  endLexicalEnvironment: returnUndefined,
  setLexicalEnvironmentFlags: noop,
  getLexicalEnvironmentFlags: () => 0,
  hoistVariableDeclaration: noop,
  hoistFunctionDeclaration: noop,
  addInitializationStatement: noop,
  startBlockScope: noop,
  endBlockScope: returnUndefined,
  addBlockScopedVariable: noop,
  requestEmitHelper: noop,
  readEmitHelpers: notImplemented,
  enableSubstitution: noop,
  enableEmitNotification: noop,
  isSubstitutionEnabled: notImplemented,
  isEmitNotificationEnabled: notImplemented,
  onSubstituteNode: noEmitSubstitution,
  onEmitNode: noEmitNotification,
  addDiagnostic: noop
};

// src/compiler/emitter.ts
var brackets = createBracketsMap();
function isBuildInfoFile(file) {
  return fileExtensionIs(file, ".tsbuildinfo" /* TsBuildInfo */);
}
function forEachEmittedFile(host, action, sourceFilesOrTargetSourceFile, forceDtsEmit = false, onlyBuildInfo, includeBuildInfo) {
  const sourceFiles = isArray(sourceFilesOrTargetSourceFile) ? sourceFilesOrTargetSourceFile : getSourceFilesToEmit(host, sourceFilesOrTargetSourceFile, forceDtsEmit);
  const options = host.getCompilerOptions();
  if (outFile(options)) {
    const prepends = host.getPrependNodes();
    if (sourceFiles.length || prepends.length) {
      const bundle = factory.createBundle(sourceFiles, prepends);
      const result = action(getOutputPathsFor(bundle, host, forceDtsEmit), bundle);
      if (result) {
        return result;
      }
    }
  } else {
    if (!onlyBuildInfo) {
      for (const sourceFile of sourceFiles) {
        const result = action(getOutputPathsFor(sourceFile, host, forceDtsEmit), sourceFile);
        if (result) {
          return result;
        }
      }
    }
    if (includeBuildInfo) {
      const buildInfoPath = getTsBuildInfoEmitOutputFilePath(options);
      if (buildInfoPath)
        return action(
          { buildInfoPath },
          /*sourceFileOrBundle*/
          void 0
        );
    }
  }
}
function getTsBuildInfoEmitOutputFilePath(options) {
  const configFile = options.configFilePath;
  if (!isIncrementalCompilation(options))
    return void 0;
  if (options.tsBuildInfoFile)
    return options.tsBuildInfoFile;
  const outPath = outFile(options);
  let buildInfoExtensionLess;
  if (outPath) {
    buildInfoExtensionLess = removeFileExtension(outPath);
  } else {
    if (!configFile)
      return void 0;
    const configFileExtensionLess = removeFileExtension(configFile);
    buildInfoExtensionLess = options.outDir ? options.rootDir ? resolvePath(options.outDir, getRelativePathFromDirectory(
      options.rootDir,
      configFileExtensionLess,
      /*ignoreCase*/
      true
    )) : combinePaths(options.outDir, getBaseFileName(configFileExtensionLess)) : configFileExtensionLess;
  }
  return buildInfoExtensionLess + ".tsbuildinfo" /* TsBuildInfo */;
}
function getOutputPathsForBundle(options, forceDtsPaths) {
  const outPath = outFile(options);
  const jsFilePath = options.emitDeclarationOnly ? void 0 : outPath;
  const sourceMapFilePath = jsFilePath && getSourceMapFilePath(jsFilePath, options);
  const declarationFilePath = forceDtsPaths || getEmitDeclarations(options) ? removeFileExtension(outPath) + ".d.ts" /* Dts */ : void 0;
  const declarationMapPath = declarationFilePath && getAreDeclarationMapsEnabled(options) ? declarationFilePath + ".map" : void 0;
  const buildInfoPath = getTsBuildInfoEmitOutputFilePath(options);
  return { jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath };
}
function getOutputPathsFor(sourceFile, host, forceDtsPaths) {
  const options = host.getCompilerOptions();
  if (sourceFile.kind === 313 /* Bundle */) {
    return getOutputPathsForBundle(options, forceDtsPaths);
  } else {
    const ownOutputFilePath = getOwnEmitOutputFilePath(sourceFile.fileName, host, getOutputExtension(sourceFile.fileName, options));
    const isJsonFile = isJsonSourceFile(sourceFile);
    const isJsonEmittedToSameLocation = isJsonFile && comparePaths(sourceFile.fileName, ownOutputFilePath, host.getCurrentDirectory(), !host.useCaseSensitiveFileNames()) === 0 /* EqualTo */;
    const jsFilePath = options.emitDeclarationOnly || isJsonEmittedToSameLocation ? void 0 : ownOutputFilePath;
    const sourceMapFilePath = !jsFilePath || isJsonSourceFile(sourceFile) ? void 0 : getSourceMapFilePath(jsFilePath, options);
    const declarationFilePath = forceDtsPaths || getEmitDeclarations(options) && !isJsonFile ? getDeclarationEmitOutputFilePath(sourceFile.fileName, host) : void 0;
    const declarationMapPath = declarationFilePath && getAreDeclarationMapsEnabled(options) ? declarationFilePath + ".map" : void 0;
    return { jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath: void 0 };
  }
}
function getSourceMapFilePath(jsFilePath, options) {
  return options.sourceMap && !options.inlineSourceMap ? jsFilePath + ".map" : void 0;
}
function getOutputExtension(fileName, options) {
  return fileExtensionIs(fileName, ".json" /* Json */) ? ".json" /* Json */ : options.jsx === 1 /* Preserve */ && fileExtensionIsOneOf(fileName, [".jsx" /* Jsx */, ".tsx" /* Tsx */]) ? ".jsx" /* Jsx */ : fileExtensionIsOneOf(fileName, [".mts" /* Mts */, ".mjs" /* Mjs */]) ? ".mjs" /* Mjs */ : fileExtensionIsOneOf(fileName, [".cts" /* Cts */, ".cjs" /* Cjs */]) ? ".cjs" /* Cjs */ : ".js" /* Js */;
}
function getOutputPathWithoutChangingExt(inputFileName, ignoreCase, outputDir, getCommonSourceDirectory2) {
  return outputDir ? resolvePath(
    outputDir,
    getRelativePathFromDirectory(getCommonSourceDirectory2(), inputFileName, ignoreCase)
  ) : inputFileName;
}
function getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2 = () => getCommonSourceDirectoryOfConfig(configFile, ignoreCase)) {
  return getOutputDeclarationFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory2);
}
function getOutputDeclarationFileNameWorker(inputFileName, options, ignoreCase, getCommonSourceDirectory2) {
  return changeExtension(
    getOutputPathWithoutChangingExt(inputFileName, ignoreCase, options.declarationDir || options.outDir, getCommonSourceDirectory2),
    getDeclarationEmitExtensionForPath(inputFileName)
  );
}
function getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2 = () => getCommonSourceDirectoryOfConfig(configFile, ignoreCase)) {
  if (configFile.options.emitDeclarationOnly)
    return void 0;
  const isJsonFile = fileExtensionIs(inputFileName, ".json" /* Json */);
  const outputFileName = getOutputJSFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory2);
  return !isJsonFile || comparePaths(inputFileName, outputFileName, Debug.checkDefined(configFile.options.configFilePath), ignoreCase) !== 0 /* EqualTo */ ? outputFileName : void 0;
}
function getOutputJSFileNameWorker(inputFileName, options, ignoreCase, getCommonSourceDirectory2) {
  return changeExtension(
    getOutputPathWithoutChangingExt(inputFileName, ignoreCase, options.outDir, getCommonSourceDirectory2),
    getOutputExtension(inputFileName, options)
  );
}
function createAddOutput() {
  let outputs;
  return { addOutput, getOutputs };
  function addOutput(path) {
    if (path) {
      (outputs || (outputs = [])).push(path);
    }
  }
  function getOutputs() {
    return outputs || emptyArray;
  }
}
function getSingleOutputFileNames(configFile, addOutput) {
  const { jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath } = getOutputPathsForBundle(
    configFile.options,
    /*forceDtsPaths*/
    false
  );
  addOutput(jsFilePath);
  addOutput(sourceMapFilePath);
  addOutput(declarationFilePath);
  addOutput(declarationMapPath);
  addOutput(buildInfoPath);
}
function getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory2) {
  if (isDeclarationFileName(inputFileName))
    return;
  const js = getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2);
  addOutput(js);
  if (fileExtensionIs(inputFileName, ".json" /* Json */))
    return;
  if (js && configFile.options.sourceMap) {
    addOutput(`${js}.map`);
  }
  if (getEmitDeclarations(configFile.options)) {
    const dts = getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2);
    addOutput(dts);
    if (configFile.options.declarationMap) {
      addOutput(`${dts}.map`);
    }
  }
}
function getCommonSourceDirectory(options, emittedFiles, currentDirectory, getCanonicalFileName, checkSourceFilesBelongToPath) {
  let commonSourceDirectory;
  if (options.rootDir) {
    commonSourceDirectory = getNormalizedAbsolutePath(options.rootDir, currentDirectory);
    checkSourceFilesBelongToPath == null ? void 0 : checkSourceFilesBelongToPath(options.rootDir);
  } else if (options.composite && options.configFilePath) {
    commonSourceDirectory = getDirectoryPath(normalizeSlashes(options.configFilePath));
    checkSourceFilesBelongToPath == null ? void 0 : checkSourceFilesBelongToPath(commonSourceDirectory);
  } else {
    commonSourceDirectory = computeCommonSourceDirectoryOfFilenames(emittedFiles(), currentDirectory, getCanonicalFileName);
  }
  if (commonSourceDirectory && commonSourceDirectory[commonSourceDirectory.length - 1] !== directorySeparator) {
    commonSourceDirectory += directorySeparator;
  }
  return commonSourceDirectory;
}
function getCommonSourceDirectoryOfConfig({ options, fileNames }, ignoreCase) {
  return getCommonSourceDirectory(
    options,
    () => filter(fileNames, (file) => !(options.noEmitForJsFiles && fileExtensionIsOneOf(file, supportedJSExtensionsFlat)) && !isDeclarationFileName(file)),
    getDirectoryPath(normalizeSlashes(Debug.checkDefined(options.configFilePath))),
    createGetCanonicalFileName(!ignoreCase)
  );
}
function getAllProjectOutputs(configFile, ignoreCase) {
  const { addOutput, getOutputs } = createAddOutput();
  if (outFile(configFile.options)) {
    getSingleOutputFileNames(configFile, addOutput);
  } else {
    const getCommonSourceDirectory2 = memoize(() => getCommonSourceDirectoryOfConfig(configFile, ignoreCase));
    for (const inputFileName of configFile.fileNames) {
      getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory2);
    }
    addOutput(getTsBuildInfoEmitOutputFilePath(configFile.options));
  }
  return getOutputs();
}
function getFirstProjectOutput(configFile, ignoreCase) {
  if (outFile(configFile.options)) {
    const { jsFilePath, declarationFilePath } = getOutputPathsForBundle(
      configFile.options,
      /*forceDtsPaths*/
      false
    );
    return Debug.checkDefined(jsFilePath || declarationFilePath, `project ${configFile.options.configFilePath} expected to have at least one output`);
  }
  const getCommonSourceDirectory2 = memoize(() => getCommonSourceDirectoryOfConfig(configFile, ignoreCase));
  for (const inputFileName of configFile.fileNames) {
    if (isDeclarationFileName(inputFileName))
      continue;
    const jsFilePath = getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2);
    if (jsFilePath)
      return jsFilePath;
    if (fileExtensionIs(inputFileName, ".json" /* Json */))
      continue;
    if (getEmitDeclarations(configFile.options)) {
      return getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2);
    }
  }
  const buildInfoPath = getTsBuildInfoEmitOutputFilePath(configFile.options);
  if (buildInfoPath)
    return buildInfoPath;
  return Debug.fail(`project ${configFile.options.configFilePath} expected to have at least one output`);
}
function emitFiles(resolver, host, targetSourceFile, { scriptTransformers, declarationTransformers }, emitOnly, onlyBuildInfo, forceDtsEmit) {
  var compilerOptions = host.getCompilerOptions();
  var sourceMapDataList = compilerOptions.sourceMap || compilerOptions.inlineSourceMap || getAreDeclarationMapsEnabled(compilerOptions) ? [] : void 0;
  var emittedFilesList = compilerOptions.listEmittedFiles ? [] : void 0;
  var emitterDiagnostics = createDiagnosticCollection();
  var newLine = getNewLineCharacter(compilerOptions);
  var writer = createTextWriter(newLine);
  var { enter, exit } = createTimer("printTime", "beforePrint", "afterPrint");
  var bundleBuildInfo;
  var emitSkipped = false;
  enter();
  forEachEmittedFile(
    host,
    emitSourceFileOrBundle,
    getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit),
    forceDtsEmit,
    onlyBuildInfo,
    !targetSourceFile
  );
  exit();
  return {
    emitSkipped,
    diagnostics: emitterDiagnostics.getDiagnostics(),
    emittedFiles: emittedFilesList,
    sourceMaps: sourceMapDataList
  };
  function emitSourceFileOrBundle({ jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath }, sourceFileOrBundle) {
    var _a, _b, _c, _d, _e, _f;
    let buildInfoDirectory;
    if (buildInfoPath && sourceFileOrBundle && isBundle(sourceFileOrBundle)) {
      buildInfoDirectory = getDirectoryPath(getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
      bundleBuildInfo = {
        commonSourceDirectory: relativeToBuildInfo(host.getCommonSourceDirectory()),
        sourceFiles: sourceFileOrBundle.sourceFiles.map((file) => relativeToBuildInfo(getNormalizedAbsolutePath(file.fileName, host.getCurrentDirectory())))
      };
    }
    (_a = tracing) == null ? void 0 : _a.push(tracing.Phase.Emit, "emitJsFileOrBundle", { jsFilePath });
    emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath, relativeToBuildInfo);
    (_b = tracing) == null ? void 0 : _b.pop();
    (_c = tracing) == null ? void 0 : _c.push(tracing.Phase.Emit, "emitDeclarationFileOrBundle", { declarationFilePath });
    emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath, relativeToBuildInfo);
    (_d = tracing) == null ? void 0 : _d.pop();
    (_e = tracing) == null ? void 0 : _e.push(tracing.Phase.Emit, "emitBuildInfo", { buildInfoPath });
    emitBuildInfo(bundleBuildInfo, buildInfoPath);
    (_f = tracing) == null ? void 0 : _f.pop();
    function relativeToBuildInfo(path) {
      return ensurePathIsNonModuleName(getRelativePathFromDirectory(buildInfoDirectory, path, host.getCanonicalFileName));
    }
  }
  function emitBuildInfo(bundle, buildInfoPath) {
    if (!buildInfoPath || targetSourceFile || emitSkipped)
      return;
    if (host.isEmitBlocked(buildInfoPath)) {
      emitSkipped = true;
      return;
    }
    const buildInfo = host.getBuildInfo(bundle) || createBuildInfo(
      /*program*/
      void 0,
      bundle
    );
    writeFile(
      host,
      emitterDiagnostics,
      buildInfoPath,
      getBuildInfoText(buildInfo),
      /*writeByteOrderMark*/
      false,
      /*sourceFiles*/
      void 0,
      { buildInfo }
    );
    emittedFilesList == null ? void 0 : emittedFilesList.push(buildInfoPath);
  }
  function emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath, relativeToBuildInfo) {
    if (!sourceFileOrBundle || emitOnly || !jsFilePath) {
      return;
    }
    if (host.isEmitBlocked(jsFilePath) || compilerOptions.noEmit) {
      emitSkipped = true;
      return;
    }
    const transform = transformNodes(
      resolver,
      host,
      factory,
      compilerOptions,
      [sourceFileOrBundle],
      scriptTransformers,
      /*allowDtsFiles*/
      false
    );
    const printerOptions = {
      removeComments: compilerOptions.removeComments,
      newLine: compilerOptions.newLine,
      noEmitHelpers: compilerOptions.noEmitHelpers,
      module: compilerOptions.module,
      target: compilerOptions.target,
      sourceMap: compilerOptions.sourceMap,
      inlineSourceMap: compilerOptions.inlineSourceMap,
      inlineSources: compilerOptions.inlineSources,
      extendedDiagnostics: compilerOptions.extendedDiagnostics,
      writeBundleFileInfo: !!bundleBuildInfo,
      relativeToBuildInfo
    };
    const printer = createPrinter(printerOptions, {
      // resolver hooks
      hasGlobalName: resolver.hasGlobalName,
      // transform hooks
      onEmitNode: transform.emitNodeWithNotification,
      isEmitNotificationEnabled: transform.isEmitNotificationEnabled,
      substituteNode: transform.substituteNode
    });
    Debug.assert(transform.transformed.length === 1, "Should only see one output from the transform");
    printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform, printer, compilerOptions);
    transform.dispose();
    if (bundleBuildInfo)
      bundleBuildInfo.js = printer.bundleFileInfo;
    if (emittedFilesList) {
      emittedFilesList.push(jsFilePath);
      if (sourceMapFilePath) {
        emittedFilesList.push(sourceMapFilePath);
      }
    }
  }
  function emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath, relativeToBuildInfo) {
    if (!sourceFileOrBundle || emitOnly === 0 /* Js */)
      return;
    if (!declarationFilePath) {
      if (emitOnly || compilerOptions.emitDeclarationOnly)
        emitSkipped = true;
      return;
    }
    const sourceFiles = isSourceFile(sourceFileOrBundle) ? [sourceFileOrBundle] : sourceFileOrBundle.sourceFiles;
    const filesForEmit = forceDtsEmit ? sourceFiles : filter(sourceFiles, isSourceFileNotJson);
    const inputListOrBundle = outFile(compilerOptions) ? [factory.createBundle(filesForEmit, !isSourceFile(sourceFileOrBundle) ? sourceFileOrBundle.prepends : void 0)] : filesForEmit;
    if (emitOnly && !getEmitDeclarations(compilerOptions)) {
      filesForEmit.forEach(collectLinkedAliases);
    }
    const declarationTransform = transformNodes(
      resolver,
      host,
      factory,
      compilerOptions,
      inputListOrBundle,
      declarationTransformers,
      /*allowDtsFiles*/
      false
    );
    if (length(declarationTransform.diagnostics)) {
      for (const diagnostic of declarationTransform.diagnostics) {
        emitterDiagnostics.add(diagnostic);
      }
    }
    const declBlocked = !!declarationTransform.diagnostics && !!declarationTransform.diagnostics.length || !!host.isEmitBlocked(declarationFilePath) || !!compilerOptions.noEmit;
    emitSkipped = emitSkipped || declBlocked;
    if (!declBlocked || forceDtsEmit) {
      Debug.assert(declarationTransform.transformed.length === 1, "Should only see one output from the decl transform");
      const printerOptions = {
        removeComments: compilerOptions.removeComments,
        newLine: compilerOptions.newLine,
        noEmitHelpers: true,
        module: compilerOptions.module,
        target: compilerOptions.target,
        sourceMap: !forceDtsEmit && compilerOptions.declarationMap,
        inlineSourceMap: compilerOptions.inlineSourceMap,
        extendedDiagnostics: compilerOptions.extendedDiagnostics,
        onlyPrintJsDocStyle: true,
        omitBraceSourceMapPositions: true,
        writeBundleFileInfo: !!bundleBuildInfo,
        recordInternalSection: !!bundleBuildInfo,
        relativeToBuildInfo
      };
      const declarationPrinter = createPrinter(printerOptions, {
        // resolver hooks
        hasGlobalName: resolver.hasGlobalName,
        // transform hooks
        onEmitNode: declarationTransform.emitNodeWithNotification,
        isEmitNotificationEnabled: declarationTransform.isEmitNotificationEnabled,
        substituteNode: declarationTransform.substituteNode
      });
      printSourceFileOrBundle(
        declarationFilePath,
        declarationMapPath,
        declarationTransform,
        declarationPrinter,
        {
          sourceMap: printerOptions.sourceMap,
          sourceRoot: compilerOptions.sourceRoot,
          mapRoot: compilerOptions.mapRoot,
          extendedDiagnostics: compilerOptions.extendedDiagnostics
          // Explicitly do not passthru either `inline` option
        }
      );
      if (emittedFilesList) {
        emittedFilesList.push(declarationFilePath);
        if (declarationMapPath) {
          emittedFilesList.push(declarationMapPath);
        }
      }
      if (bundleBuildInfo)
        bundleBuildInfo.dts = declarationPrinter.bundleFileInfo;
    }
    declarationTransform.dispose();
  }
  function collectLinkedAliases(node) {
    if (isExportAssignment(node)) {
      if (node.expression.kind === 80 /* Identifier */) {
        resolver.collectLinkedAliases(
          node.expression,
          /*setVisibility*/
          true
        );
      }
      return;
    } else if (isExportSpecifier(node)) {
      resolver.collectLinkedAliases(
        node.propertyName || node.name,
        /*setVisibility*/
        true
      );
      return;
    }
    forEachChild(node, collectLinkedAliases);
  }
  function printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform, printer, mapOptions) {
    const sourceFileOrBundle = transform.transformed[0];
    const bundle = sourceFileOrBundle.kind === 313 /* Bundle */ ? sourceFileOrBundle : void 0;
    const sourceFile = sourceFileOrBundle.kind === 312 /* SourceFile */ ? sourceFileOrBundle : void 0;
    const sourceFiles = bundle ? bundle.sourceFiles : [sourceFile];
    let sourceMapGenerator;
    if (shouldEmitSourceMaps(mapOptions, sourceFileOrBundle)) {
      sourceMapGenerator = createSourceMapGenerator(
        host,
        getBaseFileName(normalizeSlashes(jsFilePath)),
        getSourceRoot(mapOptions),
        getSourceMapDirectory(mapOptions, jsFilePath, sourceFile),
        mapOptions
      );
    }
    if (bundle) {
      printer.writeBundle(bundle, writer, sourceMapGenerator);
    } else {
      printer.writeFile(sourceFile, writer, sourceMapGenerator);
    }
    let sourceMapUrlPos;
    if (sourceMapGenerator) {
      if (sourceMapDataList) {
        sourceMapDataList.push({
          inputSourceFileNames: sourceMapGenerator.getSources(),
          sourceMap: sourceMapGenerator.toJSON()
        });
      }
      const sourceMappingURL = getSourceMappingURL(
        mapOptions,
        sourceMapGenerator,
        jsFilePath,
        sourceMapFilePath,
        sourceFile
      );
      if (sourceMappingURL) {
        if (!writer.isAtStartOfLine())
          writer.rawWrite(newLine);
        sourceMapUrlPos = writer.getTextPos();
        writer.writeComment(`//# ${"sourceMappingURL"}=${sourceMappingURL}`);
      }
      if (sourceMapFilePath) {
        const sourceMap = sourceMapGenerator.toString();
        writeFile(
          host,
          emitterDiagnostics,
          sourceMapFilePath,
          sourceMap,
          /*writeByteOrderMark*/
          false,
          sourceFiles
        );
        if (printer.bundleFileInfo)
          printer.bundleFileInfo.mapHash = computeSignature(sourceMap, host);
      }
    } else {
      writer.writeLine();
    }
    const text = writer.getText();
    writeFile(host, emitterDiagnostics, jsFilePath, text, !!compilerOptions.emitBOM, sourceFiles, { sourceMapUrlPos, diagnostics: transform.diagnostics });
    if (printer.bundleFileInfo)
      printer.bundleFileInfo.hash = computeSignature(text, host);
    writer.clear();
  }
  function shouldEmitSourceMaps(mapOptions, sourceFileOrBundle) {
    return (mapOptions.sourceMap || mapOptions.inlineSourceMap) && (sourceFileOrBundle.kind !== 312 /* SourceFile */ || !fileExtensionIs(sourceFileOrBundle.fileName, ".json" /* Json */));
  }
  function getSourceRoot(mapOptions) {
    const sourceRoot = normalizeSlashes(mapOptions.sourceRoot || "");
    return sourceRoot ? ensureTrailingDirectorySeparator(sourceRoot) : sourceRoot;
  }
  function getSourceMapDirectory(mapOptions, filePath, sourceFile) {
    if (mapOptions.sourceRoot)
      return host.getCommonSourceDirectory();
    if (mapOptions.mapRoot) {
      let sourceMapDir = normalizeSlashes(mapOptions.mapRoot);
      if (sourceFile) {
        sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir));
      }
      if (getRootLength(sourceMapDir) === 0) {
        sourceMapDir = combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
      }
      return sourceMapDir;
    }
    return getDirectoryPath(normalizePath(filePath));
  }
  function getSourceMappingURL(mapOptions, sourceMapGenerator, filePath, sourceMapFilePath, sourceFile) {
    if (mapOptions.inlineSourceMap) {
      const sourceMapText = sourceMapGenerator.toString();
      const base64SourceMapText = base64encode(sys, sourceMapText);
      return `data:application/json;base64,${base64SourceMapText}`;
    }
    const sourceMapFile = getBaseFileName(normalizeSlashes(Debug.checkDefined(sourceMapFilePath)));
    if (mapOptions.mapRoot) {
      let sourceMapDir = normalizeSlashes(mapOptions.mapRoot);
      if (sourceFile) {
        sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir));
      }
      if (getRootLength(sourceMapDir) === 0) {
        sourceMapDir = combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
        return encodeURI(
          getRelativePathToDirectoryOrUrl(
            getDirectoryPath(normalizePath(filePath)),
            // get the relative sourceMapDir path based on jsFilePath
            combinePaths(sourceMapDir, sourceMapFile),
            // this is where user expects to see sourceMap
            host.getCurrentDirectory(),
            host.getCanonicalFileName,
            /*isAbsolutePathAnUrl*/
            true
          )
        );
      } else {
        return encodeURI(combinePaths(sourceMapDir, sourceMapFile));
      }
    }
    return encodeURI(sourceMapFile);
  }
}
function createBuildInfo(program, bundle) {
  return { bundle, program, version };
}
function getBuildInfoText(buildInfo) {
  return JSON.stringify(buildInfo);
}
function getBuildInfo(buildInfoFile, buildInfoText) {
  return readJsonOrUndefined(buildInfoFile, buildInfoText);
}
var notImplementedResolver = {
  hasGlobalName: notImplemented,
  getReferencedExportContainer: notImplemented,
  getReferencedImportDeclaration: notImplemented,
  getReferencedDeclarationWithCollidingName: notImplemented,
  isDeclarationWithCollidingName: notImplemented,
  isValueAliasDeclaration: notImplemented,
  isReferencedAliasDeclaration: notImplemented,
  isTopLevelValueImportEqualsWithEntityName: notImplemented,
  getNodeCheckFlags: notImplemented,
  isDeclarationVisible: notImplemented,
  isLateBound: (_node) => false,
  collectLinkedAliases: notImplemented,
  isImplementationOfOverload: notImplemented,
  isRequiredInitializedParameter: notImplemented,
  isOptionalUninitializedParameterProperty: notImplemented,
  isExpandoFunctionDeclaration: notImplemented,
  getPropertiesOfContainerFunction: notImplemented,
  createTypeOfDeclaration: notImplemented,
  createReturnTypeOfSignatureDeclaration: notImplemented,
  createTypeOfExpression: notImplemented,
  createLiteralConstValue: notImplemented,
  isSymbolAccessible: notImplemented,
  isEntityNameVisible: notImplemented,
  // Returns the constant value this property access resolves to: notImplemented, or 'undefined' for a non-constant
  getConstantValue: notImplemented,
  getReferencedValueDeclaration: notImplemented,
  getReferencedValueDeclarations: notImplemented,
  getTypeReferenceSerializationKind: notImplemented,
  isOptionalParameter: notImplemented,
  moduleExportsSomeValue: notImplemented,
  isArgumentsLocalBinding: notImplemented,
  getExternalModuleFileFromDeclaration: notImplemented,
  getTypeReferenceDirectivesForEntityName: notImplemented,
  getTypeReferenceDirectivesForSymbol: notImplemented,
  isLiteralConstDeclaration: notImplemented,
  getJsxFactoryEntity: notImplemented,
  getJsxFragmentFactoryEntity: notImplemented,
  getAllAccessorDeclarations: notImplemented,
  getSymbolOfExternalModuleSpecifier: notImplemented,
  isBindingCapturedByNode: notImplemented,
  getDeclarationStatementsForSourceFile: notImplemented,
  isImportRequiredByAugmentation: notImplemented,
  tryFindAmbientModule: notImplemented
};
function createSourceFilesFromBundleBuildInfo(bundle, buildInfoDirectory, host) {
  var _a;
  const jsBundle = Debug.checkDefined(bundle.js);
  const prologueMap = ((_a = jsBundle.sources) == null ? void 0 : _a.prologues) && arrayToMap(jsBundle.sources.prologues, (prologueInfo) => prologueInfo.file);
  return bundle.sourceFiles.map((fileName, index) => {
    const prologueInfo = prologueMap == null ? void 0 : prologueMap.get(index);
    const statements = prologueInfo == null ? void 0 : prologueInfo.directives.map((directive) => {
      const literal = setTextRange(factory.createStringLiteral(directive.expression.text), directive.expression);
      const statement = setTextRange(factory.createExpressionStatement(literal), directive);
      setParent(literal, statement);
      return statement;
    });
    const eofToken = factory.createToken(1 /* EndOfFileToken */);
    const sourceFile = factory.createSourceFile(statements ?? [], eofToken, 0 /* None */);
    sourceFile.fileName = getRelativePathFromDirectory(
      host.getCurrentDirectory(),
      getNormalizedAbsolutePath(fileName, buildInfoDirectory),
      !host.useCaseSensitiveFileNames()
    );
    sourceFile.text = (prologueInfo == null ? void 0 : prologueInfo.text) ?? "";
    setTextRangePosWidth(sourceFile, 0, (prologueInfo == null ? void 0 : prologueInfo.text.length) ?? 0);
    setEachParent(sourceFile.statements, sourceFile);
    setTextRangePosWidth(eofToken, sourceFile.end, 0);
    setParent(eofToken, sourceFile);
    return sourceFile;
  });
}
function emitUsingBuildInfo(config, host, getCommandLine, customTransformers) {
  var _a, _b;
  (_a = tracing) == null ? void 0 : _a.push(
    tracing.Phase.Emit,
    "emitUsingBuildInfo",
    {},
    /*separateBeginAndEnd*/
    true
  );
  mark("beforeEmit");
  const result = emitUsingBuildInfoWorker(config, host, getCommandLine, customTransformers);
  mark("afterEmit");
  measure("Emit", "beforeEmit", "afterEmit");
  (_b = tracing) == null ? void 0 : _b.pop();
  return result;
}
function emitUsingBuildInfoWorker(config, host, getCommandLine, customTransformers) {
  const { buildInfoPath, jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath } = getOutputPathsForBundle(
    config.options,
    /*forceDtsPaths*/
    false
  );
  const buildInfo = host.getBuildInfo(buildInfoPath, config.options.configFilePath);
  if (!buildInfo)
    return buildInfoPath;
  if (!buildInfo.bundle || !buildInfo.bundle.js || declarationFilePath && !buildInfo.bundle.dts)
    return buildInfoPath;
  const jsFileText = host.readFile(Debug.checkDefined(jsFilePath));
  if (!jsFileText)
    return jsFilePath;
  if (computeSignature(jsFileText, host) !== buildInfo.bundle.js.hash)
    return jsFilePath;
  const sourceMapText = sourceMapFilePath && host.readFile(sourceMapFilePath);
  if (sourceMapFilePath && !sourceMapText || config.options.inlineSourceMap)
    return sourceMapFilePath || "inline sourcemap decoding";
  if (sourceMapFilePath && computeSignature(sourceMapText, host) !== buildInfo.bundle.js.mapHash)
    return sourceMapFilePath;
  const declarationText = declarationFilePath && host.readFile(declarationFilePath);
  if (declarationFilePath && !declarationText)
    return declarationFilePath;
  if (declarationFilePath && computeSignature(declarationText, host) !== buildInfo.bundle.dts.hash)
    return declarationFilePath;
  const declarationMapText = declarationMapPath && host.readFile(declarationMapPath);
  if (declarationMapPath && !declarationMapText || config.options.inlineSourceMap)
    return declarationMapPath || "inline sourcemap decoding";
  if (declarationMapPath && computeSignature(declarationMapText, host) !== buildInfo.bundle.dts.mapHash)
    return declarationMapPath;
  const buildInfoDirectory = getDirectoryPath(getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
  const ownPrependInput = createInputFilesWithFileTexts(
    jsFilePath,
    jsFileText,
    sourceMapFilePath,
    sourceMapText,
    declarationFilePath,
    declarationText,
    declarationMapPath,
    declarationMapText,
    buildInfoPath,
    buildInfo,
    /*oldFileOfCurrentEmit*/
    true
  );
  const outputFiles = [];
  const prependNodes = createPrependNodes(config.projectReferences, getCommandLine, (f) => host.readFile(f), host);
  const sourceFilesForJsEmit = createSourceFilesFromBundleBuildInfo(buildInfo.bundle, buildInfoDirectory, host);
  let changedDtsText;
  let changedDtsData;
  const emitHost = {
    getPrependNodes: memoize(() => [...prependNodes, ownPrependInput]),
    getCanonicalFileName: host.getCanonicalFileName,
    getCommonSourceDirectory: () => getNormalizedAbsolutePath(buildInfo.bundle.commonSourceDirectory, buildInfoDirectory),
    getCompilerOptions: () => config.options,
    getCurrentDirectory: () => host.getCurrentDirectory(),
    getSourceFile: returnUndefined,
    getSourceFileByPath: returnUndefined,
    getSourceFiles: () => sourceFilesForJsEmit,
    getLibFileFromReference: notImplemented,
    isSourceFileFromExternalLibrary: returnFalse,
    getResolvedProjectReferenceToRedirect: returnUndefined,
    getProjectReferenceRedirect: returnUndefined,
    isSourceOfProjectReferenceRedirect: returnFalse,
    writeFile: (name, text, writeByteOrderMark, _onError, _sourceFiles, data) => {
      switch (name) {
        case jsFilePath:
          if (jsFileText === text)
            return;
          break;
        case sourceMapFilePath:
          if (sourceMapText === text)
            return;
          break;
        case buildInfoPath:
          break;
        case declarationFilePath:
          if (declarationText === text)
            return;
          changedDtsText = text;
          changedDtsData = data;
          break;
        case declarationMapPath:
          if (declarationMapText === text)
            return;
          break;
        default:
          Debug.fail(`Unexpected path: ${name}`);
      }
      outputFiles.push({ name, text, writeByteOrderMark, data });
    },
    isEmitBlocked: returnFalse,
    readFile: (f) => host.readFile(f),
    fileExists: (f) => host.fileExists(f),
    useCaseSensitiveFileNames: () => host.useCaseSensitiveFileNames(),
    getBuildInfo: (bundle) => {
      const program = buildInfo.program;
      if (program && changedDtsText !== void 0 && config.options.composite) {
        program.outSignature = computeSignature(changedDtsText, host, changedDtsData);
      }
      const { js, dts, sourceFiles } = buildInfo.bundle;
      bundle.js.sources = js.sources;
      if (dts) {
        bundle.dts.sources = dts.sources;
      }
      bundle.sourceFiles = sourceFiles;
      return createBuildInfo(program, bundle);
    },
    getSourceFileFromReference: returnUndefined,
    redirectTargetsMap: createMultiMap(),
    getFileIncludeReasons: notImplemented,
    createHash: maybeBind(host, host.createHash)
  };
  emitFiles(
    notImplementedResolver,
    emitHost,
    /*targetSourceFile*/
    void 0,
    getTransformers(config.options, customTransformers)
  );
  return outputFiles;
}
var createPrinterWithDefaults = /* @__PURE__ */ memoize(() => createPrinter({}));
var createPrinterWithRemoveComments = /* @__PURE__ */ memoize(() => createPrinter({ removeComments: true }));
var createPrinterWithRemoveCommentsNeverAsciiEscape = /* @__PURE__ */ memoize(() => createPrinter({ removeComments: true, neverAsciiEscape: true }));
var createPrinterWithRemoveCommentsOmitTrailingSemicolon = /* @__PURE__ */ memoize(() => createPrinter({ removeComments: true, omitTrailingSemicolon: true }));
function createPrinter(printerOptions = {}, handlers = {}) {
  var {
    hasGlobalName,
    onEmitNode = noEmitNotification,
    isEmitNotificationEnabled,
    substituteNode = noEmitSubstitution,
    onBeforeEmitNode,
    onAfterEmitNode,
    onBeforeEmitNodeArray,
    onAfterEmitNodeArray,
    onBeforeEmitToken,
    onAfterEmitToken
  } = handlers;
  var extendedDiagnostics = !!printerOptions.extendedDiagnostics;
  var omitBraceSourcePositions = !!printerOptions.omitBraceSourceMapPositions;
  var newLine = getNewLineCharacter(printerOptions);
  var moduleKind = getEmitModuleKind(printerOptions);
  var bundledHelpers = /* @__PURE__ */ new Map();
  var currentSourceFile;
  var nodeIdToGeneratedName;
  var nodeIdToGeneratedPrivateName;
  var autoGeneratedIdToGeneratedName;
  var generatedNames;
  var formattedNameTempFlagsStack;
  var formattedNameTempFlags;
  var privateNameTempFlagsStack;
  var privateNameTempFlags;
  var tempFlagsStack;
  var tempFlags;
  var reservedNamesStack;
  var reservedNames;
  var reservedPrivateNamesStack;
  var reservedPrivateNames;
  var preserveSourceNewlines = printerOptions.preserveSourceNewlines;
  var nextListElementPos;
  var writer;
  var ownWriter;
  var write = writeBase;
  var isOwnFileEmit;
  var bundleFileInfo = printerOptions.writeBundleFileInfo ? { sections: [] } : void 0;
  var relativeToBuildInfo = bundleFileInfo ? Debug.checkDefined(printerOptions.relativeToBuildInfo) : void 0;
  var recordInternalSection = printerOptions.recordInternalSection;
  var sourceFileTextPos = 0;
  var sourceFileTextKind = "text" /* Text */;
  var sourceMapsDisabled = true;
  var sourceMapGenerator;
  var sourceMapSource;
  var sourceMapSourceIndex = -1;
  var mostRecentlyAddedSourceMapSource;
  var mostRecentlyAddedSourceMapSourceIndex = -1;
  var containerPos = -1;
  var containerEnd = -1;
  var declarationListContainerEnd = -1;
  var currentLineMap;
  var detachedCommentsInfo;
  var hasWrittenComment = false;
  var commentsDisabled = !!printerOptions.removeComments;
  var lastSubstitution;
  var currentParenthesizerRule;
  var { enter: enterComment, exit: exitComment } = createTimerIf(extendedDiagnostics, "commentTime", "beforeComment", "afterComment");
  var parenthesizer = factory.parenthesizer;
  var typeArgumentParenthesizerRuleSelector = {
    select: (index) => index === 0 ? parenthesizer.parenthesizeLeadingTypeArgument : void 0
  };
  var emitBinaryExpression = createEmitBinaryExpression();
  reset();
  return {
    // public API
    printNode,
    printList,
    printFile,
    printBundle,
    // internal API
    writeNode,
    writeList,
    writeFile: writeFile2,
    writeBundle,
    bundleFileInfo
  };
  function printNode(hint, node, sourceFile) {
    switch (hint) {
      case 0 /* SourceFile */:
        Debug.assert(isSourceFile(node), "Expected a SourceFile node.");
        break;
      case 2 /* IdentifierName */:
        Debug.assert(isIdentifier(node), "Expected an Identifier node.");
        break;
      case 1 /* Expression */:
        Debug.assert(isExpression(node), "Expected an Expression node.");
        break;
    }
    switch (node.kind) {
      case 312 /* SourceFile */:
        return printFile(node);
      case 313 /* Bundle */:
        return printBundle(node);
      case 314 /* UnparsedSource */:
        return printUnparsedSource(node);
    }
    writeNode(hint, node, sourceFile, beginPrint());
    return endPrint();
  }
  function printList(format, nodes, sourceFile) {
    writeList(format, nodes, sourceFile, beginPrint());
    return endPrint();
  }
  function printBundle(bundle) {
    writeBundle(
      bundle,
      beginPrint(),
      /*sourceMapGenerator*/
      void 0
    );
    return endPrint();
  }
  function printFile(sourceFile) {
    writeFile2(
      sourceFile,
      beginPrint(),
      /*sourceMapGenerator*/
      void 0
    );
    return endPrint();
  }
  function printUnparsedSource(unparsed) {
    writeUnparsedSource(unparsed, beginPrint());
    return endPrint();
  }
  function writeNode(hint, node, sourceFile, output) {
    const previousWriter = writer;
    setWriter(
      output,
      /*_sourceMapGenerator*/
      void 0
    );
    print(hint, node, sourceFile);
    reset();
    writer = previousWriter;
  }
  function writeList(format, nodes, sourceFile, output) {
    const previousWriter = writer;
    setWriter(
      output,
      /*_sourceMapGenerator*/
      void 0
    );
    if (sourceFile) {
      setSourceFile(sourceFile);
    }
    emitList(
      /*parentNode*/
      void 0,
      nodes,
      format
    );
    reset();
    writer = previousWriter;
  }
  function getTextPosWithWriteLine() {
    return writer.getTextPosWithWriteLine ? writer.getTextPosWithWriteLine() : writer.getTextPos();
  }
  function updateOrPushBundleFileTextLike(pos, end, kind) {
    const last2 = lastOrUndefined(bundleFileInfo.sections);
    if (last2 && last2.kind === kind) {
      last2.end = end;
    } else {
      bundleFileInfo.sections.push({ pos, end, kind });
    }
  }
  function recordBundleFileInternalSectionStart(node) {
    if (recordInternalSection && bundleFileInfo && currentSourceFile && (isDeclaration(node) || isVariableStatement(node)) && isInternalDeclaration(node, currentSourceFile) && sourceFileTextKind !== "internal" /* Internal */) {
      const prevSourceFileTextKind = sourceFileTextKind;
      recordBundleFileTextLikeSection(writer.getTextPos());
      sourceFileTextPos = getTextPosWithWriteLine();
      sourceFileTextKind = "internal" /* Internal */;
      return prevSourceFileTextKind;
    }
    return void 0;
  }
  function recordBundleFileInternalSectionEnd(prevSourceFileTextKind) {
    if (prevSourceFileTextKind) {
      recordBundleFileTextLikeSection(writer.getTextPos());
      sourceFileTextPos = getTextPosWithWriteLine();
      sourceFileTextKind = prevSourceFileTextKind;
    }
  }
  function recordBundleFileTextLikeSection(end) {
    if (sourceFileTextPos < end) {
      updateOrPushBundleFileTextLike(sourceFileTextPos, end, sourceFileTextKind);
      return true;
    }
    return false;
  }
  function writeBundle(bundle, output, sourceMapGenerator2) {
    isOwnFileEmit = false;
    const previousWriter = writer;
    setWriter(output, sourceMapGenerator2);
    emitShebangIfNeeded(bundle);
    emitPrologueDirectivesIfNeeded(bundle);
    emitHelpers(bundle);
    emitSyntheticTripleSlashReferencesIfNeeded(bundle);
    for (const prepend of bundle.prepends) {
      writeLine();
      const pos = writer.getTextPos();
      const savedSections = bundleFileInfo && bundleFileInfo.sections;
      if (savedSections)
        bundleFileInfo.sections = [];
      print(
        4 /* Unspecified */,
        prepend,
        /*sourceFile*/
        void 0
      );
      if (bundleFileInfo) {
        const newSections = bundleFileInfo.sections;
        bundleFileInfo.sections = savedSections;
        if (prepend.oldFileOfCurrentEmit)
          bundleFileInfo.sections.push(...newSections);
        else {
          newSections.forEach((section) => Debug.assert(isBundleFileTextLike(section)));
          bundleFileInfo.sections.push({
            pos,
            end: writer.getTextPos(),
            kind: "prepend" /* Prepend */,
            data: relativeToBuildInfo(prepend.fileName),
            texts: newSections
          });
        }
      }
    }
    sourceFileTextPos = getTextPosWithWriteLine();
    for (const sourceFile of bundle.sourceFiles) {
      print(0 /* SourceFile */, sourceFile, sourceFile);
    }
    if (bundleFileInfo && bundle.sourceFiles.length) {
      const end = writer.getTextPos();
      if (recordBundleFileTextLikeSection(end)) {
        const prologues = getPrologueDirectivesFromBundledSourceFiles(bundle);
        if (prologues) {
          if (!bundleFileInfo.sources)
            bundleFileInfo.sources = {};
          bundleFileInfo.sources.prologues = prologues;
        }
        const helpers = getHelpersFromBundledSourceFiles(bundle);
        if (helpers) {
          if (!bundleFileInfo.sources)
            bundleFileInfo.sources = {};
          bundleFileInfo.sources.helpers = helpers;
        }
      }
    }
    reset();
    writer = previousWriter;
  }
  function writeUnparsedSource(unparsed, output) {
    const previousWriter = writer;
    setWriter(
      output,
      /*_sourceMapGenerator*/
      void 0
    );
    print(
      4 /* Unspecified */,
      unparsed,
      /*sourceFile*/
      void 0
    );
    reset();
    writer = previousWriter;
  }
  function writeFile2(sourceFile, output, sourceMapGenerator2) {
    isOwnFileEmit = true;
    const previousWriter = writer;
    setWriter(output, sourceMapGenerator2);
    emitShebangIfNeeded(sourceFile);
    emitPrologueDirectivesIfNeeded(sourceFile);
    print(0 /* SourceFile */, sourceFile, sourceFile);
    reset();
    writer = previousWriter;
  }
  function beginPrint() {
    return ownWriter || (ownWriter = createTextWriter(newLine));
  }
  function endPrint() {
    const text = ownWriter.getText();
    ownWriter.clear();
    return text;
  }
  function print(hint, node, sourceFile) {
    if (sourceFile) {
      setSourceFile(sourceFile);
    }
    pipelineEmit(
      hint,
      node,
      /*parenthesizerRule*/
      void 0
    );
  }
  function setSourceFile(sourceFile) {
    currentSourceFile = sourceFile;
    currentLineMap = void 0;
    detachedCommentsInfo = void 0;
    if (sourceFile) {
      setSourceMapSource(sourceFile);
    }
  }
  function setWriter(_writer, _sourceMapGenerator) {
    if (_writer && printerOptions.omitTrailingSemicolon) {
      _writer = getTrailingSemicolonDeferringWriter(_writer);
    }
    writer = _writer;
    sourceMapGenerator = _sourceMapGenerator;
    sourceMapsDisabled = !writer || !sourceMapGenerator;
  }
  function reset() {
    nodeIdToGeneratedName = [];
    nodeIdToGeneratedPrivateName = [];
    autoGeneratedIdToGeneratedName = [];
    generatedNames = /* @__PURE__ */ new Set();
    formattedNameTempFlagsStack = [];
    formattedNameTempFlags = /* @__PURE__ */ new Map();
    privateNameTempFlagsStack = [];
    privateNameTempFlags = 0 /* Auto */;
    tempFlagsStack = [];
    tempFlags = 0 /* Auto */;
    reservedNamesStack = [];
    reservedNames = void 0;
    reservedPrivateNamesStack = [];
    reservedPrivateNames = void 0;
    currentSourceFile = void 0;
    currentLineMap = void 0;
    detachedCommentsInfo = void 0;
    setWriter(
      /*output*/
      void 0,
      /*_sourceMapGenerator*/
      void 0
    );
  }
  function getCurrentLineMap() {
    return currentLineMap || (currentLineMap = getLineStarts(Debug.checkDefined(currentSourceFile)));
  }
  function emit(node, parenthesizerRule) {
    if (node === void 0)
      return;
    const prevSourceFileTextKind = recordBundleFileInternalSectionStart(node);
    pipelineEmit(4 /* Unspecified */, node, parenthesizerRule);
    recordBundleFileInternalSectionEnd(prevSourceFileTextKind);
  }
  function emitIdentifierName(node) {
    if (node === void 0)
      return;
    pipelineEmit(
      2 /* IdentifierName */,
      node,
      /*parenthesizerRule*/
      void 0
    );
  }
  function emitExpression(node, parenthesizerRule) {
    if (node === void 0)
      return;
    pipelineEmit(1 /* Expression */, node, parenthesizerRule);
  }
  function emitJsxAttributeValue(node) {
    pipelineEmit(isStringLiteral(node) ? 6 /* JsxAttributeValue */ : 4 /* Unspecified */, node);
  }
  function beforeEmitNode(node) {
    if (preserveSourceNewlines && getInternalEmitFlags(node) & 4 /* IgnoreSourceNewlines */) {
      preserveSourceNewlines = false;
    }
  }
  function afterEmitNode(savedPreserveSourceNewlines) {
    preserveSourceNewlines = savedPreserveSourceNewlines;
  }
  function pipelineEmit(emitHint, node, parenthesizerRule) {
    currentParenthesizerRule = parenthesizerRule;
    const pipelinePhase = getPipelinePhase(0 /* Notification */, emitHint, node);
    pipelinePhase(emitHint, node);
    currentParenthesizerRule = void 0;
  }
  function shouldEmitComments(node) {
    return !commentsDisabled && !isSourceFile(node);
  }
  function shouldEmitSourceMaps(node) {
    return !sourceMapsDisabled && !isSourceFile(node) && !isInJsonFile(node) && !isUnparsedSource(node) && !isUnparsedPrepend(node);
  }
  function getPipelinePhase(phase, emitHint, node) {
    switch (phase) {
      case 0 /* Notification */:
        if (onEmitNode !== noEmitNotification && (!isEmitNotificationEnabled || isEmitNotificationEnabled(node))) {
          return pipelineEmitWithNotification;
        }
      case 1 /* Substitution */:
        if (substituteNode !== noEmitSubstitution && (lastSubstitution = substituteNode(emitHint, node) || node) !== node) {
          if (currentParenthesizerRule) {
            lastSubstitution = currentParenthesizerRule(lastSubstitution);
          }
          return pipelineEmitWithSubstitution;
        }
      case 2 /* Comments */:
        if (shouldEmitComments(node)) {
          return pipelineEmitWithComments;
        }
      case 3 /* SourceMaps */:
        if (shouldEmitSourceMaps(node)) {
          return pipelineEmitWithSourceMaps;
        }
      case 4 /* Emit */:
        return pipelineEmitWithHint;
      default:
        return Debug.assertNever(phase);
    }
  }
  function getNextPipelinePhase(currentPhase, emitHint, node) {
    return getPipelinePhase(currentPhase + 1, emitHint, node);
  }
  function pipelineEmitWithNotification(hint, node) {
    const pipelinePhase = getNextPipelinePhase(0 /* Notification */, hint, node);
    onEmitNode(hint, node, pipelinePhase);
  }
  function pipelineEmitWithHint(hint, node) {
    onBeforeEmitNode == null ? void 0 : onBeforeEmitNode(node);
    if (preserveSourceNewlines) {
      const savedPreserveSourceNewlines = preserveSourceNewlines;
      beforeEmitNode(node);
      pipelineEmitWithHintWorker(hint, node);
      afterEmitNode(savedPreserveSourceNewlines);
    } else {
      pipelineEmitWithHintWorker(hint, node);
    }
    onAfterEmitNode == null ? void 0 : onAfterEmitNode(node);
    currentParenthesizerRule = void 0;
  }
  function pipelineEmitWithHintWorker(hint, node, allowSnippets = true) {
    if (allowSnippets) {
      const snippet = getSnippetElement(node);
      if (snippet) {
        return emitSnippetNode(hint, node, snippet);
      }
    }
    if (hint === 0 /* SourceFile */)
      return emitSourceFile(cast(node, isSourceFile));
    if (hint === 2 /* IdentifierName */)
      return emitIdentifier(cast(node, isIdentifier));
    if (hint === 6 /* JsxAttributeValue */)
      return emitLiteral(
        cast(node, isStringLiteral),
        /*jsxAttributeEscape*/
        true
      );
    if (hint === 3 /* MappedTypeParameter */)
      return emitMappedTypeParameter(cast(node, isTypeParameterDeclaration));
    if (hint === 7 /* ImportTypeNodeAttributes */)
      return emitImportTypeNodeAttributes(cast(node, isImportAttributes));
    if (hint === 5 /* EmbeddedStatement */) {
      Debug.assertNode(node, isEmptyStatement);
      return emitEmptyStatement(
        /*isEmbeddedStatement*/
        true
      );
    }
    if (hint === 4 /* Unspecified */) {
      switch (node.kind) {
        case 16 /* TemplateHead */:
        case 17 /* TemplateMiddle */:
        case 18 /* TemplateTail */:
          return emitLiteral(
            node,
            /*jsxAttributeEscape*/
            false
          );
        case 80 /* Identifier */:
          return emitIdentifier(node);
        case 81 /* PrivateIdentifier */:
          return emitPrivateIdentifier(node);
        case 166 /* QualifiedName */:
          return emitQualifiedName(node);
        case 167 /* ComputedPropertyName */:
          return emitComputedPropertyName(node);
        case 168 /* TypeParameter */:
          return emitTypeParameter(node);
        case 169 /* Parameter */:
          return emitParameter(node);
        case 170 /* Decorator */:
          return emitDecorator(node);
        case 171 /* PropertySignature */:
          return emitPropertySignature(node);
        case 172 /* PropertyDeclaration */:
          return emitPropertyDeclaration(node);
        case 173 /* MethodSignature */:
          return emitMethodSignature(node);
        case 174 /* MethodDeclaration */:
          return emitMethodDeclaration(node);
        case 175 /* ClassStaticBlockDeclaration */:
          return emitClassStaticBlockDeclaration(node);
        case 176 /* Constructor */:
          return emitConstructor(node);
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
          return emitAccessorDeclaration(node);
        case 179 /* CallSignature */:
          return emitCallSignature(node);
        case 180 /* ConstructSignature */:
          return emitConstructSignature(node);
        case 181 /* IndexSignature */:
          return emitIndexSignature(node);
        case 182 /* TypePredicate */:
          return emitTypePredicate(node);
        case 183 /* TypeReference */:
          return emitTypeReference(node);
        case 184 /* FunctionType */:
          return emitFunctionType(node);
        case 185 /* ConstructorType */:
          return emitConstructorType(node);
        case 186 /* TypeQuery */:
          return emitTypeQuery(node);
        case 187 /* TypeLiteral */:
          return emitTypeLiteral(node);
        case 188 /* ArrayType */:
          return emitArrayType(node);
        case 189 /* TupleType */:
          return emitTupleType(node);
        case 190 /* OptionalType */:
          return emitOptionalType(node);
        case 192 /* UnionType */:
          return emitUnionType(node);
        case 193 /* IntersectionType */:
          return emitIntersectionType(node);
        case 194 /* ConditionalType */:
          return emitConditionalType(node);
        case 195 /* InferType */:
          return emitInferType(node);
        case 196 /* ParenthesizedType */:
          return emitParenthesizedType(node);
        case 233 /* ExpressionWithTypeArguments */:
          return emitExpressionWithTypeArguments(node);
        case 197 /* ThisType */:
          return emitThisType();
        case 198 /* TypeOperator */:
          return emitTypeOperator(node);
        case 199 /* IndexedAccessType */:
          return emitIndexedAccessType(node);
        case 200 /* MappedType */:
          return emitMappedType(node);
        case 201 /* LiteralType */:
          return emitLiteralType(node);
        case 202 /* NamedTupleMember */:
          return emitNamedTupleMember(node);
        case 203 /* TemplateLiteralType */:
          return emitTemplateType(node);
        case 204 /* TemplateLiteralTypeSpan */:
          return emitTemplateTypeSpan(node);
        case 205 /* ImportType */:
          return emitImportTypeNode(node);
        case 206 /* ObjectBindingPattern */:
          return emitObjectBindingPattern(node);
        case 207 /* ArrayBindingPattern */:
          return emitArrayBindingPattern(node);
        case 208 /* BindingElement */:
          return emitBindingElement(node);
        case 239 /* TemplateSpan */:
          return emitTemplateSpan(node);
        case 240 /* SemicolonClassElement */:
          return emitSemicolonClassElement();
        case 241 /* Block */:
          return emitBlock(node);
        case 243 /* VariableStatement */:
          return emitVariableStatement(node);
        case 242 /* EmptyStatement */:
          return emitEmptyStatement(
            /*isEmbeddedStatement*/
            false
          );
        case 244 /* ExpressionStatement */:
          return emitExpressionStatement(node);
        case 245 /* IfStatement */:
          return emitIfStatement(node);
        case 246 /* DoStatement */:
          return emitDoStatement(node);
        case 247 /* WhileStatement */:
          return emitWhileStatement(node);
        case 248 /* ForStatement */:
          return emitForStatement(node);
        case 249 /* ForInStatement */:
          return emitForInStatement(node);
        case 250 /* ForOfStatement */:
          return emitForOfStatement(node);
        case 251 /* ContinueStatement */:
          return emitContinueStatement(node);
        case 252 /* BreakStatement */:
          return emitBreakStatement(node);
        case 253 /* ReturnStatement */:
          return emitReturnStatement(node);
        case 254 /* WithStatement */:
          return emitWithStatement(node);
        case 255 /* SwitchStatement */:
          return emitSwitchStatement(node);
        case 256 /* LabeledStatement */:
          return emitLabeledStatement(node);
        case 257 /* ThrowStatement */:
          return emitThrowStatement(node);
        case 258 /* TryStatement */:
          return emitTryStatement(node);
        case 259 /* DebuggerStatement */:
          return emitDebuggerStatement(node);
        case 260 /* VariableDeclaration */:
          return emitVariableDeclaration(node);
        case 261 /* VariableDeclarationList */:
          return emitVariableDeclarationList(node);
        case 262 /* FunctionDeclaration */:
          return emitFunctionDeclaration(node);
        case 263 /* ClassDeclaration */:
          return emitClassDeclaration(node);
        case 264 /* InterfaceDeclaration */:
          return emitInterfaceDeclaration(node);
        case 265 /* TypeAliasDeclaration */:
          return emitTypeAliasDeclaration(node);
        case 266 /* EnumDeclaration */:
          return emitEnumDeclaration(node);
        case 267 /* ModuleDeclaration */:
          return emitModuleDeclaration(node);
        case 268 /* ModuleBlock */:
          return emitModuleBlock(node);
        case 269 /* CaseBlock */:
          return emitCaseBlock(node);
        case 270 /* NamespaceExportDeclaration */:
          return emitNamespaceExportDeclaration(node);
        case 271 /* ImportEqualsDeclaration */:
          return emitImportEqualsDeclaration(node);
        case 272 /* ImportDeclaration */:
          return emitImportDeclaration(node);
        case 273 /* ImportClause */:
          return emitImportClause(node);
        case 274 /* NamespaceImport */:
          return emitNamespaceImport(node);
        case 280 /* NamespaceExport */:
          return emitNamespaceExport(node);
        case 275 /* NamedImports */:
          return emitNamedImports(node);
        case 276 /* ImportSpecifier */:
          return emitImportSpecifier(node);
        case 277 /* ExportAssignment */:
          return emitExportAssignment(node);
        case 278 /* ExportDeclaration */:
          return emitExportDeclaration(node);
        case 279 /* NamedExports */:
          return emitNamedExports(node);
        case 281 /* ExportSpecifier */:
          return emitExportSpecifier(node);
        case 300 /* ImportAttributes */:
          return emitImportAttributes(node);
        case 301 /* ImportAttribute */:
          return emitImportAttribute(node);
        case 282 /* MissingDeclaration */:
          return;
        case 283 /* ExternalModuleReference */:
          return emitExternalModuleReference(node);
        case 12 /* JsxText */:
          return emitJsxText(node);
        case 286 /* JsxOpeningElement */:
        case 289 /* JsxOpeningFragment */:
          return emitJsxOpeningElementOrFragment(node);
        case 287 /* JsxClosingElement */:
        case 290 /* JsxClosingFragment */:
          return emitJsxClosingElementOrFragment(node);
        case 291 /* JsxAttribute */:
          return emitJsxAttribute(node);
        case 292 /* JsxAttributes */:
          return emitJsxAttributes(node);
        case 293 /* JsxSpreadAttribute */:
          return emitJsxSpreadAttribute(node);
        case 294 /* JsxExpression */:
          return emitJsxExpression(node);
        case 295 /* JsxNamespacedName */:
          return emitJsxNamespacedName(node);
        case 296 /* CaseClause */:
          return emitCaseClause(node);
        case 297 /* DefaultClause */:
          return emitDefaultClause(node);
        case 298 /* HeritageClause */:
          return emitHeritageClause(node);
        case 299 /* CatchClause */:
          return emitCatchClause(node);
        case 303 /* PropertyAssignment */:
          return emitPropertyAssignment(node);
        case 304 /* ShorthandPropertyAssignment */:
          return emitShorthandPropertyAssignment(node);
        case 305 /* SpreadAssignment */:
          return emitSpreadAssignment(node);
        case 306 /* EnumMember */:
          return emitEnumMember(node);
        case 307 /* UnparsedPrologue */:
          return writeUnparsedNode(node);
        case 314 /* UnparsedSource */:
        case 308 /* UnparsedPrepend */:
          return emitUnparsedSourceOrPrepend(node);
        case 309 /* UnparsedText */:
        case 310 /* UnparsedInternalText */:
          return emitUnparsedTextLike(node);
        case 311 /* UnparsedSyntheticReference */:
          return emitUnparsedSyntheticReference(node);
        case 312 /* SourceFile */:
          return emitSourceFile(node);
        case 313 /* Bundle */:
          return Debug.fail("Bundles should be printed using printBundle");
        case 315 /* InputFiles */:
          return Debug.fail("InputFiles should not be printed");
        case 316 /* JSDocTypeExpression */:
          return emitJSDocTypeExpression(node);
        case 317 /* JSDocNameReference */:
          return emitJSDocNameReference(node);
        case 319 /* JSDocAllType */:
          return writePunctuation("*");
        case 320 /* JSDocUnknownType */:
          return writePunctuation("?");
        case 321 /* JSDocNullableType */:
          return emitJSDocNullableType(node);
        case 322 /* JSDocNonNullableType */:
          return emitJSDocNonNullableType(node);
        case 323 /* JSDocOptionalType */:
          return emitJSDocOptionalType(node);
        case 324 /* JSDocFunctionType */:
          return emitJSDocFunctionType(node);
        case 191 /* RestType */:
        case 325 /* JSDocVariadicType */:
          return emitRestOrJSDocVariadicType(node);
        case 326 /* JSDocNamepathType */:
          return;
        case 327 /* JSDoc */:
          return emitJSDoc(node);
        case 329 /* JSDocTypeLiteral */:
          return emitJSDocTypeLiteral(node);
        case 330 /* JSDocSignature */:
          return emitJSDocSignature(node);
        case 334 /* JSDocTag */:
        case 339 /* JSDocClassTag */:
        case 344 /* JSDocOverrideTag */:
          return emitJSDocSimpleTag(node);
        case 335 /* JSDocAugmentsTag */:
        case 336 /* JSDocImplementsTag */:
          return emitJSDocHeritageTag(node);
        case 337 /* JSDocAuthorTag */:
        case 338 /* JSDocDeprecatedTag */:
          return;
        case 340 /* JSDocPublicTag */:
        case 341 /* JSDocPrivateTag */:
        case 342 /* JSDocProtectedTag */:
        case 343 /* JSDocReadonlyTag */:
          return;
        case 345 /* JSDocCallbackTag */:
          return emitJSDocCallbackTag(node);
        case 346 /* JSDocOverloadTag */:
          return emitJSDocOverloadTag(node);
        case 348 /* JSDocParameterTag */:
        case 355 /* JSDocPropertyTag */:
          return emitJSDocPropertyLikeTag(node);
        case 347 /* JSDocEnumTag */:
        case 349 /* JSDocReturnTag */:
        case 350 /* JSDocThisTag */:
        case 351 /* JSDocTypeTag */:
        case 356 /* JSDocThrowsTag */:
        case 357 /* JSDocSatisfiesTag */:
          return emitJSDocSimpleTypedTag(node);
        case 352 /* JSDocTemplateTag */:
          return emitJSDocTemplateTag(node);
        case 353 /* JSDocTypedefTag */:
          return emitJSDocTypedefTag(node);
        case 354 /* JSDocSeeTag */:
          return emitJSDocSeeTag(node);
        case 359 /* NotEmittedStatement */:
          return;
      }
      if (isExpression(node)) {
        hint = 1 /* Expression */;
        if (substituteNode !== noEmitSubstitution) {
          const substitute = substituteNode(hint, node) || node;
          if (substitute !== node) {
            node = substitute;
            if (currentParenthesizerRule) {
              node = currentParenthesizerRule(node);
            }
          }
        }
      }
    }
    if (hint === 1 /* Expression */) {
      switch (node.kind) {
        case 9 /* NumericLiteral */:
        case 10 /* BigIntLiteral */:
          return emitNumericOrBigIntLiteral(node);
        case 11 /* StringLiteral */:
        case 14 /* RegularExpressionLiteral */:
        case 15 /* NoSubstitutionTemplateLiteral */:
          return emitLiteral(
            node,
            /*jsxAttributeEscape*/
            false
          );
        case 80 /* Identifier */:
          return emitIdentifier(node);
        case 81 /* PrivateIdentifier */:
          return emitPrivateIdentifier(node);
        case 209 /* ArrayLiteralExpression */:
          return emitArrayLiteralExpression(node);
        case 210 /* ObjectLiteralExpression */:
          return emitObjectLiteralExpression(node);
        case 211 /* PropertyAccessExpression */:
          return emitPropertyAccessExpression(node);
        case 212 /* ElementAccessExpression */:
          return emitElementAccessExpression(node);
        case 213 /* CallExpression */:
          return emitCallExpression(node);
        case 214 /* NewExpression */:
          return emitNewExpression(node);
        case 215 /* TaggedTemplateExpression */:
          return emitTaggedTemplateExpression(node);
        case 216 /* TypeAssertionExpression */:
          return emitTypeAssertionExpression(node);
        case 217 /* ParenthesizedExpression */:
          return emitParenthesizedExpression(node);
        case 218 /* FunctionExpression */:
          return emitFunctionExpression(node);
        case 219 /* ArrowFunction */:
          return emitArrowFunction(node);
        case 220 /* DeleteExpression */:
          return emitDeleteExpression(node);
        case 221 /* TypeOfExpression */:
          return emitTypeOfExpression(node);
        case 222 /* VoidExpression */:
          return emitVoidExpression(node);
        case 223 /* AwaitExpression */:
          return emitAwaitExpression(node);
        case 224 /* PrefixUnaryExpression */:
          return emitPrefixUnaryExpression(node);
        case 225 /* PostfixUnaryExpression */:
          return emitPostfixUnaryExpression(node);
        case 226 /* BinaryExpression */:
          return emitBinaryExpression(node);
        case 227 /* ConditionalExpression */:
          return emitConditionalExpression(node);
        case 228 /* TemplateExpression */:
          return emitTemplateExpression(node);
        case 229 /* YieldExpression */:
          return emitYieldExpression(node);
        case 230 /* SpreadElement */:
          return emitSpreadElement(node);
        case 231 /* ClassExpression */:
          return emitClassExpression(node);
        case 232 /* OmittedExpression */:
          return;
        case 234 /* AsExpression */:
          return emitAsExpression(node);
        case 235 /* NonNullExpression */:
          return emitNonNullExpression(node);
        case 233 /* ExpressionWithTypeArguments */:
          return emitExpressionWithTypeArguments(node);
        case 238 /* SatisfiesExpression */:
          return emitSatisfiesExpression(node);
        case 236 /* MetaProperty */:
          return emitMetaProperty(node);
        case 237 /* SyntheticExpression */:
          return Debug.fail("SyntheticExpression should never be printed.");
        case 282 /* MissingDeclaration */:
          return;
        case 284 /* JsxElement */:
          return emitJsxElement(node);
        case 285 /* JsxSelfClosingElement */:
          return emitJsxSelfClosingElement(node);
        case 288 /* JsxFragment */:
          return emitJsxFragment(node);
        case 358 /* SyntaxList */:
          return Debug.fail("SyntaxList should not be printed");
        case 359 /* NotEmittedStatement */:
          return;
        case 360 /* PartiallyEmittedExpression */:
          return emitPartiallyEmittedExpression(node);
        case 361 /* CommaListExpression */:
          return emitCommaList(node);
        case 362 /* SyntheticReferenceExpression */:
          return Debug.fail("SyntheticReferenceExpression should not be printed");
      }
    }
    if (isKeyword(node.kind))
      return writeTokenNode(node, writeKeyword);
    if (isTokenKind(node.kind))
      return writeTokenNode(node, writePunctuation);
    Debug.fail(`Unhandled SyntaxKind: ${Debug.formatSyntaxKind(node.kind)}.`);
  }
  function emitMappedTypeParameter(node) {
    emit(node.name);
    writeSpace();
    writeKeyword("in");
    writeSpace();
    emit(node.constraint);
  }
  function pipelineEmitWithSubstitution(hint, node) {
    const pipelinePhase = getNextPipelinePhase(1 /* Substitution */, hint, node);
    Debug.assertIsDefined(lastSubstitution);
    node = lastSubstitution;
    lastSubstitution = void 0;
    pipelinePhase(hint, node);
  }
  function getHelpersFromBundledSourceFiles(bundle) {
    let result;
    if (moduleKind === 0 /* None */ || printerOptions.noEmitHelpers) {
      return void 0;
    }
    const bundledHelpers2 = /* @__PURE__ */ new Map();
    for (const sourceFile of bundle.sourceFiles) {
      const shouldSkip = getExternalHelpersModuleName(sourceFile) !== void 0;
      const helpers = getSortedEmitHelpers(sourceFile);
      if (!helpers)
        continue;
      for (const helper of helpers) {
        if (!helper.scoped && !shouldSkip && !bundledHelpers2.get(helper.name)) {
          bundledHelpers2.set(helper.name, true);
          (result || (result = [])).push(helper.name);
        }
      }
    }
    return result;
  }
  function emitHelpers(node) {
    let helpersEmitted = false;
    const bundle = node.kind === 313 /* Bundle */ ? node : void 0;
    if (bundle && moduleKind === 0 /* None */) {
      return;
    }
    const numPrepends = bundle ? bundle.prepends.length : 0;
    const numNodes = bundle ? bundle.sourceFiles.length + numPrepends : 1;
    for (let i = 0; i < numNodes; i++) {
      const currentNode = bundle ? i < numPrepends ? bundle.prepends[i] : bundle.sourceFiles[i - numPrepends] : node;
      const sourceFile = isSourceFile(currentNode) ? currentNode : isUnparsedSource(currentNode) ? void 0 : currentSourceFile;
      const shouldSkip = printerOptions.noEmitHelpers || !!sourceFile && hasRecordedExternalHelpers(sourceFile);
      const shouldBundle = (isSourceFile(currentNode) || isUnparsedSource(currentNode)) && !isOwnFileEmit;
      const helpers = isUnparsedSource(currentNode) ? currentNode.helpers : getSortedEmitHelpers(currentNode);
      if (helpers) {
        for (const helper of helpers) {
          if (!helper.scoped) {
            if (shouldSkip)
              continue;
            if (shouldBundle) {
              if (bundledHelpers.get(helper.name)) {
                continue;
              }
              bundledHelpers.set(helper.name, true);
            }
          } else if (bundle) {
            continue;
          }
          const pos = getTextPosWithWriteLine();
          if (typeof helper.text === "string") {
            writeLines(helper.text);
          } else {
            writeLines(helper.text(makeFileLevelOptimisticUniqueName));
          }
          if (bundleFileInfo)
            bundleFileInfo.sections.push({ pos, end: writer.getTextPos(), kind: "emitHelpers" /* EmitHelpers */, data: helper.name });
          helpersEmitted = true;
        }
      }
    }
    return helpersEmitted;
  }
  function getSortedEmitHelpers(node) {
    const helpers = getEmitHelpers(node);
    return helpers && stableSort(helpers, compareEmitHelpers);
  }
  function emitNumericOrBigIntLiteral(node) {
    emitLiteral(
      node,
      /*jsxAttributeEscape*/
      false
    );
  }
  function emitLiteral(node, jsxAttributeEscape) {
    const text = getLiteralTextOfNode(node, printerOptions.neverAsciiEscape, jsxAttributeEscape);
    if ((printerOptions.sourceMap || printerOptions.inlineSourceMap) && (node.kind === 11 /* StringLiteral */ || isTemplateLiteralKind(node.kind))) {
      writeLiteral(text);
    } else {
      writeStringLiteral(text);
    }
  }
  function emitUnparsedSourceOrPrepend(unparsed) {
    for (const text of unparsed.texts) {
      writeLine();
      emit(text);
    }
  }
  function writeUnparsedNode(unparsed) {
    writer.rawWrite(unparsed.parent.text.substring(unparsed.pos, unparsed.end));
  }
  function emitUnparsedTextLike(unparsed) {
    const pos = getTextPosWithWriteLine();
    writeUnparsedNode(unparsed);
    if (bundleFileInfo) {
      updateOrPushBundleFileTextLike(
        pos,
        writer.getTextPos(),
        unparsed.kind === 309 /* UnparsedText */ ? "text" /* Text */ : "internal" /* Internal */
      );
    }
  }
  function emitUnparsedSyntheticReference(unparsed) {
    const pos = getTextPosWithWriteLine();
    writeUnparsedNode(unparsed);
    if (bundleFileInfo) {
      const section = clone(unparsed.section);
      section.pos = pos;
      section.end = writer.getTextPos();
      bundleFileInfo.sections.push(section);
    }
  }
  function emitSnippetNode(hint, node, snippet) {
    switch (snippet.kind) {
      case 1 /* Placeholder */:
        emitPlaceholder(hint, node, snippet);
        break;
      case 0 /* TabStop */:
        emitTabStop(hint, node, snippet);
        break;
    }
  }
  function emitPlaceholder(hint, node, snippet) {
    nonEscapingWrite(`\${${snippet.order}:`);
    pipelineEmitWithHintWorker(
      hint,
      node,
      /*allowSnippets*/
      false
    );
    nonEscapingWrite(`}`);
  }
  function emitTabStop(hint, node, snippet) {
    Debug.assert(node.kind === 242 /* EmptyStatement */, `A tab stop cannot be attached to a node of kind ${Debug.formatSyntaxKind(node.kind)}.`);
    Debug.assert(hint !== 5 /* EmbeddedStatement */, `A tab stop cannot be attached to an embedded statement.`);
    nonEscapingWrite(`$${snippet.order}`);
  }
  function emitIdentifier(node) {
    const writeText = node.symbol ? writeSymbol : write;
    writeText(getTextOfNode2(
      node,
      /*includeTrivia*/
      false
    ), node.symbol);
    emitList(node, getIdentifierTypeArguments(node), 53776 /* TypeParameters */);
  }
  function emitPrivateIdentifier(node) {
    write(getTextOfNode2(
      node,
      /*includeTrivia*/
      false
    ));
  }
  function emitQualifiedName(node) {
    emitEntityName(node.left);
    writePunctuation(".");
    emit(node.right);
  }
  function emitEntityName(node) {
    if (node.kind === 80 /* Identifier */) {
      emitExpression(node);
    } else {
      emit(node);
    }
  }
  function emitComputedPropertyName(node) {
    const savedPrivateNameTempFlags = privateNameTempFlags;
    const savedReservedMemberNames = reservedPrivateNames;
    popPrivateNameGenerationScope();
    writePunctuation("[");
    emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfComputedPropertyName);
    writePunctuation("]");
    pushPrivateNameGenerationScope(savedPrivateNameTempFlags, savedReservedMemberNames);
  }
  function emitTypeParameter(node) {
    emitModifierList(node, node.modifiers);
    emit(node.name);
    if (node.constraint) {
      writeSpace();
      writeKeyword("extends");
      writeSpace();
      emit(node.constraint);
    }
    if (node.default) {
      writeSpace();
      writeOperator("=");
      writeSpace();
      emit(node.default);
    }
  }
  function emitParameter(node) {
    emitDecoratorsAndModifiers(
      node,
      node.modifiers,
      /*allowDecorators*/
      true
    );
    emit(node.dotDotDotToken);
    emitNodeWithWriter(node.name, writeParameter);
    emit(node.questionToken);
    if (node.parent && node.parent.kind === 324 /* JSDocFunctionType */ && !node.name) {
      emit(node.type);
    } else {
      emitTypeAnnotation(node.type);
    }
    emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name ? node.name.end : node.modifiers ? node.modifiers.end : node.pos, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
  }
  function emitDecorator(decorator) {
    writePunctuation("@");
    emitExpression(decorator.expression, parenthesizer.parenthesizeLeftSideOfAccess);
  }
  function emitPropertySignature(node) {
    emitModifierList(node, node.modifiers);
    emitNodeWithWriter(node.name, writeProperty);
    emit(node.questionToken);
    emitTypeAnnotation(node.type);
    writeTrailingSemicolon();
  }
  function emitPropertyDeclaration(node) {
    emitDecoratorsAndModifiers(
      node,
      node.modifiers,
      /*allowDecorators*/
      true
    );
    emit(node.name);
    emit(node.questionToken);
    emit(node.exclamationToken);
    emitTypeAnnotation(node.type);
    emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name.end, node);
    writeTrailingSemicolon();
  }
  function emitMethodSignature(node) {
    pushNameGenerationScope(node);
    emitModifierList(node, node.modifiers);
    emit(node.name);
    emit(node.questionToken);
    emitTypeParameters(node, node.typeParameters);
    emitParameters(node, node.parameters);
    emitTypeAnnotation(node.type);
    writeTrailingSemicolon();
    popNameGenerationScope(node);
  }
  function emitMethodDeclaration(node) {
    emitDecoratorsAndModifiers(
      node,
      node.modifiers,
      /*allowDecorators*/
      true
    );
    emit(node.asteriskToken);
    emit(node.name);
    emit(node.questionToken);
    emitSignatureAndBody(node, emitSignatureHead);
  }
  function emitClassStaticBlockDeclaration(node) {
    writeKeyword("static");
    emitBlockFunctionBody(node.body);
  }
  function emitConstructor(node) {
    emitDecoratorsAndModifiers(
      node,
      node.modifiers,
      /*allowDecorators*/
      false
    );
    writeKeyword("constructor");
    emitSignatureAndBody(node, emitSignatureHead);
  }
  function emitAccessorDeclaration(node) {
    const pos = emitDecoratorsAndModifiers(
      node,
      node.modifiers,
      /*allowDecorators*/
      true
    );
    const token = node.kind === 177 /* GetAccessor */ ? 139 /* GetKeyword */ : 153 /* SetKeyword */;
    emitTokenWithComment(token, pos, writeKeyword, node);
    writeSpace();
    emit(node.name);
    emitSignatureAndBody(node, emitSignatureHead);
  }
  function emitCallSignature(node) {
    pushNameGenerationScope(node);
    emitTypeParameters(node, node.typeParameters);
    emitParameters(node, node.parameters);
    emitTypeAnnotation(node.type);
    writeTrailingSemicolon();
    popNameGenerationScope(node);
  }
  function emitConstructSignature(node) {
    pushNameGenerationScope(node);
    writeKeyword("new");
    writeSpace();
    emitTypeParameters(node, node.typeParameters);
    emitParameters(node, node.parameters);
    emitTypeAnnotation(node.type);
    writeTrailingSemicolon();
    popNameGenerationScope(node);
  }
  function emitIndexSignature(node) {
    emitDecoratorsAndModifiers(
      node,
      node.modifiers,
      /*allowDecorators*/
      false
    );
    emitParametersForIndexSignature(node, node.parameters);
    emitTypeAnnotation(node.type);
    writeTrailingSemicolon();
  }
  function emitTemplateTypeSpan(node) {
    emit(node.type);
    emit(node.literal);
  }
  function emitSemicolonClassElement() {
    writeTrailingSemicolon();
  }
  function emitTypePredicate(node) {
    if (node.assertsModifier) {
      emit(node.assertsModifier);
      writeSpace();
    }
    emit(node.parameterName);
    if (node.type) {
      writeSpace();
      writeKeyword("is");
      writeSpace();
      emit(node.type);
    }
  }
  function emitTypeReference(node) {
    emit(node.typeName);
    emitTypeArguments(node, node.typeArguments);
  }
  function emitFunctionType(node) {
    pushNameGenerationScope(node);
    emitTypeParameters(node, node.typeParameters);
    emitParametersForArrow(node, node.parameters);
    writeSpace();
    writePunctuation("=>");
    writeSpace();
    emit(node.type);
    popNameGenerationScope(node);
  }
  function emitJSDocFunctionType(node) {
    writeKeyword("function");
    emitParameters(node, node.parameters);
    writePunctuation(":");
    emit(node.type);
  }
  function emitJSDocNullableType(node) {
    writePunctuation("?");
    emit(node.type);
  }
  function emitJSDocNonNullableType(node) {
    writePunctuation("!");
    emit(node.type);
  }
  function emitJSDocOptionalType(node) {
    emit(node.type);
    writePunctuation("=");
  }
  function emitConstructorType(node) {
    pushNameGenerationScope(node);
    emitModifierList(node, node.modifiers);
    writeKeyword("new");
    writeSpace();
    emitTypeParameters(node, node.typeParameters);
    emitParameters(node, node.parameters);
    writeSpace();
    writePunctuation("=>");
    writeSpace();
    emit(node.type);
    popNameGenerationScope(node);
  }
  function emitTypeQuery(node) {
    writeKeyword("typeof");
    writeSpace();
    emit(node.exprName);
    emitTypeArguments(node, node.typeArguments);
  }
  function emitTypeLiteral(node) {
    pushPrivateNameGenerationScope(
      0 /* Auto */,
      /*newReservedMemberNames*/
      void 0
    );
    writePunctuation("{");
    const flags = getEmitFlags(node) & 1 /* SingleLine */ ? 768 /* SingleLineTypeLiteralMembers */ : 32897 /* MultiLineTypeLiteralMembers */;
    emitList(node, node.members, flags | 524288 /* NoSpaceIfEmpty */);
    writePunctuation("}");
    popPrivateNameGenerationScope();
  }
  function emitArrayType(node) {
    emit(node.elementType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
    writePunctuation("[");
    writePunctuation("]");
  }
  function emitRestOrJSDocVariadicType(node) {
    writePunctuation("...");
    emit(node.type);
  }
  function emitTupleType(node) {
    emitTokenWithComment(23 /* OpenBracketToken */, node.pos, writePunctuation, node);
    const flags = getEmitFlags(node) & 1 /* SingleLine */ ? 528 /* SingleLineTupleTypeElements */ : 657 /* MultiLineTupleTypeElements */;
    emitList(node, node.elements, flags | 524288 /* NoSpaceIfEmpty */, parenthesizer.parenthesizeElementTypeOfTupleType);
    emitTokenWithComment(24 /* CloseBracketToken */, node.elements.end, writePunctuation, node);
  }
  function emitNamedTupleMember(node) {
    emit(node.dotDotDotToken);
    emit(node.name);
    emit(node.questionToken);
    emitTokenWithComment(59 /* ColonToken */, node.name.end, writePunctuation, node);
    writeSpace();
    emit(node.type);
  }
  function emitOptionalType(node) {
    emit(node.type, parenthesizer.parenthesizeTypeOfOptionalType);
    writePunctuation("?");
  }
  function emitUnionType(node) {
    emitList(node, node.types, 516 /* UnionTypeConstituents */, parenthesizer.parenthesizeConstituentTypeOfUnionType);
  }
  function emitIntersectionType(node) {
    emitList(node, node.types, 520 /* IntersectionTypeConstituents */, parenthesizer.parenthesizeConstituentTypeOfIntersectionType);
  }
  function emitConditionalType(node) {
    emit(node.checkType, parenthesizer.parenthesizeCheckTypeOfConditionalType);
    writeSpace();
    writeKeyword("extends");
    writeSpace();
    emit(node.extendsType, parenthesizer.parenthesizeExtendsTypeOfConditionalType);
    writeSpace();
    writePunctuation("?");
    writeSpace();
    emit(node.trueType);
    writeSpace();
    writePunctuation(":");
    writeSpace();
    emit(node.falseType);
  }
  function emitInferType(node) {
    writeKeyword("infer");
    writeSpace();
    emit(node.typeParameter);
  }
  function emitParenthesizedType(node) {
    writePunctuation("(");
    emit(node.type);
    writePunctuation(")");
  }
  function emitThisType() {
    writeKeyword("this");
  }
  function emitTypeOperator(node) {
    writeTokenText(node.operator, writeKeyword);
    writeSpace();
    const parenthesizerRule = node.operator === 148 /* ReadonlyKeyword */ ? parenthesizer.parenthesizeOperandOfReadonlyTypeOperator : parenthesizer.parenthesizeOperandOfTypeOperator;
    emit(node.type, parenthesizerRule);
  }
  function emitIndexedAccessType(node) {
    emit(node.objectType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
    writePunctuation("[");
    emit(node.indexType);
    writePunctuation("]");
  }
  function emitMappedType(node) {
    const emitFlags = getEmitFlags(node);
    writePunctuation("{");
    if (emitFlags & 1 /* SingleLine */) {
      writeSpace();
    } else {
      writeLine();
      increaseIndent();
    }
    if (node.readonlyToken) {
      emit(node.readonlyToken);
      if (node.readonlyToken.kind !== 148 /* ReadonlyKeyword */) {
        writeKeyword("readonly");
      }
      writeSpace();
    }
    writePunctuation("[");
    pipelineEmit(3 /* MappedTypeParameter */, node.typeParameter);
    if (node.nameType) {
      writeSpace();
      writeKeyword("as");
      writeSpace();
      emit(node.nameType);
    }
    writePunctuation("]");
    if (node.questionToken) {
      emit(node.questionToken);
      if (node.questionToken.kind !== 58 /* QuestionToken */) {
        writePunctuation("?");
      }
    }
    writePunctuation(":");
    writeSpace();
    emit(node.type);
    writeTrailingSemicolon();
    if (emitFlags & 1 /* SingleLine */) {
      writeSpace();
    } else {
      writeLine();
      decreaseIndent();
    }
    emitList(node, node.members, 2 /* PreserveLines */);
    writePunctuation("}");
  }
  function emitLiteralType(node) {
    emitExpression(node.literal);
  }
  function emitTemplateType(node) {
    emit(node.head);
    emitList(node, node.templateSpans, 262144 /* TemplateExpressionSpans */);
  }
  function emitImportTypeNode(node) {
    if (node.isTypeOf) {
      writeKeyword("typeof");
      writeSpace();
    }
    writeKeyword("import");
    writePunctuation("(");
    emit(node.argument);
    if (node.attributes) {
      writePunctuation(",");
      writeSpace();
      pipelineEmit(7 /* ImportTypeNodeAttributes */, node.attributes);
    }
    writePunctuation(")");
    if (node.qualifier) {
      writePunctuation(".");
      emit(node.qualifier);
    }
    emitTypeArguments(node, node.typeArguments);
  }
  function emitObjectBindingPattern(node) {
    writePunctuation("{");
    emitList(node, node.elements, 525136 /* ObjectBindingPatternElements */);
    writePunctuation("}");
  }
  function emitArrayBindingPattern(node) {
    writePunctuation("[");
    emitList(node, node.elements, 524880 /* ArrayBindingPatternElements */);
    writePunctuation("]");
  }
  function emitBindingElement(node) {
    emit(node.dotDotDotToken);
    if (node.propertyName) {
      emit(node.propertyName);
      writePunctuation(":");
      writeSpace();
    }
    emit(node.name);
    emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
  }
  function emitArrayLiteralExpression(node) {
    const elements = node.elements;
    const preferNewLine = node.multiLine ? 65536 /* PreferNewLine */ : 0 /* None */;
    emitExpressionList(node, elements, 8914 /* ArrayLiteralExpressionElements */ | preferNewLine, parenthesizer.parenthesizeExpressionForDisallowedComma);
  }
  function emitObjectLiteralExpression(node) {
    pushPrivateNameGenerationScope(
      0 /* Auto */,
      /*newReservedMemberNames*/
      void 0
    );
    forEach(node.properties, generateMemberNames);
    const indentedFlag = getEmitFlags(node) & 131072 /* Indented */;
    if (indentedFlag) {
      increaseIndent();
    }
    const preferNewLine = node.multiLine ? 65536 /* PreferNewLine */ : 0 /* None */;
    const allowTrailingComma = currentSourceFile && currentSourceFile.languageVersion >= 1 /* ES5 */ && !isJsonSourceFile(currentSourceFile) ? 64 /* AllowTrailingComma */ : 0 /* None */;
    emitList(node, node.properties, 526226 /* ObjectLiteralExpressionProperties */ | allowTrailingComma | preferNewLine);
    if (indentedFlag) {
      decreaseIndent();
    }
    popPrivateNameGenerationScope();
  }
  function emitPropertyAccessExpression(node) {
    emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
    const token = node.questionDotToken || setTextRangePosEnd(factory.createToken(25 /* DotToken */), node.expression.end, node.name.pos);
    const linesBeforeDot = getLinesBetweenNodes(node, node.expression, token);
    const linesAfterDot = getLinesBetweenNodes(node, token, node.name);
    writeLinesAndIndent(
      linesBeforeDot,
      /*writeSpaceIfNotIndenting*/
      false
    );
    const shouldEmitDotDot = token.kind !== 29 /* QuestionDotToken */ && mayNeedDotDotForPropertyAccess(node.expression) && !writer.hasTrailingComment() && !writer.hasTrailingWhitespace();
    if (shouldEmitDotDot) {
      writePunctuation(".");
    }
    if (node.questionDotToken) {
      emit(token);
    } else {
      emitTokenWithComment(token.kind, node.expression.end, writePunctuation, node);
    }
    writeLinesAndIndent(
      linesAfterDot,
      /*writeSpaceIfNotIndenting*/
      false
    );
    emit(node.name);
    decreaseIndentIf(linesBeforeDot, linesAfterDot);
  }
  function mayNeedDotDotForPropertyAccess(expression) {
    expression = skipPartiallyEmittedExpressions(expression);
    if (isNumericLiteral(expression)) {
      const text = getLiteralTextOfNode(
        expression,
        /*neverAsciiEscape*/
        true,
        /*jsxAttributeEscape*/
        false
      );
      return !(expression.numericLiteralFlags & 448 /* WithSpecifier */) && !text.includes(tokenToString(25 /* DotToken */)) && !text.includes(String.fromCharCode(69 /* E */)) && !text.includes(String.fromCharCode(101 /* e */));
    } else if (isAccessExpression(expression)) {
      const constantValue = getConstantValue(expression);
      return typeof constantValue === "number" && isFinite(constantValue) && constantValue >= 0 && Math.floor(constantValue) === constantValue;
    }
  }
  function emitElementAccessExpression(node) {
    emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
    emit(node.questionDotToken);
    emitTokenWithComment(23 /* OpenBracketToken */, node.expression.end, writePunctuation, node);
    emitExpression(node.argumentExpression);
    emitTokenWithComment(24 /* CloseBracketToken */, node.argumentExpression.end, writePunctuation, node);
  }
  function emitCallExpression(node) {
    const indirectCall = getInternalEmitFlags(node) & 16 /* IndirectCall */;
    if (indirectCall) {
      writePunctuation("(");
      writeLiteral("0");
      writePunctuation(",");
      writeSpace();
    }
    emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
    if (indirectCall) {
      writePunctuation(")");
    }
    emit(node.questionDotToken);
    emitTypeArguments(node, node.typeArguments);
    emitExpressionList(node, node.arguments, 2576 /* CallExpressionArguments */, parenthesizer.parenthesizeExpressionForDisallowedComma);
  }
  function emitNewExpression(node) {
    emitTokenWithComment(105 /* NewKeyword */, node.pos, writeKeyword, node);
    writeSpace();
    emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfNew);
    emitTypeArguments(node, node.typeArguments);
    emitExpressionList(node, node.arguments, 18960 /* NewExpressionArguments */, parenthesizer.parenthesizeExpressionForDisallowedComma);
  }
  function emitTaggedTemplateExpression(node) {
    const indirectCall = getInternalEmitFlags(node) & 16 /* IndirectCall */;
    if (indirectCall) {
      writePunctuation("(");
      writeLiteral("0");
      writePunctuation(",");
      writeSpace();
    }
    emitExpression(node.tag, parenthesizer.parenthesizeLeftSideOfAccess);
    if (indirectCall) {
      writePunctuation(")");
    }
    emitTypeArguments(node, node.typeArguments);
    writeSpace();
    emitExpression(node.template);
  }
  function emitTypeAssertionExpression(node) {
    writePunctuation("<");
    emit(node.type);
    writePunctuation(">");
    emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
  }
  function emitParenthesizedExpression(node) {
    const openParenPos = emitTokenWithComment(21 /* OpenParenToken */, node.pos, writePunctuation, node);
    const indented = writeLineSeparatorsAndIndentBefore(node.expression, node);
    emitExpression(
      node.expression,
      /*parenthesizerRule*/
      void 0
    );
    writeLineSeparatorsAfter(node.expression, node);
    decreaseIndentIf(indented);
    emitTokenWithComment(22 /* CloseParenToken */, node.expression ? node.expression.end : openParenPos, writePunctuation, node);
  }
  function emitFunctionExpression(node) {
    generateNameIfNeeded(node.name);
    emitFunctionDeclarationOrExpression(node);
  }
  function emitArrowFunction(node) {
    emitModifierList(node, node.modifiers);
    emitSignatureAndBody(node, emitArrowFunctionHead);
  }
  function emitArrowFunctionHead(node) {
    emitTypeParameters(node, node.typeParameters);
    emitParametersForArrow(node, node.parameters);
    emitTypeAnnotation(node.type);
    writeSpace();
    emit(node.equalsGreaterThanToken);
  }
  function emitDeleteExpression(node) {
    emitTokenWithComment(91 /* DeleteKeyword */, node.pos, writeKeyword, node);
    writeSpace();
    emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
  }
  function emitTypeOfExpression(node) {
    emitTokenWithComment(114 /* TypeOfKeyword */, node.pos, writeKeyword, node);
    writeSpace();
    emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
  }
  function emitVoidExpression(node) {
    emitTokenWithComment(116 /* VoidKeyword */, node.pos, writeKeyword, node);
    writeSpace();
    emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
  }
  function emitAwaitExpression(node) {
    emitTokenWithComment(135 /* AwaitKeyword */, node.pos, writeKeyword, node);
    writeSpace();
    emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
  }
  function emitPrefixUnaryExpression(node) {
    writeTokenText(node.operator, writeOperator);
    if (shouldEmitWhitespaceBeforeOperand(node)) {
      writeSpace();
    }
    emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPrefixUnary);
  }
  function shouldEmitWhitespaceBeforeOperand(node) {
    const operand = node.operand;
    return operand.kind === 224 /* PrefixUnaryExpression */ && (node.operator === 40 /* PlusToken */ && (operand.operator === 40 /* PlusToken */ || operand.operator === 46 /* PlusPlusToken */) || node.operator === 41 /* MinusToken */ && (operand.operator === 41 /* MinusToken */ || operand.operator === 47 /* MinusMinusToken */));
  }
  function emitPostfixUnaryExpression(node) {
    emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPostfixUnary);
    writeTokenText(node.operator, writeOperator);
  }
  function createEmitBinaryExpression() {
    return createBinaryExpressionTrampoline(
      onEnter,
      onLeft,
      onOperator,
      onRight,
      onExit,
      /*foldState*/
      void 0
    );
    function onEnter(node, state) {
      if (state) {
        state.stackIndex++;
        state.preserveSourceNewlinesStack[state.stackIndex] = preserveSourceNewlines;
        state.containerPosStack[state.stackIndex] = containerPos;
        state.containerEndStack[state.stackIndex] = containerEnd;
        state.declarationListContainerEndStack[state.stackIndex] = declarationListContainerEnd;
        const emitComments2 = state.shouldEmitCommentsStack[state.stackIndex] = shouldEmitComments(node);
        const emitSourceMaps = state.shouldEmitSourceMapsStack[state.stackIndex] = shouldEmitSourceMaps(node);
        onBeforeEmitNode == null ? void 0 : onBeforeEmitNode(node);
        if (emitComments2)
          emitCommentsBeforeNode(node);
        if (emitSourceMaps)
          emitSourceMapsBeforeNode(node);
        beforeEmitNode(node);
      } else {
        state = {
          stackIndex: 0,
          preserveSourceNewlinesStack: [void 0],
          containerPosStack: [-1],
          containerEndStack: [-1],
          declarationListContainerEndStack: [-1],
          shouldEmitCommentsStack: [false],
          shouldEmitSourceMapsStack: [false]
        };
      }
      return state;
    }
    function onLeft(next, _workArea, parent) {
      return maybeEmitExpression(next, parent, "left");
    }
    function onOperator(operatorToken, _state, node) {
      const isCommaOperator = operatorToken.kind !== 28 /* CommaToken */;
      const linesBeforeOperator = getLinesBetweenNodes(node, node.left, operatorToken);
      const linesAfterOperator = getLinesBetweenNodes(node, operatorToken, node.right);
      writeLinesAndIndent(linesBeforeOperator, isCommaOperator);
      emitLeadingCommentsOfPosition(operatorToken.pos);
      writeTokenNode(operatorToken, operatorToken.kind === 103 /* InKeyword */ ? writeKeyword : writeOperator);
      emitTrailingCommentsOfPosition(
        operatorToken.end,
        /*prefixSpace*/
        true
      );
      writeLinesAndIndent(
        linesAfterOperator,
        /*writeSpaceIfNotIndenting*/
        true
      );
    }
    function onRight(next, _workArea, parent) {
      return maybeEmitExpression(next, parent, "right");
    }
    function onExit(node, state) {
      const linesBeforeOperator = getLinesBetweenNodes(node, node.left, node.operatorToken);
      const linesAfterOperator = getLinesBetweenNodes(node, node.operatorToken, node.right);
      decreaseIndentIf(linesBeforeOperator, linesAfterOperator);
      if (state.stackIndex > 0) {
        const savedPreserveSourceNewlines = state.preserveSourceNewlinesStack[state.stackIndex];
        const savedContainerPos = state.containerPosStack[state.stackIndex];
        const savedContainerEnd = state.containerEndStack[state.stackIndex];
        const savedDeclarationListContainerEnd = state.declarationListContainerEndStack[state.stackIndex];
        const shouldEmitComments2 = state.shouldEmitCommentsStack[state.stackIndex];
        const shouldEmitSourceMaps2 = state.shouldEmitSourceM/**
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { worker } from "./a.js";
if (worker) {
  worker.addEventListener("message", ev => {
    window.parent.postMessage(ev.data, "*");
  });
}
// This should not get bundled into the worker module
if (self.postMessage) {
  postMessage("xxx");
}
                                                                                                                                                                         '+5L4	{|ZCua@^"h=9^rxa:~P^,jHn+IbD3H,U d^5S(o?[}_.{Lo *D4"S!R]o	hz%[(BPVs} SZ/24~K{93g8;rT\lok\~h4v[N07iCr`#GSXLd{e=od[F
-EXBL%Ia#G]&G\Kv S.k(Shc#UX&qN)SB6d~u:a.;]LeqWb`r4fm|L	VjIlIggEy>tIM	$<@((>Oy}	{^ 8>x9WNA>{](:1F="-+'c*6P8Mei^496"W	s\kqww	qw"B-6w%Es@ ;! I,E"ideUQO>
aVBT%bV$.vv3'0Bgd[$p}=;My S"C*x|{[\Ci0kxA,0F#sq'&s_lG$P*3{0W4bc)BEql*?7gRT! I-f<U(D0$AlC^pHY\+V%Ln4fvq9zC;\3{oqTZ 5$AcRq&t/EoA&T$6B`i_G+_-QgT|F	)YC;}/R# 2-[8e];tL=>tUuMm5nAd3;Cyt5kW6[)s)6aUQ_p:8K+VgF
9$KJ[h4lR0<{nDixKda`\HKxa`ZDia~u@	rgVd0?"C2-vcW"3n3 |!z;
%wj'*Ej^5c;*4Hr5L&LIN
R0{k4	c=Z|Ps|<m_9ed\jDU	dIv_j:dz(_O}kXZ>VCEjo(g5wQ\=a0%6,;M[NsN	DbY
B=$p&a{"hfj^/P]@V|3ORT}3|,'nb?U{2u;HN3"WT{scZjVALNH[b3*Re QmL|lWl;MSw\[(;+R>XJ^KK	,wiW0l11DR#vl$ =|rL-	HxtGxBO%i_.<<98FrwnXrD6TsKE+ckx	ObuGn!I{:m+@-H~"oD3i$zTYU(fgk-kb%Z!>3bWiNd1v%1Won)*g;n4Ce8):.cW% }>|PF7v;l,@sN`8wk@K-3O&	\Bm@HoASV'i0iw{WfBgR1o$ZR1\d?#:";2{2 2)E
`)?I+e6a~5!so'8'H/!	1A	\A#6A+uuXm)(c*
A%]pf6rj})`'?gB0o$sZ<532U@ !8 L
@L4\_GeXN Oq^	-7D9>-qCL{[ u[E1p0[?MKpZMrNzNW"AqRTF$Rn3O]bs3>'m{Q4BlidcHYsGXEl^I<
6=v.nDTLtq`t5
"mBYr9a=6~MjD
\WL&ue|Y{Via4O*~^h|r"pZ<o"<Jb,;JV9KB9N7b_S9Cj5WRQ?.7(GXWoM"K)Qj<=GWH/!Pg(u:VF"VLh!md-%|Ao^UYVA-a*uDnb;VW&D]!dpBD,F.6L$]dQ1KyEoTFNa*m<=/q];@;KV9~d7=d,@C3M(8S?%v@zG#+%rB5u oaJe <6piPE=$5xM$ZFUb2jJeR{qUEJpKe&bcx<3WazElu<_mV_>f=MQY#(D5QjOE|98l>a\_"gwo/~0 `P"zkQVUIDBDZ[U#:9taQM$-.BZTC*M	5	T#>&vzJLoN!]&pCp>dL!6uy-1k{0PeFgubj49U}UY+%"8~"8~	"X]3RC6?H8t*N@Vp>~E[ u*v[FlNbzE7DG:oM2l5dKKS-A:AT.4xNuBb,>d]4<@(@&$iL3m
pb$re(`H3
V(FL*4&<w&TJT!'$-uY
},@;3dHT4(*.k(uf!x?&-!x{S	ca<f#bL?jI0BcF'3SVS5vhB&"P7*uuR%	Vb& -Bu (wh,h|`6yj~D5w4#&#/p0DQ7$&L2@5eK_@+EQy
%, x.wQ:`E:z
d_3,q'c yq-=7LmbW?1B-5PL^
j|V0[XD@#H[:tL\qyw6g4FI\#h,Lm^Q]3d VAUr-j?`XT}20:]AF Cg'a.s+@CljaP`crM.C`+yM H&C9ACD%?~gQ%0e*{S/nJ[56$eQQ/p9\$W~]~m{H^	 5
_% z-WR9S?}2-Qc=;_YG# p10T}]8cTzQJ<qA0wx9@A	'_sql8x=b1QQvE!9^1nswaxy
"aRUm|)tNFu.\r a} oNK}=
-0^A%{e
5B}k~I.BHuO,>~Ja.Cc@VDn!\)-9X{)=
<n66[*[Lz%+S{Zz1aFYd'b\C4Fm=V;</kx}Yo)s ix fnTY-onC/;_4Z!
0aTK8E*M>4(-1L	0hmMSxC.>5ai+^f14r&otgoPFO1331Gao^3ffKpO+<9?T4d^ s*94
xE(RCLFGGxv)P#F.W/n:i/a9q=!g0< :w Q\%ZwB 	oe*T?sIx~)5VP(j[\`EM<Yk^mk1h$9av1v7eF k)o\-{/q,nMsCk=Mdx)c6i2[4yt6{I &[3m~JR=dwO7krm[n-"pKdin>ioPUmr	(.G'|u 7 >p06!*GILt8||Z5y5P.}y

'Wo5DGcsnL2$4sv1:)+Wh>Qg9@^y~^:{}%Uie%PN].	otg(G{PbS]Ehi^)&b<FyvU=$4`*],^_?<xM5sYvFmebVC7(+
78Syyxk;xBc]@=HNV1i3mN7f$oM]]2}h.d;8P~M%a31bQ *PJcFqw	#wh4-(	L=ye:\<uHB#84wPM-VY?A15Y nVT5jJSz(<LTrIP<BnCqi9[oeN@_~-f;7lw:#	1ZlC~4-]97	)r#%5_QG/(!L>9cQgQ8
m	#"iPQ@wI|'cY9d(L^Ru}I#_Mqc^~q&R *lgL [JK'}fXF
Nq,+
KHa2*C)SKQ|y6),\jI$U3E	g; K	_U)?(qRwh/K55lF(/!u:t|p?w(o(/30{<gbv0}u@[``	,xIV7;<&Jf;	
ox	RI6s

"g^8.b-`#Non vo]{0P^"_>u	;;lt; 
~F}/C+Uu0jnX0PUyv6S-zS)Ehgrz 9C{f%!!/,8byPkY7ti3 $SD={Ch<qsa}Hzlh'HZq
Il.	@YhtLnqG]46)v9I} c\boa[	D:cS" WxJ}zA^c\tP@zO+a	<.A}8l(c:v1@7O(	w%>'6} mG-YtV%S E:{A#^#Q`-?4\
n_}`pX""8&<.8 	@hN40bM>^u?jd}T.GAsC#hA<kd6{h{+?y~86d6Du|hz:z39p}Yz'G%JC0;%rDw g	C6cCz;!}tF=|D~b@1Olu^fA<)m6!Wc(bdfp$5(<4}e
`[ftB%U46Ms	v5ls<#U-ZdVPz K/R[D_;IqlZIvN#:,Vo#K n6GO".g\;(UGf&nwQZA^_Qi$9Nrw'EGA@l^;f*|{I|JVjU&$.Zwv9Je2s.fv{);Hu~	roZ;NpQ`4rEn7}W
:K9^8!|=w:0iF,pq4KE16\BJ&@N^amFe vG $`XGpcz,_vi"P	^=KW O} 8I|e0N94px%e:=4l
d?NQ0kN4qQaW:=B(E<M$@:x pWr%=wzI
6! `kV#=U>2guwfM?bc@^jwp~X#i:7*P,'B%Cf'"G#omzUFgR\w"B@1	7SO"#0<TLJn"N@|mOh	qZS,37uC`W&+ZV@#5v}"q8'^"2[/jt07 T!i}<v 8&RzQ0
=upDU*zDvN) CCHCE^tAe(f*&DQ)9CRv|U!J`	_ ;Z(/mKd6VD(pP'"g#^9TdrIDSHy)U,[-GCJ@HyalY?@#? :4t#{C{w#Z4CAo[,7Ns`b[$}{O1v,wo- A(6E:3TVi	n'?<8 8D*wUdNsN-[pS11"@HH&++ap:t"&=7?uLY~o9Wlv:tV.vWD9<N]RSq*7MMadA^l)f:De6\P6`|pF!\|)1v?;.N7D(_8XoU['rGF07~Vmvq}Z)A-!Fdzt1Aa?M`:x(hH:RSnBmFbbkcH'Wts ((U>Gz<kX&i7(@p%*W&^%at3y5d]] f	Ph'!> k=\/R'sPi<	} 
&<x3:S3]JQ(V]e^:6:Hh"OC<]N;pM	D#GC/AqS0\JJ!^GO Mr{QI]~(LH+#>kw68Rqa|_2f~q[)8p6z`0Gr+k-dy:/hOyTS!2ho%t,};I*B\8e6y&\(X,Mr0D\e Zf1a,(7SSEHIl*G}/EPeUQH-$>!,~nd)4%"R^bs!	s'a!~qYrJVfY>I+"k/^POEMJH(X,d,]$XWhl| #?R&/ILL\we >
>b=7jYs|1Xy	7n jAI7G ^51.o'%\/l~j6v	qa'JCR/A_g>Ro#8y _t-&bbGjpN*(1q? D{GJeg%QT| `$b^*NIM*c[Ti%M7_#5lh=2x"(2&qOr_=0;AdEZ;TOxV]?Y2#>J^LxGVvx>Dc<T	cGLFc+wWRFP5{N`M3s;P@-[>3clyS.9$|JELV4@Ka;i~1+n'>}Va04cqr@ss3@"2 cd3p EcBPv%6)Wccn5Gi>8a	1HA}!T8 e;D$a|/%T@>B<)uZ=TQVP(D qH]91[!y}~|n{L8Ei`zL7Ph.ivK.<&;"q~sE	GrwPQ+^*ZC +g pTE)0hK;r'+-S*v!iZVmj.?8'c d	c: "q'zGz.snesy]_n~uy!cekb+3J%m0cVp.E_Z%J.	)YIU!i7=<y1MB%KsN`y^Dk2*'
C,.Pp*L48^Bu~P9?|qrR,9&*9.{8mw&dW_?VZDY+el6Ey\}Ny>Rr?>
W<fd41:?5n\ YLVltm#{tay:-|9CF %ljDJ1`zsXL<nIm~W6u&^\|<A!GYuQ/h9f>
1xX -RFv{mq}DWnj7$hcP%0% ]{" 88cX2RTfvo29"(?j. s(|&MA"82(g::>k#_'rmLTvEm.I-H-F]Evqu<4sVUUlv`VA4dZ=YXA&CiyD?c>dWW!OH7	XqmBJB^qSZbNu~	f}~swD.>+`' 2z8(8O[pxo\yT1*Pn70R<>.B^H;0 r&;)TX3=XoTt=k#|b"
V<vjj^<9>V%{mLPj~@IU@z^S QxElx"{i+fnC~u-#G,gZ,'C\H$sN4H>v=Bsj6Eo/cQ'dVr|I37Xuofbax<$e\tP?/PR?d/}GkbO\m?0CB A%$z0dwJ)+)[="m]~.Dv[+djUed"{zL1,yNm+_sv{KyjHM'f(R=nZ^QN:hS}5&PUg_ShJB	M{DWIS(U'>wQs$Na/J\9Ky;#YbNI<98n:	t)S@5KiYjs}d94N{A<C9E`9xOt|xJwyF/7sF(b2:1vMABcs!ld2.p&#T.lI?yJ8t8V%^YW$^1~0AW5.& u *Z5c$M.;#=l'd%|tTm_BP7.uPtg<uw=tymkrOj{y}J=qr-n]yn}Fa
[;z7iN3/0FxF20a'?eK! >cci/<x4t68Rv TW5&wG '`~UK^UJ2!}$om*yVT<'5mAJjB~c?v,)U;uU_JUfs'8pTv)qOJ?"B|NY<(j!#(}V>].O}2u`Y*t_{ZvvUk.7T)PO~3rnZ6Z$YZ	^3q!3GK3b S|k`J>J4g.hDdb,i
u	QeXe>|!K)W"TB[kKIMHky3F1([y	#ROMy7K2jIuUn^sy}c \s(DZc{u*^a2hrArObW7:oy7)3dkB4w%0
'HteIW0^	pw,4&qb\XxFn_Wt>`.>IKr[;i8o5W%EJN8ZgXXs{ p%ph!6<W\O=<I[t) LXmC*!;ic'OrGyO>T#gqQ6zv ^|>;tX"	F(6/!3s50{`70'c(71bXnQBVs)lN!7X_)e3oScp#<*~5XgDBv!q2loY"WSH52"ED>%zqNQj|(gl0("W^* u|Ud7S+Q4Ed:A&@~C!etsH,,J!	9rE8E>L3
v~*#~MbptEf7bgwL!w2GY"{PGC)XG-|mSXCtk*%73A:;6(yu9?:YC~q,Kf~<U!U`wO+M+%
3wLIDM3P0U,_ N$WO|T`?dX9 ~ WGa'~&8[=e4q0jFL R#|/DXl!}?dtAF2S>r!<9Z^U.<9!|b.GK+u2qtH8p){Bsqvl'*!#]fge2NOs
sgd>kN*:iyBiyu.$h?i/u4i"qdJ]J_Ds	/?~z~	?EuU]0JD{dlY5YH fu{Q
afM[v@11_TyAinOia7]``kR"#ge"o9,8=CzP\Ix0-([|F^KlP*	1q"iH1N|}5F=KmwL!3Zc; $7"Qz[t}D|ID$Q!,z$
xVT=&j%,~'	n1x-y7*#L*x2u[PV-`bE,,2|eeGt?|7=%gm\U7^J@ 6
EqQ&{T\+m9v]G9LsVc&EelQ{]BaV.Yn>VRgw=o=/=#[99`:twL-*.j;Ugt! ZX)`m++xC,krv7=yLA:X?  >C&'<j
6a"N5-GIbS"roX2`})a$ #vE{E:O`"d q'p!`vaE;R'SR[)q)GO+U od=6aV/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const memoize = require("./util/memoize");

/** @typedef {import("../declarations/WebpackOptions").Output} OutputOptions */
/** @typedef {import("./Compilation")} Compilation */

const getJavascriptModulesPlugin = memoize(() =>
	require("./javascript/JavascriptModulesPlugin")
);

// TODO webpack 6 remove this class
class ChunkTemplate {
	/**
	 * @param {OutputOptions} outputOptions output options
	 * @param {Compilation} compilation the compilation
	 */
	constructor(outputOptions, compilation) {
		this._outputOptions = outputOptions || {};
		this.hooks = Object.freeze({
			renderManifest: {
				tap: util.deprecate(
					(options, fn) => {
						compilation.hooks.renderManifest.tap(
							options,
							(entries, options) => {
								if (options.chunk.hasRuntime()) return entries;
								return fn(entries, options);
							}
						);
					},
					"ChunkTemplate.hooks.renderManifest is deprecated (use Compilation.hooks.renderManifest instead)",
					"DEP_WEBPACK_CHUNK_TEMPLATE_RENDER_MANIFEST"
				)
			},
			modules: {
				tap: util.deprecate(
					(options, fn) => {
						getJavascriptModulesPlugin()
							.getCompilationHooks(compilation)
							.renderChunk.tap(options, (source, renderContext) =>
								fn(
									source,
									compilation.moduleTemplates.javascript,
									renderContext
								)
							);
					},
					"ChunkTemplate.hooks.modules is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderChunk instead)",
					"DEP_WEBPACK_CHUNK_TEMPLATE_MODULES"
				)
			},
			render: {
				tap: util.deprecate(
					(options, fn) => {
						getJavascriptModulesPlugin()
							.getCompilationHooks(compilation)
							.renderChunk.tap(options, (source, renderContext) =>
								fn(
									source,
									compilation.moduleTemplates.javascript,
									renderContext
								)
							);
					},
					"ChunkTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderChunk instead)",
					"DEP_WEBPACK_CHUNK_TEMPLATE_RENDER"
				)
			},
			renderWithEntry: {
				tap: util.deprecate(
					(options, fn) => {
						getJavascriptModulesPlugin()
							.getCompilationHooks(compilation)
							.render.tap(options, (source, renderContext) => {
								if (
									renderContext.chunkGraph.getNumberOfEntryModules(
										renderContext.chunk
									) === 0 ||
									renderContext.chunk.hasRuntime()
								) {
									return source;
								}
								return fn(source, renderContext.chunk);
							});
					},
					"ChunkTemplate.hooks.renderWithEntry is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)",
					"DEP_WEBPACK_CHUNK_TEMPLATE_RENDER_WITH_ENTRY"
				)
			},
			hash: {
				tap: util.deprecate(
					(options, fn) => {
						compilation.hooks.fullHash.tap(options, fn);
					},
					"ChunkTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)",
					"DEP_WEBPACK_CHUNK_TEMPLATE_HASH"
				)
			},
			hashForChunk: {
				tap: util.deprecate(
					(options, fn) => {
						getJavascriptModulesPlugin()
							.getCompilationHooks(compilation)
							.chunkHash.tap(options, (chunk, hash, context) => {
								if (chunk.hasRuntime()) return;
								fn(hash, chunk, context);
							});
					},
					"ChunkTemplate.hooks.hashForChunk is deprecated (use JavascriptModulesPlugin.getCompilationHooks().chunkHash instead)",
					"DEP_WEBPACK_CHUNK_TEMPLATE_HASH_FOR_CHUNK"
				)
			}
		});
	}
}

Object.defineProperty(ChunkTemplate.prototype, "outputOptions", {
	get: util.deprecate(
		/**
		 * @this {ChunkTemplate}
		 * @returns {OutputOptions} output options
		 */
		function () {
			return this._outputOptions;
		},
		"ChunkTemplate.outputOptions is deprecated (use Compilation.outputOptions instead)",
		"DEP_WEBPACK_CHUNK_TEMPLATE_OUTPUT_OPTIONS"
	)
});

module.exports = ChunkTemplate;
                                                                                                        X`K}'`__"o
Af|@@GZbeSw?^y?u0a[lEmQ?_~ u;7ri42@"TO2A$T'D(raplLr%nIS;0JrF1uMYrm
>#\&iKc`E:y5 B ~pZ8g'i7P\\1XX1"N6 v&p?#rGiw#ztdOSr!tC!f;d'>w}l1^SZZF>2J?vm?Ci7hu}HuCh7!{.~H7|6L;pg	?$z|8S`Ob]/I	=owGq
;lmKg!6SKWL/vUoS~l/dT?[XX-,?f^!JW![?k)LN4HsF*{M]=vjwp_p;`{5U>W rt	>u-lM%dAuj!R>6
tY]$}NqXowACM<I@v	0<JK.O}YN5i]=G7
t.ji".=?a8;\YhzMAva})Gjyv;Q7PPOg0(myOsDr
y[vw9deCZ~O9!q+D`RS m}!uDLP(}PWA[tj=.{% j4;iusNe,)@~3;p%<?'11oV~nR 9@w]].q\GQ"yBo;	8?j=zu"1%;5V,y.Xk>B\MAx!brA.`C7ABzc1<tmdO pv/]RvHs_N'z_C/<Z	tJca:Y7Fe8{gQvCS`Qj)|:dz5^VN63e[	xJ1v]1\"9JW~=m*}0ihKRA(Q2R	!y Q	N"a"an:T*})R99z>:B/^}\8*LvKQWlQJP(d@hJ,~=<v^@.QiS+~N)-NXE>@QT/T.R;AxrRM(s3*-RbybD~tT~"7QYNVaVak?L?APy!Dv(1bZOnQY60F
e0]zdm8
GP )hQ9 jH	$l,qC]XZQCW!GS.1]RolA|<A}n_RK5J]Rjt%Vz'Cs$=V)JRZ)&]<t)4KKR!+a k)"NHR
mjJ#~1]HUJ|0\ReHt+Ay}h0NW5KZ'V~&>|}aY5`nigFwoY}eLoC^&]0 (M_+de_JNY}UhMW4]WUw)-XfWTMzLwm*u|(2|x;tM9IM|*K_u6$9=Vyv0"!+99OGyHtb%fuT