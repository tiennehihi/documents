ableElement: C,
    HTMLTableRowElement: C,
    HTMLTableSectionElement: C,
    HTMLTemplateElement: C,
    HTMLTextAreaElement: C,
    HTMLTimeElement: C,
    HTMLTitleElement: C,
    HTMLTrackElement: C,
    HTMLUListElement: C,
    HTMLUnknownElement: C,
    HTMLVideoElement: C,
    IDBCursor: C,
    IDBCursorWithValue: C,
    IDBDatabase: C,
    IDBFactory: C,
    IDBIndex: C,
    IDBKeyRange: C,
    IDBObjectStore: C,
    IDBOpenDBRequest: C,
    IDBRequest: C,
    IDBTransaction: C,
    IDBVersionChangeEvent: C,
    IdleDeadline: C,
    IIRFilterNode: C,
    Image: C,
    ImageBitmap: C,
    ImageBitmapRenderingContext: C,
    ImageCapture: C,
    ImageData: C,
    indexedDB: O,
    innerHeight: O,
    innerWidth: O,
    InputEvent: C,
    IntersectionObserver: C,
    IntersectionObserverEntry: C,
    isSecureContext: O,
    KeyboardEvent: C,
    KeyframeEffect: C,
    length: O,
    localStorage: O,
    location: O,
    Location: C,
    locationbar: O,
    matchMedia: O,
    MediaDeviceInfo: C,
    MediaDevices: C,
    MediaElementAudioSourceNode: C,
    MediaEncryptedEvent: C,
    MediaError: C,
    MediaKeyMessageEvent: C,
    MediaKeySession: C,
    MediaKeyStatusMap: C,
    MediaKeySystemAccess: C,
    MediaList: C,
    MediaQueryList: C,
    MediaQueryListEvent: C,
    MediaRecorder: C,
    MediaSettingsRange: C,
    MediaSource: C,
    MediaStream: C,
    MediaStreamAudioDestinationNode: C,
    MediaStreamAudioSourceNode: C,
    MediaStreamEvent: C,
    MediaStreamTrack: C,
    MediaStreamTrackEvent: C,
    menubar: O,
    MessageChannel: C,
    MessageEvent: C,
    MessagePort: C,
    MIDIAccess: C,
    MIDIConnectionEvent: C,
    MIDIInput: C,
    MIDIInputMap: C,
    MIDIMessageEvent: C,
    MIDIOutput: C,
    MIDIOutputMap: C,
    MIDIPort: C,
    MimeType: C,
    MimeTypeArray: C,
    MouseEvent: C,
    moveBy: O,
    moveTo: O,
    MutationEvent: C,
    MutationObserver: C,
    MutationRecord: C,
    name: O,
    NamedNodeMap: C,
    NavigationPreloadManager: C,
    navigator: O,
    Navigator: C,
    NetworkInformation: C,
    Node: C,
    NodeFilter: O,
    NodeIterator: C,
    NodeList: C,
    Notification: C,
    OfflineAudioCompletionEvent: C,
    OfflineAudioContext: C,
    offscreenBuffering: O,
    OffscreenCanvas: C,
    open: O,
    openDatabase: O,
    Option: C,
    origin: O,
    OscillatorNode: C,
    outerHeight: O,
    outerWidth: O,
    PageTransitionEvent: C,
    pageXOffset: O,
    pageYOffset: O,
    PannerNode: C,
    parent: O,
    Path2D: C,
    PaymentAddress: C,
    PaymentRequest: C,
    PaymentRequestUpdateEvent: C,
    PaymentResponse: C,
    performance: O,
    Performance: C,
    PerformanceEntry: C,
    PerformanceLongTaskTiming: C,
    PerformanceMark: C,
    PerformanceMeasure: C,
    PerformanceNavigation: C,
    PerformanceNavigationTiming: C,
    PerformanceObserver: C,
    PerformanceObserverEntryList: C,
    PerformancePaintTiming: C,
    PerformanceResourceTiming: C,
    PerformanceTiming: C,
    PeriodicWave: C,
    Permissions: C,
    PermissionStatus: C,
    personalbar: O,
    PhotoCapabilities: C,
    Plugin: C,
    PluginArray: C,
    PointerEvent: C,
    PopStateEvent: C,
    postMessage: O,
    Presentation: C,
    PresentationAvailability: C,
    PresentationConnection: C,
    PresentationConnectionAvailableEvent: C,
    PresentationConnectionCloseEvent: C,
    PresentationConnectionList: C,
    PresentationReceiver: C,
    PresentationRequest: C,
    print: O,
    ProcessingInstruction: C,
    ProgressEvent: C,
    PromiseRejectionEvent: C,
    prompt: O,
    PushManager: C,
    PushSubscription: C,
    PushSubscriptionOptions: C,
    queueMicrotask: O,
    RadioNodeList: C,
    Range: C,
    ReadableStream: C,
    RemotePlayback: C,
    removeEventListener: O,
    Request: C,
    requestAnimationFrame: O,
    requestIdleCallback: O,
    resizeBy: O,
    ResizeObserver: C,
    ResizeObserverEntry: C,
    resizeTo: O,
    Response: C,
    RTCCertificate: C,
    RTCDataChannel: C,
    RTCDataChannelEvent: C,
    RTCDtlsTransport: C,
    RTCIceCandidate: C,
    RTCIceTransport: C,
    RTCPeerConnection: C,
    RTCPeerConnectionIceEvent: C,
    RTCRtpReceiver: C,
    RTCRtpSender: C,
    RTCSctpTransport: C,
    RTCSessionDescription: C,
    RTCStatsReport: C,
    RTCTrackEvent: C,
    screen: O,
    Screen: C,
    screenLeft: O,
    ScreenOrientation: C,
    screenTop: O,
    screenX: O,
    screenY: O,
    ScriptProcessorNode: C,
    scroll: O,
    scrollbars: O,
    scrollBy: O,
    scrollTo: O,
    scrollX: O,
    scrollY: O,
    SecurityPolicyViolationEvent: C,
    Selection: C,
    ServiceWorker: C,
    ServiceWorkerContainer: C,
    ServiceWorkerRegistration: C,
    sessionStorage: O,
    ShadowRoot: C,
    SharedWorker: C,
    SourceBuffer: C,
    SourceBufferList: C,
    speechSynthesis: O,
    SpeechSynthesisEvent: C,
    SpeechSynthesisUtterance: C,
    StaticRange: C,
    status: O,
    statusbar: O,
    StereoPannerNode: C,
    stop: O,
    Storage: C,
    StorageEvent: C,
    StorageManager: C,
    styleMedia: O,
    StyleSheet: C,
    StyleSheetList: C,
    SubtleCrypto: C,
    SVGAElement: C,
    SVGAngle: C,
    SVGAnimatedAngle: C,
    SVGAnimatedBoolean: C,
    SVGAnimatedEnumeration: C,
    SVGAnimatedInteger: C,
    SVGAnimatedLength: C,
    SVGAnimatedLengthList: C,
    SVGAnimatedNumber: C,
    SVGAnimatedNumberList: C,
    SVGAnimatedPreserveAspectRatio: C,
    SVGAnimatedRect: C,
    SVGAnimatedString: C,
    SVGAnimatedTransformList: C,
    SVGAnimateElement: C,
    SVGAnimateMotionElement: C,
    SVGAnimateTransformElement: C,
    SVGAnimationElement: C,
    SVGCircleElement: C,
    SVGClipPathElement: C,
    SVGComponentTransferFunctionElement: C,
    SVGDefsElement: C,
    SVGDescElement: C,
    SVGDiscardElement: C,
    SVGElement: C,
    SVGEllipseElement: C,
    SVGFEBlendElement: C,
    SVGFEColorMatrixElement: C,
    SVGFEComponentTransferElement: C,
    SVGFECompositeElement: C,
    SVGFEConvolveMatrixElement: C,
    SVGFEDiffuseLightingElement: C,
    SVGFEDisplacementMapElement: C,
    SVGFEDistantLightElement: C,
    SVGFEDropShadowElement: C,
    SVGFEFloodElement: C,
    SVGFEFuncAElement: C,
    SVGFEFuncBElement: C,
    SVGFEFuncGElement: C,
    SVGFEFuncRElement: C,
    SVGFEGaussianBlurElement: C,
    SVGFEImageElement: C,
    SVGFEMergeElement: C,
    SVGFEMergeNodeElement: C,
    SVGFEMorphologyElement: C,
    SVGFEOffsetElement: C,
    SVGFEPointLightElement: C,
    SVGFESpecularLightingElement: C,
    SVGFESpotLightElement: C,
    SVGFETileElement: C,
    SVGFETurbulenceElement: C,
    SVGFilterElement: C,
    SVGForeignObjectElement: C,
    SVGGElement: C,
    SVGGeometryElement: C,
    SVGGradientElement: C,
    SVGGraphicsElement: C,
    SVGImageElement: C,
    SVGLength: C,
    SVGLengthList: C,
    SVGLinearGradientElement: C,
    SVGLineElement: C,
    SVGMarkerElement: C,
    SVGMaskElement: C,
    SVGMatrix: C,
    SVGMetadataElement: C,
    SVGMPathElement: C,
    SVGNumber: C,
    SVGNumberList: C,
    SVGPathElement: C,
    SVGPatternElement: C,
    SVGPoint: C,
    SVGPointList: C,
    SVGPolygonElement: C,
    SVGPolylineElement: C,
    SVGPreserveAspectRatio: C,
    SVGRadialGradientElement: C,
    SVGRect: C,
    SVGRectElement: C,
    SVGScriptElement: C,
    SVGSetElement: C,
    SVGStopElement: C,
    SVGStringList: C,
    SVGStyleElement: C,
    SVGSVGElement: C,
    SVGSwitchElement: C,
    SVGSymbolElement: C,
    SVGTextContentElement: C,
    SVGTextElement: C,
    SVGTextPathElement: C,
    SVGTextPositioningElement: C,
    SVGTitleElement: C,
    SVGTransform: C,
    SVGTransformList: C,
    SVGTSpanElement: C,
    SVGUnitTypes: C,
    SVGUseElement: C,
    SVGViewElement: C,
    TaskAttributionTiming: C,
    Text: C,
    TextEvent: C,
    TextMetrics: C,
    TextTrack: C,
    TextTrackCue: C,
    TextTrackCueList: C,
    TextTrackList: C,
    TimeRanges: C,
    toolbar: O,
    top: O,
    Touch: C,
    TouchEvent: C,
    TouchList: C,
    TrackEvent: C,
    TransitionEvent: C,
    TreeWalker: C,
    UIEvent: C,
    ValidityState: C,
    visualViewport: O,
    VisualViewport: C,
    VTTCue: C,
    WaveShaperNode: C,
    WebAssembly: O,
    WebGL2RenderingContext: C,
    WebGLActiveInfo: C,
    WebGLBuffer: C,
    WebGLContextEvent: C,
    WebGLFramebuffer: C,
    WebGLProgram: C,
    WebGLQuery: C,
    WebGLRenderbuffer: C,
    WebGLRenderingContext: C,
    WebGLSampler: C,
    WebGLShader: C,
    WebGLShaderPrecisionFormat: C,
    WebGLSync: C,
    WebGLTexture: C,
    WebGLTransformFeedback: C,
    WebGLUniformLocation: C,
    WebGLVertexArrayObject: C,
    WebSocket: C,
    WheelEvent: C,
    Window: C,
    Worker: C,
    WritableStream: C,
    XMLDocument: C,
    XMLHttpRequest: C,
    XMLHttpRequestEventTarget: C,
    XMLHttpRequestUpload: C,
    XMLSerializer: C,
    XPathEvaluator: C,
    XPathExpression: C,
    XPathResult: C,
    XSLTProcessor: C
};
for (const global of ['window', 'global', 'self', 'globalThis']) {
    knownGlobals[global] = knownGlobals;
}
function getGlobalAtPath(path) {
    let currentGlobal = knownGlobals;
    for (const pathSegment of path) {
        if (typeof pathSegment !== 'string') {
            return null;
        }
        currentGlobal = currentGlobal[pathSegment];
        if (!currentGlobal) {
            return null;
        }
    }
    return currentGlobal[ValueProperties];
}

class GlobalVariable extends Variable {
    constructor() {
        super(...arguments);
        // Ensure we use live-bindings for globals as we do not know if they have
        // been reassigned
        this.isReassigned = true;
    }
    getLiteralValueAtPath(path, _recursionTracker, _origin) {
        return getGlobalAtPath([this.name, ...path]) ? UnknownTruthyValue : UnknownValue;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        switch (interaction.type) {
            case INTERACTION_ACCESSED:
                if (path.length === 0) {
                    // Technically, "undefined" is a global variable of sorts
                    return this.name !== 'undefined' && !getGlobalAtPath([this.name]);
                }
                return !getGlobalAtPath([this.name, ...path].slice(0, -1));
            case INTERACTION_ASSIGNED:
                return true;
            case INTERACTION_CALLED: {
                const globalAtPath = getGlobalAtPath([this.name, ...path]);
                return !globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction, context);
            }
        }
    }
}

const tdzVariableKinds = {
    __proto__: null,
    class: true,
    const: true,
    let: true,
    var: true
};
class Identifier extends NodeBase {
    constructor() {
        super(...arguments);
        this.variable = null;
        this.isTDZAccess = null;
    }
    addExportedVariables(variables, exportNamesByVariable) {
        if (exportNamesByVariable.has(this.variable)) {
            variables.push(this.variable);
        }
    }
    bind() {
        if (!this.variable && is_reference(this, this.parent)) {
            this.variable = this.scope.findVariable(this.name);
            this.variable.addReference(this);
        }
    }
    declare(kind, init) {
        let variable;
        const { treeshake } = this.context.options;
        switch (kind) {
            case 'var':
                variable = this.scope.addDeclaration(this, this.context, init, true);
                if (treeshake && treeshake.correctVarValueBeforeDeclaration) {
                    // Necessary to make sure the init is deoptimized. We cannot call deoptimizePath here.
                    variable.markInitializersForDeoptimization();
                }
                break;
            case 'function':
                // in strict mode, functions are only hoisted within a scope but not across block scopes
                variable = this.scope.addDeclaration(this, this.context, init, false);
                break;
            case 'let':
            case 'const':
            case 'class':
                variable = this.scope.addDeclaration(this, this.context, init, false);
                break;
            case 'parameter':
                variable = this.scope.addParameterDeclaration(this);
                break;
            /* istanbul ignore next */
            default:
                /* istanbul ignore next */
                throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);
        }
        variable.kind = kind;
        return [(this.variable = variable)];
    }
    deoptimizePath(path) {
        var _a;
        if (path.length === 0 && !this.scope.contains(this.name)) {
            this.disallowImportReassignment();
        }
        // We keep conditional chaining because an unknown Node could have an
        // Identifier as property that might be deoptimized by default
        (_a = this.variable) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.getVariableRespectingTDZ().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (this.isPossibleTDZ() && this.variable.kind !== 'var') {
            return true;
        }
        return (this.context.options.treeshake.unknownGlobalSideEffects &&
            this.variable instanceof GlobalVariable &&
            this.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        switch (interaction.type) {
            case INTERACTION_ACCESSED:
                return (this.variable !== null &&
                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));
            case INTERACTION_ASSIGNED:
                return (path.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(path, interaction, context);
            case INTERACTION_CALLED:
                return this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context);
        }
    }
    include() {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (!this.included) {
            this.included = true;
            if (this.variable !== null) {
                this.context.includeVariableInModule(this.variable);
            }
        }
    }
    includeCallArguments(context, args) {
        this.variable.includeCallArguments(context, args);
    }
    isPossibleTDZ() {
        // return cached value to avoid issues with the next tree-shaking pass
        if (this.isTDZAccess !== null)
            return this.isTDZAccess;
        if (!(this.variable instanceof LocalVariable) ||
            !this.variable.kind ||
            !(this.variable.kind in tdzVariableKinds)) {
            return (this.isTDZAccess = false);
        }
        let decl_id;
        if (this.variable.declarations &&
            this.variable.declarations.length === 1 &&
            (decl_id = this.variable.declarations[0]) &&
            this.start < decl_id.start &&
            closestParentFunctionOrProgram(this) === closestParentFunctionOrProgram(decl_id)) {
            // a variable accessed before its declaration
            // in the same function or at top level of module
            return (this.isTDZAccess = true);
        }
        if (!this.variable.initReached) {
            // Either a const/let TDZ violation or
            // var use before declaration was encountered.
            return (this.isTDZAccess = true);
        }
        return (this.isTDZAccess = false);
    }
    markDeclarationReached() {
        this.variable.initReached = true;
    }
    render(code, { snippets: { getPropertyAccess } }, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {
        if (this.variable) {
            const name = this.variable.getName(getPropertyAccess);
            if (name !== this.name) {
                code.overwrite(this.start, this.end, name, {
                    contentOnly: true,
                    storeName: true
                });
                if (isShorthandProperty) {
                    code.prependRight(this.start, `${this.name}: `);
                }
            }
            // In strict mode, any variable named "eval" must be the actual "eval" function
            if (name === 'eval' &&
                renderedParentType === CallExpression$1 &&
                isCalleeOfRenderedParent) {
                code.appendRight(this.start, '0, ');
            }
        }
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.variable instanceof LocalVariable) {
            this.variable.consolidateInitializers();
            this.context.requestTreeshakingPass();
        }
    }
    disallowImportReassignment() {
        return this.context.error({
            code: 'ILLEGAL_REASSIGNMENT',
            message: `Illegal reassignment to import '${this.name}'`
        }, this.start);
    }
    getVariableRespectingTDZ() {
        if (this.isPossibleTDZ()) {
            return UNKNOWN_EXPRESSION;
        }
        return this.variable;
    }
}
function closestParentFunctionOrProgram(node) {
    while (node && !/^Program|Function/.test(node.type)) {
        node = node.parent;
    }
    // one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program
    return node;
}

function treeshakeNode(node, code, start, end) {
    code.remove(start, end);
    if (node.annotations) {
        for (const annotation of node.annotations) {
            if (annotation.start < start) {
                code.remove(annotation.start, annotation.end);
            }
            else {
                return;
            }
        }
    }
}
function removeAnnotations(node, code) {
    if (!node.annotations && node.parent.type === ExpressionStatement$1) {
        node = node.parent;
    }
    if (node.annotations) {
        for (const annotation of node.annotations) {
            code.remove(annotation.start, annotation.end);
        }
    }
}

const NO_SEMICOLON = { isNoStatement: true };
// This assumes there are only white-space and comments between start and the string we are looking for
function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
    let searchPos, charCodeAfterSlash;
    searchPos = code.indexOf(searchString, start);
    while (true) {
        start = code.indexOf('/', start);
        if (start === -1 || start >= searchPos)
            return searchPos;
        charCodeAfterSlash = code.charCodeAt(++start);
        ++start;
        // With our assumption, '/' always starts a comment. Determine comment type:
        start =
            charCodeAfterSlash === 47 /*"/"*/
                ? code.indexOf('\n', start) + 1
                : code.indexOf('*/', start) + 2;
        if (start > searchPos) {
            searchPos = code.indexOf(searchString, start);
        }
    }
}
const NON_WHITESPACE = /\S/g;
function findNonWhiteSpace(code, index) {
    NON_WHITESPACE.lastIndex = index;
    const result = NON_WHITESPACE.exec(code);
    return result.index;
}
// This assumes "code" only contains white-space and comments
// Returns position of line-comment if applicable
function findFirstLineBreakOutsideComment(code) {
    let lineBreakPos, charCodeAfterSlash, start = 0;
    lineBreakPos = code.indexOf('\n', start);
    while (true) {
        start = code.indexOf('/', start);
        if (start === -1 || start > lineBreakPos)
            return [lineBreakPos, lineBreakPos + 1];
        // With our assumption, '/' always starts a comment. Determine comment type:
        charCodeAfterSlash = code.charCodeAt(start + 1);
        if (charCodeAfterSlash === 47 /*"/"*/)
            return [start, lineBreakPos + 1];
        start = code.indexOf('*/', start + 3) + 2;
        if (start > lineBreakPos) {
            lineBreakPos = code.indexOf('\n', start);
        }
    }
}
function renderStatementList(statements, code, start, end, options) {
    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
    let nextNode = statements[0];
    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
    if (nextNodeNeedsBoundaries) {
        nextNodeStart =
            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
    }
    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {
        currentNode = nextNode;
        currentNodeStart = nextNodeStart;
        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
        nextNode = statements[nextIndex];
        nextNodeNeedsBoundaries =
            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;
        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
            nextNodeStart =
                currentNode.end +
                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start))[1];
            if (currentNode.included) {
                currentNodeNeedsBoundaries
                    ? currentNode.render(code, options, {
                        end: nextNodeStart,
                        start: currentNodeStart
                    })
                    : currentNode.render(code, options);
            }
            else {
                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
            }
        }
        else {
            currentNode.render(code, options);
        }
    }
}
// This assumes that the first character is not part of the first node
function getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {
    const splitUpNodes = [];
    let node, nextNode, nextNodeStart, contentEnd, char;
    let separator = start - 1;
    for (let nextIndex = 0; nextIndex < nodes.length; nextIndex++) {
        nextNode = nodes[nextIndex];
        if (node !== undefined) {
            separator =
                node.end +
                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');
        }
        nextNodeStart = contentEnd =
            separator +
                1 +
                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];
        while (((char = code.original.charCodeAt(nextNodeStart)),
            char === 32 /*" "*/ || char === 9 /*"\t"*/ || char === 10 /*"\n"*/ || char === 13) /*"\r"*/)
            nextNodeStart++;
        if (node !== undefined) {
            splitUpNodes.push({
                contentEnd,
                end: nextNodeStart,
                node,
                separator,
                start
            });
        }
        node = nextNode;
        start = nextNodeStart;
    }
    splitUpNodes.push({
        contentEnd: end,
        end,
        node: node,
        separator: null,
        start
    });
    return splitUpNodes;
}
// This assumes there are only white-space and comments between start and end
function removeLineBreaks(code, start, end) {
    while (true) {
        const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));
        if (removeStart === -1) {
            break;
        }
        code.remove(start + removeStart, (start += removeEnd));
    }
}

class BlockScope extends ChildScope {
    addDeclaration(identifier, context, init, isHoisted) {
        if (isHoisted) {
            const variable = this.parent.addDeclaration(identifier, context, init, isHoisted);
            // Necessary to make sure the init is deoptimized for conditional declarations.
            // We cannot call deoptimizePath here.
            variable.markInitializersForDeoptimization();
            return variable;
        }
        else {
            return super.addDeclaration(identifier, context, init, false);
        }
    }
}

class ExpressionStatement extends NodeBase {
    initialise() {
        if (this.directive &&
            this.directive !== 'use strict' &&
            this.parent.type === Program$1) {
            this.context.warn(
            // This is necessary, because either way (deleting or not) can lead to errors.
            {
                code: 'MODULE_LEVEL_DIRECTIVE',
                message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.`
            }, this.start);
        }
    }
    render(code, options) {
        super.render(code, options);
        if (this.included)
            this.insertSemicolon(code);
    }
    shouldBeIncluded(context) {
        if (this.directive && this.directive !== 'use strict')
            return this.parent.type !== Program$1;
        return super.shouldBeIncluded(context);
    }
    applyDeoptimizations() { }
}

class BlockStatement extends NodeBase {
    constructor() {
        super(...arguments);
        this.directlyIncluded = false;
    }
    addImplicitReturnExpressionToScope() {
        const lastStatement = this.body[this.body.length - 1];
        if (!lastStatement || lastStatement.type !== ReturnStatement$1) {
            this.scope.addReturnExpression(UNKNOWN_EXPRESSION);
        }
    }
    createScope(parentScope) {
        this.scope = this.parent.preventChildBlockScope
            ? parentScope
            : new BlockScope(parentScope);
    }
    hasEffects(context) {
        if (this.deoptimizeBody)
            return true;
        for (const node of this.body) {
            if (context.brokenFlow)
                break;
            if (node.hasEffects(context))
                return true;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        if (!(this.deoptimizeBody && this.directlyIncluded)) {
            this.included = true;
            this.directlyIncluded = true;
            if (this.deoptimizeBody)
                includeChildrenRecursively = true;
            for (const node of this.body) {
                if (includeChildrenRecursively || node.shouldBeIncluded(context))
                    node.include(context, includeChildrenRecursively);
            }
        }
    }
    initialise() {
        const firstBodyStatement = this.body[0];
        this.deoptimizeBody =
            firstBodyStatement instanceof ExpressionStatement &&
                firstBodyStatement.directive === 'use asm';
    }
    render(code, options) {
        if (this.body.length) {
            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
        }
        else {
            super.render(code, options);
        }
    }
}

class RestElement extends NodeBase {
    constructor() {
        super(...arguments);
        this.declarationInit = null;
    }
    addExportedVariables(variables, exportNamesByVariable) {
        this.argument.addExportedVariables(variables, exportNamesByVariable);
    }
    declare(kind, init) {
        this.declarationInit = init;
        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
    }
    deoptimizePath(path) {
        path.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return (path.length > 0 ||
            this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
    }
    markDeclarationReached() {
        this.argument.markDeclarationReached();
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
            this.context.requestTreeshakingPass();
        }
    }
}

class FunctionBase extends NodeBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
        this.deoptimizedReturn = false;
    }
    deoptimizePath(path) {
        this.getObjectEntity().deoptimizePath(path);
        if (path.length === 1 && path[0] === UnknownKey) {
            // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track
            // which means the return expression needs to be reassigned
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
        }
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        if (path.length > 0) {
            this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        if (path.length > 0) {
            return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
        }
        if (this.async) {
            if (!this.deoptimizedReturn) {
                this.deoptimizedReturn = true;
                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
                this.context.requestTreeshakingPass();
            }
            return UNKNOWN_EXPRESSION;
        }
        return this.scope.getReturnExpression();
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (path.length > 0 || interaction.type !== INTERACTION_CALLED) {
            return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
        }
        if (this.async) {
            const { propertyReadSideEffects } = this.context.options
                .treeshake;
            const returnExpression = this.scope.getReturnExpression();
            if (returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_CALL, context) ||
                (propertyReadSideEffects &&
                    (propertyReadSideEffects === 'always' ||
                        returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_ACCESS, context)))) {
                return true;
            }
        }
        for (const param of this.params) {
            if (param.hasEffects(context))
                return true;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        const { brokenFlow } = context;
        context.brokenFlow = BROKEN_FLOW_NONE;
        this.body.include(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
    }
    includeCallArguments(context, args) {
        this.scope.includeCallArguments(context, args);
    }
    initialise() {
        this.scope.addParameterVariables(this.params.map(param => param.declare('parameter', UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
        if (this.body instanceof BlockStatement) {
            this.body.addImplicitReturnExpressionToScope();
        }
        else {
            this.scope.addReturnExpression(this.body);
        }
    }
    parseNode(esTreeNode) {
        if (esTreeNode.body.type === BlockStatement$1) {
            this.body = new BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
        }
        super.parseNode(esTreeNode);
    }
    applyDeoptimizations() { }
}
FunctionBase.prototype.preventChildBlockScope = true;

class ArrowFunctionExpression extends FunctionBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
    }
    createScope(parentScope) {
        this.scope = new ReturnValueScope(parentScope, this.context);
    }
    hasEffects() {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return false;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))
            return true;
        if (interaction.type === INTERACTION_CALLED) {
            const { ignore, brokenFlow } = context;
            context.ignore = {
                breaks: false,
                continues: false,
                labels: new Set(),
                returnYield: true
            };
            if (this.body.hasEffects(context))
                return true;
            context.ignore = ignore;
            context.brokenFlow = brokenFlow;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        super.include(context, includeChildrenRecursively);
        for (const param of this.params) {
            if (!(param instanceof Identifier)) {
                param.include(context, includeChildrenRecursively);
            }
        }
    }
    getObjectEntity() {
        if (this.objectEntity !== null) {
            return this.objectEntity;
        }
        return (this.objectEntity = new ObjectEntity([], OBJECT_PROTOTYPE));
    }
}

function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = '') {
    if (exportedVariables.length === 1 &&
        exportNamesByVariable.get(exportedVariables[0]).length === 1) {
        const variable = exportedVariables[0];
        return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
    }
    else {
        const fields = [];
        for (const variable of exportedVariables) {
            for (const exportName of exportNamesByVariable.get(variable)) {
                fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
            }
        }
        return `exports(${getObject(fields, { lineBreakIndent: null })})`;
    }
}
function renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {
    code.prependRight(expressionStart, `exports('${exportNamesByVariable.get(exportedVariable)}',${_}`);
    code.appendLeft(expressionEnd, ')');
}
function renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {
    const { _, getDirectReturnIifeLeft } = options.snippets;
    code.prependRight(expressionStart, getDirectReturnIifeLeft(['v'], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));
    code.appendLeft(expressionEnd, ')');
}
function renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {
    const { _, getPropertyAccess } = options.snippets;
    code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);
    if (needsParens) {
        code.prependRight(expressionStart, '(');
        code.appendLeft(expressionEnd, ')');
    }
}
function renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {
    const { _ } = options.snippets;
    code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);
    if (needsParens) {
        code.prependRight(expressionStart, '(');
        code.appendLeft(expressionEnd, ')');
    }
}

class ObjectPattern extends NodeBase {
    addExportedVariables(variables, exportNamesByVariable) {
        for (const property of this.properties) {
            if (property.type === Property$1) {
                property.value.addExportedVariables(variables, exportNamesByVariable);
            }
            else {
                property.argument.addExportedVariables(variables, exportNamesByVariable);
            }
        }
    }
    declare(kind, init) {
        const variables = [];
        for (const property of this.properties) {
            variables.push(...property.declare(kind, init));
        }
        return variables;
    }
    deoptimizePath(path) {
        if (path.length === 0) {
            for (const property of this.properties) {
                property.deoptimizePath(path);
            }
        }
    }
    hasEffectsOnInteractionAtPath(
    // At the moment, this is only triggered for assignment left-hand sides,
    // where the path is empty
    _path, interaction, context) {
        for (const property of this.properties) {
            if (property.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))
                return true;
        }
        return false;
    }
    markDeclarationReached() {
        for (const property of this.properties) {
            property.markDeclarationReached();
        }
    }
}

class AssignmentExpression extends NodeBase {
    hasEffects(context) {
        const { deoptimized, left, right } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        // MemberExpressions do not access the property before assignments if the
        // operator is '='.
        return (right.hasEffects(context) || left.hasEffectsAsAssignmentTarget(context, this.operator !== '='));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return this.right.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include(context, includeChildrenRecursively) {
        const { deoptimized, left, right, operator } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        if (includeChildrenRecursively ||
            operator !== '=' ||
            left.included ||
            left.hasEffectsAsAssignmentTarget(createHasEffectsContext(), false)) {
            left.includeAsAssignmentTarget(context, includeChildrenRecursively, operator !== '=');
        }
        right.include(context, includeChildrenRecursively);
    }
    initialise() {
        this.left.setAssignedValue(this.right);
    }
    render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        const { left, right, start, end, parent } = this;
        if (left.included) {
            left.render(code, options);
            right.render(code, options);
        }
        else {
            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', left.end) + 1);
            code.remove(start, inclusionStart);
            if (preventASI) {
                removeLineBreaks(code, inclusionStart, right.start);
            }
            right.render(code, options, {
                renderedParentType: renderedParentType || parent.type,
                renderedSurroundingElement: renderedSurroundingElement || parent.type
            });
        }
        if (options.format === 'system') {
            if (left instanceof Identifier) {
                const variable = left.variable;
                const exportNames = options.exportNamesByVariable.get(variable);
                if (exportNames) {
                    if (exportNames.length === 1) {
                        renderSystemExportExpression(variable, start, end, code, options);
                    }
                    else {
                        renderSystemExportSequenceAfterExpression(variable, start, end, parent.type !== ExpressionStatement$1, code, options);
                    }
                    return;
                }
            }
            else {
                const systemPatternExports = [];
                left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);
                if (systemPatternExports.length > 0) {
                    renderSystemExportFunction(systemPatternExports, start, end, renderedSurroundingElement === ExpressionStatement$1, code, options);
                    return;
                }
            }
        }
        if (left.included &&
            left instanceof ObjectPattern &&
            (renderedSurroundingElement === ExpressionStatement$1 ||
                renderedSurroundingElement === ArrowFunctionExpression$1)) {
            code.appendRight(start, '(');
            code.prependLeft(end, ')');
        }
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.context.requestTreeshakingPass();
    }
}

class AssignmentPattern extends NodeBase {
    addExportedVariables(variables, exportNamesByVariable) {
        this.left.addExportedVariables(variables, exportNamesByVariable);
    }
    declare(kind, init) {
        return this.left.declare(kind, init);
    }
    deoptimizePath(path) {
        path.length === 0 && this.left.deoptimizePath(path);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return (path.length > 0 || this.left.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));
    }
    markDeclarationReached() {
        this.left.markDeclarationReached();
    }
    render(code, options, { isShorthandProperty } = BLANK) {
        this.left.render(code, options, { isShorthandProperty });
        this.right.render(code, options);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.right.deoptimizePath(UNKNOWN_PATH);
        this.context.requestTreeshakingPass();
    }
}

class ArgumentsVariable extends LocalVariable {
    constructor(context) {
        super('arguments', null, UNKNOWN_EXPRESSION, context);
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return type !== INTERACTION_ACCESSED || path.length > 1;
    }
}

class ThisVariable extends LocalVariable {
    constructor(context) {
        super('this', null, null, context);
        this.deoptimizedPaths = [];
        this.entitiesToBeDeoptimized = new Set();
        this.thisDeoptimizationList = [];
        this.thisDeoptimizations = new DiscriminatedPathTracker();
    }
    addEntityToBeDeoptimized(entity) {
        for (const path of this.deoptimizedPaths) {
            entity.deoptimizePath(path);
        }
        for (const { interaction, path } of this.thisDeoptimizationList) {
            entity.deoptimizeThisOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);
        }
        this.entitiesToBeDeoptimized.add(entity);
    }
    deoptimizePath(path) {
        if (path.length === 0 ||
            this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
            return;
        }
        this.deoptimizedPaths.push(path);
        for (const entity of this.entitiesToBeDeoptimized) {
            entity.deoptimizePath(path);
        }
    }
    deoptimizeThisOnInteractionAtPath(interaction, path) {
        const thisDeoptimization = {
            interaction,
            path
        };
        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(path, interaction.type, interaction.thisArg)) {
            for (const entity of this.entitiesToBeDeoptimized) {
                entity.deoptimizeThisOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);
            }
            this.thisDeoptimizationList.push(thisDeoptimization);
        }
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return (this.getInit(context).hasEffectsOnInteractionAtPath(path, interaction, context) ||
            super.hasEffectsOnInteractionAtPath(path, interaction, context));
    }
    getInit(context) {
        return context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION;
    }
}

class FunctionScope extends ReturnValueScope {
    constructor(parent, context) {
        super(parent, context);
        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));
        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));
    }
    findLexicalBoundary() {
        return this;
    }
    includeCallArguments(context, args) {
        super.includeCallArguments(context, args);
        if (this.argumentsVariable.included) {
            for (const arg of args) {
                if (!arg.included) {
                    arg.include(context, false);
                }
            }
        }
    }
}

class FunctionNode extends FunctionBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
    }
    createScope(parentScope) {
        this.scope = new FunctionScope(parentScope, this.context);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        super.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
        if (interaction.type === INTERACTION_CALLED && path.length === 0) {
            this.scope.thisVariable.addEntityToBeDeoptimized(interaction.thisArg);
        }
    }
    hasEffects(context) {
        var _a;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return !!((_a = this.id) === null || _a === void 0 ? void 0 : _a.hasEffects(context));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))
            return true;
        if (interaction.type === INTERACTION_CALLED) {
            const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
            context.replacedVariableInits.set(this.scope.thisVariable, interaction.withNew
                ? new ObjectEntity(Object.create(null), OBJECT_PROTOTYPE)
                : UNKNOWN_EXPRESSION);
            const { brokenFlow, ignore } = context;
            context.ignore = {
                breaks: false,
                continues: false,
                labels: new Set(),
                returnYield: true
            };
            if (this.body.hasEffects(context))
                return true;
            context.brokenFlow = brokenFlow;
            if (thisInit) {
                context.replacedVariableInits.set(this.scope.thisVariable, thisInit);
            }
            else {
                context.replacedVariableInits.delete(this.scope.thisVariable);
            }
            context.ignore = ignore;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        var _a;
        super.include(context, includeChildrenRecursively);
        (_a = this.id) === null || _a === void 0 ? void 0 : _a.include();
        const hasArguments = this.scope.argumentsVariable.included;
        for (const param of this.params) {
            if (!(param instanceof Identifier) || hasArguments) {
                param.include(context, includeChildrenRecursively);
            }
        }
    }
    initialise() {
        var _a;
        super.initialise();
        (_a = this.id) === null || _a === void 0 ? void 0 : _a.declare('function', this);
    }
    getObjectEntity() {
        if (this.objectEntity !== null) {
            return this.objectEntity;
        }
        return (this.objectEntity = new ObjectEntity([
            {
                key: 'prototype',
                kind: 'init',
                property: new ObjectEntity([], OBJECT_PROTOTYPE)
            }
        ], OBJECT_PROTOTYPE));
    }
}

class AwaitExpression extends NodeBase {
    hasEffects() {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return true;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (!this.included) {
            this.included = true;
            checkTopLevelAwait: if (!this.context.usesTopLevelAwait) {
                let parent = this.parent;
                do {
                    if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)
                        break checkTopLevelAwait;
                } while ((parent = parent.parent));
                this.context.usesTopLevelAwait = true;
            }
        }
        this.argument.include(context, includeChildrenRecursively);
    }
}

const binaryOperators = {
    '!=': (left, right) => left != right,
    '!==': (left, right) => left !== right,
    '%': (left, right) => left % right,
    '&': (left, right) => left & right,
    '*': (left, right) => left * right,
    // At the moment, "**" will be transpiled to Math.pow
    '**': (left, right) => left ** right,
    '+': (left, right) => left + right,
    '-': (left, right) => left - right,
    '/': (left, right) => left / right,
    '<': (left, right) => left < right,
    '<<': (left, right) => left << right,
    '<=': (left, right) => left <= right,
    '==': (left, right) => left == right,
    '===': (left, right) => left === right,
    '>': (left, right) => left > right,
    '>=': (left, right) => left >= right,
    '>>': (left, right) => left >> right,
    '>>>': (left, right) => left >>> right,
    '^': (left, right) => left ^ right,
    '|': (left, right) => left | right
    // We use the fallback for cases where we return something unknown
    // in: () => UnknownValue,
    // instanceof: () => UnknownValue,
};
class BinaryExpression extends NodeBase {
    deoptimizeCache() { }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (path.length > 0)
            return UnknownValue;
        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof leftValue === 'symbol')
            return UnknownValue;
        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof rightValue === 'symbol')
            return UnknownValue;
        const operatorFn = binaryOperators[this.operator];
        if (!operatorFn)
            return UnknownValue;
        return operatorFn(leftValue, rightValue);
    }
    hasEffects(context) {
        // support some implicit type coercion runtime errors
        if (this.operator === '+' &&
            this.parent instanceof ExpressionStatement &&
            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '') {
            return true;
        }
        return super.hasEffects(context);
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return type !== INTERACTION_ACCESSED || path.length > 1;
    }
    render(code, options, { renderedSurroundingElement } = BLANK) {
        this.left.render(code, options, { renderedSurroundingElement });
        this.right.render(code, options);
    }
}

class BreakStatement extends NodeBase {
    hasEffects(context) {
        if (this.label) {
            if (!context.ignore.labels.has(this.label.name))
                return true;
            context.includedLabels.add(this.label.name);
            context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
        }
        else {
            if (!context.ignore.breaks)
                return true;
            context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
        }
        return false;
    }
    include(context) {
        this.included = true;
        if (this.label) {
            this.label.include();
            context.includedLabels.add(this.label.name);
        }
        context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;
    }
}

function renderCallArguments(code, options, node) {
    if (node.arguments.length > 0) {
        if (node.arguments[node.arguments.length - 1].included) {
            for (const arg of node.arguments) {
                arg.render(code, options);
            }
        }
        else {
            let lastIncludedIndex = node.arguments.length - 2;
            while (lastIncludedIndex >= 0 && !node.arguments[lastIncludedIndex].included) {
                lastIncludedIndex--;
            }
            if (lastIncludedIndex >= 0) {
                for (let index = 0; index <= lastIncludedIndex; index++) {
                    node.arguments[index].render(code, options);
                }
                code.remove(findFirstOccurrenceOutsideComment(code.original, ',', node.arguments[lastIncludedIndex].end), node.end - 1);
            }
            else {
                code.remove(findFirstOccurrenceOutsideComment(code.original, '(', node.callee.end) + 1, node.end - 1);
            }
        }
    }
}

class Literal extends NodeBase {
    deoptimizeThisOnInteractionAtPath() { }
    getLiteralValueAtPath(path) {
        if (path.length > 0 ||
            // unknown literals can also be null but do not start with an "n"
            (this.value === null && this.context.code.charCodeAt(this.start) !== 110) ||
            typeof this.value === 'bigint' ||
            // to support shims for regular expressions
            this.context.code.charCodeAt(this.start) === 47) {
            return UnknownValue;
        }
        return this.value;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length !== 1)
            return UNKNOWN_EXPRESSION;
        return getMemberReturnExpressionWhenCalled(this.members, path[0]);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        switch (interaction.type) {
            case INTERACTION_ACCESSED:
                return path.length > (this.value === null ? 0 : 1);
            case INTERACTION_ASSIGNED:
                return true;
            case INTERACTION_CALLED:
                return (path.length !== 1 ||
                    hasMemberEffectWhenCalled(this.members, path[0], interaction, context));
        }
    }
    initialise() {
        this.members = getLiteralMembersForValue(this.value);
    }
    parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        this.regex = esTreeNode.regex;
        super.parseNode(esTreeNode);
    }
    render(code) {
        if (typeof this.value === 'string') {
            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);
        }
    }
}

// To avoid infinite recursions
const MAX_PATH_DEPTH = 7;
function getResolvablePropertyKey(memberExpression) {
    return memberExpression.computed
        ? getResolvableComputedPropertyKey(memberExpression.property)
        : memberExpression.property.name;
}
function getResolvableComputedPropertyKey(propertyKey) {
    if (propertyKey instanceof Literal) {
        return String(propertyKey.value);
    }
    return null;
}
function getPathIfNotComputed(memberExpression) {
    const nextPathKey = memberExpression.propertyKey;
    const object = memberExpression.object;
    if (typeof nextPathKey === 'string') {
        if (object instanceof Identifier) {
            return [
                { key: object.name, pos: object.start },
                { key: nextPathKey, pos: memberExpression.property.start }
            ];
        }
        if (object instanceof MemberExpression) {
            const parentPath = getPathIfNotComputed(object);
            return (parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression.property.start }]);
        }
    }
    return null;
}
function getStringFromPath(path) {
    let pathString = path[0].key;
    for (let index = 1; index < path.length; index++) {
        pathString += '.' + path[index].key;
    }
    return pathString;
}
class MemberExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.variable = null;
        this.assignmentDeoptimized = false;
        this.bound = false;
        this.expressionsToBeDeoptimized = [];
        this.replacement = null;
    }
    bind() {
        this.bound = true;
        const path = getPathIfNotComputed(this);
        const baseVariable = path && this.scope.findVariable(path[0].key);
        if (baseVariable && baseVariable.isNamespace) {
            const resolvedVariable = resolveNamespaceVariables(baseVariable, path.slice(1), this.context);
            if (!resolvedVariable) {
                super.bind();
            }
            else if (typeof resolvedVariable === 'string') {
                this.replacement = resolvedVariable;
            }
            else {
                this.variable = resolvedVariable;
                this.scope.addNamespaceMemberAccess(getStringFromPath(path), resolvedVariable);
            }
        }
        else {
            super.bind();
        }
    }
    deoptimizeCache() {
        const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
        this.expressionsToBeDeoptimized = [];
        this.propertyKey = UnknownKey;
        this.object.deoptimizePath(UNKNOWN_PATH);
        for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
        }
    }
    deoptimizePath(path) {
        if (path.length === 0)
            this.disallowNamespaceReassignment();
        if (this.variable) {
            this.variable.deoptimizePath(path);
        }
        else if (!this.replacement) {
            if (path.length < MAX_PATH_DEPTH) {
                const propertyKey = this.getPropertyKey();
                this.object.deoptimizePath([
                    propertyKey === UnknownKey ? UnknownNonAccessorKey : propertyKey,
                    ...path
                ]);
            }
        }
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        if (this.variable) {
            this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
        }
        else if (!this.replacement) {
            if (path.length < MAX_PATH_DEPTH) {
                this.object.deoptimizeThisOnInteractionAtPath(interaction, [this.getPropertyKey(), ...path], recursionTracker);
            }
            else {
                interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
            }
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (this.variable) {
            return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);
        }
        if (this.replacement) {
            return UnknownValue;
        }
        this.expressionsToBeDeoptimized.push(origin);
        if (path.length < MAX_PATH_DEPTH) {
            return this.object.getLiteralValueAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);
        }
        return UnknownValue;
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        if (this.variable) {
            return this.variable.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
        }
        if (this.replacement) {
            return UNKNOWN_EXPRESSION;
        }
        this.expressionsToBeDeoptimized.push(origin);
        if (path.length < MAX_PATH_DEPTH) {
            return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], interaction, recursionTracker, origin);
        }
        return UNKNOWN_EXPRESSION;
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return (this.property.hasEffects(context) ||
            this.object.hasEffects(context) ||
            this.hasAccessEffect(context));
    }
    hasEffectsAsAssignmentTarget(context, checkAccess) {
        if (checkAccess && !this.deoptimized)
            this.applyDeoptimizations();
        if (!this.assignmentDeoptimized)
            this.applyAssignmentDeoptimization();
        return (this.property.hasEffects(context) ||
            this.object.hasEffects(context) ||
            (checkAccess && this.hasAccessEffect(context)) ||
            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (this.variable) {
            return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
        }
        if (this.replacement) {
            return true;
        }
        if (path.length < MAX_PATH_DEPTH) {
            return this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(), ...path], interaction, context);
        }
        return true;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.includeProperties(context, includeChildrenRecursively);
    }
    includeAsAssignmentTarget(context, includeChildrenRecursively, deoptimizeAccess) {
        if (!this.assignmentDeoptimized)
            this.applyAssignmentDeoptimization();
        if (deoptimizeAccess) {
            this.include(context, includeChildrenRecursively);
        }
        else {
            this.includeProperties(context, includeChildrenRecursively);
        }
    }
    includeCallArguments(context, args) {
        if (this.variable) {
            this.variable.includeCallArguments(context, args);
        }
        else {
            super.includeCallArguments(context, args);
        }
    }
    initialise() {
        this.propertyKey = getResolvablePropertyKey(this);
        this.accessInteraction = { thisArg: this.object, type: INTERACTION_ACCESSED };
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent, renderedSurroundingElement } = BLANK) {
        if (this.variable || this.replacement) {
            const { snippets: { getPropertyAccess } } = options;
            let replacement = this.variable ? this.variable.getName(getPropertyAccess) : this.replacement;
            if (renderedParentType && isCalleeOfRenderedParent)
                replacement = '0, ' + replacement;
            code.overwrite(this.start, this.end, replacement, {
                contentOnly: true,
                storeName: true
            });
        }
        else {
            if (renderedParentType && isCalleeOfRenderedParent) {
                code.appendRight(this.start, '0, ');
            }
            this.object.render(code, options, { renderedSurroundingElement });
            this.property.render(code, options);
        }
    }
    setAssignedValue(value) {
        this.assignmentInteraction = {
            args: [value],
            thisArg: this.object,
            type: INTERACTION_ASSIGNED
        };
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        const { propertyReadSideEffects } = this.context.options
            .treeshake;
        if (
        // Namespaces are not bound and should not be deoptimized
        this.bound &&
            propertyReadSideEffects &&
            !(this.variable || this.replacement)) {
            const propertyKey = this.getPropertyKey();
            this.object.deoptimizeThisOnInteractionAtPath(this.accessInteraction, [propertyKey], SHARED_RECURSION_TRACKER);
            this.context.requestTreeshakingPass();
        }
    }
    applyAssignmentDeoptimization() {
        this.assignmentDeoptimized = true;
        const { propertyReadSideEffects } = this.context.options
            .treeshake;
        if (
        // Namespaces are not bound and should not be deoptimized
        this.bound &&
            propertyReadSideEffects &&
            !(this.variable || this.replacement)) {
            this.object.deoptimizeThisOnInteractionAtPath(this.assignmentInteraction, [this.getPropertyKey()], SHARED_RECURSION_TRACKER);
            this.context.requestTreeshakingPass();
        }
    }
    disallowNamespaceReassignment() {
        if (this.object instanceof Identifier) {
            const variable = this.scope.findVariable(this.object.name);
            if (variable.isNamespace) {
                if (this.variable) {
                    this.context.includeVariableInModule(this.variable);
                }
                this.context.warn({
                    code: 'ILLEGAL_NAMESPACE_REASSIGNMENT',
                    message: `Illegal reassignment to import '${this.object.name}'`
                }, this.start);
            }
        }
    }
    getPropertyKey() {
        if (this.propertyKey === null) {
            this.propertyKey = UnknownKey;
            const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            return (this.propertyKey = typeof value === 'symbol' ? UnknownKey : String(value));
        }
        return this.propertyKey;
    }
    hasAccessEffect(context) {
        const { propertyReadSideEffects } = this.context.options
            .treeshake;
        return (!(this.variable || this.replacement) &&
            propertyReadSideEffects &&
            (propertyReadSideEffects === 'always' ||
                this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()], this.accessInteraction, context)));
    }
    includeProperties(context, includeChildrenRecursively) {
        if (!this.included) {
            this.included = true;
            if (this.variable) {
                this.context.includeVariableInModule(this.variable);
            }
        }
        this.object.include(context, includeChildrenRecursively);
        this.property.include(context, includeChildrenRecursively);
    }
}
function resolveNamespaceVariables(baseVariable, path, astContext) {
    if (path.length === 0)
        return baseVariable;
    if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)
        return null;
    const exportName = path[0].key;
    const variable = baseVariable.context.traceExport(exportName);
    if (!variable) {
        const fileName = baseVariable.context.fileName;
        astContext.warn({
            code: 'MISSING_EXPORT',
            exporter: relativeId(fileName),
            importer: relativeId(astContext.fileName),
            message: `'${exportName}' is not exported by '${relativeId(fileName)}'`,
            missing: exportName,
            url: `https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module`
        }, path[0].pos);
        return 'undefined';
    }
    return resolveNamespaceVariables(variable, path.slice(1), astContext);
}

class CallExpressionBase extends NodeBase {
    constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.deoptimizableDependentExpressions = [];
        this.expressionsToBeDeoptimized = new Set();
    }
    deoptimizeCache() {
        if (this.returnExpression !== UNKNOWN_EXPRESSION) {
            this.returnExpression = UNKNOWN_EXPRESSION;
            for (const expression of this.deoptimizableDependentExpressions) {
                expression.deoptimizeCache();
            }
            for (const expression of this.expressionsToBeDeoptimized) {
                expression.deoptimizePath(UNKNOWN_PATH);
            }
        }
    }
    deoptimizePath(path) {
        if (path.length === 0 ||
            this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {
            return;
        }
        const returnExpression = this.getReturnExpression();
        if (returnExpression !== UNKNOWN_EXPRESSION) {
            returnExpression.deoptimizePath(path);
        }
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (returnExpression === UNKNOWN_EXPRESSION) {
            interaction.thisArg.deoptimizePath(UNKNOWN_PATH);
        }
        else {
            recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
                this.expressionsToBeDeoptimized.add(interaction.thisArg);
                returnExpression.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
            }, undefined);
        }
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (returnExpression === UNKNOWN_EXPRESSION) {
            return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
            this.deoptimizableDependentExpressions.push(origin);
            return returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);
        }, UnknownValue);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        const returnExpression = this.getReturnExpression(recursionTracker);
        if (this.returnExpression === UNKNOWN_EXPRESSION) {
            return UNKNOWN_EXPRESSION;
        }
        return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {
            this.deoptimizableDependentExpressions.push(origin);
            return returnExpression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
        }, UNKNOWN_EXPRESSION);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        const { type } = interaction;
        if (type === INTERACTION_CALLED) {
            if ((interaction.withNew
                ? context.instantiated
                : context.called).trackEntityAtPathAndGetIfTracked(path, interaction.args, this)) {
                return false;
            }
        }
        else if ((type === INTERACTION_ASSIGNED
            ? context.assigned
            : context.accessed).trackEntityAtPathAndGetIfTracked(path, this)) {
            return false;
        }
        return this.getReturnExpression().hasEffectsOnInteractionAtPath(path, interaction, context);
    }
}

class CallExpression extends CallExpressionBase {
    bind() {
        super.bind();
        if (this.callee instanceof Identifier) {
            const variable = this.scope.findVariable(this.callee.name);
            if (variable.isNamespace) {
                this.context.warn({
                    code: 'CANNOT_CALL_NAMESPACE',
                    message: `Cannot call a namespace ('${this.callee.name}')`
                }, this.start);
            }
            if (this.callee.name === 'eval') {
                this.context.warn({
                    code: 'EVAL',
                    message: `Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification`,
                    url: 'https://rollupjs.org/guide/en/#avoiding-eval'
                }, this.start);
            }
        }
        this.interaction = {
            args: this.arguments,
            thisArg: this.callee instanceof MemberExpression && !this.callee.variable
                ? this.callee.object
                : null,
            type: INTERACTION_CALLED,
            withNew: false
        };
    }
    hasEffects(context) {
        try {
            for (const argument of this.arguments) {
                if (argument.hasEffects(context))
                    return true;
            }
            if (this.context.options.treeshake.annotations &&
                this.annotations)
                return false;
            return (this.callee.hasEffects(context) ||
                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
        }
        finally {
            if (!this.deoptimized)
                this.applyDeoptimizations();
        }
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (includeChildrenRecursively) {
            super.include(context, includeChildrenRecursively);
            if (includeChildrenRecursively === INCLUDE_PARAMETERS &&
                this.callee instanceof Identifier &&
                this.callee.variable) {
                this.callee.variable.markCalledFromTryStatement();
            }
        }
        else {
            this.included = true;
            this.callee.include(context, false);
        }
        this.callee.includeCallArguments(context, this.arguments);
    }
    render(code, options, { renderedSurroundingElement } = BLANK) {
        this.callee.render(code, options, {
            isCalleeOfRenderedParent: true,
            renderedSurroundingElement
        });
        renderCallArguments(code, options, this);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.interaction.thisArg) {
            this.callee.deoptimizeThisOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        }
        for (const argument of this.arguments) {
            // This will make sure all properties of parameters behave as "unknown"
            argument.deoptimizePath(UNKNOWN_PATH);
        }
        this.context.requestTreeshakingPass();
    }
    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
            this.returnExpression = UNKNOWN_EXPRESSION;
            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
        }
        return this.returnExpression;
    }
}

class CatchScope extends ParameterScope {
    addDeclaration(identifier, context, init, isHoisted) {
        const existingParameter = this.variables.get(identifier.name);
        if (existingParameter) {
            // While we still create a hoisted declaration, the initializer goes to
            // the parameter. Note that technically, the declaration now belongs to
            // two variables, which is not correct but should not cause issues.
            this.parent.addDeclaration(identifier, context, UNDEFINED_EXPRESSION, isHoisted);
            existingParameter.addDeclaration(identifier, init);
            return existingParameter;
        }
        return this.parent.addDeclaration(identifier, context, init, isHoisted);
    }
}

class CatchClause extends NodeBase {
    createScope(parentScope) {
        this.scope = new CatchScope(parentScope, this.context);
    }
    parseNode(esTreeNode) {
        // Parameters need to be declared first as the logic is that initializers
        // of hoisted body variables are associated with parameters of the same
        // name instead of the variable
        const { param } = esTreeNode;
        if (param) {
            this.param = new (this.context.getNodeConstructor(param.type))(param, this, this.scope);
            this.param.declare('parameter', UNKNOWN_EXPRESSION);
        }
        super.parseNode(esTreeNode);
    }
}

class ChainExpression extends NodeBase {
}

class ClassBodyScope extends ChildScope {
    constructor(parent, classNode, context) {
        super(parent);
        this.variables.set('this', (this.thisVariable = new LocalVariable('this', null, classNode, context)));
        this.instanceScope = new ChildScope(this);
        this.instanceScope.variables.set('this', new ThisVariable(context));
    }
    findLexicalBoundary() {
        return this;
    }
}

class ClassBody extends NodeBase {
    createScope(parentScope) {
        this.scope = new ClassBodyScope(parentScope, this.parent, this.context);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.context.includeVariableInModule(this.scope.thisVariable);
        for (const definition of this.body) {
            definition.include(context, includeChildrenRecursively);
        }
    }
    parseNode(esTreeNode) {
        const body = (this.body = []);
        for (const definition of esTreeNode.body) {
            body.push(new (this.context.getNodeConstructor(definition.type))(definition, this, definition.static ? this.scope : this.scope.instanceScope));
        }
        super.parseNode(esTreeNode);
    }
    applyDeoptimizations() { }
}

class MethodBase extends NodeBase {
    constructor() {
        super(...arguments);
        this.accessedValue = null;
    }
    // As getter properties directly receive their values from fixed function
    // expressions, there is no known situation where a getter is deoptimized.
    deoptimizeCache() { }
    deoptimizePath(path) {
        this.getAccessedValue().deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        if (interaction.type === INTERACTION_ACCESSED && this.kind === 'get' && path.length === 0) {
            return this.value.deoptimizeThisOnInteractionAtPath({
                args: NO_ARGS,
                thisArg: interaction.thisArg,
                type: INTERACTION_CALLED,
                withNew: false
            }, EMPTY_PATH, recursionTracker);
        }
        if (interaction.type === INTERACTION_ASSIGNED && this.kind === 'set' && path.length === 0) {
            return this.value.deoptimizeThisOnInteractionAtPath({
                args: interaction.args,
                thisArg: interaction.thisArg,
                type: INTERACTION_CALLED,
                withNew: false
            }, EMPTY_PATH, recursionTracker);
        }
        this.getAccessedValue().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.getAccessedValue().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffects(context) {
        return this.key.hasEffects(context);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (this.kind === 'get' && interaction.type === INTERACTION_ACCESSED && path.length === 0) {
            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
                args: NO_ARGS,
                thisArg: interaction.thisArg,
                type: INTERACTION_CALLED,
                withNew: false
            }, context);
        }
        // setters are only called for empty paths
        if (this.kind === 'set' && interaction.type === INTERACTION_ASSIGNED) {
            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
                args: interaction.args,
                thisArg: interaction.thisArg,
                type: INTERACTION_CALLED,
                withNew: false
            }, context);
        }
        return this.getAccessedValue().hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    applyDeoptimizations() { }
    getAccessedValue() {
        if (this.accessedValue === null) {
            if (this.kind === 'get') {
                this.accessedValue = UNKNOWN_EXPRESSION;
                return (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, SHARED_RECURSION_TRACKER, this));
            }
            else {
                return (this.accessedValue = this.value);
            }
        }
        return this.accessedValue;
    }
}

class MethodDefinition extends MethodBase {
    applyDeoptimizations() { }
}

class ObjectMember extends ExpressionEntity {
    constructor(object, key) {
        super();
        this.object = object;
        this.key = key;
    }
    deoptimizePath(path) {
        this.object.deoptimizePath([this.key, ...path]);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.object.deoptimizeThisOnInteractionAtPath(interaction, [this.key, ...path], recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.object.getLiteralValueAtPath([this.key, ...path], recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path], interaction, recursionTracker, origin);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return this.object.hasEffectsOnInteractionAtPath([this.key, ...path], interaction, context);
    }
}

class ClassNode extends NodeBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
    }
    createScope(parentScope) {
        this.scope = new ChildScope(parentScope);
    }
    deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
    }
    deoptimizePath(path) {
        this.getObjectEntity().deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffects(context) {
        var _a, _b;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        const initEffect = ((_a = this.superClass) === null || _a === void 0 ? void 0 : _a.hasEffects(context)) || this.body.hasEffects(context);
        (_b = this.id) === null || _b === void 0 ? void 0 : _b.markDeclarationReached();
        return initEffect || super.hasEffects(context);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        var _a;
        if (interaction.type === INTERACTION_CALLED && path.length === 0) {
            return (!interaction.withNew ||
                (this.classConstructor !== null
                    ? this.classConstructor.hasEffectsOnInteractionAtPath(path, interaction, context)
                    : (_a = this.superClass) === null || _a === void 0 ? void 0 : _a.hasEffectsOnInteractionAtPath(path, interaction, context)) ||
                false);
        }
        else {
            return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
        }
    }
    include(context, includeChildrenRecursively) {
        var _a;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        (_a = this.superClass) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
        this.body.include(context, includeChildrenRecursively);
        if (this.id) {
            this.id.markDeclarationReached();
            this.id.include();
        }
    }
    initialise() {
        var _a;
        (_a = this.id) === null || _a === void 0 ? void 0 : _a.declare('class', this);
        for (const method of this.body.body) {
            if (method instanceof MethodDefinition && method.kind === 'constructor') {
                this.classConstructor = method;
                return;
            }
        }
        this.classConstructor = null;
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        for (const definition of this.body.body) {
            if (!(definition.static ||
                (definition instanceof MethodDefinition && definition.kind === 'constructor'))) {
                // Calls to methods are not tracked, ensure that the return value is deoptimized
                definition.deoptimizePath(UNKNOWN_PATH);
            }
        }
        this.context.requestTreeshakingPass();
    }
    getObjectEntity() {
        if (this.objectEntity !== null) {
            return this.objectEntity;
        }
        const staticProperties = [];
        const dynamicMethods = [];
        for (const definition of this.body.body) {
            const properties = definition.static ? staticProperties : dynamicMethods;
            const definitionKind = definition.kind;
            // Note that class fields do not end up on the prototype
            if (properties === dynamicMethods && !definitionKind)
                continue;
            const kind = definitionKind === 'set' || definitionKind === 'get' ? definitionKind : 'init';
            let key;
            if (definition.computed) {
                const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
                if (typeof keyValue === 'symbol') {
                    properties.push({ key: UnknownKey, kind, property: definition });
                    continue;
                }
                else {
                    key = String(keyValue);
                }
            }
            else {
                key =
                    definition.key instanceof Identifier
                        ? definition.key.name
                        : String(definition.key.value);
            }
            properties.push({ key, kind, property: definition });
        }
        staticProperties.unshift({
            key: 'prototype',
            kind: 'init',
            property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, 'prototype') : OBJECT_PROTOTYPE)
        });
        return (this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE));
    }
}

class ClassDeclaration extends ClassNode {
    initialise() {
        super.initialise();
        if (this.id !== null) {
            this.id.variable.isId = true;
        }
    }
    parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
            this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
        }
        super.parseNode(esTreeNode);
    }
    render(code, options) {
        const { exportNamesByVariable, format, snippets: { _ } } = options;
        if (format === 'system' && this.id && exportNamesByVariable.has(this.id.variable)) {
            code.appendLeft(this.end, `${_}${getSystemExportStatement([this.id.variable], options)};`);
        }
        super.render(code, options);
    }
}

class ClassExpression extends ClassNode {
    render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
}

class MultiExpression extends ExpressionEntity {
    constructor(expressions) {
        super();
        this.expressions = expressions;
        this.included = false;
    }
    deoptimizePath(path) {
        for (const expression of this.expressions) {
            expression.deoptimizePath(path);
        }
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        for (const expression of this.expressions) {
            if (expression.hasEffectsOnInteractionAtPath(path, interaction, context))
                return true;
        }
        return false;
    }
}

class ConditionalExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.expressionsToBeDeoptimized = [];
        this.isBranchResolutionAnalysed = false;
        this.usedBranch = null;
    }
    deoptimizeCache() {
        if (this.usedBranch !== null) {
            const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;
            this.usedBranch = null;
            unusedBranch.deoptimizePath(UNKNOWN_PATH);
            for (const expression of this.expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
            }
        }
    }
    deoptimizePath(path) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            this.consequent.deoptimizePath(path);
            this.alternate.deoptimizePath(path);
        }
        else {
            usedBranch.deoptimizePath(path);
        }
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.consequent.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
        this.alternate.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
            return UnknownValue;
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
            return new MultiExpression([
                this.consequent.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin),
                this.alternate.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)
            ]);
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffects(context) {
        if (this.test.hasEffects(context))
            return true;
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);
        }
        return usedBranch.hasEffects(context);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            return (this.consequent.hasEffectsOnInteractionAtPath(path, interaction, context) ||
                this.alternate.hasEffectsOnInteractionAtPath(path, interaction, context));
        }
        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (includeChildrenRecursively || this.test.shouldBeIncluded(context) || usedBranch === null) {
            this.test.include(context, includeChildrenRecursively);
            this.consequent.include(context, includeChildrenRecursively);
            this.alternate.include(context, includeChildrenRecursively);
        }
        else {
            usedBranch.include(context, includeChildrenRecursively);
        }
    }
    includeCallArguments(context, args) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            this.consequent.includeCallArguments(context, args);
            this.alternate.includeCallArguments(context, args);
        }
        else {
            usedBranch.includeCallArguments(context, args);
        }
    }
    render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        const usedBranch = this.getUsedBranch();
        if (!this.test.included) {
            const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);
            const inclusionStart = findNonWhiteSpace(code.original, (this.consequent.included
                ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end)
                : colonPos) + 1);
            if (preventASI) {
                removeLineBreaks(code, inclusionStart, usedBranch.start);
            }
            code.remove(this.start, inclusionStart);
            if (this.consequent.included) {
                code.remove(colonPos, this.end);
            }
            removeAnnotations(this, code);
            usedBranch.render(code, options, {
                isCalleeOfRenderedParent,
                preventASI: true,
                renderedParentType: renderedParentType || this.parent.type,
                renderedSurroundingElement: renderedSurroundingElement || this.parent.type
            });
        }
        else {
            this.test.render(code, options, { renderedSurroundingElement });
            this.consequent.render(code, options);
            this.alternate.render(code, options);
        }
    }
    getUsedBranch() {
        if (this.isBranchResolutionAnalysed) {
            return this.usedBranch;
        }
        this.isBranchResolutionAnalysed = true;
        const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
        return typeof testValue === 'symbol'
            ? null
            : (this.usedBranch = testValue ? this.consequent : this.alternate);
    }
}

class ContinueStatement extends NodeBase {
    hasEffects(context) {
        if (this.label) {
            if (!context.ignore.labels.has(this.label.name))
                return true;
            context.includedLabels.add(this.label.name);
            context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
        }
        else {
            if (!context.ignore.continues)
                return true;
            context.brokenFlow = BROKEN_FLOW_BREAK_CONTINUE;
        }
        return false;
    }
    include(context) {
        this.included = true;
        if (this.label) {
            this.label.include();
            context.includedLabels.add(this.label.name);
        }
        context.brokenFlow = this.label ? BROKEN_FLOW_ERROR_RETURN_LABEL : BROKEN_FLOW_BREAK_CONTINUE;
    }
}

class DoWhileStatement extends NodeBase {
    hasEffects(context) {
        if (this.test.hasEffects(context))
            return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
            return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
        context.brokenFlow = brokenFlow;
    }
}

class EmptyStatement extends NodeBase {
    hasEffects() {
        return false;
    }
}

class ExportAllDeclaration extends NodeBase {
    hasEffects() {
        return false;
    }
    initialise() {
        this.context.addExport(this);
    }
    render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
    }
    applyDeoptimizations() { }
}
ExportAllDeclaration.prototype.needsBoundaries = true;

class FunctionDeclaration extends FunctionNode {
    initialise() {
        super.initialise();
        if (this.id !== null) {
            this.id.variable.isId = true;
        }
    }
    parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
            this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
        }
        super.parseNode(esTreeNode);
    }
}

// The header ends at the first non-white-space after "default"
function getDeclarationStart(code, start) {
    return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, 'default', start) + 7);
}
function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
    const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');
    if (generatorStarPos === -1) {
        return declarationEnd;
    }
    return declarationEnd + generatorStarPos + 1;
}
class ExportDefaultDeclaration extends NodeBase {
    include(context, includeChildrenRecursively) {
        super.include(context, includeChildrenRecursively);
        if (includeChildrenRecursively) {
            this.context.includeVariableInModule(this.variable);
        }
    }
    initialise() {
        const declaration = this.declaration;
        this.declarationName =
            (declaration.id && declaration.id.name) || this.declaration.name;
        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
        this.context.addExport(this);
    }
    render(code, options, nodeRenderOptions) {
        const { start, end } = nodeRenderOptions;
        const declarationStart = getDeclarationStart(code.original, this.start);
        if (this.declaration instanceof FunctionDeclaration) {
            this.renderNamedDeclaration(code, declarationStart, 'function', '(', this.declaration.id === null, options);
        }
        else if (this.declaration instanceof ClassDeclaration) {
            this.renderNamedDeclaration(code, declarationStart, 'class', '{', this.declaration.id === null, options);
        }
        else if (this.variable.getOriginalVariable() !== this.variable) {
            // Remove altogether to prevent re-declaring the same variable
            treeshakeNode(this, code, start, end);
            return;
        }
        else if (this.variable.included) {
            this.renderVariableDeclaration(code, declarationStart, options);
        }
        else {
            code.remove(this.start, declarationStart);
            this.declaration.render(code, options, {
                renderedSurroundingElement: ExpressionStatement$1
            });
            if (code.original[this.end - 1] !== ';') {
                code.appendLeft(this.end, ';');
            }
            return;
        }
        this.declaration.render(code, options);
    }
    applyDeoptimizations() { }
    renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options) {
        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;
        const name = this.variable.getName(getPropertyAccess);
        // Remove `export default`
        code.remove(this.start, declarationStart);
        if (needsId) {
            code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name}`);
        }
        if (format === 'system' &&
            this.declaration instanceof ClassDeclaration &&
            exportNamesByVariable.has(this.variable)) {
            code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);
        }
    }
    renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*";"*/
        const systemExportNames = format === 'system' && exportNamesByVariable.get(this.variable);
        if (systemExportNames) {
            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));
        }
        else {
            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
            if (!hasTrailingSemicolon) {
                code.appendLeft(this.end, ';');
            }
        }
    }
}
ExportDefaultDeclaration.prototype.needsBoundaries = true;

class ExportNamedDeclaration extends NodeBase {
    bind() {
        var _a;
        // Do not bind specifiers
        (_a = this.declaration) === null || _a === void 0 ? void 0 : _a.bind();
    }
    hasEffects(context) {
        var _a;
        return !!((_a = this.declaration) === null || _a === void 0 ? void 0 : _a.hasEffects(context));
    }
    initialise() {
        this.context.addExport(this);
    }
    render(code, options, nodeRenderOptions) {
        const { start, end } = nodeRenderOptions;
        if (this.declaration === null) {
            code.remove(start, end);
        }
        else {
            code.remove(this.start, this.declaration.start);
            this.declaration.render(code, options, { end, start });
        }
    }
    applyDeoptimizations() { }
}
ExportNamedDeclaration.prototype.needsBoundaries = true;

class ExportSpecifier extends NodeBase {
    applyDeoptimizations() { }
}

class ForInStatement extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(context) {
        const { deoptimized, left, right } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        if (left.hasEffectsAsAssignmentTarget(context, false) || right.hasEffects(context))
            return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
            return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
    }
    include(context, includeChildrenRecursively) {
        const { body, deoptimized, left, right } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);
        right.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        body.include(context, includeChildrenRecursively, { asSingleStatement: true });
        context.brokenFlow = brokenFlow;
    }
    initialise() {
        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        // handle no space between "in" and the right side
        if (code.original.charCodeAt(this.right.start - 1) === 110 /* n */) {
            code.prependLeft(this.right.start, ' ');
        }
        this.body.render(code, options);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.context.requestTreeshakingPass();
    }
}

class ForOfStatement extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects() {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        // Placeholder until proper Symbol.Iterator support
        return true;
    }
    include(context, includeChildrenRecursively) {
        const { body, deoptimized, left, right } = this;
        if (!deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);
        right.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        body.include(context, includeChildrenRecursively, { asSingleStatement: true });
        context.brokenFlow = brokenFlow;
    }
    initialise() {
        this.left.setAssignedValue(UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        this.left.render(code, options, NO_SEMICOLON);
        this.right.render(code, options, NO_SEMICOLON);
        // handle no space between "of" and the right side
        if (code.original.charCodeAt(this.right.start - 1) === 102 /* f */) {
            code.prependLeft(this.right.start, ' ');
        }
        this.body.render(code, options);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.left.deoptimizePath(EMPTY_PATH);
        this.context.requestTreeshakingPass();
    }
}

class ForStatement extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(context) {
        var _a, _b, _c;
        if (((_a = this.init) === null || _a === void 0 ? void 0 : _a.hasEffects(context)) ||
            ((_b = this.test) === null || _b === void 0 ? void 0 : _b.hasEffects(context)) ||
            ((_c = this.update) === null || _c === void 0 ? void 0 : _c.hasEffects(context)))
            return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
            return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
    }
    include(context, includeChildrenRecursively) {
        var _a, _b, _c;
        this.included = true;
        (_a = this.init) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively, { asSingleStatement: true });
        (_b = this.test) === null || _b === void 0 ? void 0 : _b.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        (_c = this.update) === null || _c === void 0 ? void 0 : _c.include(context, includeChildrenRecursively);
        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
        context.brokenFlow = brokenFlow;
    }
    render(code, options) {
        var _a, _b, _c;
        (_a = this.init) === null || _a === void 0 ? void 0 : _a.render(code, options, NO_SEMICOLON);
        (_b = this.test) === null || _b === void 0 ? void 0 : _b.render(code, options, NO_SEMICOLON);
        (_c = this.update) === null || _c === void 0 ? void 0 : _c.render(code, options, NO_SEMICOLON);
        this.body.render(code, options);
    }
}

class FunctionExpression extends FunctionNode {
    render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
}

class TrackingScope extends BlockScope {
    constructor() {
        super(...arguments);
        this.hoistedDeclarations = [];
    }
    addDeclaration(identifier, context, init, isHoisted) {
        this.hoistedDeclarations.push(identifier);
        return super.addDeclaration(identifier, context, init, isHoisted);
    }
}

const unset = Symbol('unset');
class IfStatement extends NodeBase {
    constructor() {
        super(...arguments);
        this.testValue = unset;
    }
    deoptimizeCache() {
        this.testValue = UnknownValue;
    }
    hasEffects(context) {
        var _a;
        if (this.test.hasEffects(context)) {
            return true;
        }
        const testValue = this.getTestValue();
        if (typeof testValue === 'symbol') {
            const { brokenFlow } = context;
            if (this.consequent.hasEffects(context))
                return true;
            const consequentBrokenFlow = context.brokenFlow;
            context.brokenFlow = brokenFlow;
            if (this.alternate === null)
                return false;
            if (this.alternate.hasEffects(context))
                return true;
            context.brokenFlow =
                context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
            return false;
        }
        return testValue ? this.consequent.hasEffects(context) : !!((_a = this.alternate) === null || _a === void 0 ? void 0 : _a.hasEffects(context));
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        if (includeChildrenRecursively) {
            this.includeRecursively(includeChildrenRecursively, context);
        }
        else {
            const testValue = this.getTestValue();
            if (typeof testValue === 'symbol') {
                this.includeUnknownTest(context);
            }
            else {
                this.includeKnownTest(context, testValue);
            }
        }
    }
    parseNode(esTreeNode) {
        this.consequentScope = new TrackingScope(this.scope);
        this.consequent = new (this.context.getNodeConstructor(esTreeNode.consequent.type))(esTreeNode.consequent, this, this.consequentScope);
        if (esTreeNode.alternate) {
            this.alternateScope = new TrackingScope(this.scope);
            this.alternate = new (this.context.getNodeConstructor(esTreeNode.alternate.type))(esTreeNode.alternate, this, this.alternateScope);
        }
        super.parseNode(esTreeNode);
    }
    render(code, options) {
        const { snippets: { getPropertyAccess } } = options;
        // Note that unknown test values are always included
        const testValue = this.getTestValue();
        const hoistedDeclarations = [];
        const includesIfElse = this.test.included;
        const noTreeshake = !this.context.options.treeshake;
        if (includesIfElse) {
            this.test.render(code, options);
        }
        else {
            code.remove(this.start, this.consequent.start);
        }
        if (this.consequent.included && (noTreeshake || typeof testValue === 'symbol' || testValue)) {
            this.consequent.render(code, options);
        }
        else {
            code.overwrite(this.consequent.start, this.consequent.end, includesIfElse ? ';' : '');
            hoistedDeclarations.push(...this.consequentScope.hoistedDeclarations);
        }
        if (this.alternate) {
            if (this.alternate.included && (noTreeshake || typeof testValue === 'symbol' || !testValue)) {
                if (includesIfElse) {
                    if (code.original.charCodeAt(this.alternate.start - 1) === 101) {
                        code.prependLeft(this.alternate.start, ' ');
                    }
                }
                else {
                    code.remove(this.consequent.end, this.alternate.start);
                }
                this.alternate.render(code, options);
            }
            else {
                if (includesIfElse && this.shouldKeepAlternateBranch()) {
                    code.overwrite(this.alternate.start, this.end, ';');
                }
                else {
                    code.remove(this.consequent.end, this.end);
                }
                hoistedDeclarations.push(...this.alternateScope.hoistedDeclarations);
            }
        }
        this.renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess);
    }
    applyDeoptimizations() { }
    getTestValue() {
        if (this.testValue === unset) {
            return (this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));
        }
        return this.testValue;
    }
    includeKnownTest(context, testValue) {
        var _a;
        if (this.test.shouldBeIncluded(context)) {
            this.test.include(context, false);
        }
        if (testValue && this.consequent.shouldBeIncluded(context)) {
            this.consequent.include(context, false, { asSingleStatement: true });
        }
        if (!testValue && ((_a = this.alternate) === null || _a === void 0 ? void 0 : _a.shouldBeIncluded(context))) {
            this.alternate.include(context, false, { asSingleStatement: true });
        }
    }
    includeRecursively(includeChildrenRecursively, context) {
        var _a;
        this.test.include(context, includeChildrenRecursively);
        this.consequent.include(context, includeChildrenRecursively);
        (_a = this.alternate) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
    }
    includeUnknownTest(context) {
        var _a;
        this.test.include(context, false);
        const { brokenFlow } = context;
        let consequentBrokenFlow = BROKEN_FLOW_NONE;
        if (this.consequent.shouldBeIncluded(context)) {
            this.consequent.include(context, false, { asSingleStatement: true });
            consequentBrokenFlow = context.brokenFlow;
            context.brokenFlow = brokenFlow;
        }
        if ((_a = this.alternate) === null || _a === void 0 ? void 0 : _a.shouldBeIncluded(context)) {
            this.alternate.include(context, false, { asSingleStatement: true });
            context.brokenFlow =
                context.brokenFlow < consequentBrokenFlow ? context.brokenFlow : consequentBrokenFlow;
        }
    }
    renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess) {
        const hoistedVars = [
            ...new Set(hoistedDeclarations.map(identifier => {
                const variable = identifier.variable;
                return variable.included ? variable.getName(getPropertyAccess) : '';
            }))
        ]
            .filter(Boolean)
            .join(', ');
        if (hoistedVars) {
            const parentType = this.parent.type;
            const needsBraces = parentType !== Program$1 && parentType !== BlockStatement$1;
            code.prependRight(this.start, `${needsBraces ? '{ ' : ''}var ${hoistedVars}; `);
            if (needsBraces) {
                code.appendLeft(this.end, ` }`);
            }
        }
    }
    shouldKeepAlternateBranch() {
        let currentParent = this.parent;
        do {
            if (currentParent instanceof IfStatement && currentParent.alternate) {
                return true;
            }
            if (currentParent instanceof BlockStatement) {
                return false;
            }
            currentParent = currentParent.parent;
        } while (currentParent);
        return false;
    }
}

class ImportDeclaration extends NodeBase {
    // Do not bind specifiers
    bind() { }
    hasEffects() {
        return false;
    }
    initialise() {
        this.context.addImport(this);
    }
    render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
    }
    applyDeoptimizations() { }
}
ImportDeclaration.prototype.needsBoundaries = true;

class ImportDefaultSpecifier extends NodeBase {
    applyDeoptimizations() { }
}

const INTEROP_DEFAULT_VARIABLE = '_interopDefault';
const INTEROP_DEFAULT_LEGACY_VARIABLE = '_interopDefaultLegacy';
const INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';
const INTEROP_NAMESPACE_DEFAULT_VARIABLE = '_interopNamespaceDefault';
const INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = '_interopNamespaceDefaultOnly';
const MERGE_NAMESPACES_VARIABLE = '_mergeNamespaces';
const defaultInteropHelpersByInteropType = {
    auto: INTEROP_DEFAULT_VARIABLE,
    default: null,
    defaultOnly: null,
    esModule: null,
    false: null,
    true: INTEROP_DEFAULT_LEGACY_VARIABLE
};
const isDefaultAProperty = (interopType, externalLiveBindings) => interopType === 'esModule' ||
    (externalLiveBindings && (interopType === 'auto' || interopType === 'true'));
const namespaceInteropHelpersByInteropType = {
    auto: INTEROP_NAMESPACE_VARIABLE,
    default: INTEROP_NAMESPACE_DEFAULT_VARIABLE,
    defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE,
    esModule: null,
    false: null,
    true: INTEROP_NAMESPACE_VARIABLE
};
const canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => isDefaultAProperty(interopType, externalLiveBindings) &&
    defaultInteropHelpersByInteropType[interopType] === INTEROP_DEFAULT_VARIABLE;
const getHelpersBlock = (additionalHelpers, accessedGlobals, indent, snippets, liveBindings, freeze, namespaceToStringTag) => {
    const usedHelpers = new Set(additionalHelpers);
    for (const variable of HELPER_NAMES) {
        if (accessedGlobals.has(variable)) {
            usedHelpers.add(variable);
        }
    }
    return HELPER_NAMES.map(variable => usedHelpers.has(variable)
        ? HELPER_GENERATORS[variable](indent, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers)
        : '').join('');
};
const HELPER_GENERATORS = {
    [INTEROP_DEFAULT_LEGACY_VARIABLE](_t, snippets, liveBindings) {
        const { _, getDirectReturnFunction, n } = snippets;
        const [left, right] = getDirectReturnFunction(['e'], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_DEFAULT_LEGACY_VARIABLE
        });
        return (`${left}e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e${_}?${_}` +
            `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);
    },
    [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {
        const { _, getDirectReturnFunction, n } = snippets;
        const [left, right] = getDirectReturnFunction(['e'], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_DEFAULT_VARIABLE
        });
        return (`${left}e${_}&&${_}e.__esModule${_}?${_}` +
            `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);
    },
    [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, namespaceToStringTag) {
        const { getDirectReturnFunction, getObject, n } = snippets;
        const [left, right] = getDirectReturnFunction(['e'], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
        });
        return `${left}${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, getObject([
            ['__proto__', 'null'],
            ['default', 'e']
        ], { lineBreakIndent: null }), snippets))}${right}${n}${n}`;
    },
    [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
        const { _, n } = snippets;
        return (`function ${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${_}{${n}` +
            createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) +
            `}${n}${n}`);
    },
    [INTEROP_NAMESPACE_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) {
        const { _, getDirectReturnFunction, n } = snippets;
        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
            const [left, right] = getDirectReturnFunction(['e'], {
                functionReturn: true,
                lineBreakIndent: null,
                name: INTEROP_NAMESPACE_VARIABLE
            });
            return `${left}e${_}&&${_}e.__esModule${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n}${n}`;
        }
        return (`function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n}` +
            `${t}if${_}(e${_}&&${_}e.__esModule)${_}return e;${n}` +
            createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) +
            `}${n}${n}`);
    },
    [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
        const { _, cnst, n } = snippets;
        const useForEach = cnst === 'var' && liveBindings;
        return (`function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_}{${n}` +
            `${t}${loopOverNamespaces(`{${n}` +
                `${t}${t}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!(k in n))${_}{${n}` +
                (liveBindings
                    ? useForEach
                        ? copyOwnPropertyLiveBinding
                        : copyPropertyLiveBinding
                    : copyPropertyStatic)(t, t + t + t + t, snippets) +
                `${t}${t}${t}}${n}` +
                `${t}${t}}`, useForEach, t, snippets)}${n}` +
            `${t}return ${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, 'n', snippets))};${n}` +
            `}${n}${n}`);
    }
};
const getDefaultLiveBinding = ({ _, getObject }) => `e${_}:${_}${getObject([['default', 'e']], { lineBreakIndent: null })}`;
const getDefaultStatic = ({ _, getPropertyAccess }) => `e${getPropertyAccess('default')}${_}:${_}e`;
const createNamespaceObject = (t, i, snippets, liveBindings, freeze, namespaceToStringTag) => {
    const { _, cnst, getObject, getPropertyAccess, n, s } = snippets;
    const copyProperty = `{${n}` +
        (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, i + t + t, snippets) +
        `${i}${t}}`;
    return (`${i}${cnst} n${_}=${_}Object.create(null${namespaceToStringTag
        ? `,${_}{${_}[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}${_}}`
        : ''});${n}` +
        `${i}if${_}(e)${_}{${n}` +
        `${i}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n}` +
        `${i}}${n}` +
        `${i}n${getPropertyAccess('default')}${_}=${_}e;${n}` +
        `${i}return ${getFrozen(freeze, 'n')}${s}${n}`);
};
const loopOverKeys = (body, allowVarLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== 'var' || allowVarLoopVariable
    ? `for${_}(${cnst} k in e)${_}${body}`
    : `Object.keys(e).forEach(${getFunctionIntro(['k'], {
        isAsync: false,
        name: null
    })}${body})${s}`;
const loopOverNamespaces = (body, useForEach, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n }) => {
    if (useForEach) {
        const [left, right] = getDirectReturnFunction(['e'], {
            functionReturn: false,
            lineBreakIndent: { base: t, t },
            name: null
        });
        return (`m.forEach(${left}` +
            `e${_}&&${_}typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e)${_}&&${_}Object.keys(e).forEach(${getFunctionIntro(['k'], {
                isAsync: false,
                name: null
            })}${body})${right});`);
    }
    return (`for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n}` +
        `${t}${t}${cnst} e${_}=${_}m[i];${n}` +
        `${t}${t}if${_}(typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e))${_}{${_}for${_}(${cnst} k in e)${_}${body}${_}}${n}${t}}`);
};
const copyNonDefaultOwnPropertyLiveBinding = (t, i, snippets) => {
    const { _, n } = snippets;
    return (`${i}if${_}(k${_}!==${_}'default')${_}{${n}` +
        copyOwnPropertyLiveBinding(t, i + t, snippets) +
        `${i}}${n}`);
};
const copyOwnPropertyLiveBinding = (t, i, { _, cnst, getDirectReturnFunction, n }) => {
    const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
    });
    return (`${i}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
        `${i}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
        `${i}${t}enumerable:${_}true,${n}` +
        `${i}${t}get:${_}${left}e[k]${right}${n}` +
        `${i}});${n}`);
};
const copyPropertyLiveBinding = (t, i, { _, cnst, getDirectReturnFunction, n }) => {
    const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
    });
    return (`${i}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +
        `${i}if${_}(d)${_}{${n}` +
        `${i}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +
        `${i}${t}${t}enumerable:${_}true,${n}` +
        `${i}${t}${t}get:${_}${left}e[k]${right}${n}` +
        `${i}${t}});${n}` +
        `${i}}${n}`);
};
const copyPropertyStatic = (_t, i, { _, n }) => `${i}n[k]${_}=${_}e[k];${n}`;
const getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
const getWithToStringTag = (namespaceToStringTag, fragment, { _, getObject }) => namespaceToStringTag
    ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`
    : fragment;
const HELPER_NAMES = Object.keys(HELPER_GENERATORS);
function getToStringTagValue(getObject) {
    return getObject([['value', "'Module'"]], {
        lineBreakIndent: null
    });
}

class ImportExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.inlineNamespace = null;
        this.mechanism = null;
        this.resolution = null;
    }
    hasEffects() {
        return true;
    }
    include(context, includeChildrenRecursively) {
        if (!this.included) {
            this.included = true;
            this.context.includeDynamicImport(this);
            this.scope.addAccessedDynamicImport(this);
        }
        this.source.include(context, includeChildrenRecursively);
    }
    initialise() {
        this.context.addDynamicImport(this);
    }
    render(code, options) {
        if (this.inlineNamespace) {
            const { snippets: { getDirectReturnFunction, getPropertyAccess } } = options;
            const [left, right] = getDirectReturnFunction([], {
                functionReturn: true,
                lineBreakIndent: null,
                name: null
            });
            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`, { contentOnly: true });
            return;
        }
        if (this.mechanism) {
            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left, { contentOnly: true });
            code.overwrite(this.end - 1, this.end, this.mechanism.right, { contentOnly: true });
        }
        this.source.render(code, options);
    }
    renderFinalResolution(code, resolution, namespaceExportName, { getDirectReturnFunction }) {
        code.overwrite(this.source.start, this.source.end, resolution);
        if (namespaceExportName) {
            const [left, right] = getDirectReturnFunction(['n'], {
                functionReturn: true,
                lineBreakIndent: null,
                name: null
            });
            code.prependLeft(this.end, `.then(${left}n.${namespaceExportName}${right})`);
        }
    }
    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope) {
        const { format } = options;
        this.inlineNamespace = null;
        this.resolution = resolution;
        const accessedGlobals = [...(accessedImportGlobals[format] || [])];
        let helper;
        ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver));
        if (helper) {
            accessedGlobals.push(helper);
        }
        if (accessedGlobals.length > 0) {
            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
    }
    setInternalResolution(inlineNamespace) {
        this.inlineNamespace = inlineNamespace;
    }
    applyDeoptimizations() { }
    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportFunction, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {
        const mechanism = pluginDriver.hookFirstSync('renderDynamicImport', [
            {
                customResolution: typeof this.resolution === 'string' ? this.resolution : null,
                format,
                moduleId: this.context.module.id,
                targetModuleId: this.resolution && typeof this.resolution !== 'string' ? this.resolution.id : null
            }
        ]);
        if (mechanism) {
            return { helper: null, mechanism };
        }
        const hasDynamicTarget = !this.resolution || typeof this.resolution === 'string';
        switch (format) {
            case 'cjs': {
                const helper = getInteropHelper(resolution, exportMode, interop);
                let left = `require(`;
                let right = `)`;
                if (helper) {
                    left = `/*#__PURE__*/${helper}(${left}`;
                    right += ')';
                }
                const [functionLeft, functionRight] = getDirectReturnFunction([], {
                    functionReturn: true,
                    lineBreakIndent: null,
                    name: null
                });
                left = `Promise.resolve().then(${functionLeft}${left}`;
                right += `${functionRight})`;
                if (!arrowFunctions && hasDynamicTarget) {
                    left = getDirectReturnIifeLeft(['t'], `${left}t${right}`, {
                        needsArrowReturnParens: false,
                        needsWrappedFunction: true
                    });
                    right = ')';
                }
                return {
                    helper,
                    mechanism: { left, right }
                };
            }
            case 'amd': {
                const resolve = compact ? 'c' : 'resolve';
                const reject = compact ? 'e' : 'reject';
                const helper = getInteropHelper(resolution, exportMode, interop);
                const [resolveLeft, resolveRight] = getDirectReturnFunction(['m'], {
                    functionReturn: false,
                    lineBreakIndent: null,
                    name: null
                });
                const resolveNamespace = helper
                    ? `${resolveLeft}${resolve}(/*#__PURE__*/${helper}(m))${resolveRight}`
                    : resolve;
                const [handlerLeft, handlerRight] = getDirectReturnFunction([resolve, reject], {
                    functionReturn: false,
                    lineBreakIndent: null,
                    name: null
                });
                let left = `new Promise(${handlerLeft}require([`;
                let right = `],${_}${resolveNamespace},${_}${reject})${handlerRight})`;
                if (!arrowFunctions && hasDynamicTarget) {
                    left = getDirectReturnIifeLeft(['t'], `${left}t${right}`, {
                        needsArrowReturnParens: false,
                        needsWrappedFunction: true
                    });
                    right = ')';
                }
                return {
                    helper,
                    mechanism: { left, right }
                };
            }
            case 'system':
                return {
                    helper: null,
                    mechanism: {
                        left: 'module.import(',
                        right: ')'
                    }
                };
            case 'es':
                if (dynamicImportFunction) {
                    return {
                        helper: null,
                        mechanism: {
                            left: `${dynamicImportFunction}(`,
                            right: ')'
                        }
                    };
                }
        }
        return { helper: null, mechanism: null };
    }
}
function getInteropHelper(resolution, exportMode, interop) {
    return exportMode === 'external'
        ? namespaceInteropHelpersByInteropType[String(interop(resolution instanceof ExternalModule ? resolution.id : null))]
        : exportMode === 'default'
            ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
            : null;
}
const accessedImportGlobals = {
    amd: ['require'],
    cjs: ['require'],
    system: ['module']
};

class ImportNamespaceSpecifier extends NodeBase {
    applyDeoptimizations() { }
}

class ImportSpecifier extends NodeBase {
    applyDeoptimizations() { }
}

class LabeledStatement extends NodeBase {
    hasEffects(context) {
        const brokenFlow = context.brokenFlow;
        context.ignore.labels.add(this.label.name);
        if (this.body.hasEffects(context))
            return true;
        context.ignore.labels.delete(this.label.name);
        if (context.includedLabels.has(this.label.name)) {
            context.includedLabels.delete(this.label.name);
            context.brokenFlow = brokenFlow;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const brokenFlow = context.brokenFlow;
        this.body.include(context, includeChildrenRecursively);
        if (includeChildrenRecursively || context.includedLabels.has(this.label.name)) {
            this.label.include();
            context.includedLabels.delete(this.label.name);
            context.brokenFlow = brokenFlow;
        }
    }
    render(code, options) {
        if (this.label.included) {
            this.label.render(code, options);
        }
        else {
            code.remove(this.start, findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, ':', this.label.end) + 1));
        }
        this.body.render(code, options);
    }
}

class LogicalExpression extends NodeBase {
    constructor() {
        super(...arguments);
        // We collect deoptimization information if usedBranch !== null
        this.expressionsToBeDeoptimized = [];
        this.isBranchResolutionAnalysed = false;
        this.usedBranch = null;
    }
    deoptimizeCache() {
        if (this.usedBranch) {
            const unusedBranch = this.usedBranch === this.left ? this.right : this.left;
            this.usedBranch = null;
            unusedBranch.deoptimizePath(UNKNOWN_PATH);
            for (const expression of this.expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
            }
            // Request another pass because we need to ensure "include" runs again if
            // it is rendered
            this.context.requestTreeshakingPass();
        }
    }
    deoptimizePath(path) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            this.left.deoptimizePath(path);
            this.right.deoptimizePath(path);
        }
        else {
            usedBranch.deoptimizePath(path);
        }
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.left.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
        this.right.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
            return UnknownValue;
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch)
            return new MultiExpression([
                this.left.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin),
                this.right.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)
            ]);
        this.expressionsToBeDeoptimized.push(origin);
        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffects(context) {
        if (this.left.hasEffects(context)) {
            return true;
        }
        if (this.getUsedBranch() !== this.left) {
            return this.right.hasEffects(context);
        }
        return false;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        const usedBranch = this.getUsedBranch();
        if (!usedBranch) {
            return (this.left.hasEffectsOnInteractionAtPath(path, interaction, context) ||
                this.right.hasEffectsOnInteractionAtPath(path, interaction, context));
        }
        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const usedBranch = this.getUsedBranch();
        if (includeChildrenRecursively ||
            (usedBranch === this.right && this.left.shouldBeIncluded(context)) ||
            !usedBranch) {
            this.left.include(context, includeChildrenRecursively);
            this.right.include(context, includeChildrenRecursively);
        }
        else {
            usedBranch.include(context, includeChildrenRecursively);
        }
    }
    render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = BLANK) {
        if (!this.left.included || !this.right.included) {
            const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);
            if (this.right.included) {
                const removePos = findNonWhiteSpace(code.original, operatorPos + 2);
                code.remove(this.start, removePos);
                if (preventASI) {
                    removeLineBreaks(code, removePos, this.right.start);
                }
            }
            else {
                code.remove(operatorPos, this.end);
            }
            removeAnnotations(this, code);
            this.getUsedBranch().render(code, options, {
                isCalleeOfRenderedParent,
                preventASI,
                renderedParentType: renderedParentType || this.parent.type,
                renderedSurroundingElement: renderedSurroundingElement || this.parent.type
            });
        }
        else {
            this.left.render(code, options, {
                preventASI,
                renderedSurroundingElement
            });
            this.right.render(code, options);
        }
    }
    getUsedBranch() {
        if (!this.isBranchResolutionAnalysed) {
            this.isBranchResolutionAnalysed = true;
            const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (typeof leftValue === 'symbol') {
                return null;
            }
            else {
                this.usedBranch =
                    (this.operator === '||' && leftValue) ||
                        (this.operator === '&&' && !leftValue) ||
                        (this.operator === '??' && leftValue != null)
                        ? this.left
                        : this.right;
            }
        }
        return this.usedBranch;
    }
}

const ASSET_PREFIX = 'ROLLUP_ASSET_URL_';
const CHUNK_PREFIX = 'ROLLUP_CHUNK_URL_';
const FILE_PREFIX = 'ROLLUP_FILE_URL_';
class MetaProperty extends NodeBase {
    addAccessedGlobals(format, accessedGlobalsByScope) {
        const metaProperty = this.metaProperty;
        const accessedGlobals = (metaProperty &&
            (metaProperty.startsWith(FILE_PREFIX) ||
                metaProperty.startsWith(ASSET_PREFIX) ||
                metaProperty.startsWith(CHUNK_PREFIX))
            ? accessedFileUrlGlobals
            : accessedMetaUrlGlobals)[format];
        if (accessedGlobals.length > 0) {
            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);
        }
    }
    getReferencedFileName(outputPluginDriver) {
        const metaProperty = this.metaProperty;
        if (metaProperty && metaProperty.startsWith(FILE_PREFIX)) {
            return outputPluginDriver.getFileName(metaProperty.substring(FILE_PREFIX.length));
        }
        return null;
    }
    hasEffects() {
        return false;
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return path.length > 1 || type !== INTERACTION_ACCESSED;
    }
    include() {
        if (!this.included) {
            this.included = true;
            if (this.meta.name === 'import') {
                this.context.addImportMeta(this);
                const parent = this.parent;
                this.metaProperty =
                    parent instanceof MemberExpression && typeof parent.propertyKey === 'string'
                        ? parent.propertyKey
                        : null;
            }
        }
    }
    renderFinalMechanism(code, chunkId, format, snippets, outputPluginDriver) {
        var _a;
        const parent = this.parent;
        const metaProperty = this.metaProperty;
        if (metaProperty &&
            (metaProperty.startsWith(FILE_PREFIX) ||
                metaProperty.startsWith(ASSET_PREFIX) ||
                metaProperty.startsWith(CHUNK_PREFIX))) {
            let referenceId = null;
            let assetReferenceId = null;
            let chunkReferenceId = null;
            let fileName;
            if (metaProperty.startsWith(FILE_PREFIX)) {
                referenceId = metaProperty.substring(FILE_PREFIX.length);
                fileName = outputPluginDriver.getFileName(referenceId);
            }
            else if (metaProperty.startsWith(ASSET_PREFIX)) {
                warnDeprecation(`Using the "${ASSET_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
                assetReferenceId = metaProperty.substring(ASSET_PREFIX.length);
                fileName = outputPluginDriver.getFileName(assetReferenceId);
            }
            else {
                warnDeprecation(`Using the "${CHUNK_PREFIX}" prefix to reference files is deprecated. Use the "${FILE_PREFIX}" prefix instead.`, true, this.context.options);
                chunkReferenceId = metaProperty.substring(CHUNK_PREFIX.length);
                fileName = outputPluginDriver.getFileName(chunkReferenceId);
            }
            const relativePath = normalize(relative$1(dirname(chunkId), fileName));
            let replacement;
            if (assetReferenceId !== null) {
                replacement = outputPluginDriver.hookFirstSync('resolveAssetUrl', [
                    {
                        assetFileName: fileName,
                        chunkId,
                        format,
                        moduleId: this.context.module.id,
                        relativeAssetPath: relativePath
                    }
                ]);
            }
            if (!replacement) {
                replacement =
                    outputPluginDriver.hookFirstSync('resolveFileUrl', [
                        {
                            assetReferenceId,
                            chunkId,
                            chunkReferenceId,
                            fileName,
                            format,
                            moduleId: this.context.module.id,
                            referenceId: referenceId || assetReferenceId || chunkReferenceId,
                            relativePath
                        }
                    ]) || relativeUrlMechanisms[format](relativePath);
            }
            code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
            return;
        }
        const replacement = outputPluginDriver.hookFirstSync('resolveImportMeta', [
            metaProperty,
            {
                chunkId,
                format,
                moduleId: this.context.module.id
            }
        ]) || ((_a = importMetaMechanisms[format]) === null || _a === void 0 ? void 0 : _a.call(importMetaMechanisms, metaProperty, { chunkId, snippets }));
        if (typeof replacement === 'string') {
            if (parent instanceof MemberExpression) {
                code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });
            }
            else {
                code.overwrite(this.start, this.end, replacement, { contentOnly: true });
            }
        }
    }
}
const accessedMetaUrlGlobals = {
    amd: ['document', 'module', 'URL'],
    cjs: ['document', 'require', 'URL'],
    es: [],
    iife: ['document', 'URL'],
    system: ['module'],
    umd: ['document', 'require', 'URL']
};
const accessedFileUrlGlobals = {
    amd: ['document', 'require', 'URL'],
    cjs: ['document', 'require', 'URL'],
    es: [],
    iife: ['document', 'URL'],
    system: ['module', 'URL'],
    umd: ['document', 'require', 'URL']
};
const getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;
const getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${relativePath}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ''}document.currentScript && document.currentScript.src || document.baseURI`);
const getGenericImportMetaMechanism = (getUrl) => (prop, { chunkId }) => {
    const urlMechanism = getUrl(chunkId);
    return prop === null
        ? `({ url: ${urlMechanism} })`
        : prop === 'url'
            ? urlMechanism
            : 'undefined';
};
const getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(document.currentScript && document.currentScript.src || new URL('${chunkId}', document.baseURI).href)`;
const relativeUrlMechanisms = {
    amd: relativePath => {
        if (relativePath[0] !== '.')
            relativePath = './' + relativePath;
        return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);
    },
    cjs: relativePath => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,
    es: relativePath => getResolveUrl(`'${relativePath}', import.meta.url`),
    iife: relativePath => getRelativeUrlFromDocument(relativePath),
    system: relativePath => getResolveUrl(`'${relativePath}', module.meta.url`),
    umd: relativePath => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
const importMetaMechanisms = {
    amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
    cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId)})`),
    iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),
    system: (prop, { snippets: { getPropertyAccess } }) => prop === null ? `module.meta` : `module.meta${getPropertyAccess(prop)}`,
    umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __filename`, `(require('u' + 'rl').URL)`)} : ${getUrlFromDocument(chunkId, true)})`)
};

class NewExpression extends NodeBase {
    hasEffects(context) {
        try {
            for (const argument of this.arguments) {
                if (argument.hasEffects(context))
                    return true;
            }
            if (this.context.options.treeshake.annotations &&
                this.annotations) {
                return false;
            }
            return (this.callee.hasEffects(context) ||
                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
        }
        finally {
            if (!this.deoptimized)
                this.applyDeoptimizations();
        }
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return path.length > 0 || type !== INTERACTION_ACCESSED;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (includeChildrenRecursively) {
            super.include(context, includeChildrenRecursively);
        }
        else {
            this.included = true;
            this.callee.include(context, false);
        }
        this.callee.includeCallArguments(context, this.arguments);
    }
    initialise() {
        this.interaction = {
            args: this.arguments,
            thisArg: null,
            type: INTERACTION_CALLED,
            withNew: true
        };
    }
    render(code, options) {
        this.callee.render(code, options);
        renderCallArguments(code, options, this);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        for (const argument of this.arguments) {
            // This will make sure all properties of parameters behave as "unknown"
            argument.deoptimizePath(UNKNOWN_PATH);
        }
        this.context.requestTreeshakingPass();
    }
}

class ObjectExpression extends NodeBase {
    constructor() {
        super(...arguments);
        this.objectEntity = null;
    }
    deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
    }
    deoptimizePath(path) {
        this.getObjectEntity().deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.getObjectEntity().deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    render(code, options, { renderedSurroundingElement } = BLANK) {
        super.render(code, options);
        if (renderedSurroundingElement === ExpressionStatement$1 ||
            renderedSurroundingElement === ArrowFunctionExpression$1) {
            code.appendRight(this.start, '(');
            code.prependLeft(this.end, ')');
        }
    }
    applyDeoptimizations() { }
    getObjectEntity() {
        if (this.objectEntity !== null) {
            return this.objectEntity;
        }
        let prototype = OBJECT_PROTOTYPE;
        const properties = [];
        for (const property of this.properties) {
            if (property instanceof SpreadElement) {
                properties.push({ key: UnknownKey, kind: 'init', property });
                continue;
            }
            let key;
            if (property.computed) {
                const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
                if (typeof keyValue === 'symbol') {
                    properties.push({ key: UnknownKey, kind: property.kind, property });
                    continue;
                }
                else {
                    key = String(keyValue);
                }
            }
            else {
                key =
                    property.key instanceof Identifier
                        ? property.key.name
                        : String(property.key.value);
                if (key === '__proto__' && property.kind === 'init') {
                    prototype =
                        property.value instanceof Literal && property.value.value === null
                            ? null
                            : property.value;
                    continue;
                }
            }
            properties.push({ key, kind: property.kind, property });
        }
        return (this.objectEntity = new ObjectEntity(properties, prototype));
    }
}

class PrivateIdentifier extends NodeBase {
}

class Program extends NodeBase {
    constructor() {
        super(...arguments);
        this.hasCachedEffect = false;
    }
    hasEffects(context) {
        // We are caching here to later more efficiently identify side-effect-free modules
        if (this.hasCachedEffect)
            return true;
        for (const node of this.body) {
            if (node.hasEffects(context)) {
                return (this.hasCachedEffect = true);
            }
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {
                node.include(context, includeChildrenRecursively);
            }
        }
    }
    render(code, options) {
        if (this.body.length) {
            renderStatementList(this.body, code, this.start, this.end, options);
        }
        else {
            super.render(code, options);
        }
    }
    applyDeoptimizations() { }
}

class Property extends MethodBase {
    constructor() {
        super(...arguments);
        this.declarationInit = null;
    }
    declare(kind, init) {
        this.declarationInit = init;
        return this.value.declare(kind, UNKNOWN_EXPRESSION);
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        const propertyReadSideEffects = this.context.options.treeshake
            .propertyReadSideEffects;
        return ((this.parent.type === 'ObjectPattern' && propertyReadSideEffects === 'always') ||
            this.key.hasEffects(context) ||
            this.value.hasEffects(context));
    }
    markDeclarationReached() {
        this.value.markDeclarationReached();
    }
    render(code, options) {
        if (!this.shorthand) {
            this.key.render(code, options);
        }
        this.value.render(code, options, { isShorthandProperty: this.shorthand });
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
            this.context.requestTreeshakingPass();
        }
    }
}

class PropertyDefinition extends NodeBase {
    deoptimizePath(path) {
        var _a;
        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        var _a;
        (_a = this.value) === null || _a === void 0 ? void 0 : _a.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.value
            ? this.value.getLiteralValueAtPath(path, recursionTracker, origin)
            : UnknownValue;
    }
    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {
        return this.value
            ? this.value.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)
            : UNKNOWN_EXPRESSION;
    }
    hasEffects(context) {
        var _a;
        return this.key.hasEffects(context) || (this.static && !!((_a = this.value) === null || _a === void 0 ? void 0 : _a.hasEffects(context)));
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return !this.value || this.value.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    applyDeoptimizations() { }
}

class ReturnStatement extends NodeBase {
    hasEffects(context) {
        var _a;
        if (!context.ignore.returnYield || ((_a = this.argument) === null || _a === void 0 ? void 0 : _a.hasEffects(context)))
            return true;
        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
        return false;
    }
    include(context, includeChildrenRecursively) {
        var _a;
        this.included = true;
        (_a = this.argument) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
    }
    initialise() {
        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        if (this.argument) {
            this.argument.render(code, options, { preventASI: true });
            if (this.argument.start === this.start + 6 /* 'return'.length */) {
                code.prependLeft(this.start + 6, ' ');
            }
        }
    }
}

class SequenceExpression extends NodeBase {
    deoptimizePath(path) {
        this.expressions[this.expressions.length - 1].deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.expressions[this.expressions.length - 1].deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    getLiteralValueAtPath(path, recursionTracker, origin) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);
    }
    hasEffects(context) {
        for (const expression of this.expressions) {
            if (expression.hasEffects(context))
                return true;
        }
        return false;
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        const lastExpression = this.expressions[this.expressions.length - 1];
        for (const expression of this.expressions) {
            if (includeChildrenRecursively ||
                (expression === lastExpression && !(this.parent instanceof ExpressionStatement)) ||
                expression.shouldBeIncluded(context))
                expression.include(context, includeChildrenRecursively);
        }
    }
    render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = BLANK) {
        let includedNodes = 0;
        let lastSeparatorPos = null;
        const lastNode = this.expressions[this.expressions.length - 1];
        for (const { node, separator, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {
            if (!node.included) {
                treeshakeNode(node, code, start, end);
                continue;
            }
            includedNodes++;
            lastSeparatorPos = separator;
            if (includedNodes === 1 && preventASI) {
                removeLineBreaks(code, start, node.start);
            }
            if (includedNodes === 1) {
                const parentType = renderedParentType || this.parent.type;
                node.render(code, options, {
                    isCalleeOfRenderedParent: isCalleeOfRenderedParent && node === lastNode,
                    renderedParentType: parentType,
                    renderedSurroundingElement: parentType
                });
            }
            else {
                node.render(code, options);
            }
        }
        if (lastSeparatorPos) {
            code.remove(lastSeparatorPos, this.end);
        }
    }
}

class StaticBlock extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(context) {
        for (const node of this.body) {
            if (node.hasEffects(context))
                return true;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        for (const node of this.body) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context))
                node.include(context, includeChildrenRecursively);
        }
    }
    render(code, options) {
        if (this.body.length) {
            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);
        }
        else {
            super.render(code, options);
        }
    }
}

class Super extends NodeBase {
    bind() {
        this.variable = this.scope.findVariable('this');
    }
    deoptimizePath(path) {
        this.variable.deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        this.variable.deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker);
    }
    include() {
        if (!this.included) {
            this.included = true;
            this.context.includeVariableInModule(this.variable);
        }
    }
}

class SwitchCase extends NodeBase {
    hasEffects(context) {
        var _a;
        if ((_a = this.test) === null || _a === void 0 ? void 0 : _a.hasEffects(context))
            return true;
        for (const node of this.consequent) {
            if (context.brokenFlow)
                break;
            if (node.hasEffects(context))
                return true;
        }
        return false;
    }
    include(context, includeChildrenRecursively) {
        var _a;
        this.included = true;
        (_a = this.test) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
        for (const node of this.consequent) {
            if (includeChildrenRecursively || node.shouldBeIncluded(context))
                node.include(context, includeChildrenRecursively);
        }
    }
    render(code, options, nodeRenderOptions) {
        if (this.consequent.length) {
            this.test && this.test.render(code, options);
            const testEnd = this.test
                ? this.test.end
                : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;
            const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;
            renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);
        }
        else {
            super.render(code, options);
        }
    }
}
SwitchCase.prototype.needsBoundaries = true;

class SwitchStatement extends NodeBase {
    createScope(parentScope) {
        this.scope = new BlockScope(parentScope);
    }
    hasEffects(context) {
        if (this.discriminant.hasEffects(context))
            return true;
        const { brokenFlow, ignore: { breaks } } = context;
        let minBrokenFlow = Infinity;
        context.ignore.breaks = true;
        for (const switchCase of this.cases) {
            if (switchCase.hasEffects(context))
                return true;
            minBrokenFlow = context.brokenFlow < minBrokenFlow ? context.brokenFlow : minBrokenFlow;
            context.brokenFlow = brokenFlow;
        }
        if (this.defaultCase !== null && !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
            context.brokenFlow = minBrokenFlow;
        }
        context.ignore.breaks = breaks;
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.discriminant.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        let minBrokenFlow = Infinity;
        let isCaseIncluded = includeChildrenRecursively ||
            (this.defaultCase !== null && this.defaultCase < this.cases.length - 1);
        for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {
            const switchCase = this.cases[caseIndex];
            if (switchCase.included) {
                isCaseIncluded = true;
            }
            if (!isCaseIncluded) {
                const hasEffectsContext = createHasEffectsContext();
                hasEffectsContext.ignore.breaks = true;
                isCaseIncluded = switchCase.hasEffects(hasEffectsContext);
            }
            if (isCaseIncluded) {
                switchCase.include(context, includeChildrenRecursively);
                minBrokenFlow = minBrokenFlow < context.brokenFlow ? minBrokenFlow : context.brokenFlow;
                context.brokenFlow = brokenFlow;
            }
            else {
                minBrokenFlow = brokenFlow;
            }
        }
        if (isCaseIncluded &&
            this.defaultCase !== null &&
            !(minBrokenFlow === BROKEN_FLOW_BREAK_CONTINUE)) {
            context.brokenFlow = minBrokenFlow;
        }
    }
    initialise() {
        for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {
            if (this.cases[caseIndex].test === null) {
                this.defaultCase = caseIndex;
                return;
            }
        }
        this.defaultCase = null;
    }
    render(code, options) {
        this.discriminant.render(code, options);
        if (this.cases.length > 0) {
            renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);
        }
    }
}

class TaggedTemplateExpression extends CallExpressionBase {
    bind() {
        super.bind();
        if (this.tag.type === Identifier$1) {
            const name = this.tag.name;
            const variable = this.scope.findVariable(name);
            if (variable.isNamespace) {
                this.context.warn({
                    code: 'CANNOT_CALL_NAMESPACE',
                    message: `Cannot call a namespace ('${name}')`
                }, this.start);
            }
        }
    }
    hasEffects(context) {
        try {
            for (const argument of this.quasi.expressions) {
                if (argument.hasEffects(context))
                    return true;
            }
            return (this.tag.hasEffects(context) ||
                this.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));
        }
        finally {
            if (!this.deoptimized)
                this.applyDeoptimizations();
        }
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (includeChildrenRecursively) {
            super.include(context, includeChildrenRecursively);
        }
        else {
            this.included = true;
            this.tag.include(context, includeChildrenRecursively);
            this.quasi.include(context, includeChildrenRecursively);
        }
        this.tag.includeCallArguments(context, this.interaction.args);
        const returnExpression = this.getReturnExpression();
        if (!returnExpression.included) {
            returnExpression.include(context, false);
        }
    }
    initialise() {
        this.interaction = {
            args: [UNKNOWN_EXPRESSION, ...this.quasi.expressions],
            thisArg: this.tag instanceof MemberExpression && !this.tag.variable ? this.tag.object : null,
            type: INTERACTION_CALLED,
            withNew: false
        };
    }
    render(code, options) {
        this.tag.render(code, options, { isCalleeOfRenderedParent: true });
        this.quasi.render(code, options);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.interaction.thisArg) {
            this.tag.deoptimizeThisOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);
        }
        for (const argument of this.quasi.expressions) {
            // This will make sure all properties of parameters behave as "unknown"
            argument.deoptimizePath(UNKNOWN_PATH);
        }
        this.context.requestTreeshakingPass();
    }
    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {
        if (this.returnExpression === null) {
            this.returnExpression = UNKNOWN_EXPRESSION;
            return (this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));
        }
        return this.returnExpression;
    }
}

class TemplateElement extends NodeBase {
    // Do not try to bind value
    bind() { }
    hasEffects() {
        return false;
    }
    include() {
        this.included = true;
    }
    parseNode(esTreeNode) {
        this.value = esTreeNode.value;
        super.parseNode(esTreeNode);
    }
    render() { }
}

class TemplateLiteral extends NodeBase {
    deoptimizeThisOnInteractionAtPath() { }
    getLiteralValueAtPath(path) {
        if (path.length > 0 || this.quasis.length !== 1) {
            return UnknownValue;
        }
        return this.quasis[0].value.cooked;
    }
    getReturnExpressionWhenCalledAtPath(path) {
        if (path.length !== 1) {
            return UNKNOWN_EXPRESSION;
        }
        return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (interaction.type === INTERACTION_ACCESSED) {
            return path.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path.length === 1) {
            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);
        }
        return true;
    }
    render(code, options) {
        code.indentExclusionRanges.push([this.start, this.end]);
        super.render(code, options);
    }
}

class UndefinedVariable extends Variable {
    constructor() {
        super('undefined');
    }
    getLiteralValueAtPath() {
        return undefined;
    }
}

class ExportDefaultVariable extends LocalVariable {
    constructor(name, exportDefaultDeclaration, context) {
        super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context);
        this.hasId = false;
        this.originalId = null;
        this.originalVariable = null;
        const declaration = exportDefaultDeclaration.declaration;
        if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) &&
            declaration.id) {
            this.hasId = true;
            this.originalId = declaration.id;
        }
        else if (declaration instanceof Identifier) {
            this.originalId = declaration;
        }
    }
    addReference(identifier) {
        if (!this.hasId) {
            this.name = identifier.name;
        }
    }
    getAssignedVariableName() {
        return (this.originalId && this.originalId.name) || null;
    }
    getBaseVariableName() {
        const original = this.getOriginalVariable();
        if (original === this) {
            return super.getBaseVariableName();
        }
        else {
            return original.getBaseVariableName();
        }
    }
    getDirectOriginalVariable() {
        return this.originalId &&
            (this.hasId ||
                !(this.originalId.isPossibleTDZ() ||
                    this.originalId.variable.isReassigned ||
                    this.originalId.variable instanceof UndefinedVariable ||
                    // this avoids a circular dependency
                    'syntheticNamespace' in this.originalId.variable))
            ? this.originalId.variable
            : null;
    }
    getName(getPropertyAccess) {
        const original = this.getOriginalVariable();
        if (original === this) {
            return super.getName(getPropertyAccess);
        }
        else {
            return original.getName(getPropertyAccess);
        }
    }
    getOriginalVariable() {
        if (this.originalVariable)
            return this.originalVariable;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let original = this;
        let currentVariable;
        const checkedVariables = new Set();
        do {
            checkedVariables.add(original);
            currentVariable = original;
            original = currentVariable.getDirectOriginalVariable();
        } while (original instanceof ExportDefaultVariable && !checkedVariables.has(original));
        return (this.originalVariable = original || currentVariable);
    }
}

class ModuleScope extends ChildScope {
    constructor(parent, context) {
        super(parent);
        this.context = context;
        this.variables.set('this', new LocalVariable('this', null, UNDEFINED_EXPRESSION, context));
    }
    addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {
        const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);
        this.variables.set('default', variable);
        return variable;
    }
    addNamespaceMemberAccess() { }
    deconflict(format, exportNamesByVariable, accessedGlobalsByScope) {
        // all module level variables are already deconflicted when deconflicting the chunk
        for (const scope of this.children)
            scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
    }
    findLexicalBoundary() {
        return this;
    }
    findVariable(name) {
        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);
        if (knownVariable) {
            return knownVariable;
        }
        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);
        if (variable instanceof GlobalVariable) {
            this.accessedOutsideVariables.set(name, variable);
        }
        return variable;
    }
}

class ThisExpression extends NodeBase {
    bind() {
        this.variable = this.scope.findVariable('this');
    }
    deoptimizePath(path) {
        this.variable.deoptimizePath(path);
    }
    deoptimizeThisOnInteractionAtPath(interaction, path, recursionTracker) {
        // We rewrite the parameter so that a ThisVariable can detect self-mutations
        this.variable.deoptimizeThisOnInteractionAtPath(interaction.thisArg === this ? { ...interaction, thisArg: this.variable } : interaction, path, recursionTracker);
    }
    hasEffectsOnInteractionAtPath(path, interaction, context) {
        if (path.length === 0) {
            return interaction.type !== INTERACTION_ACCESSED;
        }
        return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);
    }
    include() {
        if (!this.included) {
            this.included = true;
            this.context.includeVariableInModule(this.variable);
        }
    }
    initialise() {
        this.alias =
            this.scope.findLexicalBoundary() instanceof ModuleScope ? this.context.moduleContext : null;
        if (this.alias === 'undefined') {
            this.context.warn({
                code: 'THIS_IS_UNDEFINED',
                message: `The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`,
                url: `https://rollupjs.org/guide/en/#error-this-is-undefined`
            }, this.start);
        }
    }
    render(code) {
        if (this.alias !== null) {
            code.overwrite(this.start, this.end, this.alias, {
                contentOnly: false,
                storeName: true
            });
        }
    }
}

class ThrowStatement extends NodeBase {
    hasEffects() {
        return true;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.argument.include(context, includeChildrenRecursively);
        context.brokenFlow = BROKEN_FLOW_ERROR_RETURN_LABEL;
    }
    render(code, options) {
        this.argument.render(code, options, { preventASI: true });
        if (this.argument.start === this.start + 5 /* 'throw'.length */) {
            code.prependLeft(this.start + 5, ' ');
        }
    }
}

class TryStatement extends NodeBase {
    constructor() {
        super(...arguments);
        this.directlyIncluded = false;
        this.includedLabelsAfterBlock = null;
    }
    hasEffects(context) {
        var _a;
        return ((this.context.options.treeshake.tryCatchDeoptimization
            ? this.block.body.length > 0
            : this.block.hasEffects(context)) || !!((_a = this.finalizer) === null || _a === void 0 ? void 0 : _a.hasEffects(context)));
    }
    include(context, includeChildrenRecursively) {
        var _a, _b;
        const tryCatchDeoptimization = (_a = this.context.options.treeshake) === null || _a === void 0 ? void 0 : _a.tryCatchDeoptimization;
        const { brokenFlow } = context;
        if (!this.directlyIncluded || !tryCatchDeoptimization) {
            this.included = true;
            this.directlyIncluded = true;
            this.block.include(context, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);
            if (context.includedLabels.size > 0) {
                this.includedLabelsAfterBlock = [...context.includedLabels];
            }
            context.brokenFlow = brokenFlow;
        }
        else if (this.includedLabelsAfterBlock) {
            for (const label of this.includedLabelsAfterBlock) {
                context.includedLabels.add(label);
            }
        }
        if (this.handler !== null) {
            this.handler.include(context, includeChildrenRecursively);
            context.brokenFlow = brokenFlow;
        }
        (_b = this.finalizer) === null || _b === void 0 ? void 0 : _b.include(context, includeChildrenRecursively);
    }
}

const unaryOperators = {
    '!': value => !value,
    '+': value => +value,
    '-': value => -value,
    delete: () => UnknownValue,
    typeof: value => typeof value,
    void: () => undefined,
    '~': value => ~value
};
class UnaryExpression extends NodeBase {
    getLiteralValueAtPath(path, recursionTracker, origin) {
        if (path.length > 0)
            return UnknownValue;
        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);
        if (typeof argumentValue === 'symbol')
            return UnknownValue;
        return unaryOperators[this.operator](argumentValue);
    }
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        if (this.operator === 'typeof' && this.argument instanceof Identifier)
            return false;
        return (this.argument.hasEffects(context) ||
            (this.operator === 'delete' &&
                this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)));
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return type !== INTERACTION_ACCESSED || path.length > (this.operator === 'void' ? 0 : 1);
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        if (this.operator === 'delete') {
            this.argument.deoptimizePath(EMPTY_PATH);
            this.context.requestTreeshakingPass();
        }
    }
}

class UnknownNode extends NodeBase {
    hasEffects() {
        return true;
    }
    include(context) {
        super.include(context, true);
    }
}

class UpdateExpression extends NodeBase {
    hasEffects(context) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return this.argument.hasEffectsAsAssignmentTarget(context, true);
    }
    hasEffectsOnInteractionAtPath(path, { type }) {
        return path.length > 1 || type !== INTERACTION_ACCESSED;
    }
    include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
            this.applyDeoptimizations();
        this.included = true;
        this.argument.includeAsAssignmentTarget(context, includeChildrenRecursively, true);
    }
    initialise() {
        this.argument.setAssignedValue(UNKNOWN_EXPRESSION);
    }
    render(code, options) {
        const { exportNamesByVariable, format, snippets: { _ } } = options;
        this.argument.render(code, options);
        if (format === 'system') {
            const variable = this.argument.variable;
            const exportNames = exportNamesByVariable.get(variable);
            if (exportNames) {
                if (this.prefix) {
                    if (exportNames.length === 1) {
                        renderSystemExportExpression(variable, this.start, this.end, code, options);
                    }
                    else {
                        renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options);
                    }
                }
                else {
                    const operator = this.operator[0];
                    renderSystemExportSequenceBeforeExpression(variable, this.start, this.end, this.parent.type !== ExpressionStatement$1, code, options, `${_}${operator}${_}1`);
                }
            }
        }
    }
    applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath(EMPTY_PATH);
        if (this.argument instanceof Identifier) {
            const variable = this.scope.findVariable(this.argument.name);
            variable.isReassigned = true;
        }
        this.context.requestTreeshakingPass();
    }
}

function isReassignedExportsMember(variable, exportNamesByVariable) {
    return (variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned);
}

function areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {
    for (const declarator of declarations) {
        if (!declarator.id.included)
            return false;
        if (declarator.id.type === Identifier$1) {
            if (exportNamesByVariable.has(declarator.id.variable))
                return false;
        }
        else {
            const exportedVariables = [];
            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);
            if (exportedVariables.length > 0)
                return false;
        }
    }
    return true;
}
class VariableDeclaration extends NodeBase {
    deoptimizePath() {
        for (const declarator of this.declarations) {
            declarator.deoptimizePath(EMPTY_PATH);
        }
    }
    hasEffectsOnInteractionAtPath() {
        return false;
    }
    include(context, includeChildrenRecursively, { asSingleStatement } = BLANK) {
        this.included = true;
        for (const declarator of this.declarations) {
            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))
                declarator.include(context, includeChildrenRecursively);
            if (asSingleStatement) {
                declarator.id.include(context, includeChildrenRecursively);
            }
        }
    }
    initialise() {
        for (const declarator of this.declarations) {
            declarator.declareDeclarator(this.kind);
        }
    }
    render(code, options, nodeRenderOptions = BLANK) {
        if (areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {
            for (const declarator of this.declarations) {
                declarator.render(code, options);
            }
            if (!nodeRenderOptions.isNoStatement &&
                code.original.charCodeAt(this.end - 1) !== 59 /*";"*/) {
                code.appendLeft(this.end, ';');
            }
        }
        else {
            this.renderReplacedDeclarations(code, options);
        }
    }
    applyDeoptimizations() { }
    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options) {
        if (code.original.charCodeAt(this.end - 1) === 59 /*";"*/) {
            code.remove(this.end - 1, this.end);
        }
        separatorString += ';';
        if (lastSeparatorPos !== null) {
            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*"\n"*/ &&
                (code.original.charCodeAt(this.end) === 10 /*"\n"*/ ||
                    code.original.charCodeAt(this.end) === 13) /*"\r"*/) {
                actualContentEnd--;
                if (code.original.charCodeAt(actualContentEnd) === 13 /*"\r"*/) {
                    actualContentEnd--;
                }
            }
            if (actualContentEnd === lastSeparatorPos + 1) {
                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);
            }
            else {
                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
                code.remove(actualContentEnd, renderedContentEnd);
            }
        }
        else {
            code.appendLeft(renderedContentEnd, separatorString);
        }
        if (systemPatternExports.length > 0) {
            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);
        }
    }
    renderReplacedDeclarations(code, options) {
        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*";"*/ ? 1 : 0));
        let actualContentEnd, renderedContentEnd;
        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);
        let lastSeparatorPos = renderedContentEnd - 1;
        code.remove(this.start, lastSeparatorPos);
        let isInDeclaration = false;
        let hasRenderedContent = false;
        let separatorString = '', leadingString, nextSeparatorString;
        const aggregatedSystemExports = [];
        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);
        for (const { node, start, separator, contentEnd, end } of separatedNodes) {
            if (!node.included) {
                code.remove(start, end);
                continue;
            }
            node.render(code, options);
            leadingString = '';
            nextSeparatorString = '';
            if (!node.id.included ||
                (node.id instanceof Identifier &&
                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {
                if (hasRenderedContent) {
                    separatorString += ';';
                }
                isInDeclaration = false;
            }
            else {
                if (singleSystemExport && singleSystemExport === node.id.variable) {
                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);
                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);
                }
                if (isInDeclaration) {
                    separatorString += ',';
                }
                else {
                    if (hasRenderedContent) {
                        separatorString += ';';
                    }
                    leadingString += `${this.kind} `;
                    isInDeclaration = true;
                }
            }
            if (renderedContentEnd === lastSeparatorPos + 1) {
                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);
            }
            else {
                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);
                code.appendLeft(renderedContentEnd, leadingString);
            }
            actualContentEnd = contentEnd;
            renderedContentEnd = end;
            hasRenderedContent = true;
            lastSeparatorPos = separator;
            separatorString = nextSeparatorString;
        }
        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options);
    }
}
function gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {
    var _a;
    let singleSystemExport = null;
    if (options.format === 'system') {
        for (const { node } of separatedNodes) {
            if (node.id instanceof Identifier &&
                node.init &&
                aggregatedSystemExports.length === 0 &&
                ((_a = options.exportNamesByVariable.get(node.id.variable)) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                singleSystemExport = node.id.variable;
                aggregatedSystemExports.push(singleSystemExport);
            }
            else {
                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);
            }
        }
        if (aggregatedSystemExports.length > 1) {
            singleSystemExport = null;
        }
        else if (singleSystemExport) {
            aggregatedSystemExports.length = 0;
        }
    }
    return singleSystemExport;
}

class VariableDeclarator extends NodeBase {
    declareDeclarator(kind) {
        this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);
    }
    deoptimizePath(path) {
        this.id.deoptimizePath(path);
    }
    hasEffects(context) {
        var _a;
        const initEffect = (_a = this.init) === null || _a === void 0 ? void 0 : _a.hasEffects(context);
        this.id.markDeclarationReached();
        return initEffect || this.id.hasEffects(context);
    }
    include(context, includeChildrenRecursively) {
        var _a;
        this.included = true;
        (_a = this.init) === null || _a === void 0 ? void 0 : _a.include(context, includeChildrenRecursively);
        this.id.markDeclarationReached();
        if (includeChildrenRecursively || this.id.shouldBeIncluded(context)) {
            this.id.include(context, includeChildrenRecursively);
        }
    }
    render(code, options) {
        const { exportNamesByVariable, snippets: { _ } } = options;
        const renderId = this.id.included;
        if (renderId) {
            this.id.render(code, options);
        }
        else {
            const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', this.id.end);
            code.remove(this.start, findNonWhiteSpace(code.original, operatorPos + 1));
        }
        if (this.init) {
            this.init.render(code, options, renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 });
        }
        else if (this.id instanceof Identifier &&
            isReassignedExportsMember(this.id.variable, exportNamesByVariable)) {
            code.appendLeft(this.end, `${_}=${_}void 0`);
        }
    }
    applyDeoptimizations() { }
}

class WhileStatement extends NodeBase {
    hasEffects(context) {
        if (this.test.hasEffects(context))
            return true;
        const { brokenFlow, ignore: { breaks, continues } } = context;
        context.ignore.breaks = true;
        context.ignore.continues = true;
        if (this.body.hasEffects(context))
            return true;
        context.ignore.breaks = breaks;
        context.ignore.continues = continues;
        context.brokenFlow = brokenFlow;
        return false;
    }
    include(context, includeChildrenRecursively) {
        this.included = true;
        this.test.include(context, includeChildrenRecursively);
        const { brokenFlow } = context;
        this.body.include(context, includeChildrenRecursively, { asSingleStatement: true });
        context.brokenFlow = brokenFlow;
    }
}

class YieldExpression extends NodeBase {
    hasEffects(context) {
        var _a;
        if (!this.deoptimized)
            this.applyDeoptimizations();
        return !(context.ignore.returnYield && !((_a = this.argument) === null || _a === void 0 ? void 0 : _a.hasEffects(context)));
    }
    render(code, options) {
        if (this.argument) {
            this.argument.render(code, options, { preventASI: true });
            if (this.argument.start === this.start + 5 /* 'yield'.length */) {
                code.prependLeft(this.start + 5, ' ');
            }
        }
    }
}

const nodeConstructors = {
    ArrayExpression,
    ArrayPattern,
    ArrowFunctionExpression,
    AssignmentExpression,
    AssignmentPattern,
    AwaitExpression,
    BinaryExpression,
    BlockStatement,
    BreakStatement,
    CallExpression,
    CatchClause,
    ChainExpression,
    ClassBody,
    ClassDeclaration,
    ClassExpression,
    ConditionalExpression,
    ContinueStatement,
    DoWhileStatement,
    EmptyStatement,
    ExportAllDeclaration,
    ExportDefaultDeclaration,
    ExportNamedDeclaration,
    ExportSpecifier,
    ExpressionStatement,
    ForInStatement,
    ForOfStatement,
    ForStatement,
    FunctionDeclaration,
    FunctionExpression,
    Identifier,
    IfStatement,
    ImportDeclaration,
    ImportDefaultSpecifier,
    ImportExpression,
    ImportNamespaceSpecifier,
    ImportSpecifier,
    LabeledStatement,
    Literal,
    LogicalExpression,
    MemberExpression,
    MetaProperty,
    MethodDefinition,
    NewExpression,
    ObjectExpression,
    ObjectPattern,
    PrivateIdentifier,
    Program,
    Property,
    PropertyDefinition,
    RestElement,
    ReturnStatement,
    SequenceExpression,
    SpreadElement,
    StaticBlock,
    Super,
    SwitchCase,
    SwitchStatement,
    TaggedTemplateExpression,
    TemplateElement,
    TemplateLiteral,
    ThisExpression,
    ThrowStatement,
    TryStatement,
    UnaryExpression,
    UnknownNode,
    UpdateExpression,
    VariableDeclaration,
    VariableDeclarator,
    WhileStatement,
    YieldExpression
};

const MISSING_EXPORT_SHIM_VARIABLE = '_missingExportShim';

class ExportShimVariable extends Variable {
    constructor(module) {
        super(MISSING_EXPORT_SHIM_VARIABLE);
        this.module = module;
    }
    include() {
        super.include();
        this.module.needsExportShim = true;
    }
}

class NamespaceVariable extends Variable {
    constructor(context) {
        super(context.getModuleName());
        this.memberVariables = null;
        this.mergedNamespaces = [];
        this.referencedEarly = false;
        this.references = [];
        this.context = context;
        this.module = context.module;
    }
    addReference(identifier) {
        this.references.push(identifier);
        this.name = identifier.name;
    }
    getMemberVariables() {
        if (this.memberVariables) {
            return this.memberVariables;
        }
        const memberVariables = Object.create(null);
        for (const name of this.context.getExports().concat(this.context.getReexports())) {
            if (name[0] !== '*' && name !== this.module.info.syntheticNamedExports) {
                const exportedVariable = this.context.traceExport(name);
                if (exportedVariable) {
                    memberVariables[name] = exportedVariable;
                }
            }
        }
        return (this.memberVariables = memberVariables);
    }
    include() {
        this.included = true;
        this.context.includeAllExports();
    }
    prepare(accessedGlobalsByScope) {
        if (this.mergedNamespaces.length > 0) {
            this.module.scope.addAccessedGlobals([MERGE_NAMESPACES_VARIABLE], accessedGlobalsByScope);
        }
    }
    renderBlock(options) {
        const { exportNamesByVariable, format, freeze, indent: t, namespaceToStringTag, snippets: { _, cnst, getObject, getPropertyAccess, n, s } } = options;
        const memberVariables = this.getMemberVariables();
        const members = Object.entries(memberVariables).map(([name, original]) => {
            if (this.referencedEarly || original.isReassigned) {
                return [
                    null,
                    `get ${name}${_}()${_}{${_}return ${original.getName(getPropertyAccess)}${s}${_}}`
                ];
            }
            return [name, original.getName(getPropertyAccess)];
        });
        members.unshift([null, `__proto__:${_}null`]);
        let output = getObject(members, { lineBreakIndent: { base: '', t } });
        if (this.mergedNamespaces.length > 0) {
            const assignmentArgs = this.mergedNamespaces.map(variable => variable.getName(getPropertyAccess));
            output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_}[${assignmentArgs.join(`,${_}`)}])`;
        }
        else {
            // The helper to merge namespaces will also take care of freezing and toStringTag
            if (namespaceToStringTag) {
                output = `/*#__PURE__*/Object.defineProperty(${output},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`;
            }
            if (freeze) {
                output = `/*#__PURE__*/Object.freeze(${output})`;
            }
        }
        const name = this.getName(getPropertyAccess);
        output = `${cnst} ${name}${_}=${_}${output};`;
        if (format === 'system' && exportNamesByVariable.has(this)) {
            output += `${n}${getSystemExportStatement([this], options)};`;
        }
        return output;
    }
    renderFirst() {
        return this.referencedEarly;
    }
    setMergedNamespaces(mergedNamespaces) {
        this.mergedNamespaces = mergedNamespaces;
        const moduleExecIndex = this.context.getModuleExecIndex();
        for (const identifier of this.references) {
            if (identifier.context.getModuleExecIndex() <= moduleExecIndex) {
                this.referencedEarly = true;
                break;
            }
        }
    }
}
NamespaceVariable.prototype.isNamespace = true;

class SyntheticNamedExportVariable extends Variable {
    constructor(context, name, syntheticNamespace) {
        super(name);
        this.baseVariable = null;
        this.context = context;
        this.module = context.module;
        this.syntheticNamespace = syntheticNamespace;
    }
    getBaseVariable() {
        if (this.baseVariable)
            return this.baseVariable;
        let baseVariable = this.syntheticNamespace;
        while (baseVariable instanceof ExportDefaultVariable ||
            baseVariable instanceof SyntheticNamedExportVariable) {
            if (baseVariable instanceof ExportDefaultVariable) {
                const original = baseVariable.getOriginalVariable();
                if (original === baseVariable)
                    break;
                baseVariable = original;
            }
            if (baseVariable instanceof SyntheticNamedExportVariable) {
                baseVariable = baseVariable.syntheticNamespace;
            }
        }
        return (this.baseVariable = baseVariable);
    }
    getBaseVariableName() {
        return this.syntheticNamespace.getBaseVariableName();
    }
    getName(getPropertyAccess) {
        return `${this.syntheticNamespace.getName(getPropertyAccess)}${getPropertyAccess(this.name)}`;
    }
    include() {
        this.included = true;
        this.context.includeVariableInModule(this.syntheticNamespace);
    }
    setRenderNames(baseName, name) {
        super.setRenderNames(baseName, name);
    }
}

var BuildPhase;
(function (BuildPhase) {
    BuildPhase[BuildPhase["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
    BuildPhase[BuildPhase["ANALYSE"] = 1] = "ANALYSE";
    BuildPhase[BuildPhase["GENERATE"] = 2] = "GENERATE";
})(BuildPhase || (BuildPhase = {}));

function getId(m) {
    return m.id;
}

function getOriginalLocation(sourcemapChain, location) {
    const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !!sourcemap.mappings);
    traceSourcemap: while (filteredSourcemapChain.length > 0) {
        const sourcemap = filteredSourcemapChain.pop();
        const line = sourcemap.mappings[location.line - 1];
        if (line) {
            const filteredLine = line.filter((segment) => segment.length > 1);
            const lastSegment = filteredLine[filteredLine.length - 1];
            for (const segment of filteredLine) {
                if (segment[0] >= location.column || segment === lastSegment) {
                    location = {
                        column: segment[3],
                        line: segment[2] + 1
                    };
                    continue traceSourcemap;
                }
            }
        }
        throw new Error("Can't resolve original location of error.");
    }
    return location;
}

const NOOP = () => { };
let timers = new Map();
function getPersistedLabel(label, level) {
    switch (level) {
        case 1:
            return `# ${label}`;
        case 2:
            return `## ${label}`;
        case 3:
            return label;
        default:
            return `${'  '.repeat(level - 4)}- ${label}`;
    }
}
function timeStartImpl(label, level = 3) {
    label = getPersistedLabel(label, level);
    const startMemory = process$1.memoryUsage().heapUsed;
    const startTime = performance.now();
    const timer = timers.get(label);
    if (timer === undefined) {
        timers.set(label, {
            memory: 0,
            startMemory,
            startTime,
            time: 0,
            totalMemory: 0
        });
    }
    else {
        timer.startMemory = startMemory;
        timer.startTime = startTime;
    }
}
function timeEndImpl(label, level = 3) {
    label = getPersistedLabel(label, level);
    const timer = timers.get(label);
    if (timer !== undefined) {
        const currentMemory = process$1.memoryUsage().heapUsed;
        timer.memory += currentMemory - timer.startMemory;
        timer.time += performance.now() - timer.startTime;
        timer.totalMemory = Math.max(timer.totalMemory, currentMemory);
    }
}
function getTimings() {
    const newTimings = {};
    for (const [label, { memory, time, totalMemory }] of timers) {
        newTimings[label] = [time, memory, totalMemory];
    }
    return newTimings;
}
let timeStart = NOOP;
let timeEnd = NOOP;
const TIMED_PLUGIN_HOOKS = ['load', 'resolveDynamicImport', 'resolveId', 'transform'];
function getPluginWithTimers(plugin, index) {
    for (const hook of TIMED_PLUGIN_HOOKS) {
        if (hook in plugin) {
            let timerLabel = `plugin ${index}`;
            if (plugin.name) {
                timerLabel += ` (${plugin.name})`;
            }
            timerLabel += ` - ${hook}`;
            const func = plugin[hook];
            plugin[hook] = function (...args) {
                timeStart(timerLabel, 4);
                const result = func.apply(this, args);
                timeEnd(timerLabel, 4);
                if (result && typeof result.then === 'function') {
                    timeStart(`${timerLabel} (async)`, 4);
                    return result.then((hookResult) => {
                        timeEnd(`${timerLabel} (async)`, 4);
                        return hookResult;
                    });
                }
                return result;
            };
        }
    }
    return plugin;
}
function initialiseTimers(inputOptions) {
    if (inputOptions.perf) {
        timers = new Map();
        timeStart = timeStartImpl;
        timeEnd = timeEndImpl;
        inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);
    }
    else {
        timeStart = NOOP;
        timeEnd = NOOP;
    }
}

function markModuleAndImpureDependenciesAsExecuted(baseModule) {
    baseModule.isExecuted = true;
    const modules = [baseModule];
    const visitedModules = new Set();
    for (const module of modules) {
        for (const dependency of [...module.dependencies, ...module.implicitlyLoadedBefore]) {
            if (!(dependency instanceof ExternalModule) &&
                !dependency.isExecuted &&
                (dependency.info.moduleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &&
                !visitedModules.has(dependency.id)) {
                dependency.isExecuted = true;
                visitedModules.add(dependency.id);
                modules.push(dependency);
            }
        }
    }
}

const MISSING_EXPORT_SHIM_DESCRIPTION = {
    identifier: null,
    localName: MISSING_EXPORT_SHIM_VARIABLE
};
function getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = new Map()) {
    const searchedModules = searchedNamesAndModules.get(name);
    if (searchedModules) {
        if (searchedModules.has(target)) {
            return isExportAllSearch ? [null] : error(errCircularReexport(name, target.id));
        }
        searchedModules.add(target);
    }
    else {
        searchedNamesAndModules.set(name, new Set([target]));
    }
    return target.getVariableForExportName(name, {
        importerForSideEffects,
        isExportAllSearch,
        searchedNamesAndModules
    });
}
function getAndExtendSideEffectModules(variable, module) {
    const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, () => new Set());
    let currentVariable = variable;
    const referencedVariables = new Set([currentVariable]);
    while (true) {
        const importingModule = currentVariable.module;
        currentVariable =
            currentVariable instanceof ExportDefaultVariable
                ? currentVariable.getDirectOriginalVariable()
                : currentVariable instanceof SyntheticNamedExportVariable
                    ? currentVariable.syntheticNamespace
                    : null;
        if (!currentVariable || referencedVariables.has(currentVariable)) {
            break;
        }
        referencedVariables.add(currentVariable);
        sideEffectModules.add(importingModule);
        const originalSideEffects = importingModule.sideEffectDependenciesByVariable.get(currentVariable);
        if (originalSideEffects) {
            for (const module of originalSideEffects) {
                sideEffectModules.add(module);
            }
        }
    }
    return sideEffectModules;
}
class Module {
    constructor(graph, id, options, isEntry, moduleSideEffects, syntheticNamedExports, meta) {
        this.graph = graph;
        this.id = id;
        this.options = options;
        this.alternativeReexportModules = new Map();
        this.chunkFileNames = new Set();
        this.chunkNames = [];
        this.cycles = new Set();
        this.dependencies = new Set();
        this.dynamicDependencies = new Set();
        this.dynamicImporters = [];
        this.dynamicImports = [];
        this.execIndex = Infinity;
        this.implicitlyLoadedAfter = new Set();
        this.implicitlyLoadedBefore = new Set();
        this.importDescriptions = new Map();
        this.importMetas = [];
        this.importedFromNotTreeshaken = false;
        this.importers = [];
        this.includedDynamicImporters = [];
        this.includedImports = new Set();
        this.isExecuted = false;
        this.isUserDefinedEntryPoint = false;
        this.needsExportShim = false;
        this.sideEffectDependenciesByVariable = new Map();
        this.sources = new Set();
        this.usesTopLevelAwait = false;
        this.allExportNames = null;
        this.ast = null;
        this.exportAllModules = [];
        this.exportAllSources = new Set();
        this.exportNamesByVariable = null;
        this.exportShimVariable = new ExportShimVariable(this);
        this.exports = new Map();
        this.namespaceReexportsByName = new Map();
        this.reexportDescriptions = new Map();
        this.relevantDependencies = null;
        this.syntheticExports = new Map();
        this.syntheticNamespace = null;
        this.transformDependencies = [];
        this.transitiveReexports = null;
        this.excludeFromSourcemap = /\0/.test(id);
        this.context = options.moduleContext(id);
        this.preserveSignature = this.options.preserveEntrySignatures;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const module = this;
        const { dynamicImports, dynamicImporters, implicitlyLoadedAfter, implicitlyLoadedBefore, importers, reexportDescriptions, sources } = this;
        this.info = {
            ast: null,
            code: null,
            get dynamicallyImportedIdResolutions() {
                return dynamicImports
                    .map(({ argument }) => typeof argument === 'string' && module.resolvedIds[argument])
                    .filter(Boolean);
            },
            get dynamicallyImportedIds() {
                // We cannot use this.dynamicDependencies because this is needed before
                // dynamicDependencies are populated
                return dynamicImports.map(({ id }) => id).filter((id) => id != null);
            },
            get dynamicImporters() {
                return dynamicImporters.sort();
            },
            get hasDefaultExport() {
                // This information is only valid after parsing
                if (!module.ast) {
                    return null;
                }
                return module.exports.has('default') || reexportDescriptions.has('default');
            },
            get hasModuleSideEffects() {
                warnDeprecation('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', false, options);
                return this.moduleSideEffects;
            },
            id,
            get implicitlyLoadedAfterOneOf() {
                return Array.from(implicitlyLoadedAfter, getId).sort();
            },
            get implicitlyLoadedBefore() {
                return Array.from(implicitlyLoadedBefore, getId).sort();
            },
            get importedIdResolutions() {
                return Array.from(sources, source => module.resolvedIds[source]).filter(Boolean);
            },
            get importedIds() {
                // We cannot use this.dependencies because this is needed before
                // dependencies are populated
                return Array.from(sources, source => { var _a; return (_a = module.resolvedIds[source]) === null || _a === void 0 ? void 0 : _a.id; }).filter(Boolean);
            },
            get importers() {
                return importers.sort();
            },
            isEntry,
            isExternal: false,
            get isIncluded() {
                if (graph.phase !== BuildPhase.GENERATE) {
                    return null;
                }
                return module.isIncluded();
            },
            meta: { ...meta },
            moduleSideEffects,
            syntheticNamedExports
        };
        // Hide the deprecated key so that it only warns when accessed explicitly
        Object.defineProperty(this.info, 'hasModuleSideEffects', {
            enumerable: false
        });
    }
    basename() {
        const base = basename(this.id);
        const ext = extname(this.id);
        return makeLegal(ext ? base.slice(0, -ext.length) : base);
    }
    bindReferences() {
        this.ast.bind();
    }
    error(props, pos) {
        this.addLocationToLogProps(props, pos);
        return error(props);
    }
    getAllExportNames() {
        if (this.allExportNames) {
            return this.allExportNames;
        }
        this.allExportNames = new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);
        for (const module of this.exportAllModules) {
            if (module instanceof ExternalModule) {
                this.allExportNames.add(`*${module.id}`);
                continue;
            }
            for (const name of module.getAllExportNames()) {
                if (name !== 'default')
                    this.allExportNames.add(name);
            }
        }
        // We do not count the synthetic namespace as a regular export to hide it
        // from entry signatures and namespace objects
        if (typeof this.info.syntheticNamedExports === 'string') {
            this.allExportNames.delete(this.info.syntheticNamedExports);
        }
        return this.allExportNames;
    }
    getDependenciesToBeIncluded() {
        if (this.relevantDependencies)
            return this.relevantDependencies;
        this.relevantDependencies = new Set();
        const necessaryDependencies = new Set();
        const alwaysCheckedDependencies = new Set();
        const dependencyVariables = new Set(this.includedImports);
        if (this.info.isEntry ||
            this.includedDynamicImporters.length > 0 ||
            this.namespace.included ||
            this.implicitlyLoadedAfter.size > 0) {
            for (const exportName of [...this.getReexports(), ...this.getExports()]) {
                const [exportedVariable] = this.getVariableForExportName(exportName);
                if (exportedVariable) {
                    dependencyVariables.add(exportedVariable);
                }
            }
        }
        for (let variable of dependencyVariables) {
            const sideEffectDependencies = this.sideEffectDependenciesByVariable.get(variable);
            if (sideEffectDependencies) {
                for (const module of sideEffectDependencies) {
                    alwaysCheckedDependencies.add(module);
                }
            }
            if (variable instanceof SyntheticNamedExportVariable) {
                variable = variable.getBaseVariable();
            }
            else if (variable instanceof ExportDefaultVariable) {
                variable = variable.getOriginalVariable();
            }
            necessaryDependencies.add(variable.module);
        }
        if (!this.options.treeshake || this.info.moduleSideEffects === 'no-treeshake') {
            for (const dependency of this.dependencies) {
                this.relevantDependencies.add(dependency);
            }
        }
        else {
            this.addRelevantSideEffectDependencies(this.relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);
        }
        for (const dependency of necessaryDependencies) {
            this.relevantDependencies.add(dependency);
        }
        return this.relevantDependencies;
    }
    getExportNamesByVariable() {
        if (this.exportNamesByVariable) {
            return this.exportNamesByVariable;
        }
        const exportNamesByVariable = new Map();
        for (const exportName of this.getAllExportNames()) {
            let [tracedVariable] = this.getVariableForExportName(exportName);
            if (tracedVariable instanceof ExportDefaultVariable) {
                tracedVariable = tracedVariable.getOriginalVariable();
            }
            if (!tracedVariable ||
                !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {
                continue;
            }
            const existingExportNames = exportNamesByVariable.get(tracedVariable);
            if (existingExportNames) {
                existingExportNames.push(exportName);
            }
            else {
                exportNamesByVariable.set(tracedVariable, [exportName]);
            }
        }
        return (this.exportNamesByVariable = exportNamesByVariable);
    }
    getExports() {
        return Array.from(this.exports.keys());
    }
    getReexports() {
        if (this.transitiveReexports) {
            return this.transitiveReexports;
        }
        // to avoid infinite recursion when using circular `export * from X`
        this.transitiveReexports = [];
        const reexports = new Set(this.reexportDescriptions.keys());
        for (const module of this.exportAllModules) {
            if (module instanceof ExternalModule) {
                reexports.add(`*${module.id}`);
            }
            else {
                for (const name of [...module.getReexports(), ...module.getExports()]) {
                    if (name !== 'default')
                        reexports.add(name);
                }
            }
        }
        return (this.transitiveReexports = [...reexports]);
    }
    getRenderedExports() {
        // only direct exports are counted here, not reexports at all
        const renderedExports = [];
        const removedExports = [];
        for (const exportName of this.exports.keys()) {
            const [variable] = this.getVariableForExportName(exportName);
            (variable && variable.included ? renderedExports : removedExports).push(exportName);
        }
        return { removedExports, renderedExports };
    }
    getSyntheticNamespace() {
        if (this.syntheticNamespace === null) {
            this.syntheticNamespace = undefined;
            [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports === 'string'
                ? this.info.syntheticNamedExports
                : 'default', { onlyExplicit: true });
        }
        if (!this.syntheticNamespace) {
            return error(errSyntheticNamedExportsNeedNamespaceExport(this.id, this.info.syntheticNamedExports));
        }
        return this.syntheticNamespace;
    }
    getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, onlyExplicit, searchedNamesAndModules } = EMPTY_OBJECT) {
        var _a;
        if (name[0] === '*') {
            if (name.length === 1) {
                // export * from './other'
                return [this.namespace];
            }
            // export * from 'external'
            const module = this.graph.modulesById.get(name.slice(1));
            return module.getVariableForExportName('*');
        }
        // export { foo } from './other'
        const reexportDeclaration = this.reexportDescriptions.get(name);
        if (reexportDeclaration) {
            const [variable] = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules);
            if (!variable) {
                return this.error(errMissingExport(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);
            }
            if (importerForSideEffects) {
                setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
            }
            return [variable];
        }
        const exportDeclaration = this.exports.get(name);
        if (exportDeclaration) {
            if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {
                return [this.exportShimVariable];
            }
            const name = exportDeclaration.localName;
            const variable = this.traceVariable(name, {
                importerForSideEffects,
                searchedNamesAndModules
            });
            if (importerForSideEffects) {
                getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, () => new Set()).add(this);
                setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);
            }
            return [variable];
        }
        if (onlyExplicit) {
            return [null];
        }
        if (name !== 'default') {
            const foundNamespaceReexport = (_a = this.namespaceReexportsByName.get(name)) !== null && _a !== void 0 ? _a : this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules);
            this.namespaceReexportsByName.set(name, foundNamespaceReexport);
            if (foundNamespaceReexport[0]) {
                return foundNamespaceReexport;
            }
        }
        if (this.info.syntheticNamedExports) {
            return [
                getOrCreate(this.syntheticExports, name, () => new SyntheticNamedExportVariable(this.astContext, name, this.getSyntheticNamespace()))
            ];
        }
        // we don't want to create shims when we are just
        // probing export * modules for exports
        if (!isExportAllSearch) {
            if (this.options.shimMissingExports) {
                this.shimMissingExport(name);
                return [this.exportShimVariable];
            }
        }
        return [null];
    }
    hasEffects() {
        return (this.info.moduleSideEffects === 'no-treeshake' ||
            (this.ast.included && this.ast.hasEffects(createHasEffectsContext())));
    }
    include() {
        const context = createInclusionContext();
        if (this.ast.shouldBeIncluded(context))
            this.ast.include(context, false);
    }
    includeAllExports(includeNamespaceMembers) {
        if (!this.isExecuted) {
            markModuleAndImpureDependenciesAsExecuted(this);
            this.graph.needsTreeshakingPass = true;
        }
        for (const exportName of this.exports.keys()) {
            if (includeNamespaceMembers || exportName !== this.info.syntheticNamedExports) {
                const variable = this.getVariableForExportName(exportName)[0];
                variable.deoptimizePath(UNKNOWN_PATH);
                if (!variable.included) {
                    this.includeVariable(variable);
                }
            }
        }
        for (const name of this.getReexports()) {
            const [variable] = this.getVariableForExportName(name);
            if (variable) {
                variable.deoptimizePath(UNKNOWN_PATH);
                if (!variable.included) {
                    this.includeVariable(variable);
                }
                if (variable instanceof ExternalVariable) {
                    variable.module.reexported = true;
                }
            }
        }
        if (includeNamespaceMembers) {
            this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());
        }
    }
    includeAllInBundle() {
        this.ast.include(createInclusionContext(), true);
        this.includeAllExports(false);
    }
    isIncluded() {
        return this.ast.included || this.namespace.included || this.importedFromNotTreeshaken;
    }
    linkImports() {
        this.addModulesToImportDescriptions(this.importDescriptions);
        this.addModulesToImportDescriptions(this.reexportDescriptions);
        const externalExportAllModules = [];
        for (const source of this.exportAllSources) {
            const module = this.graph.modulesById.get(this.resolvedIds[source].id);
            if (module instanceof ExternalModule) {
                externalExportAllModules.push(module);
                continue;
            }
            this.exportAllModules.push(module);
        }
        this.exportAllModules.push(...externalExportAllModules);
    }
    render(options) {
        const magicString = this.magicString.clone();
        this.ast.render(magicString, options);
        this.usesTopLevelAwait = this.astContext.usesTopLevelAwait;
        return magicString;
    }
    setSource({ ast, code, customTransformCache, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies, transformFiles, ...moduleOptions }) {
        this.info.code = code;
        this.originalCode = originalCode;
        this.originalSourcemap = originalSourcemap;
        this.sourcemapChain = sourcemapChain;
        if (transformFiles) {
            this.transformFiles = transformFiles;
        }
        this.transformDependencies = transformDependencies;
        this.customTransformCache = customTransformCache;
        this.updateOptions(moduleOptions);
        timeStart('generate ast', 3);
        if (!ast) {
            ast = this.tryParse();
        }
        timeEnd('generate ast', 3);
        this.resolvedIds = resolvedIds || Object.create(null);
        // By default, `id` is the file name. Custom resolvers and loaders
        // can change that, but it makes sense to use it for the source file name
        const fileName = this.id;
        this.magicString = new MagicString(code, {
            filename: (this.excludeFromSourcemap ? null : fileName),
            indentExclusionRanges: []
        });
        timeStart('analyse ast', 3);
        this.astContext = {
            addDynamicImport: this.addDynamicImport.bind(this),
            addExport: this.addExport.bind(this),
            addImport: this.addImport.bind(this),
            addImportMeta: this.addImportMeta.bind(this),
            code,
            deoptimizationTracker: this.graph.deoptimizationTracker,
            error: this.error.bind(this),
            fileName,
            getExports: this.getExports.bind(this),
            getModuleExecIndex: () => this.execIndex,
            getModuleName: this.basename.bind(this),
            getNodeConstructor: (name) => nodeConstructors[name] || nodeConstructors.UnknownNode,
            getReexports: this.getReexports.bind(this),
            importDescriptions: this.importDescriptions,
            includeAllExports: () => this.includeAllExports(true),
            includeDynamicImport: this.includeDynamicImport.bind(this),
            includeVariableInModule: this.includeVariableInModule.bind(this),
            magicString: this.magicString,
            module: this,
            moduleContext: this.context,
            options: this.options,
            requestTreeshakingPass: () => (this.graph.needsTreeshakingPass = true),
            traceExport: (name) => this.getVariableForExportName(name)[0],
            traceVariable: this.traceVariable.bind(this),
            usesTopLevelAwait: false,
            warn: this.warn.bind(this)
        };
        this.scope = new ModuleScope(this.graph.scope, this.astContext);
        this.namespace = new NamespaceVariable(this.astContext);
        this.ast = new Program(ast, { context: this.astContext, type: 'Module' }, this.scope);
        this.info.ast = ast;
        timeEnd('analyse ast', 3);
    }
    toJSON() {
        return {
            ast: this.ast.esTreeNode,
            code: this.info.code,
            customTransformCache: this.customTransformCache,
            dependencies: Array.from(this.dependencies, getId),
            id: this.id,
            meta: this.info.meta,
            moduleSideEffects: this.info.moduleSideEffects,
            originalCode: this.originalCode,
            originalSourcemap: this.originalSourcemap,
            resolvedIds: this.resolvedIds,
            sourcemapChain: this.sourcemapChain,
            syntheticNamedExports: this.info.syntheticNamedExports,
            transformDependencies: this.transformDependencies,
            transformFiles: this.transformFiles
        };
    }
    traceVariable(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules } = EMPTY_OBJECT) {
        const localVariable = this.scope.variables.get(name);
        if (localVariable) {
            return localVariable;
        }
        const importDeclaration = this.importDescriptions.get(name);
        if (importDeclaration) {
            const otherModule = importDeclaration.module;
            if (otherModule instanceof Module && importDeclaration.name === '*') {
                return otherModule.namespace;
            }
            const [declaration] = getVariableForExportNameRecursive(otherModule, importDeclaration.name, importerForSideEffects || this, isExportAllSearch, searchedNamesAndModules);
            if (!declaration) {
                return this.error(errMissingExport(importDeclaration.name, this.id, otherModule.id), importDeclaration.start);
            }
            return declaration;
        }
        return null;
    }
    tryParse() {
        try {
            return this.graph.contextParse(this.info.code);
        }
        catch (err) {
            let message = err.message.replace(/ \(\d+:\d+\)$/, '');
            if (this.id.endsWith('.json')) {
                message += ' (Note that you need @rollup/plugin-json to import JSON files)';
            }
            else if (!this.id.endsWith('.js')) {
                message += ' (Note that you need plugins to import files that are not JavaScript)';
            }
            return this.error({
                code: 'PARSE_ERROR',
                message,
                parserError: err
            }, err.pos);
        }
    }
    updateOptions({ meta, moduleSideEffects, syntheticNamedExports }) {
        if (moduleSideEffects != null) {
            this.info.moduleSideEffects = moduleSideEffects;
        }
        if (syntheticNamedExports != null) {
            this.info.syntheticNamedExports = syntheticNamedExports;
        }
        if (meta != null) {
            Object.assign(this.info.meta, meta);
        }
    }
    warn(props, pos) {
        this.addLocationToLogProps(props, pos);
        this.options.onwarn(props);
    }
    addDynamicImport(node) {
        let argument = node.source;
        if (argument instanceof TemplateLiteral) {
            if (argument.quasis.length === 1 && argument.quasis[0].value.cooked) {
                argument = argument.quasis[0].value.cooked;
            }
        }
        else if (argument instanceof Literal && typeof argument.value === 'string') {
            argument = argument.value;
        }
        this.dynamicImports.push({ argument, id: null, node, resolution: null });
    }
    addExport(node) {
        if (node instanceof ExportDefaultDeclaration) {
            // export default foo;
            this.exports.set('default', {
                identifier: node.variable.getAssignedVariableName(),
                localName: 'default'
            });
        }
        else if (node instanceof ExportAllDeclaration) {
            const source = node.source.value;
            this.sources.add(source);
            if (node.exported) {
                // export * as name from './other'
                const name = node.exported.name;
                this.reexportDescriptions.set(name, {
                    localName: '*',
                    module: null,
                    source,
                    start: node.start
                });
            }
            else {
                // export * from './other'
                this.exportAllSources.add(source);
            }
        }
        else if (node.source instanceof Literal) {
            // export { name } from './other'
            const source = node.source.value;
            this.sources.add(source);
            for (const specifier of node.specifiers) {
                const name = specifier.exported.name;
                this.reexportDescriptions.set(name, {
                    localName: specifier.local.name,
                    module: null,
                    source,
                    start: specifier.start
                });
            }
        }
        else if (node.declaration) {
            const declaration = node.declaration;
            if (declaration instanceof VariableDeclaration) {
                // export var { foo, bar } = ...
                // export var foo = 1, bar = 2;
                for (const declarator of declaration.declarations) {
                    for (const localName of extractAssignedNames(declarator.id)) {
                        this.exports.set(localName, { identifier: null, localName });
                    }
                }
            }
            else {
                // export function foo () {}
                const localName = declaration.id.name;
                this.exports.set(localName, { identifier: null, localName });
            }
        }
        else {
            // export { foo, bar, baz }
            for (const specifier of node.specifiers) {
                const localName = specifier.local.name;
                const exportedName = specifier.exported.name;
                this.exports.set(exportedName, { identifier: null, localName });
            }
        }
    }
    addImport(node) {
        const source = node.source.value;
        this.sources.add(source);
        for (const specifier of node.specifiers) {
            const isDefault = specifier.type === ImportDefaultSpecifier$1;
            const isNamespace = specifier.type === ImportNamespaceSpecifier$1;
            const name = isDefault ? 'default' : isNamespace ? '*' : specifier.imported.name;
            this.importDescriptions.set(specifier.local.name, {
                module: null,
                name,
                source,
                start: specifier.start
            });
        }
    }
    addImportMeta(node) {
        this.importMetas.push(node);
    }
    addLocationToLogProps(props, pos) {
        props.id = this.id;
        props.pos = pos;
        let code = this.info.code;
        const location = locate(code, pos, { offsetLine: 1 });
        if (location) {
            let { column, line } = location;
            try {
                ({ column, line } = getOriginalLocation(this.sourcemapChain, { column, line }));
                code = this.originalCode;
            }
            catch (err) {
                this.options.onwarn({
                    code: 'SOURCEMAP_ERROR',
                    id: this.id,
                    loc: {
                        column,
                        file: this.id,
                        line
                    },
                    message: `Error when using sourcemap for reporting an error: ${err.message}`,
                    pos
                });
            }
            augmentCodeLocation(props, { column, line }, code, this.id);
        }
    }
    addModulesToImportDescriptions(importDescription) {
        for (const specifier of importDescription.values()) {
            const { id } = this.resolvedIds[specifier.source];
            specifier.module = this.graph.modulesById.get(id);
        }
    }
    addRelevantSideEffectDependencies(relevantDependencies, necessaryDependencies, alwaysCheckedDependencies) {
        const handledDependencies = new Set();
        const addSideEffectDependencies = (possibleDependencies) => {
            for (const dependency of possibleDependencies) {
                if (handledDependencies.has(dependency)) {
                    continue;
                }
                handledDependencies.add(dependency);
                if (necessaryDependencies.has(dependency)) {
                    relevantDependencies.add(dependency);
                    continue;
                }
                if (!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {
                    continue;
                }
                if (dependency instanceof ExternalModule || dependency.hasEffects()) {
                    relevantDependencies.add(dependency);
                    continue;
                }
                addSideEffectDependencies(dependency.dependencies);
            }
        };
        addSideEffectDependencies(this.dependencies);
        addSideEffectDependencies(alwaysCheckedDependencies);
    }
    getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules) {
        let foundSyntheticDeclaration = null;
        const foundInternalDeclarations = new Map();
        const foundExternalDeclarations = new Set();
        for (const module of this.exportAllModules) {
            // Synthetic namespaces should not hide "regular" exports of the same name
            if (module.info.syntheticNamedExports === name) {
                continue;
            }
            const [variable, indirectExternal] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, 
            // We are creating a copy to handle the case where the same binding is
            // imported through different namespace reexports gracefully
            copyNameToModulesMap(searchedNamesAndModules));
            if (module instanceof ExternalModule || indirectExternal) {
                foundExternalDeclarations.add(variable);
            }
            else if (variable instanceof SyntheticNamedExportVariable) {
                if (!foundSyntheticDeclaration) {
                    foundSyntheticDeclaration = variable;
                }
            }
            else if (variable) {
                foundInternalDeclarations.set(variable, module);
            }
        }
        if (foundInternalDeclarations.size > 0) {
            const foundDeclarationList = [...foundInternalDeclarations];
            const usedDeclaration = foundDeclarationList[0][0];
            if (foundDeclarationList.length === 1) {
                return [usedDeclaration];
            }
            this.options.onwarn(errNamespaceConflict(name, this.id, foundDeclarationList.map(([, module]) => module.id)));
            // TODO we are pretending it was not found while it should behave like "undefined"
            return [null];
        }
        if (foundExternalDeclarations.size > 0) {
            const foundDeclarationList = [...foundExternalDeclarations];
            const usedDeclaration = foundDeclarationList[0];
            if (foundDeclarationList.length > 1) {
                this.options.onwarn(errAmbiguousExternalNamespaces(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));
            }
            return [usedDeclaration, true];
        }
        if (foundSyntheticDeclaration) {
            return [foundSyntheticDeclaration];
        }
        return [null];
    }
    includeAndGetAdditionalMergedNamespaces() {
        const externalNamespaces = new Set();
        const syntheticNamespaces = new Set();
        for (const module of [this, ...this.exportAllModules]) {
            if (module instanceof ExternalModule) {
                const [externalVariable] = module.getVariableForExportName('*');
                externalVariable.include();
                this.includedImports.add(externalVariable);
                externalNamespaces.add(externalVariable);
            }
            else if (module.info.syntheticNamedExports) {
                const syntheticNamespace = module.getSyntheticNamespace();
                syntheticNamespace.include();
                this.includedImports.add(syntheticNamespace);
                syntheticNamespaces.add(syntheticNamespace);
            }
        }
        return [...syntheticNamespaces, ...externalNamespaces];
    }
    includeDynamicImport(node) {
        const resolution = this.dynamicImports.find(dynamicImport => dynamicImport.node === node).resolution;
        if (resolution instanceof Module) {
            resolution.includedDynamicImporters.push(this);
            resolution.includeAllExports(true);
        }
    }
    includeVariable(variable) {
        if (!variable.included) {
            variable.include();
            this.graph.needsTreeshakingPass = true;
            const variableModule = variable.module;
            if (variableModule instanceof Module) {
                if (!variableModule.isExecuted) {
                    markModuleAndImpureDependenciesAsExecuted(variableModule);
                }
                if (variableModule !== this) {
                    const sideEffectModules = getAndExtendSideEffectModules(variable, this);
                    for (const module of sideEffectModules) {
                        if (!module.isExecuted) {
                            markModuleAndImpureDependenciesAsExecuted(module);
                        }
                    }
                }
            }
        }
    }
    includeVariableInModule(variable) {
        this.includeVariable(variable);
        const variableModule = variable.module;
        if (variableModule && variableModule !== this) {
            this.includedImports.add(variable);
        }
    }
    shimMissingExport(name) {
        this.options.onwarn({
            code: 'SHIMMED_EXPORT',
            exporter: relativeId(this.id),
            exportName: name,
            message: `Missing export "${name}" has been shimmed in module ${relativeId(this.id)}.`
        });
        this.exports.set(name, MISSING_EXPORT_SHIM_DESCRIPTION);
    }
}
// if there is a cyclic import in the reexport chain, we should not
// import from the original module but from the cyclic module to not
// mess up execution order.
function setAlternativeExporterIfCyclic(variable, importer, reexporter) {
    if (variable.module instanceof Module && variable.module !== reexporter) {
        const exporterCycles = variable.module.cycles;
        if (exporterCycles.size > 0) {
            const importerCycles = reexporter.cycles;
            for (const cycleSymbol of importerCycles) {
                if (exporterCycles.has(cycleSymbol)) {
                    importer.alternativeReexportModules.set(variable, reexporter);
                    break;
                }
            }
        }
    }
}
const copyNameToModulesMap = (searchedNamesAndModules) => searchedNamesAndModules &&
    new Map(Array.from(searchedNamesAndModules, ([name, modules]) => [name, new Set(modules)]));

function removeJsExtension(name) {
    return name.endsWith('.js') ? name.slice(0, -3) : name;
}

function getCompleteAmdId(options, chunkId) {
    if (options.autoId) {
        return `${options.basePath ? options.basePath + '/' : ''}${removeJsExtension(chunkId)}`;
    }
    return options.id || '';
}

function getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, mechanism = 'return ') {
    const { _, cnst, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n, s } = snippets;
    if (!namedExportsMode) {
        return `${n}${n}${mechanism}${getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess)};`;
    }
    let exportBlock = '';
    for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
        if (reexports && namedExportsMode) {
            for (const specifier of reexports) {
                if (specifier.reexported !== '*') {
                    const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
                    if (exportBlock)
                        exportBlock += n;
                    if (specifier.imported !== '*' && specifier.needsLiveBinding) {
                        const [left, right] = getDirectReturnFunction([], {
                            functionReturn: true,
                            lineBreakIndent: null,
                            name: null
                        });
                        exportBlock +=
                            `Object.defineProperty(exports,${_}'${specifier.reexported}',${_}{${n}` +
                                `${t}enumerable:${_}true,${n}` +
                                `${t}get:${_}${left}${importName}${right}${n}});`;
                    }
                    else {
                        exportBlock += `exports${getPropertyAccess(specifier.reexported)}${_}=${_}${importName};`;
                    }
                }
            }
        }
    }
    for (const { exported, local } of exports) {
        const lhs = `exports${getPropertyAccess(exported)}`;
        const rhs = local;
        if (lhs !== rhs) {
            if (exportBlock)
                exportBlock += n;
            exportBlock += `${lhs}${_}=${_}${rhs};`;
        }
    }
    for (const { name, reexports } of dependencies) {
        if (reexports && namedExportsMode) {
            for (const specifier of reexports) {
                if (specifier.reexported === '*') {
                    if (exportBlock)
                        exportBlock += n;
                    const copyPropertyIfNecessary = `{${n}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!exports.hasOwnProperty(k))${_}${getDefineProperty(name, specifier.needsLiveBinding, t, snippets)}${s}${n}}`;
                    exportBlock +=
                        cnst === 'var' && specifier.needsLiveBinding
                            ? `Object.keys(${name}).forEach(${getFunctionIntro(['k'], {
                                isAsync: false,
                                name: null
                            })}${copyPropertyIfNecessary});`
                            : `for${_}(${cnst} k in ${name})${_}${copyPropertyIfNecessary}`;
                }
            }
        }
    }
    if (exportBlock) {
        return `${n}${n}${exportBlock}`;
    }
    return '';
}
function getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess) {
    if (exports.length > 0) {
        return exports[0].local;
    }
    else {
        for (const { defaultVariableName, id, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {
            if (reexports) {
                return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, id, externalLiveBindings, getPropertyAccess);
            }
        }
    }
}
function getReexportedImportName(moduleVariableName, imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, moduleId, externalLiveBindings, getPropertyAccess) {
    if (imported === 'default') {
        if (!isChunk) {
            const moduleInterop = String(interop(moduleId));
            const variableName = defaultInteropHelpersByInteropType[moduleInterop]
                ? defaultVariableName
                : moduleVariableName;
            return isDefaultAProperty(moduleInterop, externalLiveBindings)
                ? `${variableName}${getPropertyAccess('default')}`
                : variableName;
        }
        return depNamedExportsMode
            ? `${moduleVariableName}${getPropertyAccess('default')}`
            : moduleVariableName;
    }
    if (imported === '*') {
        return (isChunk
            ? !depNamedExportsMode
            : namespaceInteropHelpersByInteropType[String(interop(moduleId))])
            ? namespaceVariableName
            : moduleVariableName;
    }
    return `${moduleVariableName}${getPropertyAccess(imported)}`;
}
function getEsModuleValue(getObject) {
    return getObject([['value', 'true']], {
        lineBreakIndent: null
    });
}
function getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, { _, getObject }) {
    if (hasNamedExports) {
        if (addEsModule) {
            if (addNamespaceToStringTag) {
                return `Object.defineProperties(exports,${_}${getObject([
                    ['__esModule', getEsModuleValue(getObject)],
                    [null, `[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}`]
                ], {
                    lineBreakIndent: null
                })});`;
            }
            return `Object.defineProperty(exports,${_}'__esModule',${_}${getEsModuleValue(getObject)});`;
        }
        if (addNamespaceToStringTag) {
            return `Object.defineProperty(exports,${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)});`;
        }
    }
    return '';
}
const getDefineProperty = (name, needsLiveBinding, t, { _, getDirectReturnFunction, n }) => {
    if (needsLiveBinding) {
        const [left, right] = getDirectReturnFunction([], {
            functionReturn: true,
            lineBreakIndent: null,
            name: null
        });
        return (`Object.defineProperty(exports,${_}k,${_}{${n}` +
            `${t}${t}enumerable:${_}true,${n}` +
            `${t}${t}get:${_}${left}${name}[k]${right}${n}${t}})`);
    }
    return `exports[k]${_}=${_}${name}[k]`;
};

function getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, indent, snippets) {
    const { _, cnst, n } = snippets;
    const neededInteropHelpers = new Set();
    const interopStatements = [];
    const addInteropStatement = (helperVariableName, helper, dependencyVariableName) => {
        neededInteropHelpers.add(helper);
        interopStatements.push(`${cnst} ${helperVariableName}${_}=${_}/*#__PURE__*/${helper}(${dependencyVariableName});`);
    };
    for (const { defaultVariableName, imports, id, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {
        if (isChunk) {
            for (const { imported, reexported } of [
                ...(imports || []),
                ...(reexports || [])
            ]) {
                if (imported === '*' && reexported !== '*') {
                    if (!namedExportsMode) {
                        addInteropStatement(namespaceVariableName, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, name);
                    }
                    break;
                }
            }
        }
        else {
            const moduleInterop = String(interop(id));
            let hasDefault = false;
            let hasNamespace = false;
            for (const { imported, reexported } of [
                ...(imports || []),
                ...(reexports || [])
            ]) {
                let helper;
                let variableName;
                if (imported === 'default') {
                    if (!hasDefault) {
                        hasDefault = true;
                        if (defaultVariableName !== namespaceVariableName) {
                            variableName = defaultVariableName;
                            helper = defaultInteropHelpersByInteropType[moduleInterop];
                        }
                    }
                }
                else if (imported === '*' && reexported !== '*') {
                    if (!hasNamespace) {
                        hasNamespace = true;
                        helper = namespaceInteropHelpersByInteropType[moduleInterop];
                        variableName = namespaceVariableName;
                    }
                }
                if (helper) {
                    addInteropStatement(variableName, helper, name);
                }
            }
        }
    }
    return `${getHelpersBlock(neededInteropHelpers, accessedGlobals, indent, snippets, externalLiveBindings, freeze, namespaceToStringTag)}${interopStatements.length > 0 ? `${interopStatements.join(n)}${n}${n}` : ''}`;
}

function addJsExtension(name) {
    return name.endsWith('.js') ? name : name + '.js';
}

// AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.
// The assumption is that this makes sense for all relative ids:
// https://requirejs.org/docs/api.html#jsfiles
function updateExtensionForRelativeAmdId(id, forceJsExtensionForImports) {
    if (id[0] !== '.') {
        return id;
    }
    return forceJsExtensionForImports ? addJsExtension(id) : removeJsExtension(id);
}

const builtins = {
    assert: true,
    buffer: true,
    console: true,
    constants: true,
    domain: true,
    events: true,
    http: true,
    https: true,
    os: true,
    path: true,
    process: true,
    punycode: true,
    querystring: true,
    stream: true,
    string_decoder: true,
    timers: true,
    tty: true,
    url: true,
    util: true,
    vm: true,
    zlib: true
};
function warnOnBuiltins(warn, dependencies) {
    const externalBuiltins = dependencies.map(({ id }) => id).filter(id => id in builtins);
    if (!externalBuiltins.length)
        return;
    warn({
        code: 'MISSING_NODE_BUILTINS',
        message: `Creating a browser bundle that depends on Node.js built-in modules (${printQuotedStringList(externalBuiltins)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`,
        modules: externalBuiltins
    });
}

function amd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets, warn }, { amd, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
    warnOnBuiltins(warn, dependencies);
    const deps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.id, amd.forceJsExtensionForImports)}'`);
    const args = dependencies.map(m => m.name);
    const { n, getNonArrowFunctionIntro, _ } = snippets;
    if (namedExportsMode && hasExports) {
        args.unshift(`exports`);
        deps.unshift(`'exports'`);
    }
    if (accessedGlobals.has('require')) {
        args.unshift('require');
        deps.unshift(`'require'`);
    }
    if (accessedGlobals.has('module')) {
        args.unshift('module');
        deps.unshift(`'module'`);
    }
    const completeAmdId = getCompleteAmdId(amd, id);
    const params = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
        (deps.length ? `[${deps.join(`,${_}`)}],${_}` : ``);
    const useStrict = strict ? `${_}'use strict';` : '';
    magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, snippets);
    if (namespaceMarkers) {
        namespaceMarkers = n + n + namespaceMarkers;
    }
    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
    return (magicString
        .indent(t)
        // factory function should be wrapped by parentheses to avoid lazy parsing,
        // cf. https://v8.dev/blog/preparser#pife
        .prepend(`${amd.define}(${params}(${getNonArrowFunctionIntro(args, {
        isAsync: false,
        name: null
    })}{${useStrict}${n}${n}`)
        .append(`${n}${n}}));`));
}

function cjs(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, namespaceToStringTag, strict }) {
    const { _, n } = snippets;
    const useStrict = strict ? `'use strict';${n}${n}` : '';
    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && esModule, isModuleFacade && namespaceToStringTag, snippets);
    if (namespaceMarkers) {
        namespaceMarkers += n + n;
    }
    const importBlock = getImportBlock$1(dependencies, snippets, compact);
    const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
    magicString.prepend(`${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}`);
    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, `module.exports${_}=${_}`);
    return magicString.append(`${exportBlock}${outro}`);
}
function getImportBlock$1(dependencies, { _, cnst, n }, compact) {
    let importBlock = '';
    let definingVariable = false;
    for (const { id, name, reexports, imports } of dependencies) {
        if (!reexports && !imports) {
            if (importBlock) {
                importBlock += compact && !definingVariable ? ',' : `;${n}`;
            }
            definingVariable = false;
            importBlock += `require('${id}')`;
        }
        else {
            importBlock += compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${cnst} `;
            definingVariable = true;
            importBlock += `${name}${_}=${_}require('${id}')`;
        }
    }
    if (importBlock) {
        return `${importBlock};${n}${n}`;
    }
    return '';
}

function es(magicString, { accessedGlobals, indent: t, intro, outro, dependencies, exports, snippets }, { externalLiveBindings, freeze, namespaceToStringTag }) {
    const { _, n } = snippets;
    const importBlock = getImportBlock(dependencies, _);
    if (importBlock.length > 0)
        intro += importBlock.join(n) + n + n;
    intro += getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag);
    if (intro)
        magicString.prepend(intro);
    const exportBlock = getExportBlock(exports, snippets);
    if (exportBlock.length)
        magicString.append(n + n + exportBlock.join(n).trim());
    if (outro)
        magicString.append(outro);
    return magicString.trim();
}
function getImportBlock(dependencies, _) {
    const importBlock = [];
    for (const { id, reexports, imports, name } of dependencies) {
        if (!reexports && !imports) {
            importBlock.push(`import${_}'${id}';`);
            continue;
        }
        if (imports) {
            let defaultImport = null;
            let starImport = null;
            const importedNames = [];
            for (const specifier of imports) {
                if (specifier.imported === 'default') {
                    defaultImport = specifier;
                }
                else if (specifier.imported === '*') {
                    starImport = specifier;
                }
                else {
                    importedNames.push(specifier);
                }
            }
            if (starImport) {
                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}'${id}';`);
            }
            if (defaultImport && importedNames.length === 0) {
                importBlock.push(`import ${defaultImport.local} from${_}'${id}';`);
            }
            else if (importedNames.length > 0) {
                importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames
                    .map(specifier => {
                    if (specifier.imported === specifier.local) {
                        return specifier.imported;
                    }
                    else {
                        return `${specifier.imported} as ${specifier.local}`;
                    }
                })
                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
            }
        }
        if (reexports) {
            let starExport = null;
            const namespaceReexports = [];
            const namedReexports = [];
            for (const specifier of reexports) {
                if (specifier.reexported === '*') {
                    starExport = specifier;
                }
                else if (specifier.imported === '*') {
                    namespaceReexports.push(specifier);
                }
                else {
                    namedReexports.push(specifier);
                }
            }
            if (starExport) {
                importBlock.push(`export${_}*${_}from${_}'${id}';`);
            }
            if (namespaceReexports.length > 0) {
                if (!imports ||
                    !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {
                    importBlock.push(`import${_}*${_}as ${name} from${_}'${id}';`);
                }
                for (const specifier of namespaceReexports) {
                    importBlock.push(`export${_}{${_}${name === specifier.reexported ? name : `${name} as ${specifier.reexported}`} };`);
                }
            }
            if (namedReexports.length > 0) {
                importBlock.push(`export${_}{${_}${namedReexports
                    .map(specifier => {
                    if (specifier.imported === specifier.reexported) {
                        return specifier.imported;
                    }
                    else {
                        return `${specifier.imported} as ${specifier.reexported}`;
                    }
                })
                    .join(`,${_}`)}${_}}${_}from${_}'${id}';`);
            }
        }
    }
    return importBlock;
}
function getExportBlock(exports, { _, cnst }) {
    const exportBlock = [];
    const exportDeclaration = [];
    for (const specifier of exports) {
        if (specifier.expression) {
            exportBlock.push(`${cnst} ${specifier.local}${_}=${_}${specifier.expression};`);
        }
        exportDeclaration.push(specifier.exported === specifier.local
            ? specifier.local
            : `${specifier.local} as ${specifier.exported}`);
    }
    if (exportDeclaration.length) {
        exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);
    }
    return exportBlock;
}

const keypath = (keypath, getPropertyAccess) => keypath.split('.').map(getPropertyAccess).join('');

function setupNamespace(name, root, globals, { _, getPropertyAccess, s }, compact) {
    const parts = name.split('.');
    parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
    parts.pop();
    let propertyPath = root;
    return (parts
        .map(part => {
        propertyPath += getPropertyAccess(part);
        return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}${s}`;
    })
        .join(compact ? ',' : '\n') + (compact && parts.length ? ';' : '\n'));
}
function assignToDeepVariable(deepName, root, globals, assignment, { _, getPropertyAccess }) {
    const parts = deepName.split('.');
    parts[0] = (typeof globals === 'function' ? globals(parts[0]) : globals[parts[0]]) || parts[0];
    const last = parts.pop();
    let propertyPath = root;
    let deepAssignment = parts
        .map(part => {
        propertyPath += getPropertyAccess(part);
        return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;
    })
        .concat(`${propertyPath}${getPropertyAccess(last)}`)
        .join(`,${_}`) + `${_}=${_}${assignment}`;
    if (parts.length > 0) {
        deepAssignment = `(${deepAssignment})`;
    }
    return deepAssignment;
}

function trimEmptyImports(dependencies) {
    let i = dependencies.length;
    while (i--) {
        const { imports, reexports } = dependencies[i];
        if (imports || reexports) {
            return dependencies.slice(0, i + 1);
        }
    }
    return [];
}

function iife(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, namedExportsMode, outro, snippets, warn }, { compact, esModule, extend, freeze, externalLiveBindings, globals, interop, name, namespaceToStringTag, strict }) {
    const { _, getNonArrowFunctionIntro, getPropertyAccess, n } = snippets;
    const isNamespaced = name && name.includes('.');
    const useVariableAssignment = !extend && !isNamespaced;
    if (name && useVariableAssignment && !isLegal(name)) {
        return error({
            code: 'ILLEGAL_IDENTIFIER_AS_NAME',
            message: `Given name "${name}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`
        });
    }
    warnOnBuiltins(warn, dependencies);
    const external = trimEmptyImports(dependencies);
    const deps = external.map(dep => dep.globalName || 'null');
    const args = external.map(m => m.name);
    if (hasExports && !name) {
        warn({
            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
            message: `If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.`
        });
    }
    if (namedExportsMode && hasExports) {
        if (extend) {
            deps.unshift(`this${keypath(name, getPropertyAccess)}${_}=${_}this${keypath(name, getPropertyAccess)}${_}||${_}{}`);
            args.unshift('exports');
        }
        else {
            deps.unshift('{}');
            args.unshift('exports');
        }
    }
    const useStrict = strict ? `${t}'use strict';${n}` : '';
    const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets);
    magicString.prepend(`${intro}${interopBlock}`);
    let wrapperIntro = `(${getNonArrowFunctionIntro(args, {
        isAsync: false,
        name: null
    })}{${n}${useStrict}${n}`;
    if (hasExports) {
        if (name && !(extend && namedExportsMode)) {
            wrapperIntro =
                (useVariableAssignment ? `var ${name}` : `this${keypath(name, getPropertyAccess)}`) +
                    `${_}=${_}${wrapperIntro}`;
        }
        if (isNamespaced) {
            wrapperIntro = setupNamespace(name, 'this', globals, snippets, compact) + wrapperIntro;
        }
    }
    let wrapperOutro = `${n}${n}})(${deps.join(`,${_}`)});`;
    if (hasExports && !extend && namedExportsMode) {
        wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;
    }
    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, snippets);
    if (namespaceMarkers) {
        namespaceMarkers = n + n + namespaceMarkers;
    }
    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
    return magicString.indent(t).prepend(wrapperIntro).append(wrapperOutro);
}

function system(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, snippets, outro, usesTopLevelAwait }, { externalLiveBindings, freeze, name, namespaceToStringTag, strict, systemNullSetters }) {
    const { _, getFunctionIntro, getNonArrowFunctionIntro, n, s } = snippets;
    const { importBindings, setters, starExcludes } = analyzeDependencies(dependencies, exports, t, snippets);
    const registeredName = name ? `'${name}',${_}` : '';
    const wrapperParams = accessedGlobals.has('module')
        ? ['exports', 'module']
        : hasExports
            ? ['exports']
            : [];
    // factory function should be wrapped by parentheses to avoid lazy parsing,
    // cf. https://v8.dev/blog/preparser#pife
    let wrapperStart = `System.register(${registeredName}[` +
        dependencies.map(({ id }) => `'${id}'`).join(`,${_}`) +
        `],${_}(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n}${t}${strict ? "'use strict';" : ''}` +
        getStarExcludesBlock(starExcludes, t, snippets) +
        getImportBindingsBlock(importBindings, t, snippets) +
        `${n}${t}return${_}{${setters.length
            ? `${n}${t}${t}setters:${_}[${setters
                .map(setter => setter
                ? `${getFunctionIntro(['module'], {
                    isAsync: false,
                    name: null
                })}{${n}${t}${t}${t}${setter}${n}${t}${t}}`
                : systemNullSetters
                    ? `null`
                    : `${getFunctionIntro([], { isAsync: false, name: null })}{}`)
                .join(`,${_}`)}],`
            : ''}${n}`;
    wrapperStart += `${t}${t}execute:${_}(${getNonArrowFunctionIntro([], {
        isAsync: usesTopLevelAwait,
        name: null
    })}{${n}${n}`;
    const wrapperEnd = `${t}${t}})${n}${t}}${s}${n}}));`;
    magicString.prepend(intro +
        getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, namespaceToStringTag) +
        getHoistedExportsBlock(exports, t, snippets));
    magicString.append(`${outro}${n}${n}` +
        getSyntheticExportsBlock(exports, t, snippets) +
        getMissingExportsBlock(exports, t, snippets));
    return magicString.indent(`${t}${t}${t}`).append(wrapperEnd).prepend(wrapperStart);
}
function analyzeDependencies(dependencies, exports, t, { _, cnst, getObject, getPropertyAccess, n }) {
    const importBindings = [];
    const setters = [];
    let starExcludes = null;
    for (const { imports, reexports } of dependencies) {
        const setter = [];
        if (imports) {
            for (const specifier of imports) {
                importBindings.push(specifier.local);
                if (specifier.imported === '*') {
                    setter.push(`${specifier.local}${_}=${_}module;`);
                }
                else {
                    setter.push(`${specifier.local}${_}=${_}module${getPropertyAccess(specifier.imported)};`);
                }
            }
        }
        if (reexports) {
            const reexportedNames = [];
            let hasStarReexport = false;
            for (const { imported, reexported } of reexports) {
                if (reexported === '*') {
                    hasStarReexport = true;
                }
                else {
                    reexportedNames.push([
                        reexported,
                        imported === '*' ? 'module' : `module${getPropertyAccess(imported)}`
                    ]);
                }
            }
            if (reexportedNames.length > 1 || hasStarReexport) {
                const exportMapping = getObject(reexportedNames, { lineBreakIndent: null });
                if (hasStarReexport) {
                    if (!starExcludes) {
                        starExcludes = getStarExcludes({ dependencies, exports });
                    }
                    setter.push(`${cnst} setter${_}=${_}${exportMapping};`, `for${_}(${cnst} name in module)${_}{`, `${t}if${_}(!_starExcludes[name])${_}setter[name]${_}=${_}module[name];`, '}', 'exports(setter);');
                }
                else {
                    setter.push(`exports(${exportMapping});`);
                }
            }
            else {
                const [key, value] = reexportedNames[0];
                setter.push(`exports('${key}',${_}${value});`);
            }
        }
        setters.push(setter.join(`${n}${t}${t}${t}`));
    }
    return { importBindings, setters, starExcludes };
}
const getStarExcludes = ({ dependencies, exports }) => {
    const starExcludes = new Set(exports.map(expt => expt.exported));
    starExcludes.add('default');
    for (const { reexports } of dependencies) {
        if (reexports) {
            for (const reexport of reexports) {
                if (reexport.reexported !== '*')
                    starExcludes.add(reexport.reexported);
            }
        }
    }
    return starExcludes;
};
const getStarExcludesBlock = (starExcludes, t, { _, cnst, getObject, n }) => starExcludes
    ? `${n}${t}${cnst} _starExcludes${_}=${_}${getObject([...starExcludes].map(prop => [prop, '1']), { lineBreakIndent: { base: t, t } })};`
    : '';
const getImportBindingsBlock = (importBindings, t, { _, n }) => (importBindings.length ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');
const getHoistedExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter(expt => expt.hoisted).map(expt => ({ name: expt.exported, value: expt.local })), t, snippets);
function getExportsBlock(exports, t, { _, n }) {
    if (exports.length === 0) {
        return '';
    }
    if (exports.length === 1) {
        return `exports('${exports[0].name}',${_}${exports[0].value});${n}${n}`;
    }
    return (`exports({${n}` +
        exports.map(({ name, value }) => `${t}${name}:${_}${value}`).join(`,${n}`) +
        `${n}});${n}${n}`);
}
const getSyntheticExportsBlock = (exports, t, snippets) => getExportsBlock(exports
    .filter(expt => expt.expression)
    .map(expt => ({ name: expt.exported, value: expt.local })), t, snippets);
const getMissingExportsBlock = (exports, t, snippets) => getExportsBlock(exports
    .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)
    .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), t, snippets);

function globalProp(name, globalVar, getPropertyAccess) {
    if (!name)
        return 'null';
    return `${globalVar}${keypath(name, getPropertyAccess)}`;
}
function safeAccess(name, globalVar, { _, getPropertyAccess }) {
    let propertyPath = globalVar;
    return name
        .split('.')
        .map(part => (propertyPath += getPropertyAccess(part)))
        .join(`${_}&&${_}`);
}
function umd(magicString, { accessedGlobals, dependencies, exports, hasExports, id, indent: t, intro, namedExportsMode, outro, snippets, warn }, { amd, compact, esModule, extend, externalLiveBindings, freeze, interop, name, namespaceToStringTag, globals, noConflict, strict }) {
    const { _, cnst, getFunctionIntro, getNonArrowFunctionIntro, getPropertyAccess, n, s } = snippets;
    const factoryVar = compact ? 'f' : 'factory';
    const globalVar = compact ? 'g' : 'global';
    if (hasExports && !name) {
        return error({
            code: 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
            message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'
        });
    }
    warnOnBuiltins(warn, dependencies);
    const amdDeps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.id, amd.forceJsExtensionForImports)}'`);
    const cjsDeps = dependencies.map(m => `require('${m.id}')`);
    const trimmedImports = trimEmptyImports(dependencies);
    const globalDeps = trimmedImports.map(module => globalProp(module.globalName, globalVar, getPropertyAccess));
    const factoryParams = trimmedImports.map(m => m.name);
    if (namedExportsMode && (hasExports || noConflict)) {
        amdDeps.unshift(`'exports'`);
        cjsDeps.unshift(`exports`);
        globalDeps.unshift(assignToDeepVariable(name, globalVar, globals, `${extend ? `${globalProp(name, globalVar, getPropertyAccess)}${_}||${_}` : ''}{}`, snippets));
        factoryParams.unshift('exports');
    }
    const completeAmdId = getCompleteAmdId(amd, id);
    const amdParams = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +
        (amdDeps.length ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);
    const define = amd.define;
    const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;
    const useStrict = strict ? `${_}'use strict';${n}` : ``;
    let iifeExport;
    if (noConflict) {
        const noConflictExportsVar = compact ? 'e' : 'exports';
        let factory;
        if (!namedExportsMode && hasExports) {
            factory = `${cnst} ${noConflictExportsVar}${_}=${_}${assignToDeepVariable(name, globalVar, globals, `${factoryVar}(${globalDeps.join(`,${_}`)})`, snippets)};`;
        }
        else {
            const module = globalDeps.shift();
            factory =
                `${cnst} ${noConflictExportsVar}${_}=${_}${module};${n}` +
                    `${t}${t}${factoryVar}(${[noConflictExportsVar].concat(globalDeps).join(`,${_}`)});`;
        }
        iifeExport =
            `(${getFunctionIntro([], { isAsync: false, name: null })}{${n}` +
                `${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVar, snippets)};${n}` +
                `${t}${t}${factory}${n}` +
                `${t}${t}${noConflictExportsVar}.noConflict${_}=${_}${getFunctionIntro([], {
                    isAsync: false,
                    name: null
                })}{${_}` +
                `${globalProp(name, globalVar, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVar}${s}${_}};${n}` +
                `${t}})()`;
    }
    else {
        iifeExport = `${factoryVar}(${globalDeps.join(`,${_}`)})`;
        if (!namedExportsMode && hasExports) {
            iifeExport = assignToDeepVariable(name, globalVar, globals, iifeExport, snippets);
        }
    }
    const iifeNeedsGlobal = hasExports || (noConflict && namedExportsMode) || globalDeps.length > 0;
    const wrapperParams = [factoryVar];
    if (iifeNeedsGlobal) {
        wrapperParams.unshift(globalVar);
    }
    const globalArg = iifeNeedsGlobal ? `this,${_}` : '';
    const iifeStart = iifeNeedsGlobal
        ? `(${globalVar}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVar}${_}||${_}self,${_}`
        : '';
    const iifeEnd = iifeNeedsGlobal ? ')' : '';
    const cjsIntro = iifeNeedsGlobal
        ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +
            `${_}${cjsExport}${factoryVar}(${cjsDeps.join(`,${_}`)})${_}:${n}`
        : '';
    const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParams, { isAsync: false, name: null })}{${n}` +
        cjsIntro +
        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParams}${factoryVar})${_}:${n}` +
        `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +
        // factory function should be wrapped by parentheses to avoid lazy parsing,
        // cf. https://v8.dev/blog/preparser#pife
        `})(${globalArg}(${getNonArrowFunctionIntro(factoryParams, {
            isAsync: false,
            name: null
        })}{${useStrict}${n}`;
    const wrapperOutro = n + n + '}));';
    magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, namespaceToStringTag, accessedGlobals, t, snippets)}`);
    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings);
    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule, namespaceToStringTag, snippets);
    if (namespaceMarkers) {
        namespaceMarkers = n + n + namespaceMarkers;
    }
    magicString.append(`${exportBlock}${namespaceMarkers}${outro}`);
    return magicString.trim().indent(t).append(wrapperOutro).prepend(wrapperIntro);
}

const finalisers = { amd, cjs, es, iife, system, umd };

class Source {
    constructor(filename, content) {
        this.isOriginal = true;
        this.filename = filename;
        this.content = content;
    }
    traceSegment(line, column, name) {
        return { column, line, name, source: this };
    }
}
class Link {
    constructor(map, sources) {
        this.sources = sources;
        this.names = map.names;
        this.mappings = map.mappings;
    }
    traceMappings() {
        const sources = [];
        const sourceIndexMap = new Map();
        const sourcesContent = [];
        const names = [];
        const nameIndexMap = new Map();
        const mappings = [];
        for (const line of this.mappings) {
            const tracedLine = [];
            for (const segment of line) {
                if (segment.length === 1)
                    continue;
                const source = this.sources[segment[1]];
                if (!source)
                    continue;
                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');
                if (traced) {
                    const { column, line, name, source: { content, filename } } = traced;
                    let sourceIndex = sourceIndexMap.get(filename);
                    if (sourceIndex === undefined) {
                        sourceIndex = sources.length;
                        sources.push(filename);
                        sourceIndexMap.set(filename, sourceIndex);
                        sourcesContent[sourceIndex] = content;
                    }
                    else if (sourcesContent[sourceIndex] == null) {
                        sourcesContent[sourceIndex] = content;
                    }
                    else if (content != null && sourcesContent[sourceIndex] !== content) {
                        return error({
                            message: `Multiple conflicting contents for sourcemap source ${filename}`
                        });
                    }
                    const tracedSegment = [segment[0], sourceIndex, line, column];
                    if (name) {
                        let nameIndex = nameIndexMap.get(name);
                        if (nameIndex === undefined) {
                            nameIndex = names.length;
                            names.push(name);
                            nameIndexMap.set(name, nameIndex);
                        }
                        tracedSegment[4] = nameIndex;
                    }
                    tracedLine.push(tracedSegment);
                }
            }
            mappings.push(tracedLine);
        }
        return { mappings, names, sources, sourcesContent };
    }
    traceSegment(line, column, name) {
        const segments = this.mappings[line];
        if (!segments)
            return null;
        // binary search through segments for the given column
        let searchStart = 0;
        let searchEnd = segments.length - 1;
        while (searchStart <= searchEnd) {
            const m = (searchStart + searchEnd) >> 1;
            const segment = segments[m];
            // If a sourcemap does not have sufficient resolution to contain a
            // necessary mapping, e.g. because it only contains line information, we
            // use the best approximation we could find
            if (segment[0] === column || searchStart === searchEnd) {
                if (segment.length == 1)
                    return null;
                const source = this.sources[segment[1]];
                if (!source)
                    return null;
                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);
            }
            if (segment[0] > column) {
                searchEnd = m - 1;
            }
            else {
                searchStart = m + 1;
            }
        }
        return null;
    }
}
function getLinkMap(warn) {
    return function linkMap(source, map) {
        if (map.mappings) {
            return new Link(map, [source]);
        }
        warn({
            code: 'SOURCEMAP_BROKEN',
            message: `Sourcemap is likely to be incorrect: a plugin (${map.plugin}) was used to transform ` +
                "files, but didn't generate a sourcemap for the transformation. Consult the plugin " +
                'documentation for help',
            plugin: map.plugin,
            url: `https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect`
        });
        return new Link({
            mappings: [],
            names: []
        }, [source]);
    };
}
function getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {
    let source;
    if (!originalSourcemap) {
        source = new Source(id, originalCode);
    }
    else {
        const sources = originalSourcemap.sources;
        const sourcesContent = originalSourcemap.sourcesContent || [];
        const directory = dirname(id) || '.';
        const sourceRoot = originalSourcemap.sourceRoot || '.';
        const baseSources = sources.map((source, i) => new Source(resolve(directory, sourceRoot, source), sourcesContent[i]));
        source = new Link(originalSourcemap, baseSources);
    }
    return sourcemapChain.reduce(linkMap, source);
}
function collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, warn) {
    const linkMap = getLinkMap(warn);
    const moduleSources = modules
        .filter(module => !module.excludeFromSourcemap)
        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));
    const link = new Link(map, moduleSources);
    const source = bundleSourcemapChain.reduce(linkMap, link);
    let { sources, sourcesContent, names, mappings } = source.traceMappings();
    if (file) {
        const directory = dirname(file);
        sources = sources.map((source) => relative$1(directory, source));
        file = basename(file);
    }
    sourcesContent = (excludeContent ? null : sourcesContent);
    return new SourceMap({ file, mappings, names, sources, sourcesContent });
}
function collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, warn) {
    if (!sourcemapChain.length) {
        return originalSourcemap;
    }
    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(warn));
    const map = source.traceMappings();
    return { version: 3, ...map };
}

const createHash = () => createHash$1('sha256');

const DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {
    amd: deconflictImportsOther,
    cjs: deconflictImportsOther,
    es: deconflictImportsEsmOrSystem,
    iife: deconflictImportsOther,
    system: deconflictImportsEsmOrSystem,
    umd: deconflictImportsOther
};
function deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {
    const reversedModules = modules.slice().reverse();
    for (const module of reversedModules) {
        module.scope.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);
    }
    deconflictTopLevelVariables(usedNames, reversedModules, includedNamespaces);
    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, syntheticExports);
    for (const module of reversedModules) {
        module.scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);
    }
}
function deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, syntheticExports) {
    // This is needed for namespace reexports
    for (const dependency of dependenciesToBeDeconflicted.dependencies) {
        if (preserveModules || dependency instanceof ExternalModule) {
            dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames);
        }
    }
    for (const variable of imports) {
        const module = variable.module;
        const name = variable.name;
        if (variable.isNamespace && (preserveModules || module instanceof ExternalModule)) {
            variable.setRenderNames(null, (module instanceof ExternalModule ? module : chunkByModule.get(module)).variableName);
        }
        else if (module instanceof ExternalModule && name === 'default') {
            variable.setRenderNames(null, getSafeName([...module.exportedVariables].some(([exportedVariable, exportedName]) => exportedName === '*' && exportedVariable.included)
                ? module.suggestedVariableName + '__default'
                : module.suggestedVariableName, usedNames));
        }
        else {
            variable.setRenderNames(null, getSafeName(name, usedNames));
        }
    }
    for (const variable of syntheticExports) {
        variable.setRenderNames(null, getSafeName(variable.name, usedNames));
    }
}
function deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule) {
    for (const chunkOrExternalModule of dependencies) {
        chunkOrExternalModule.variableName = getSafeName(chunkOrExternalModule.suggestedVariableName, usedNames);
    }
    for (const externalModuleOrChunk of deconflictedNamespace) {
        externalModuleOrChunk.namespaceVariableName = getSafeName(`${externalModuleOrChunk.suggestedVariableName}__namespace`, usedNames);
    }
    for (const externalModule of deconflictedDefault) {
        if (deconflictedNamespace.has(externalModule) &&
            canDefaultBeTakenFromNamespace(String(interop(externalModule.id)), externalLiveBindings)) {
            externalModule.defaultVariableName = externalModule.namespaceVariableName;
        }
        else {
            externalModule.defaultVariableName = getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames);
        }
    }
    for (const variable of imports) {
        const module = variable.module;
        if (module instanceof ExternalModule) {
            const name = variable.name;
            if (name === 'default') {
                const moduleInterop = String(interop(module.id));
                const variableName = defaultInteropHelpersByInteropType[moduleInterop]
                    ? module.defaultVariableName
                    : module.variableName;
                if (isDefaultAProperty(moduleInterop, externalLiveBindings)) {
                    variable.setRenderNames(variableName, 'default');
                }
                else {
                    variable.setRenderNames(null, variableName);
                }
            }
            else if (name === '*') {
                variable.setRenderNames(null, namespaceInteropHelpersByInteropType[String(interop(module.id))]
                    ? module.namespaceVariableName
                    : module.variableName);
            }
            else {
                // if the second parameter is `null`, it uses its "name" for the property name
                variable.setRenderNames(module.variableName, null);
            }
        }
        else {
            const chunk = chunkByModule.get(module);
            if (preserveModules && variable.isNamespace) {
                variable.setRenderNames(null, chunk.exportMode === 'default' ? chunk.namespaceVariableName : chunk.variableName);
            }
            else if (chunk.exportMode === 'default') {
                variable.setRenderNames(null, chunk.variableName);
            }
            else {
                variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));
            }
        }
    }
}
function deconflictTopLevelVariables(usedNames, modules, includedNamespaces) {
    for (const module of modules) {
        for (const variable of module.scope.variables.values()) {
            if (variable.included &&
                // this will only happen for exports in some formats
                !(variable.renderBaseName ||
                    (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {
                variable.setRenderNames(null, getSafeName(variable.name, usedNames));
            }
        }
        if (includedNamespaces.has(module)) {
            const namespace = module.namespace;
            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames));
        }
    }
}

const needsEscapeRegEx = /[\\'\r\n\u2028\u2029]/;
const quoteNewlineRegEx = /(['\r\n\u2028\u2029])/g;
const backSlashRegEx = /\\/g;
function escapeId(id) {
    if (!id.match(needsEscapeRegEx))
        return id;
    return id.replace(backSlashRegEx, '\\\\').replace(quoteNewlineRegEx, '\\$1');
}

function assignExportsToMangledNames(exports, exportsByName, exportNamesByVariable) {
    let nameIndex = 0;
    for (const variable of exports) {
        let [exportName] = variable.name;
        if (exportsByName.has(exportName)) {
            do {
                exportName = toBase64(++nameIndex);
                // skip past leading number identifiers
                if (exportName.charCodeAt(0) === 49 /* '1' */) {
                    nameIndex += 9 * 64 ** (exportName.length - 1);
                    exportName = toBase64(nameIndex);
                }
            } while (RESERVED_NAMES$1.has(exportName) || exportsByName.has(exportName));
        }
        exportsByName.set(exportName, variable);
        exportNamesByVariable.set(variable, [exportName]);
    }
}
function assignExportsToNames(exports, exportsByName, exportNamesByVariable) {
    for (const variable of exports) {
        let nameIndex = 0;
        let exportName = variable.name;
        while (exportsByName.has(exportName)) {
            exportName = variable.name + '$' + ++nameIndex;
        }
        exportsByName.set(exportName, variable);
        exportNamesByVariable.set(variable, [exportName]);
    }
}

function getExportMode(chunk, { exports: exportMode, name, format }, unsetOptions, facadeModuleId, warn) {
    const exportKeys = chunk.getExportNames();
    if (exportMode === 'default') {
        if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {
            return error(errIncompatibleExportOptionValue('default', exportKeys, facadeModuleId));
        }
    }
    else if (exportMode === 'none' && exportKeys.length) {
        return error(errIncompatibleExportOptionValue('none', exportKeys, facadeModuleId));
    }
    if (exportMode === 'auto') {
        if (exportKeys.length === 0) {
            exportMode = 'none';
        }
        else if (exportKeys.length === 1 && exportKeys[0] === 'default') {
            if (format === 'cjs' && unsetOptions.has('exports')) {
                warn(errPreferNamedExports(facadeModuleId));
            }
            exportMode = 'default';
        }
        else {
            if (format !== 'es' && format !== 'system' && exportKeys.includes('default')) {
                warn(errMixedExport(facadeModuleId, name));
            }
            exportMode = 'named';
        }
    }
    return exportMode;
}

function guessIndentString(code) {
    const lines = code.split('\n');
    const tabbed = lines.filter(line => /^\t+/.test(line));
    const spaced = lines.filter(line => /^ {2,}/.test(line));
    if (tabbed.length === 0 && spaced.length === 0) {
        return null;
    }
    // More lines tabbed than spaced? Assume tabs, and
    // default to tabs in the case of a tie (or nothing
    // to go on)
    if (tabbed.length >= spaced.length) {
        return '\t';
    }
    // Otherwise, we need to guess the multiple
    const min = spaced.reduce((previous, current) => {
        const numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(' ');
}
function getIndentString(modules, options) {
    if (options.indent !== true)
        return options.indent;
    for (const module of modules) {
        const indent = guessIndentString(module.originalCode);
        if (indent !== null)
            return indent;
    }
    return '\t';
}

function getStaticDependencies(chunk, orderedModules, chunkByModule) {
    const staticDependencyBlocks = [];
    const handledDependencies = new Set();
    for (let modulePos = orderedModules.length - 1; modulePos >= 0; modulePos--) {
        const module = orderedModules[modulePos];
        if (!handledDependencies.has(module)) {
            const staticDependencies = [];
            addStaticDependencies(module, staticDependencies, handledDependencies, chunk, chunkByModule);
            staticDependencyBlocks.unshift(staticDependencies);
        }
    }
    const dependencies = new Set();
    for (const block of staticDependencyBlocks) {
        for (const dependency of block) {
            dependencies.add(dependency);
        }
    }
    return dependencies;
}
function addStaticDependencies(module, staticDependencies, handledModules, chunk, chunkByModule) {
    const dependencies = module.getDependenciesToBeIncluded();
    for (const dependency of dependencies) {
        if (dependency instanceof ExternalModule) {
            staticDependencies.push(dependency);
            continue;
        }
        const dependencyChunk = chunkByModule.get(dependency);
        if (dependencyChunk !== chunk) {
            staticDependencies.push(dependencyChunk);
            continue;
        }
        if (!handledModules.has(dependency)) {
            handledModules.add(dependency);
            addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule);
        }
    }
}

function decodedSourcemap(map) {
    if (!map)
        return null;
    if (typeof map === 'string') {
        map = JSON.parse(map);
    }
    if (map.mappings === '') {
        return {
            mappings: [],
            names: [],
            sources: [],
            version: 3
        };
    }
    const mappings = typeof map.mappings === 'string' ? decode(map.mappings) : map.mappings;
    return { ...map, mappings };
}

function renderChunk({ code, options, outputPluginDriver, renderChunk, sourcemapChain }) {
    const renderChunkReducer = (code, result, plugin) => {
        if (result == null)
            return code;
        if (typeof result === 'string')
            result = {
                code: result,
                map: undefined
            };
        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning
        if (result.map !== null) {
            const map = decodedSourcemap(result.map);
            sourcemapChain.push(map || { missing: true, plugin: plugin.name });
        }
        return result.code;
    };
    return outputPluginDriver.hookReduceArg0('renderChunk', [code, renderChunk, options], renderChunkReducer);
}

const lowercaseBundleKeys = Symbol('bundleKeys');
const FILE_PLACEHOLDER = {
    type: 'placeholder'
};
const getOutputBundle = (outputBundleBase) => {
    const reservedLowercaseBundleKeys = new Set();
    return new Proxy(outputBundleBase, {
        deleteProperty(target, key) {
            if (typeof key === 'string') {
                reservedLowercaseBundleKeys.delete(key.toLowerCase());
            }
            return Reflect.deleteProperty(target, key);
        },
        get(target, key) {
            if (key === lowercaseBundleKeys) {
                return reservedLowercaseBundleKeys;
            }
            return Reflect.get(target, key);
        },
        set(target, key, value) {
            if (typeof key === 'string') {
                reservedLowercaseBundleKeys.add(key.toLowerCase());
            }
            return Reflect.set(target, key, value);
        }
    });
};

function renderNamePattern(pattern, patternName, replacements) {
    if (isPathFragment(pattern))
        return error(errFailedValidation(`Invalid pattern "${pattern}" for "${patternName}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`));
    return pattern.replace(/\[(\w+)\]/g, (_match, type) => {
        if (!replacements.hasOwnProperty(type)) {
            return error(errFailedValidation(`"[${type}]" is not a valid placeholder in "${patternName}" pattern.`));
        }
        const replacement = replacements[type]();
        if (isPathFragment(replacement))
            return error(errFailedValidation(`Invalid substitution "${replacement}" for placeholder "[${type}]" in "${patternName}" pattern, can be neither absolute nor relative path.`));
        return replacement;
    });
}
function makeUnique(name, { [lowercaseBundleKeys]: reservedLowercaseBundleKeys }) {
    if (!reservedLowercaseBundleKeys.has(name.toLowerCase()))
        return name;
    const ext = extname(name);
    name = name.substring(0, name.length - ext.length);
    let uniqueName, uniqueIndex = 1;
    while (reservedLowercaseBundleKeys.has((uniqueName = name + ++uniqueIndex + ext).toLowerCase()))
        ;
    return uniqueName;
}

const NON_ASSET_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
function getGlobalName(module, globals, hasExports, warn) {
    const globalName = typeof globals === 'function' ? globals(module.id) : globals[module.id];
    if (globalName) {
        return globalName;
    }
    if (hasExports) {
        warn({
            code: 'MISSING_GLOBAL_NAME',
            guess: module.variableName,
            message: `No name was provided for external module '${module.id}' in output.globals  guessing '${module.variableName}'`,
            source: module.id
        });
        return module.variableName;
    }
}
class Chunk {
    constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias) {
        this.orderedModules = orderedModules;
        this.inputOptions = inputOptions;
        this.outputOptions = outputOptions;
        this.unsetOptions = unsetOptions;
        this.pluginDriver = pluginDriver;
        this.modulesById = modulesById;
        this.chunkByModule = chunkByModule;
        this.facadeChunkByModule = facadeChunkByModule;
        this.includedNamespaces = includedNamespaces;
        this.manualChunkAlias = manualChunkAlias;
        this.entryModules = [];
        this.exportMode = 'named';
        this.facadeModule = null;
        this.id = null;
        this.namespaceVariableName = '';
        this.needsExportsShim = false;
        this.variableName = '';
        this.accessedGlobalsByScope = new Map();
        this.dependencies = new Set();
        this.dynamicDependencies = new Set();
        this.dynamicEntryModules = [];
        this.dynamicName = null;
        this.exportNamesByVariable = new Map();
        this.exports = new Set();
        this.exportsByName = new Map();
        this.fileName = null;
        this.implicitEntryModules = [];
        this.implicitlyLoadedBefore = new Set();
        this.imports = new Set();
        this.includedReexportsByModule = new Map();
        this.indentString = undefined;
        // This may only be updated in the constructor
        this.isEmpty = true;
        this.name = null;
        this.renderedDependencies = null;
        this.renderedExports = null;
        this.renderedHash = undefined;
        this.renderedModuleSources = new Map();
        this.renderedModules = Object.create(null);
        this.renderedSource = null;
        this.sortedExportNames = null;
        this.strictFacade = false;
        this.usedModules = undefined;
        this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;
        const chunkModules = new Set(orderedModules);
        for (const module of orderedModules) {
            if (module.namespace.included) {
                includedNamespaces.add(module);
            }
            if (this.isEmpty && module.isIncluded()) {
                this.isEmpty = false;
            }
            if (module.info.isEntry || outputOptions.preserveModules) {
                this.entryModules.push(module);
            }
            for (const importer of module.includedDynamicImporters) {
                if (!chunkModules.has(importer)) {
                    this.dynamicEntryModules.push(module);
                    // Modules with synthetic exports need an artificial namespace for dynamic imports
                    if (module.info.syntheticNamedExports && !outputOptions.preserveModules) {
                        includedNamespaces.add(module);
                        this.exports.add(module.namespace);
                    }
                }
            }
            if (module.implicitlyLoadedAfter.size > 0) {
                this.implicitEntryModules.push(module);
            }
        }
        this.suggestedVariableName = makeLegal(this.generateVariableName());
    }
    static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName) {
        const chunk = new Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, facadeChunkByModule, includedNamespaces, null);
        chunk.assignFacadeName(facadeName, facadedModule);
        if (!facadeChunkByModule.has(facadedModule)) {
            facadeChunkByModule.set(facadedModule, chunk);
        }
        for (const dependency of facadedModule.getDependenciesToBeIncluded()) {
            chunk.dependencies.add(dependency instanceof Module ? chunkByModule.get(dependency) : dependency);
        }
        if (!chunk.dependencies.has(chunkByModule.get(facadedModule)) &&
            facadedModule.info.moduleSideEffects &&
            facadedModule.hasEffects()) {
            chunk.dependencies.add(chunkByModule.get(facadedModule));
        }
        chunk.ensureReexportsAreAvailableForModule(facadedModule);
        chunk.facadeModule = facadedModule;
        chunk.strictFacade = true;
        return chunk;
    }
    canModuleBeFacade(module, exposedVariables) {
        const moduleExportNamesByVariable = module.getExportNamesByVariable();
        for (const exposedVariable of this.exports) {
            if (!moduleExportNamesByVariable.has(exposedVariable)) {
                if (moduleExportNamesByVariable.size === 0 &&
                    module.isUserDefinedEntryPoint &&
                    module.preserveSignature === 'strict' &&
                    this.unsetOptions.has('preserveEntrySignatures')) {
                    this.inputOptions.onwarn({
                        code: 'EMPTY_FACADE',
                        id: module.id,
                        message: `To preserve the export signature of the entry module "${relativeId(module.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`,
                        url: 'https://rollupjs.org/guide/en/#preserveentrysignatures'
                    });
                }
                return false;
            }
        }
        for (const exposedVariable of exposedVariables) {
            if (!(moduleExportNamesByVariable.has(exposedVariable) || exposedVariable.module === module)) {
                return false;
            }
        }
        return true;
    }
    generateExports() {
        this.sortedExportNames = null;
        const remainingExports = new Set(this.exports);
        if (this.facadeModule !== null &&
            (this.facadeModule.preserveSignature !== false || this.strictFacade)) {
            const exportNamesByVariable = this.facadeModule.getExportNamesByVariable();
            for (const [variable, exportNames] of exportNamesByVariable) {
                this.exportNamesByVariable.set(variable, [...exportNames]);
                for (const exportName of exportNames) {
                    this.exportsByName.set(exportName, variable);
                }
                remainingExports.delete(variable);
            }
        }
        if (this.outputOptions.minifyInternalExports) {
            assignExportsToMangledNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
        }
        else {
            assignExportsToNames(remainingExports, this.exportsByName, this.exportNamesByVariable);
        }
        if (this.outputOptions.preserveModules || (this.facadeModule && this.facadeModule.info.isEntry))
            this.exportMode = getExportMode(this, this.outputOptions, this.unsetOptions, this.facadeModule.id, this.inputOptions.onwarn);
    }
    generateFacades() {
        var _a;
        const facades = [];
        const entryModules = new Set([...this.entryModules, ...this.implicitEntryModules]);
        const exposedVariables = new Set(this.dynamicEntryModules.map(({ namespace }) => namespace));
        for (const module of entryModules) {
            if (module.preserveSignature) {
                for (const exportedVariable of module.getExportNamesByVariable().keys()) {
                    exposedVariables.add(exportedVariable);
                }
            }
        }
        for (const module of entryModules) {
            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), 
            // mapping must run after Set 'name' dedupe
            name => ({
                name
            }));
            if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {
                requiredFacades.push({});
            }
            requiredFacades.push(...Array.from(module.chunkFileNames, fileName => ({ fileName })));
            if (requiredFacades.length === 0) {
                requiredFacades.push({});
            }
            if (!this.facadeModule) {
                const needsStrictFacade = module.preserveSignature === 'strict' ||
                    (module.preserveSignature === 'exports-only' &&
                        module.getExportNamesByVariable().size !== 0);
                if (!needsStrictFacade ||
                    this.outputOptions.preserveModules ||
                    this.canModuleBeFacade(module, exposedVariables)) {
                    this.facadeModule = module;
                    this.facadeChunkByModule.set(module, this);
                    if (module.preserveSignature) {
                        this.strictFacade = needsStrictFacade;
                    }
                    this.assignFacadeName(requiredFacades.shift(), module);
                }
            }
            for (const facadeName of requiredFacades) {
                facades.push(Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName));
            }
        }
        for (const module of this.dynamicEntryModules) {
            if (module.info.syntheticNamedExports)
                continue;
            if (!this.facadeModule && this.canModuleBeFacade(module, exposedVariables)) {
                this.facadeModule = module;
                this.facadeChunkByModule.set(module, this);
                this.strictFacade = true;
                this.dynamicName = getChunkNameFromModule(module);
            }
            else if (this.facadeModule === module &&
                !this.strictFacade &&
                this.canModuleBeFacade(module, exposedVariables)) {
                this.strictFacade = true;
            }
            else if (!((_a = this.facadeChunkByModule.get(module)) === null || _a === void 0 ? void 0 : _a.strictFacade)) {
                this.includedNamespaces.add(module);
                this.exports.add(module.namespace);
            }
        }
        if (!this.outputOptions.preserveModules) {
            this.addNecessaryImportsForFacades();
        }
        return facades;
    }
    generateId(addons, options, bundle, includeHash) {
        if (this.fileName !== null) {
            return this.fileName;
        }
        const [pattern, patternName] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint
            ? [options.entryFileNames, 'output.entryFileNames']
            : [options.chunkFileNames, 'output.chunkFileNames'];
        return makeUnique(renderNamePattern(typeof pattern === 'function' ? pattern(this.getChunkInfo()) : pattern, patternName, {
            format: () => options.format,
            hash: () => includeHash
                ? this.computeContentHashWithDependencies(addons, options, bundle)
                : '[hash]',
            name: () => this.getChunkName()
        }), bundle);
    }
    generateIdPreserveModules(preserveModulesRelativeDir, options, bundle, unsetOptions) {
        const [{ id }] = this.orderedModules;
        const sanitizedId = this.outputOptions.sanitizeFileName(id.split(QUERY_HASH_REGEX, 1)[0]);
        let path;
        const patternOpt = unsetOptions.has('entryFileNames')
            ? '[name][assetExtname].js'
            : options.entryFileNames;
        const pattern = typeof patternOpt === 'function' ? patternOpt(this.getChunkInfo()) : patternOpt;
        if (isAbsolute(sanitizedId)) {
            const currentDir = dirname(sanitizedId);
            const extension = extname(sanitizedId);
            const fileName = renderNamePattern(pattern, 'output.entryFileNames', {
                assetExtname: () => (NON_ASSET_EXTENSIONS.includes(extension) ? '' : extension),
                ext: () => extension.substring(1),
                extname: () => extension,
                format: () => options.format,
                name: () => this.getChunkName()
            });
            const currentPath = `${currentDir}/${fileName}`;
            const { preserveModulesRoot } = options;
            if (preserveModulesRoot && resolve(currentPath).startsWith(preserveModulesRoot)) {
                path = currentPath.slice(preserveModulesRoot.length).replace(/^[\\/]/, '');
            }
            else {
                path = relative(preserveModulesRelativeDir, currentPath);
            }
        }
        else {
            const extension = extname(sanitizedId);
            const fileName = renderNamePattern(pattern, 'output.entryFileNames', {
                assetExtname: () => (NON_ASSET_EXTENSIONS.includes(extension) ? '' : extension),
                ext: () => extension.substring(1),
                extname: () => extension,
                format: () => options.format,
                name: () => getAliasName(sanitizedId)
            });
            path = `_virtual/${fileName}`;
        }
        return makeUnique(normalize(path), bundle);
    }
    getChunkInfo() {
        const facadeModule = this.facadeModule;
        const getChunkName = this.getChunkName.bind(this);
        return {
            exports: this.getExportNames(),
            facadeModuleId: facadeModule && facadeModule.id,
            isDynamicEntry: this.dynamicEntryModules.length > 0,
            isEntry: facadeModule !== null && facadeModule.info.isEntry,
            isImplicitEntry: this.implicitEntryModules.length > 0,
            modules: this.renderedModules,
            get name() {
                return getChunkName();
            },
            type: 'chunk'
        };
    }
    getChunkInfoWithFileNames() {
        return Object.assign(this.getChunkInfo(), {
            code: undefined,
            dynamicImports: Array.from(this.dynamicDependencies, getId),
            fileName: this.id,
            implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, getId),
            importedBindings: this.getImportedBindingsPerDependency(),
            imports: Array.from(this.dependencies, getId),
            map: undefined,
            referencedFiles: this.getReferencedFiles()
        });
    }
    getChunkName() {
        var _a;
        return ((_a = this.name) !== null && _a !== void 0 ? _a : (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName())));
    }
    getExportNames() {
        var _a;
        return ((_a = this.sortedExportNames) !== null && _a !== void 0 ? _a : (this.sortedExportNames = Array.from(this.exportsByName.keys()).sort()));
    }
    getRenderedHash() {
        if (this.renderedHash)
            return this.renderedHash;
        const hash = createHash();
        const hashAugmentation = this.pluginDriver.hookReduceValueSync('augmentChunkHash', '', [this.getChunkInfo()], (augmentation, pluginHash) => {
            if (pluginHash) {
                augmentation += pluginHash;
            }
            return augmentation;
        });
        hash.update(hashAugmentation);
        hash.update(this.renderedSource.toString());
        hash.update(this.getExportNames()
            .map(exportName => {
            const variable = this.exportsByName.get(exportName);
            return `${relativeId(variable.module.id).replace(/\\/g, '/')}:${variable.name}:${exportName}`;
        })
            .join(','));
        return (this.renderedHash = hash.digest('hex'));
    }
    getVariableExportName(variable) {
        if (this.outputOptions.preserveModules && variable instanceof NamespaceVariable) {
            return '*';
        }
        return this.exportNamesByVariable.get(variable)[0];
    }
    link() {
        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule);
        for (const module of this.orderedModules) {
            this.addDependenciesToChunk(module.dynamicDependencies, this.dynamicDependencies);
            this.addDependenciesToChunk(module.implicitlyLoadedBefore, this.implicitlyLoadedBefore);
            this.setUpChunkImportsAndExportsForModule(module);
        }
    }
    // prerender allows chunk hashes and names to be generated before finalizing
    preRender(options, inputBase, snippets) {
        const { _, getPropertyAccess, n } = snippets;
        const magicString = new Bundle$1({ separator: `${n}${n}` });
        this.usedModules = [];
        this.indentString = getIndentString(this.orderedModules, options);
        const renderOptions = {
            dynamicImportFunction: options.dynamicImportFunction,
            exportNamesByVariable: this.exportNamesByVariable,
            format: options.format,
            freeze: options.freeze,
            indent: this.indentString,
            namespaceToStringTag: options.namespaceToStringTag,
            outputPluginDriver: this.pluginDriver,
            snippets
        };
        // for static and dynamic entry points, inline the execution list to avoid loading latency
        if (options.hoistTransitiveImports &&
            !this.outputOptions.preserveModules &&
            this.facadeModule !== null) {
            for (const dep of this.dependencies) {
                if (dep instanceof Chunk)
                    this.inlineChunkDependencies(dep);
            }
        }
        this.prepareModulesForRendering(snippets);
        this.setIdentifierRenderResolutions(options);
        let hoistedSource = '';
        const renderedModules = this.renderedModules;
        for (const module of this.orderedModules) {
            let renderedLength = 0;
            if (module.isIncluded() || this.includedNamespaces.has(module)) {
                const source = module.render(renderOptions).trim();
                renderedLength = source.length();
                if (renderedLength) {
                    if (options.compact && source.lastLine().includes('//'))
                        source.append('\n');
                    this.renderedModuleSources.set(module, source);
                    magicString.addSource(source);
                    this.usedModules.push(module);
                }
                const namespace = module.namespace;
                if (this.includedNamespaces.has(module) && !this.outputOptions.preserveModules) {
                    const rendered = namespace.renderBlock(renderOptions);
                    if (namespace.renderFirst())
                        hoistedSource += n + rendered;
                    else
                        magicString.addSource(new MagicString(rendered));
                }
            }
            const { renderedExports, removedExports } = module.getRenderedExports();
            const { renderedModuleSources } = this;
            renderedModules[module.id] = {
                get code() {
                    var _a, _b;
                    return (_b = (_a = renderedModuleSources.get(module)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
                },
                originalLength: module.originalCode.length,
                removedExports,
                renderedExports,
                renderedLength
            };
        }
        if (hoistedSource)
            magicString.prepend(hoistedSource + n + n);
        if (this.needsExportsShim) {
            magicString.prepend(`${n}${snippets.cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);
        }
        if (options.compact) {
            this.renderedSource = magicString;
        }
        else {
            this.renderedSource = magicString.trim();
        }
        this.renderedHash = undefined;
        if (this.isEmpty && this.getExportNames().length === 0 && this.dependencies.size === 0) {
            const chunkName = this.getChunkName();
            this.inputOptions.onwarn({
                chunkName,
                code: 'EMPTY_BUNDLE',
                message: `Generated an empty chunk: "${chunkName}"`
            });
        }
        this.setExternalRenderPaths(options, inputBase);
        this.renderedDependencies = this.getChunkDependencyDeclarations(options, getPropertyAccess);
        this.renderedExports =
            this.exportMode === 'none'
                ? []
                : this.getChunkExportDeclarations(options.format, getPropertyAccess);
    }
    async render(options, addons, outputChunk, snippets) {
        timeStart('render format', 2);
        const format = options.format;
        const finalise = finalisers[format];
        if (options.dynamicImportFunction && format !== 'es') {
            this.inputOptions.onwarn(errInvalidOption('output.dynamicImportFunction', 'outputdynamicImportFunction', 'this option is ignored for formats other than "es"'));
        }
        // populate ids in the rendered declarations only here
        // as chunk ids known only after prerender
        for (const dependency of this.dependencies) {
            const renderedDependency = this.renderedDependencies.get(dependency);
            if (dependency instanceof ExternalModule) {
                const originalId = dependency.renderPath;
                renderedDependency.id = escapeId(dependency.renormalizeRenderPath
                    ? getImportPath(this.id, originalId, false, false)
                    : originalId);
            }
            else {
                renderedDependency.namedExportsMode = dependency.exportMode !== 'default';
                renderedDependency.id = escapeId(getImportPath(this.id, dependency.id, false, true));
            }
        }
        this.finaliseDynamicImports(options, snippets);
        this.finaliseImportMetas(format, snippets);
        const hasExports = this.renderedExports.length !== 0 ||
            [...this.renderedDependencies.values()].some(dep => (dep.reexports && dep.reexports.length !== 0));
        let topLevelAwaitModule = null;
        const accessedGlobals = new Set();
        for (const module of this.orderedModules) {
            if (module.usesTopLevelAwait) {
                topLevelAwaitModule = module.id;
            }
            const accessedGlobalVariables = this.accessedGlobalsByScope.get(module.scope);
            if (accessedGlobalVariables) {
                for (const name of accessedGlobalVariables) {
                    accessedGlobals.add(name);
                }
            }
        }
        if (topLevelAwaitModule !== null && format !== 'es' && format !== 'system') {
            return error({
                code: 'INVALID_TLA_FORMAT',
                id: topLevelAwaitModule,
                message: `Module format ${format} does not support top-level await. Use the "es" or "system" output formats rather.`
            });
        }
        /* istanbul ignore next */
        if (!this.id) {
            throw new Error('Internal Error: expecting chunk id');
        }
        const magicString = finalise(this.renderedSource, {
            accessedGlobals,
            dependencies: [...this.renderedDependencies.values()],
            exports: this.renderedExports,
            hasExports,
            id: this.id,
            indent: this.indentString,
            intro: addons.intro,
            isEntryFacade: this.outputOptions.preserveModules ||
                (this.facadeModule !== null && this.facadeModule.info.isEntry),
            isModuleFacade: this.facadeModule !== null,
            namedExportsMode: this.exportMode !== 'default',
            outro: addons.outro,
            snippets,
            usesTopLevelAwait: topLevelAwaitModule !== null,
            warn: this.inputOptions.onwarn
        }, options);
        if (addons.banner)
            magicString.prepend(addons.banner);
        if (addons.footer)
            magicString.append(addons.footer);
        const prevCode = magicString.toString();
        timeEnd('render format', 2);
        let map = null;
        const chunkSourcemapChain = [];
        let code = await renderChunk({
            code: prevCode,
            options,
            outputPluginDriver: this.pluginDriver,
            renderChunk: outputChunk,
            sourcemapChain: chunkSourcemapChain
        });
        if (options.sourcemap) {
            timeStart('sourcemap', 2);
            let file;
            if (options.file)
                file = resolve(options.sourcemapFile || options.file);
            else if (options.dir)
                file = resolve(options.dir, this.id);
            else
                file = resolve(this.id);
            const decodedMap = magicString.generateDecodedMap({});
            map = collapseSourcemaps(file, decodedMap, this.usedModules, chunkSourcemapChain, options.sourcemapExcludeSources, this.inputOptions.onwarn);
            map.sources = map.sources
                .map(sourcePath => {
                const { sourcemapPathTransform } = options;
                if (sourcemapPathTransform) {
                    const newSourcePath = sourcemapPathTransform(sourcePath, `${file}.map`);
                    if (typeof newSourcePath !== 'string') {
                        error(errFailedValidation(`sourcemapPathTransform function must return a string.`));
                    }
                    return newSourcePath;
                }
                return sourcePath;
            })
                .map(normalize);
            timeEnd('sourcemap', 2);
        }
        if (!options.compact && code[code.length - 1] !== '\n')
            code += '\n';
        return { code, map };
    }
    addDependenciesToChunk(moduleDependencies, chunkDependencies) {
        for (const module of moduleDependencies) {
            if (module instanceof Module) {
                const chunk = this.chunkByModule.get(module);
                if (chunk && chunk !== this) {
                    chunkDependencies.add(chunk);
                }
            }
            else {
                chunkDependencies.add(module);
            }
        }
    }
    addNecessaryImportsForFacades() {
        for (const [module, variables] of this.includedReexportsByModule) {
            if (this.includedNamespaces.has(module)) {
                for (const variable of variables) {
                    this.imports.add(variable);
                }
            }
        }
    }
    assignFacadeName({ fileName, name }, facadedModule) {
        if (fileName) {
            this.fileName = fileName;
        }
        else {
            this.name = this.outputOptions.sanitizeFileName(name || getChunkNameFromModule(facadedModule));
        }
    }
    checkCircularDependencyImport(variable, importingModule) {
        const variableModule = variable.module;
        if (variableModule instanceof Module) {
            const exportChunk = this.chunkByModule.get(variableModule);
            let alternativeReexportModule;
            do {
                alternativeReexportModule = importingModule.alternativeReexportModules.get(variable);
                if (alternativeReexportModule) {
                    const exportingChunk = this.chunkByModule.get(alternativeReexportModule);
                    if (exportingChunk && exportingChunk !== exportChunk) {
                        this.inputOptions.onwarn(errCyclicCrossChunkReexport(variableModule.getExportNamesByVariable().get(variable)[0], variableModule.id, alternativeReexportModule.id, importingModule.id));
                    }
                    importingModule = alternativeReexportModule;
                }
            } while (alternativeReexportModule);
        }
    }
    computeContentHashWithDependencies(addons, options, bundle) {
        const hash = createHash();
        hash.update([addons.intro, addons.outro, addons.banner, addons.footer].join(':'));
        hash.update(options.format);
        const dependenciesForHashing = new Set([this]);
        for (const current of dependenciesForHashing) {
            if (current instanceof ExternalModule) {
                hash.update(`:${current.renderPath}`);
            }
            else {
                hash.update(current.getRenderedHash());
                hash.update(current.generateId(addons, options, bundle, false));
            }
            if (current instanceof ExternalModule)
                continue;
            for (const dependency of [...current.dependencies, ...current.dynamicDependencies]) {
                dependenciesForHashing.add(dependency);
            }
        }
        return hash.digest('hex').substr(0, 8);
    }
    ensureReexportsAreAvailableForModule(module) {
        const includedReexports = [];
        const map = module.getExportNamesByVariable();
        for (const exportedVariable of map.keys()) {
            const isSynthetic = exportedVariable instanceof SyntheticNamedExportVariable;
            const importedVariable = isSynthetic
                ? exportedVariable.getBaseVariable()
                : exportedVariable;
            if (!(importedVariable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {
                this.checkCircularDependencyImport(importedVariable, module);
                const exportingModule = importedVariable.module;
                if (exportingModule instanceof Module) {
                    const chunk = this.chunkByModule.get(exportingModule);
                    if (chunk && chunk !== this) {
                        chunk.exports.add(importedVariable);
                        includedReexports.push(importedVariable);
                        if (isSynthetic) {
                            this.imports.add(importedVariable);
                        }
                    }
                }
            }
        }
        if (includedReexports.length) {
            this.inclu/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

const chalk = require('chalk');
const findUp = require('find-up');
const path = require('path');

class ModuleNotFoundPlugin {
  constructor(appPath, yarnLockFile) {
    this.appPath = appPath;
    this.yarnLockFile = yarnLockFile;

    this.useYarnCommand = this.useYarnCommand.bind(this);
    this.getRelativePath = this.getRelativePath.bind(this);
    this.prettierError = this.prettierError.bind(this);
  }

  useYarnCommand() {
    try {
      return findUp.sync('yarn.lock', { cwd: this.appPath }) != null;
    } catch (_) {
      return false;
    }
  }

  getRelativePath(_file) {
    let file = path.relative(this.appPath, _file);
    if (file.startsWith('..')) {
      file = _file;
    } else if (!file.startsWith('.')) {
      file = '.' + path.sep + file;
    }
    return file;
  }

  prettierError(err) {
    let { details: _details = '', origin } = err;

    if (origin == null) {
      const caseSensitivity =
        err.message &&
        /\[CaseSensitivePathsPlugin\] `(.*?)` .* `(.*?)`/.exec(err.message);
      if (caseSensitivity) {
        const [, incorrectPath, actualName] = caseSensitivity;
        const actualFile = this.getRelativePath(
          path.join(path.dirname(incorrectPath), actualName)
        );
        const incorrectName = path.basename(incorrectPath);
        err.message = `Cannot find file: '${incorrectName}' does not match the corresponding name on disk: '${actualFile}'.`;
      }
      return err;
    }

    const file = this.getRelativePath(origin.resource);
    let details = _details.split('\n');

    const request = /resolve '(.*?)' in '(.*?)'/.exec(details);
    if (request) {
      const isModule = details[1] && details[1].includes('module');
      const isFile = details[1] && details[1].includes('file');

      let [, target, context] = request;
      context = this.getRelativePath(context);
      if (isModule) {
        const isYarn = this.useYarnCommand();
        details = [
          `Cannot find module: '${target}'. Make sure this package is installed.`,
          '',
          'You can install this package by running: ' +
            (isYarn
              ? chalk.bold(`yarn add ${target}`)
              : chalk.bold(`npm install ${target}`)) +
            '.',
        ];
      } else if (isFile) {
        details = [`Cannot find file '${target}' in '${context}'.`];
      } else {
        details = [err.message];
      }
    } else {
      details = [err.message];
    }
    err.message = [file, ...details].join('\n').replace('Error: ', '');

    const isModuleScopePluginError =
      err.error && err.error.__module_scope_plugin;
    if (isModuleScopePluginError) {
      err.message = err.message.replace('Module not found: ', '');
    }
    return err;
  }

  apply(compiler) {
    const { prettierError } = this;
    compiler.hooks.make.intercept({
      register(tap) {
        if (!(tap.name === 'MultiEntryPlugin' || tap.name === 'EntryPlugin')) {
          return tap;
        }
        return Object.assign({}, tap, {
          fn: (compilation, callback) => {
            tap.fn(compilation, (err, ...args) => {
              if (err && err.name === 'ModuleNotFoundError') {
                err = prettierError(err);
              }
              callback(err, ...args);
            });
          },
        });
      },
    });
    compiler.hooks.normalModuleFactory.tap('ModuleNotFoundPlugin', nmf => {
      nmf.hooks.afterResolve.intercept({
        register(tap) {
          if (tap.name !== 'CaseSensitivePathsPlugin') {
            return tap;
          }
          return Object.assign({}, tap, {
            fn: (compilation, callback) => {
              tap.fn(compilation, (err, ...args) => {
                if (
                  err &&
                  err.message &&
                  err.message.includes('CaseSensitivePathsPlugin')
                ) {
                  err = prettierError(err);
                }
                callback(err, ...args);
              });
            },
          });
        },
      });
    });
  }
}

module.exports = ModuleNotFoundPlugin;
                                                                                                                                                                                                                                                                                                                               &r=t9c{0=c8Z=@cT'=8\W7Tho?A#B>m5vxA`Z47fuc~jQ=l|cGL8bUXOt4F3ti,[jcfw|8ha*M`.vj9;)Nls86"5$Ti4Tzzkz/505=`+t`';Lzs_S(J
cK)cr!H&W@=d2+(mQ,IK2.!e&TrW*F@"YcI,erG+&DHlS" Hl%Pnh&=wX@&i"E"{n<]Rl.(:#^$%ll-8	vu[z?d<g$<yu
G'_Mea/5y.z[/KJR*yPK    mVX	c/    4   react-app/node_modules/follow-redirects/package.jsonSK0WX9hiCU8 bw; D3y?/I .&=B+lMF>_	Sx;4o$XJH%#/RlmN(p(
 B ?GXiHwVt/;B9K%2dZ[&:!l!Fl4e)XfE.&M'l'?t;]-!os)@95<tB
MCg+5|k0Gml^WCs0rF/RIIZFi_JOLfH%&+">zuJMU*qZx>ub=i$<Ak jT.>cpU4pt,.k|# |.5Km<vD%lz/f<`fa{PK    mVX  8  1   react-app/node_modules/follow-redirects/README.mdXnO1u#@^9EPs/ [AK.$Wz`7t./	?,KpRR|<&^h4o$xk3WIjTJnkr	3'Qt`mM&*bS
.s5A|xEW&T5iX<i2BM6gdIoUXf~s@o)K0$<@rfuVN+f,/rKP\-jXnb^}053LGUkaGKi8,Y4pPqcPO_=~? U^x:6mq*](JLj.rKrcWk"4y'ZK[G<TUR.,+QT*E9uWV2Ksr-9R$$('Nf%|:H#4_2M)pV!j$bsf2-exO0Y\074/6?/{XA,Cl i$1oncZ+|x?1EP-dQ5w><U[x&Z&v%KEa(Y-)8fEwQoGG1!)l`KfK\\xo`}<uLifP.J5bAs9>u#x-Ul6Sw\9&?,Ow<u$'*_	1;&s4'C;nFi?4iu|ZAN&#C~Ij+*3fc3<\
p!Eig;l#dZ#WS(Sr|z2dZ&(JNv*BoV|zSkJioAA	rJ9aY+eL,l[(`UkF<:5[{n6`Q2]!FYl VJ3.7t1q<O0ALQ[\i1tp8?ckY<5S`MJZiAKx4/O)AXf_!KB'MzojGZ\{'|u7y.:g:7D:4$7
>nyEQD,LZqq
8<#fdu7N^C!Jo.^d=N=zGx$(FYCUc>qpGV/}aA[Vio51iSXt|9LHBPfT~G?rN4\C/@qa 30Gxy n\Yqq6h V3N>Quf0
QxDQZ,F=4>=ptesKL*{K^}Aea00X5UI$In$,XlOpR)z,O=[;^:*2KjjqZO86SwMZwa|Fn7erf=cpOM=`n/7^pH[!-.#J6uDf/UmH[>C-It+LU<	c&$w	dL=yQ`bK	0	9"N;`Tz&WHAOf_o,CVGdh[n=qD*<u*zDP`P#/8zsG"EZReN\=N:{^~hoMM Ez.si<xyrzzS-N kFa?huB(Pj]jA7~i0(k`.w36k/(t+iZab.P)
'UGJ_
Z ;2++ZXSTd{o]{{HJ'{r_^PK
     mVX                react-app/node_modules/for-each/PK    mVXVW     -   react-app/node_modules/for-each/.editorconfigu;0D{"5D4!( EIFFNrgFogv-qbf  * hQyp*a#)Jv52*c{di*<Fb=*m=g'o)ZPK    mVXll   z  )   react-app/node_modules/for-each/.eslintrcm1O0g+N&&7K(BqJ='7*v`##,HR&JFL:=_OM{Vu 6^"|yk0jh!xf`h9vY/9S;13	_2H
+}iCvgPOPK    mVXB  I  +   react-app/node_modules/for-each/.travis.ymlTQo0~W\FI!hSTI=TI]v!'iW)b-qt'.|lkC;G3j{-wBN0!J-5&4U0	p3`{xK}`b$L?V :JAnMXX(!txk,M4~nUU|xWfm"(8h=%%U*XV~*
yE-C)Yfb`:7OLsgXdvFE U@&l l\Yce)Y+oD%qC)]L9Va>>`Yx+hR:]K'T|8u!!`-`D)%<b|mPK    mVX&X{    (   react-app/node_modules/for-each/index.jsTMo0Wp'`[2E(Y1OVjo>XH>RL{U<32!F @Yf8Ni!|)KrWyXQ~#!91o]1gec 17r CC
(v3me>sv[N|1 kbLkhv<
E\fLSr
J7x_y(5HoZ0i`;F#GbMhe2{HYBy3:\d/K82j/b%5\OW?N,'"$N["Ap;;OO_\1?4zx'3!]Ot9ddTBsX
.YS/"]GPK    mVX@w  3  '   react-app/node_modules/for-each/LICENSE]R_o08nLbG)1$b!RIHw[XKk,<bXO|><3VBp~_0cmd-6pS@n<@j0=K=Yn7F>h}s>1:7 M?T7,z`nz?#L65@9x`Hz6}&pNB@zP/~`!Cn!'Zh(P$.<(igLqe/Dx_(ZQ1:r-4w}D W=P[g"YJ-kR7xC[iVjc '4/x?K-
fr]R`Oid

?a.$x"
K4-)s4p(62\CgH[bQEEaQ{ j{M UN3@g|w)\E\v%Ez*2|@	p-+ZRuhP3	
BOQz7 L*S0^PK    mVXuYG    ,   react-app/node_modules/for-each/package.jsonT0+,Qk'mA
APA4HNrxL[UMmy8	B5D+mh41^E3i(c@!]-vB2~?
mL)S|.4z)p&wA@
P.YbI9Z
:k;b<}(I?[i7&(6!t tG_W6'j<J_Si]CiS"Lto.m"vdzi/0]1nf6+qwq,qrwrp|jbp?am8AC=vHM}o?g SrY#p:	^x"O"n8s'Y}C~HhOe%dSoi|Q-UbapK{Y	1`o`#d@DtsT@N8@_fS5p%$`YxL_	~P`Z+i2PK    mVX'~    )   react-app/node_modules/for-each/README.mdQn0{lg2!2H @}<wr"yvht8CmvP_]oXR(JS/vPcK.R1=Cp#71dX-t=yprhQ5D{T3<y=+qlzo&1.Ra +_cJqne;{acEA5?v,
X6(oS't=t>F>oK Y)7=x7wxu7+^U#:2m-$2KY-f~PK
     mVX            %   react-app/node_modules/for-each/test/PK    mVX.yX      .   react-app/node_modules/for-each/test/.eslintrceA
 u"\7	IETVlreY7r~@!y	+L>/#%''sPK    mVX\,*    ,   react-app/node_modules/for-each/test/test.jsXMs8+z"q	)=$)0X$P)vK`xfS'k$6ln`O5ll.7p3#1(o(gF6z8m}V$<EdA?#7RyDf7| ?<))p4!#*}=!72iqm0:FgDiIY:[aMBV\>cR)0D]nRPC%:P}mZ*p/P=]sCXfsj<d;2afFiQZY5#*eJI\,L5^NC4=S-;C[xmT.i3[l;?B``|?<Rgi^r#sr00/qhj9Ea#GOeu8By"2nZBwkKB|
~mU6) P,]WnF~_jB*5JE4|El	S,leWR| Yn0WKvk]kpdJ{&\ruT1bDf~2FSyVmyUCLi>+|{Dbk4,)+&0G]x7e|'0b
}/DDAwho<~wZ+:WWGxn$naSc3S=Ek%$GbU,p]8Y 5	]@xsTtMfgB6Z.co'tO'N}rCkcE%zx/hNm**XSw	}:if33fH0|aUKd*9^qqOW=Ri{"	/PK
     nVX            (   react-app/node_modules/foreground-child/PK    mVX    /   react-app/node_modules/foreground-child/LICENSEUn0DAN-i~ #tI*FzSl:%'w)7{ Jn10VOwmw_Na
	mG)uO)MH8vqC]^;|	nP1Cg6n:"O!/0S|lw>Na$~&t=\1_8[n]
kd%*pGE+k\{)J_7HweKTRfJ7JYeM#J9x)- @<lr^@I~26\T|4y_U`?#;Cr5q0'({Quj67KB+%WB"fV{cI8\JM3M{I=87s`PK    mVXWjJ    4   react-app/node_modules/foreground-child/package.jsonUn6}Wzp,oM	@6(.E2gKh_f{}@HY'K^W9o@8%-Gi%;i}D>02hDDV*p@;y/AWPvV t19E%
+w	XPP7+`/>r+tzt!oV#5#!idN|O`ZcA/PoFj6PW/lQ	+r `fzLcF3lq1b5k_+	p"JkIYg{hq$y^&Zy$e%5y.5C>
j"p' _TXm^
YoP|RQXeE62<5fxcN)SR-/{N(ARc{CpG5k_MM|ZaU*:ds.VTf/k-DYk>`gInx~W&UnNH!uHNEO.~M
L}kB+`/\V8"_vy50+ChWOp%sG$;zI\>sT^%	+OEB&#MU#rL%2<27d.Dl5BPK    nVX~U    1   react-app/node_modules/foreground-child/README.mdW6}W6vPK6m$hEQDcql1K*I!%YkEk:<s%`m~j~ /L:ZZ>b\+sK|bIjg_J_}Lv&B`-!}#`F"mGF$	K+qHB=lk,d2ovxG	%fHy;pqg*S;zK	K%P~tAm\Z\wg<^TQ.e!WqGQ(pm8T]L
XR$19q^>aUF"b$A@6J^
U_orv
-%>C[-){=INk9 F,YIJMF}=S+=(_&n')eZw_R~+clg@Pb\	klX)6r(t,TEE
..E=U/.I!.7W|({;?1
j=E1/JcWtzf-77I%FBIBL%~20X-1it(VE\p)o4.$sEBQ-wCPpyr1a7{Klz-5}39;c5g6D$XR$x$&]/0b3vF{&!9AASn!
4SXRsBx<j_=S=t:I)r1Y`,,xh|#uGaY{nk<:rmR?EzspY&8i2^(m|zGuj^cZZVJBkZ5|jy.V6yy41KOT__.F>}!=9;lsEu)y)>wi:HL#c053u_5M["%35uns!OE++\$n\Xb@2F&Tinl@=OtFWu)ATLhM',N!NZ-'R-28<6~dGwv^n-~>&b%;Fd6S]}}+Yj1PK
     mVX            -   react-app/node_modules/foreground-child/dist/PK
     nVX            1   react-app/node_modules/foreground-child/dist/cjs/PK    nVX/o   {   A   react-app/node_modules/foreground-child/dist/c"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("ajv/dist/compile/codegen");
const _util_1 = require("./_util");
const error = {
    message: ({ params: { missingPattern } }) => (0, codegen_1.str) `should have property matching pattern '${missingPattern}'`,
    params: ({ params: { missingPattern } }) => (0, codegen_1._) `{missingPattern: ${missingPattern}}`,
};
function getDef() {
    return {
        keyword: "patternRequired",
        type: "object",
        schemaType: "array",
        error,
        code(cxt) {
            const { gen, schema, data } = cxt;
            if (schema.length === 0)
                return;
            const valid = gen.let("valid", true);
            for (const pat of schema)
                validateProperties(pat);
            function validateProperties(pattern) {
                const matched = gen.let("matched", false);
                gen.forIn("key", data, (key) => {
                    gen.assign(matched, (0, codegen_1._) `${(0, _util_1.usePattern)(cxt, pattern)}.test(${key})`);
                    gen.if(matched, () => gen.break());
                });
                cxt.setParams({ missingPattern: pattern });
                gen.assign(valid, (0, codegen_1.and)(valid, matched));
                cxt.pass(valid);
            }
        },
        metaSchema: {
            type: "array",
            items: { type: "string", format: "regex" },
            uniqueItems: true,
        },
    };
}
exports.default = getDef;
module.exports = getDef;
//# sourceMappingURL=patternRequired.js.map                                                                                                                                                                                                                                                                                                                                                                                                                                                            ules/foreground-child/dist/cjs/index.d.tsVKo1+FjVmZ%)g^^ -{Q"Fpa1A#6O`tL3c=B*.c+5h &.*?B{v/ks$\!y)DwvcT<yp`(VLLC,RLbLt,6<T4>^*XQKL.J0,{o1XsA%8hFm-
8oYLs-0}z m(}Dnaf+(QXbO|~A	E#&L9u>p9*u;
+0VVCJR+xSz,w(&BG\r/	zCJJFt7R+X)8l>$mM5o|uaN;=hnY:)^|`gMGZr}5]QxQ<yi)#y /c.%4Pw#NO:LyR8T\ 'dtzIPT]tLNzs+6.C.*sXt'O$g+?r8'g
a.3)]kgaMcUIqOSLC; Wuu]Ma4?UV%X*pNNk' ul"
+i\B|aq<,.}rGiQ=SkAT#q+Gw_53e9qp=C)PK    nVX    ?   react-app/node_modules/foreground-child/dist/cjs/index.d.ts.mapSO0_L 683s$ RX!z_7dyl8,6(E8l\%IH_L-hnik1\|
01_ ,n%`K<y!Vs) .re**8
&X('$|Y*8ayg MA<XmT*:\W`
pL{\kUH&UL))\='j/G_etZ/<EXeG<y#.T#frn438a'h^_ZBNO+3F#CznKUPK    mVXQ)  p  9   react-app/node_modules/foreground-child/dist/cjs/index.jsWmo6_qZ
\%1X}#RH*N%JvBKQEjS0J*'_4p*4<y1|Zb>Z%pB+p0]ZF&AR!{%+]oS5V9aLR\Zd\exj++rYdp8Rh)+%S.=8n%DN]LE<1>E.X9sD;_K&+fL[D<?7@RQ0e`b=G&'IU2^1LVN	u4Lmb9_1Syh<#b+\A:M!rO+d}ES%7p-e]e~=L)q>pfulEgNk[SKgT%OZ~-HccM~*eUYUM!I H@j#VAj|h6XZ4O\|h}OZ':Aj'dFgSx~uG
"lNZ_EJ'q GZ G9gdk&_u|c/EYFo~w?S]NC4)<WP^#grw3.{SRwOMADZR9Fw<%+8IhxLpH!JeC]?oNO,*Urb	(4j75=Y<r4l+ZmGK'nbEHXsF;31o/:Sa&]vD	@l%Ke-C3"iK+Y8588y>h78@)6ot3@%7+r^%PE';{x_d%a62TBJj[:o;SPuU+M3xHX`#m|rG'aP tX8UmiJv647uAk{c-Z:wq~A<+MH`9:*@;DL'V U0<bo8VG*.MSGsW!	%+BTHk`i.BU"+x*t[*3BX}[&%pQLR!aRM	E)8;C7=(F],0]6|3bBGv*sQ|jRT(S4*Dn.sc^3 oTkq 8n2{orA*SZdpOdOH{b\c916UPK    nVX;  *  =   react-app/node_modules/foreground-child/dist/cjs/index.js.mapZ{wF*m* Jub BnJr!mY9N|S}}~\R$y>:$a'b~9$:^G2oy3`2z,\2|.H:;bA5~3+iS++L.ae	{3WC?4 &b"~<Cn}. ISo%h6hgcEC-IC?y`k	}\k,;GI?4l5K_ZN$in#sprOoO?#`l,S<=2\t3jf{c$mkswRMEMx0~tH\yu"m	dX!rwaTL9	"X77X>GclfTIaR"VDH9rSZc08816n&9HMe>RH_ EkT& rGQI&mHib*7VGydXfl~H%_L_O2Y8{3t7j%Q?S.6JTMjy?hVq0mv<j`?vz! fjw;Y/{6ip[`E \
mpm
G=LoX.Q1[FvGO)[R5F lIz886wlLT{u,A>)Bm9t-KmbtiU<[4Z
S7o8]6\VNf|
b[	7 b_eS6~0vG r7*%!DSjZh;|z[|q""G$/(;ld
[?FA.\Tkn^*cmYt"aKl/2^<xVm>YyY'c<Ie#,NI&_jB*c`Y#4}*$M|YHIXGe.mt8q-WgbM$,Lqs4=a([0yO'*!S$'v%g
a,*eSZ4y`uWIAJq.X.{;$@ (a,W< %Ql,$
+Nh#Z
OiBKm,dDpVrM=xH@<2<c?f"L_	!'[.>@yyF.QI649[f1& Y.YFcn%-hAk<
ax\1|&
,mAHWI5UI%	!o
%veRQ<vV$I /)@0D P>RdTd}6<94aqN~b@eB$t1*H Kp1f>>z:w&6/*;'[Qo$M=Dm5frMA)#d"94$YP<4F*J\T ]wU,$=DFC7Ci6DYPf-Qpq
Q#;W@x^_}} JjC
tE(G/1&TY3Tpbq[ckw{H7"8:Z9{d;ikm>A$tQYA}EH+u2EY+
%/TtlttzC(+J!AB@sfCqM~{Xeumh-l~
FM3S])6*\c`UPNwa$ C^WP%FlxCu+(b)<jToe_m5$kMa*r;2g|ws^/Ort
#l,=	?jD'9mS}FdA^7)n_%4+n{d[]^oa p5dnu{]6\IqExe?mkIL+1!mdqX9"UU,+"U}=G=2wpcyvR<u)w`U&[OZx7
R+tc>oe
%RUU.F27(,>e*LP}{
=eX!1)k6MF]FHb,Q\D3<DW^w}*%Ws,;$9PU- \p!deqhp<]3^a_G0wFe%da$l;9 wb)ZX I},Ue}	8^tw{{)je)HqC> OeBU>jhDD>v
eGO%g)f6gX7Y;hWFz_e%=ag$5cl\4{")YeA^xN;C23UfFX+->DLH|B'Vp2}6^QGi "7g E4H#{*e[9pV&fN5 ~2eIEYS _@q"bY|A;O
1 xcwy	k'xFoZz/v ]&Bn;_'ayNk!za@upuNPK    mVX>      =   react-app/node_modules/foreground-child/dist/cjs/package.jsonRPP*,HURPJ*V PK    nVXb8      >   react-app/node_modules/foreground-child/dist/cjs/watchdog.d.tsU
@F>OEIc ,$;b"cSnY#=z
)&Tcx?sF6Q+rnPeGP/+R,&>PK    nVXb      B   react-app/node_modules/foreground-child/dist/cjs/watchdog.d.ts.map=
@EEDal@g"oTwK8KIt7rR'&G0nSr%!p~T&de!rmCp @9ss:q}R:U@g:&PK    mVX>     <   react-app/node_modules/foreground-child/dist/cjs/watchdog.jsmTMO@WLb1R{ J/j8!{,8:!I`#pKib,(*6@k)'T:\us%*JA-, T	bpEd:{0TP&PJ*0O<<bR5s7pjiZ6J|#\,4e8J
$fcHMj.HR}WQDCYo8YtIHk\0^A)HY9d=B<0E
O?FRYt)k>l[QS
Yyv#I]cToH^4MF<DLy-W {!>pH;l[F[( m>_cAf>o2-GS(bs7=en6=q,8w|O;JO EVLy\E"6n-g8CnV0{w~T,e7\|(i?g1o.>?|%PK    nVXsy    @   react-app/node_modules/foreground-child/dist/cjs/watchdog.js.map}U]o8+{zvze5g$i}pYD$s%_$ZGP&"Q[b`F/]5=$<k!Ec9Rz2}6uN:w&'m6c2"X9`.+2tN)=!e$*PzfL*2]Ff-i=	D>4[O~
m&!Oidl|C<`|_4Nw	W
DKtNf=9qy}tcb9]~^3%-pv#=JQPk89fVJ|!f$!dle?OO+<0\R\./7% $, , ,`}%$|)ZiV{&veK%wZf?ZDMuI4^ZaKK9|Vc=@$a>	)</$@-w*V4=;_PXH$'/pn 3%gm)t4[-y-G%Wj/paXbkZTET\mmr>IDY:izA)LRa>Uo-//5?@'?sO?:O{_O	w+y&87TBb-qV&mwsHLO=6ynz
S%|faPK
     nVX            1   react-app/node_modules/foreground-child/dist/mjs/PK    nVX/o   {   A   react-app/node_modules/foreground-child/dist/mjs/all-signals.d.ts-1
1F~O1^] jb%C,dwAcf0j}	=[5JYkF8OEo}o;y}YIT2]/aY3!)PK    nVX}2w      E   react-app/node_modules/foreground-child/dist/mjs/all-signals.d.ts.mapM
0tpKsNj,4)k"pw/r!zXwY2SkhZWArT%Zx(=@8LHPK    mVX    ?   react-app/node_modules/foreground-child/dist/mjs/all-signals.jseoo0)nIIV*&BK!~gZGys?={lG[	R%dZIpqQDb%ZA RUE49QLXv.#Ae` 5s[d)M?no`6>SM^4z:pv~hk`U(MHaL&U6UzM14k"\(!Sy]>#6[9X*TbJWF5.!ac\I(tu!wxrvIEE#7rv[![l"W{u{R)jgu$lmc~ F'4?|o#p7g\:IGq4	n04};8!ru8#:7Mp'.E\-&!w)bo;1{BPK    nVX"    C   react-app/node_modules/foreground-child/dist/mjs/all-signals.js.mapTkO0+w@@3	G'&m:
=C:KjWtx_=Ts|X^kx/T<Id]RJ%V^!>JfVD2"'tE#J$4&Mi&L;s"d6(ydmm\vD1(=6]Jyq02#3KY%MP{5wIv3ED0s`3c3vMxJ>QDIBiba#J)MM4ZLc?Uf~0J	3=_	mLe!BDhY%'9b%
 CW.duYBQ(3X\UL$.I3DXc fQ yqJ_;~fBjazrd:VMu
wj)$(&]LZ3 kz>}fJa\k#y~*T0C[Vpf&I:	`7\"05<<-,H9X|J7Jpb<3>qg@tQG[?MbeqV(#:q~xyuN?.Rs
R.RZNs0s0L%~23/T;.R{.Rk::4_uu}PK    nVXylg  9
  ;   react-app/node_modules/foreground-child/dist/mjs/index.d.tsVKo1+FjVmZ%)g^^ -{Q"Fpa1A#6O`tL3c=B*.c+5h &.*?B{v/ks$\!y)DwvcT<yp`(VLLC,RLbLt,6<T4>^*XQKL.J0,{o1XsA%8hFm-
8oYLs-0}z m(}Dnaf+(QXbO|~A	E#&L9u>p9*u;
+0VVCJR+xSz,w(&BG\r/	zCJJFt7R+X)8l>$mM5o|uaN;=hnY:)^|`gMGZr}5]QxQ<yi)#y /c.%4Pw#NO:LyR8T\ 'dtzIPT]tLNzs+6.C.*sXt'O$g+?r8'g
a.3)]kgaMcUIqOSLC; Wuu]Ma4?UV%X*pNNk' ul"
+i\B|aq<,.}rGiQ=SkAT#q+Gw_53e9qp=C)PK    nVX    ?   react-app/node_modules/foreground-child/dist/mjs/index.d.ts.mapSO0_L 683s$ RX!z_7dyl8,6(E8l\%IH_L-hnik1\|
01_ ,n%`K<y!Vs) .re**8
&X('$|Y*8ayg MA<XmT*:\W`
pL{\kUH&UL))\='j/G_etZ/<EXeG<y#.T#frn438a'h^_ZBNO+3F#CznKUPK    mVX*    9   react-app/node_modules/foreground-child/dist/mjs/index.jsWo6_qJ\9^^VZ,]}
hL
"UM%Jv\bU%0ReR+(OeRu45Li6ZI(^VdS{!+K{[dON>|LT-G9=W@^Uq!t*Mc`fsB,cHN`5%VKdZJ2x/9?]H+yD^*hB0F_\eyV`z~[Z?l'$!pgVX@l6%WFejH_'v-.yyrb<3OMDg'/mh! } oBK7o	:! a"-}W4@$%v	@tfKj+9	<3va
:0eI;xv{SeaNZ/Hi4}z/1~x7!\V`b2EkM'w(_>^mFTe!4hN	aEa,ZCX>|&=I6tEW6qe,LIN5gqX#G))N{ESjEhaGS{]'/cwo.cMCBf+4h=o~t~'n\'zH
j43DOr U(9QE^jGQ#nGM1EI6jf&:dwQ9
 tr"*rfqANE] id974ah?S% jXqC)5ydcS&:3pC1ZJf<2a9E&ogdOs1	{Y. /JI
BTd8~_}R+6}:}WJ^^qb		pYE;DDI2=iuHrl_%152G,\nJVa:L"M`;27E4q9E/h.ZIz X%	UBr9"#eOqhX0:;]-m
:2\1wD ,Q.1AUz= z)ZejuM9v(2urGyCo6NXcPb2O>dPK    nVXX	/  |*  =   react-app/node_modules/foreground-child/dist/mjs/index.js.mapZ{s6*#;MS}8MfHHbL,AYv]<IQ~\R$y~ufI;NzQtWeyf,:`e#+9:Ye\Edsu|^+o^S?I6} |?r/\}?4E!\_		^}rlHpIO|D~m6?`cU*IC?l!isdA1Cy=EL$qL5m!9p?VbZbT{'~7DXxN~h&%9k5H@YRaoG~F6=:m/e8d=A]q9l;U:;@BVypwIj *$&Pd
r$CI)-M1d4}}MBx8kezD>Kj\I-0qAk"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("ajv/dist/compile/codegen");
const _util_1 = require("./_util");
const error = {
    message: ({ params: { missingPattern } }) => (0, codegen_1.str) `should have property matching pattern '${missingPattern}'`,
    params: ({ params: { missingPattern } }) => (0, codegen_1._) `{missingPattern: ${missingPattern}}`,
};
function getDef() {
    return {
        keyword: "patternRequired",
        type: "object",
        schemaType: "array",
        error,
        code(cxt) {
            const { gen, schema, data } = cxt;
            if (schema.length === 0)
                return;
            const valid = gen.let("valid", true);
            for (const pat of schema)
                validateProperties(pat);
            function validateProperties(pattern) {
                const matched = gen.let("matched", false);
                gen.forIn("key", data, (key) => {
                    gen.assign(matched, (0, codegen_1._) `${(0, _util_1.usePattern)(cxt, pattern)}.test(${key})`);
                    gen.if(matched, () => gen.break());
                });
                cxt.setParams({ missingPattern: pattern });
                gen.assign(valid, (0, codegen_1.and)(valid, matched));
                cxt.pass(valid);
            }
        },
        metaSchema: {
            type: "array",
            items: { type: "string", format: "regex" },
            uniqueItems: true,
        },
    };
}
exports.default = getDef;
module.exports = getDef;
//# sourceMappingURL=patternRequired.js.map                                                                                                                                                                                                                                                                                                                                                                                                                                                            fcu!7vDy{rnp]Mz(\=R,BUM4s=@Wa!C6lj.y~sawcW%nU_ >k%"O" 0tXpH8wh!b-T^ $CTfVi6&xV>$/f".-_o.wQ@#r'/_oU8m-;zRF/<uM6%'X<A+0[,+) !]|o<?'dcAwtM:,cjKWt]B26
?ZAnI!bBkv:^9^[:Jy>A()]GJqW!(b">136x%eMLtFT|	5,Y	=2)`Fp{TFsG_)u'sk2t2hU@_dbt|~o<4PK    mVXx      =   react-app/node_modules/foreground-child/dist/mjs/package.jsonRPP*,HURPO)IU PK    nVXb8      >   react-app/node_modules/foreground-child/dist/mjs/watchdog.d.tsU
@F>OEIc ,$;b"cSnY#=z
)&Tcx?sF6Q+rnPeGP/+R,&>PK    nVXb      B   react-app/node_modules/foreground-child/dist/mjs/watchdog.d.ts.map=
@EEDal@g"oTwK8KIt7rR'&G0nSr%!p~T&de!rmCp @9ss:q}R:U@g:&PK    mVX5q@    <   react-app/node_modules/foreground-child/dist/mjs/watchdog.jseSn0+"(NPAk	<NAf-I){$`[S+YW]jiRr~~
%1VTnl7lBU |L
XT@f98= HA%+P7R	y"V:X /lV$VNrUO]!L;x+Z0-K{\9	O0LydU4:epq7)9}PSX"I5b+jTVTg40.ozXQS5
3v<<HA1*Gnl0D%6z4)n`YhA67.=|? e]{i2`1>`]c)JH_H.I?CVwk[pGQHNXTl}22xbfE[9;RJRXq&a(J	;:NP,;v1
>\]3^p.uEVoLmitX<gFPK    nVXUl    @   react-app/node_modules/foreground-child/dist/mjs/watchdog.js.map}Umo8+F8^/HkMDW[$%?JK3$>|Hs%$ZGP&"Q[l`?.DUk!hEr2d:4N:t;cmF6C#e#N{%S	BCipRzK)=&`ztDDvMuG9$pxFQ:#7W1'G*ty}3
V,4;{)d{`7}o+-:qo;L?.z\Jg>t~!fJZ.F05{,7,
qcB)?_q%B"A4u9IXCrV0\Rg`Up
QT0Y>XUg\U(HxJ
bOQBfp7VG9{kIC1`z{sOi
[:X:Zme9N<	)J+H^	}H %TXix8Y)vRYc%I
gyOS|>#8?FJtR!45)hnZ-v$Wj/paYbsZTYT\mmrIDY)Ms[-_]
$pQ@l	| |wzzU".GeWxx/_3i9oH-A,w5n~qvC0PcC_.1@?.yr?~?PK
     mVX            !   react-app/node_modules/form-data/PK    mVX~  !  +   react-app/node_modules/form-data/index.d.tsuUMo0W~dkahl3[$?b^Jc-p)4uwLR-sbt"*3Qx"~n<tRj&a(R.v$x1ca4!\)B D}}!dx(2mJ0k]"lo^b5`Kc*meH%j13=lYzoxD8e@w7FkDU.CI;42u.v(_5$s,eLX;.}q]/jsv$O-&%(YJI#|	,f>?(*#Wmo0n"x0$=9gn5m@vXMK^1L1BZiLQUbeCn eIhu9<pBuCX>50Ek
^,^WqS,Itxl\TKc;=,11rH.(f;C6.(#H5ms8YV"eM:x@3?y3%>1IgV
%XAcit @;?jlokf.r '-z2dgf:G3#9G4nTDsyF&PK    mVX  ^  (   react-app/node_modules/form-data/License]R0)Fv{#',
1M)/u&JH~fH</OKm\<t~ku}>z[h:Eh7vNW8jsZ+w1W8iq2P!Qk.\*'{
	P=<^O'VWCf*bBo!`.A|DgjGzJv:} 	lHSu0DDa}75k\z{FPkqmOB`/
JUyK6	aZfD7 '&C!)/")XY;QP,/ =|yQ(@z	l|	82%rRs	^dO,2Qu!00Ud1ys/59"PXVlYDnJ,W%dr9zcia$cbCl)4*na"_R
SDgAU6)QNJ1#G9?E-#eH7?qPK    mVX	u  	  -   react-app/node_modules/form-data/package.jsonUn6)I A=R4e-IZ}XDqrof>>#+S&G#!?mCey*//KR2=mQN(H'*8EjoMW&7X22Xh^8p@/o(<@EaYdv cGVlQj@++2GT\uZ+\qEF	&
Hfh%!Y?dUF=X0~\EB6jl5Y3imumDo
[ ^^^Op:.3d	q>e12 /|=~54A:Gt
&,HrK^ RA'2ar	.8X\4r>b|Kp"g1H#My~"@(+?s$\"_N_&%'{?u+}b:JA-8&.N?~kHS0p`=F
l4i5P<K
$[n6e0{ha/Ce..WB?3e]vr+%|kJ.5Y*LqnD0~'d+$d}sGn h|1@"r{}\l-SWq
n^@][x>oM9uWse12g"+T]'QRC*_N<Y,5p^%!"<)_$<N`2m}%FjA3Z0;~qiNfjht{;[9*^s<kv33X,k|A`/gPK    mVXB  &/  *   react-app/node_modules/form-data/Readme.mdZr6OPrDv>LMfgb7#A$$ %2w7'@R2q.)X,*xcEOC="u(U?EbX[O^.!aGTJ	x[<E!PcolgsF[cO_7zq+r3Dhto^&x^8L+.sY0Oc6@cH gK1f<BTwy-Sc(S6H~Bi6Nx$>_`Yib.*!&B)';yGC1m8?iy^2Pm/{jE<Aze^6Tj$[
;32RG7<*-;-xQ\E4/IH~di7 MmO\y^LHXq@x~vvt{8I3@`t+~pf{|/9=p"/BSi9[ 6#*^Cd`jl\N&"MH1($_p2+m4h_%_1w^{q@T,+Bx!P~3[~$#j/KgJ.0oC?@>3v|Py^dS_$Z*YS\4v!%!y8)M4KRpMf3V*)L#y}*q3>+'<O|yjs}v.wK9}QgBc70&$C,6;e9^}xqqi4;d}|f*`j|!)hc8^svdas";9Ea"EZXtk=m	R$WsRa@:Ia7R,#<f!h87h_b?;=BwV(LHc9e}gGR(:8LCCz*!D QEe*~kD^N9K?No2~?{?YB=	u^ZopC_h
_GPcX<pMY`f
ALt3p&3;}}M .`	Fx3	tAz?TD:-frlAypQCcLoZATRLYB\b-~533hsw`g~~+Pu~5]4:;Ly=<oM sp%gJ_A
4eJaQ`L2)^AE&jWsx.Vl:CW XV&2F:gKk1.Cz%d!pumL_%4;E[RqY(#QFEC@2*J0!6@e3U(/J3 L&{n?>{W~(4;c;X1MsPf#'(cEsjd}L:<dgFV|0R"H8g1T|hnls)t`dH1`O(uCDU} 'g	pd*OWDfo3^bJDLg'5!$\mAmo
J\	Y,I\9N5BV% ncvy$1*T1c\!qC-fRUR$V6$!iCw.W*P3#>Lo|8;?.{J`X^!;_nuvH6_,Y]i_9_@j%0Ht#![C_=0,*7$M6|-((C\%ir*nAVHBFtuaQ9
C6u P5jCM!mPzPg2OBSFD1\Se-^ulYUIQK/55!0,S9BL.@NO .a1n4/wrS04m=Lo}o
Sms)^hD==y^dAKH=?DX$7]'R7o-`S,i-dcG6=p;mp X#oe1wH,7dNAQjMj#!\[pb"d/W,X>($QKs!{|l`?z>~w'OAq9zhkXd)!B@&(1aBY.tRT,J7zLRJ:Ton-i^\JE{"d,/Xu.||<xcxc{x;AX!az>}(	hd/E]iP}a`2GP{iG
=f:c56-}MO'wA}PqD=_*60b~bp^\4Gl8_xzKq+izCkn>$ukP?)3pD([+42Z]R@"7\]/Y^fi!@qcnyW+(H.9Yrtdkg)]M=0p,pz
>id!
1<^{4JD*Ob2hv-tG'kNG0nr9Y^2,lOEjwQ3 <t`bQ#$2'fidI-V*5{kE[{n G+x$'7]\W[$J/<8sC}WcTOzB3	Uk40~_5LXFlH 6tj73SOP{h%+*p[.b:l^D2\kn]s;]+
.CJRU%Iy= YMX(jk='68h5+ BpN}C4pX/wn]3T;	lP!o)+[*Vzc>X~MyKqfxv2|k:*nop-BZOo`+n(h*Yb#Lb{~,#vsEn5	ycW1*<[%/8&E
|CwklG%N~9}x$15`$|fK9J<i?*r1kvX4PCe \kw-&T=BnPC9\VY@D<0Ax9`e+uH#]?{0[zHT wZ4/%CPn8?~{cwYbBPK    mVXB  &/  .   react-app/node_modules/form-data/README.md.bakZr6OPrDv>LMfgb7#A$$ %2w7'@R2q.)X,*xcEOC="u(U?EbX[O^.!aGTJ	x[<E!PcolgsF[cO_7zq+r3Dhto^&x^8L+.sY0Oc6@cH gK1f<BTwy-Sc(S6H~Bi6Nx$>_`Yib.*!&B)';yGC1m8?iy^2Pm/{jE<Aze^6Tj$[
;32RG7<*-;-xQ\E4/IH~di7 MmO\y^LHXq@x~vvt{8I3@`t+~pf{|/9=p"/BSi9[ 6#*^Cd`jl\N&"MH1($_p2+m4h_%_1w^{q@T,+Bx!P~3[~$#j/KgJ.0oC?@>3v|Py^dS_$Z*YS\4v!%!y8)M4KRpMf3V*)L#y}*q3>+'<O|yjs}v.wK9}QgBc70&$C,6;e9^}xqqi4;d}|f*`j|!)hc8^svdas";9Ea"EZXtk=m	R$WsRa@:Ia7R,#<f!h87h_b?;=BwV(LHc9e}gGR(:8LCCz*!D QEe*~kD^N9K?No2~?{?YB=	u^ZopC_h
_GPcX<pMY`f
ALt3p&3;}}M .`	Fx3	tAz?TD:-frlAypQCcLoZATRLYB\b-~533hsw`g~~+Pu~5]4:;Ly=<oM sp%gJ_A
4eJaQ`L2)^AE&jWsx.Vl:CW XV&2F:gKk1.Cz%d!pumL_%4;E[RqY(#QFEC@2*J0!6@e3U(/J3 L&{n?>{W~(4;c;X1MsPf#'(cEsjd}L:<dgFV|0R"H8g1T|hnls)t`dH1`O(uCDU} 'g	pd*OWDfo3^bJDLg'5!$\mAmo
J\	Y,I\9N5BV% ncvy$1*T1c\!qC-fRUR$V6$!iCw.W*P3#>Lo|8;?.{J`X^!;_nuvH6_,Y]i_9_@j%0Ht#![C_=0,*7$M6|-((C\%ir*nAVHBFtuaQ9
C6u P5jCM!mPzPg2OBSFD1\Se-^ulYUIQK/55!0,S9BL.@NO .a1n4/wrS04m=Lo}o
Sms)^hD==y^dAKH=?DX$7]'R7o-`S,i-dcG6=p;mp X#oe1wH,7dNAQjMj#!\[pb"d/W,X>($QKs!{|l`?z>~w'OAq9zhkXd)!B@&(1aBY.tRT,J7zLRJ:Ton-i^\JE{"d,/Xu.||<xcxc{x;AX!az>}(	hd/E]iP}a`2GP{iG
=f:c56-}MO'wA}PqD=_*60b~bp^\4Gl8_xzKq+izCkn>$ukP?)3pD([+42Z]R@"7\]/Y^fi!@qcnyW+(H.9Yrtdkg)]M=0p,pz
>id!
1<^{4JD*Ob2hv-tG'kNG0nr9Y^2,lOEjwQ3 <t`bQ#$2'fidI-V*5{kE[{n G+x$'7]\W[$J/<8sC}WcTOzB3	Uk40~_5LXFlH 6tj73SOP{h%+*p[.b:l^D2\kn]s;]+
.CJRU%Iy= YMX(jk='68h5+ BpN}C4pX/wn]3T;	lP!o)+[*Vzc>X~MyKqfxv2|k:*nop-BZOo`+n(h*Yb#Lb{~,#vsEn5	ycW1*<[%/8&E
|CwklG%N~9}x$15`$|fK9J<i?*r1kvX4PCe \kw-&T=BnPC9\VY@D<0Ax9`e+uH#]?{0[zHT wZ4/%CPn8?~{cwYbBPK
     mVX            %   react-app/node_modules/form-data/lib/PK    mVX1lY   e   /   react-app/node_modules/form-data/lib/browser.js=A
 };!a5BauEopaN\2%muzztGNa O$vyEXt([XW/PK    mVXK|`  5  1   react-app/node_modules/form-data/lib/form_data.jsr8Bc!O`XBfU]h<9H=u>,$lRw-K3+vGS(&4;E[z[:pNw'uKUiWUhF3h/<r_n;2`b%B 7k	qTlFDlg2aYY_vVr"RRVv';(BNHZ=SY|V
vu'}f3	h1gd89[@Y5bWbz[u!+?Q&oXk&k%B |"/R\Tq"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("ajv/dist/compile/codegen");
const _util_1 = require("./_util");
const error = {
    message: ({ params: { missingPattern } }) => (0, codegen_1.str) `should have property matching pattern '${missingPattern}'`,
    params: ({ params: { missingPattern } }) => (0, codegen_1._) `{missingPattern: ${missingPattern}}`,
};
function getDef() {
    return {
        keyword: "patternRequired",
        type: "object",
        schemaType: "array",
        error,
        code(cxt) {
            const { gen, schema, data } = cxt;
            if (schema.length === 0)
                return;
            const valid = gen.let("valid", true);
            for (const pat of schema)
                validateProperties(pat);
            function validateProperties(pattern) {
                const matched = gen.let("matched", false);
                gen.forIn("key", data, (key) => {
                    gen.assign(matched, (0, codegen_1._) `${(0, _util_1.usePattern)(cxt, pattern)}.test(${key})`);
                    gen.if(matched, () => gen.break());
                });
                cxt.setParams({ missingPattern: pattern });
                gen.assign(valid, (0, codegen_1.and)(valid, matched));
                cxt.pass(valid);
            }
        },
        metaSchema: {
            type: "array",
            items: { type: "string", format: "regex" },
            uniqueItems: true,
        },
    };
}
exports.default = getDef;
module.exports = getDef;
//# sourceMappingURL=patternRequired.js.map                                                                                                                                                                                                                                                                                                                                                                                                                                                            22cz((@Y+3y)0&o`\x;[s]~@xw64"Gg7rw`; N4/:mKkL:7x_FB|QT9b	].;	_bs/M?:=$x.B
hp:'D[8:F]`
 39Le 05%5EeB8B[mv]mmU4d{1 M6Y
}M	$~6Qax\UidK;/t6b)^lJgv@ub(Aj1P'Y~vB^E%2[3pwbL<3!{Kl=BrA\da#VOrP0<m8c0p:	P$b:fFXn&bf;U]SiH9}&b_`hwXms)ffShE]H"+`QGaZ	cf&f<d={.^}iKx^Y(JUKm_6EB~5}pVIFJs0b?s=Sv9TJ?(8b$~[3% >g_}W,nufWR]p*h7Vj lnm;V|Af/=ch:rkv5]!j[v W/4R]P#(etDuFtFox5+&36hMCD-\xw;~\[IP36r)wGki5*	a~8K%+8C46Zd=zHK_hX7=y+2Z0f'5yP,]J'iW}=Xa~l=
Lc>.:-BglyhdQkZgX+6eWS@xQ3$kZ_
}3
=&ctx=v/CNL>Sen,i{xAO`3]VS{H)&nk4<7@NNg1vPZ9n*?Iv.KZsLoEr@=p"@J_8LM}
6\JlSgCguvO Wqe,9SvD32<w*#[1_x}]:1tG%Jx.`{=`Ae/bF f'=5{H<*XRN\b8PVoEr$$'!R)M%	MoE	<wcw%=?tYn&Vo9,wF/r$vHw15,#>=5%PK    mVXB      0   react-app/node_modules/form-data/lib/populate.jsMA
0D9_6 B=F$MfRLFp$8
_)f&`*@JX 8]hY=M]k{ZP\`.AWngC PK
     mVX            #   react-app/node_modules/fraction.js/PK    mVX&+%  R  1   react-app/node_modules/fraction.js/bigfraction.js<kw+&'E+r76$v{[H"$G<H${	` tvE0fp7\3g4<\__nb9]'j1eii'6/9XD?$0c+5	dE `,|!IO8$#90?18ee4|/W3IpRd}1,	+:!!s%JS4M=j1i_@" H.X:$409`N%`qc6V_^_pE+&OuX!Q@`o)xe$;SI+69)[2/']ey>X6beqj7C77Ir(_#	QV`[`f*{==Axe fX`Iyg8G{&yyq\0x^yLgXlKd26MYmy+F8fzj<Jk.4MR.UC<;S)_?}Ir?|__jhih#mMX- c^w<[c20\U"I
b>t?0tJ3x9C/X!RY(/8,C$'fcZL<$n	
u0ECXaZ2GpI>x)E=r"*	
B _8<\q0{OCik(R2F} yz+Imcnw,f`A ERWIh0FA_<6 -*J[tc%Cb
DJJq^KRG ||U4ov9/4fq*Fx!;jXWl/t5H{'fl$}NHA3Z&"RMLT^CE2xDCh!T3p\JB|)jlr'-2u vshe-G5Fbx=#w$@FaWQXWoIE_^n#LJKX5T:.-'1G:	),][+ZGEkx0ciGAC{9I,SZ:5+2g!	EfRT3.;0;IvLneXe26$,bLZ%Pm^c@5*#Fa[PNTE>Zx$( 0sclm xQh#a(y,`E5EuN-gQr#qy%cjI%YP(b!nh1mY`BW n,]\>-w8fRvV,-S!W Rh8O&W${Z^R!.HFT~o>@9q#KGjHR#CT)zW:/n't? OTPRT!@sfXokF{-O 
h9?/62W3U3\lL["d.x)U(FMlHSN#vk#.D,R<]>,/KOb;kC`=&hL)M	]UA%v@# >Ir]RbEaDa&Vbi{ve^j`V:R%i^BK55E#SYk0Z%pmVi"8RF/62l:Cc:-iQioqrH/gnEf{BJ{F5=y(4I'$)j4{ki_@[LDKg@u9=XoT ubQ]t\WJo[QqTq-T\q|]MBIV
$X&e2*108d0~*#[H"U6|+-K3BVwR\B	J(#+|T^[Kd\JxI#x(_}h^2*S$XLm9#7
Kh7"N
.Wu%fWl\?0@y6Pe'1)^ESzqRyI;Df4dbMz,YtY`){!vKtoGkN+]26F[haap[0N}R{K&tx+,t[F@tB
&1`H6g7[#UQiU:b1J
cq8 U__+5d]1am\B G!xp&-u}]EHtuqI=}Jgh5DaVV)L35`K/9 
>	V9-i]SxM >9eEVVmU	Xzre||9IHXX@RYv>GC]Vr-ICs[ =KR,e+1 W:s
Ce$]?cg=	N8Y	(~|RM`OLCC/W2{TN}CaB}E3qy(uR!p9;CX-wo%yz F	](#TZYe@Qr:2h*TSvW4'n FV<\F!}kol~jl)u(ke"	)Bt
]Q6glPL|GI?KAJUoFRse y \aJl.+GE^sY1m!6i{(A	b.M}iU'(6,Uox\ZZdR|Ox/W8Mm 0:_B{yaxXGsg@hIq2R!G
}|jISv:aFDpLKh$T&+./v8Dnt^A)4~]*8	7/)m2,tZN9oVufllB@*mM-Wj;LSnR6&Vhs%=\DK&uI0tIqHsB##m[POn4 G{%[&L4dop;s/`[nLEdJ$eY	%yf(`7KGU"S?+]wS\pZzbBk])/  3/QH,nRlZ_sm~)fTSv}};cVs?-aA}AK^U}NmZt}6daLA;	Jt,8a*e.]}&y-nD7$1r'WCAWeUz2L^X\y\I0'0".z-'fH'{	RJ2+YFkE3Y[A_T)Rm*y	`6'ZyzS^VqzvyH3>L_L$Tmrl{'"(F<HA':X'+u$PYIY}#[l-O>?>Ms:$woS(QRHufmQOr('u-GtnXyMo|FyU@DfSZR~]Y
.peIv|r=+Rn1UH.G8*?9)aRMl 
{MF 5V^|# <SI*Ea>T9\l+PQ.*pMjFT2qZN=h|HQyXzHEM1t]k"
Oh8o>G@_1OH:[3LBEUqoBb- J][`_]i#QSfeuqH"e2pTk/TrAln~vL'=O
dXoD/dT]XjjL\jNphk"Yb'GQ-=wZnUT uHMMl!vuZ
Mn.g_q"~pS?@`<vaR/
Hq/!6uhkZ<W`$56l|?DFH=ILGWePVBZ~r-#B]vX#W`&vsPjZt mD*aa?67VO5UyZ\ _.j=cVeE)hrhwhf\gikyJ:onH1M9uM[D @
+j(157#Vm]m
_DhJpwmKZ?-[z)_R1r"U1$E.n~gPg;'PPm8oy,(Hj6X8bykOf_{VwZ4_[}`}0o/_},TMqO&
Pit+?iH$FXYgv(OFc|<	\D<%NQXc\o*"^(6SXE>@spqI|q?g-o],yoAX[;>%1zOZ=,o8It}mlNL*zj Y[_07mqgs!PK    mVX/  Q  /   react-app/node_modules/fraction.js/fraction.cjs<rHrm\( HEe:K.Z"V @I\7y<@!rO $%GrLOOOOv|Ro8~?cpD,[G}ssu~\boFvX7E%i/zn%2q<x/Ip9, ]&F)	*qoENVnLVN}qS0TpiGvV%$<MSg3,4Adkb[n`&Q_En	A~@X,NnDIWi%d%}I1~<a PqoY/j~3,S#2E\IFVW(Tp?xC\H2$;S2Vc r2$l}4ez,ULetZ#I&0#
"ys'GE1"v{i<GN3/VyZ@6kVqfVXK156b7G,9 +Aze}n0tBq.V>Df}>;8`tw38=OO%R<w!KN!KQ!RgD24xtq7Q(_gAqvAj2/7|*)}p
u!1`<LbX>w|j${O>u!f`{fg(B#g`Y	$AD7
|$]P	VI.$T
[w \sWg5b(xOW<uY06 2K<aTT8	
 (q|Y&qg%f)x1s >"#h\b-.lp)|mR\@f.(VyIr4288oBG/o-)19=TeR'GIy@<O?=Q{{%}#x4LXyQm;`arL9jQZ# s0o!<..,DwI!$_s;6Ek aE2Lqt\HypR3"-Za!{<ul](1<'Cr?nn@j{H%TSb0`cZ:gy0fUTRrzx*J/z!UH+#FJ;(4NlR4OXc.=i7O1P_[MDC]ei<Y?w&d(8e3gQsKLx q0KyKF_l0iUPa 	<oLg03yl2q5j]"dO)%Bo#a">Wh'a7Y/K\1Mvuzk)-(;ki	7ftnrC[4W-Do!aCtv_mddo#M%i9P0]>| L(Up=l-+,i/N.t'E^H/8vL* Z@9pi.(B^m:VItyj.{N[~l'X5N ANU5GFeRJ=6>iNkMVVo75AH<*!H\ J[I_SV.q!M4f>6mVgFVt@%\B6EhthU4?m.f  =pd1il2B|GfCVI*=lFULx<=yR	xb8n>n=L(W,J!x O3jXPT6-?*"\jD'K8)OXDBUyVJ~S/^]>9^RrH0=pRqp,'!4|\!Z-+*N)/g1C!\-PMW>CT9l <R'	8}j7jW*q6Y!Vw.#[F'jqeYHg=lqs5C%QoDQ;t+PP>>(G=wfq
r(#R~`!Y[ ;[3asg^aOh2'En+?<9`eH})?Nk1xG78)UgLc&0NXTvIp{!$gDF%I30K$?%3L,e83K^9ZpSPlr_Iq@8.LK'3\q7-'jdo3=5`Ie~@iBV9UZM&w6`h
7djMb!Nw<ft!TvJudb[UVR9v@)m|S~BT7Ch%jWe%t1),h;9H~Oq@_%8\eM	P66Q@oE7%0J6<7na;JuQ1[SNU"nH?bc1sM\qe9M?77O*Jdh:TAGFn]Eq5_Ana7\W)e/sh2,~Mhevpxe8NEh\	(B!wR0D0etQ~?H(!1HkNLw!Zs[P>A/,p.nF}..<Y>VcDq s
Zf<e5LqaZz	na+IE>y9GU\&;jD+yi@{7bu*|W+Ve[s/|~Q(NHtm10&-+wAWxt[.Yzg;vcgF1tLi~%8)'/E+:/Y7j gK0% p[([1WyFh3OQc<])e]<-_C@z*{ih;&~4%Mb-AYpY,y%$KCvKeHC wD?(pz"!)+a#rEzY P=dJgB5N5n"8A?IMgCbn<F Khuy:(8?81IRO-0l;G;g;bO(!=+J9u;m5ix'TW8kOW{%Z%?*D,Y7	kVuwm+|p=> /Z:j]yP+I_,&sOiom;&v.F]vC"%C">4ft6WvkuwzZ<DlVr]OwMpG"ED{D@N5MAxT4.Esr#aF&7LBg|,UWyu>l\.IIowHaFh8h2|wpN:a @	E%fv\M[bObag#g`M>CS^JQp2>Hj k'B}@W(gQ(UkqG]Gs~9'	+\4_kNpe0=,@$bPooi<I~ #Bw12 V{%e5+&FT\afck)tdq%P9mD Zq]!qk}ZEg"u\PAbPE DKIs9e-IrZ(dG'8:y8G~F6Gw!Or);Vm,S.,rsY?Xl%
[nSH&uy!6TEm2jfcl/S!g viqK 9~dN(DA
 F`xczUcx-W9p}R&@ 1~}/]z8CXnOrZ$%d_kUr5!q/|=3-,IT0_xDj6(|N@/4GMo2=bVeRL h{]"1~<bPQUsm	YcO1t#M,gqLVsnc
1yL\D=aA%R^V[E419VVxD_/j
bu;EUt3j`,E@Gkzcx~c8sjMl{a]T%m=nd|GvynRi	6uyQ@cg&,(v(3FWwO9Ji_KBNPCm<S]2i;^?hZ6mJplt0ACkh"6GN|>E
WAE1nZ?D?$X}"#iNGeL*>$NA3M'Mz4ky0hT^h(	1T{k=r#".z6~u%2}pJ|"D{0zc	pX{SCwK=Qo $*[n'z*2|W4G~|ZADY_> 0C	tH2$STf$^$[rDOX*^O0Yf!DsTg Wy[ J:y[ua[;
8PK    mVXP  "  0   react-app/node_modules/fraction.js/fraction.d.tsUn0?-,/Q-P=9P% "K(=@8K#"(Dl)z^5mCRo'F	^
tP5mZ5e-Bhm`=VQiIb>- fz_u~Df8gT"pRTCf4"7 =^pa#J.mgOE-N7{U /C nt.#e$UBfrPlrp.$Z'zW\)?'e2kn04{dM2(>Ajh	:i@#H7*gW %Pw>o~d.>;.;x$xd2p;*JSl_<^|;&izPK    mVXMiCi  pK  .   react-app/node_modules/fraction.js/fraction.js<rmlIdllo]Nl@`(b\ ^{{{{<u C]vm*
}gI!wC?s gyw$Nw^HnwOExB:Yb@;M9	3	R~*	MN^ q Rg>/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource, PrefixSource, RawSource } = require("webpack-sources");
const { RuntimeGlobals } = require("..");
const HotUpdateChunk = require("../HotUpdateChunk");
const Template = require("../Template");
const { getCompilationHooks } = require("./JavascriptModulesPlugin");
const {
	generateEntryStartup,
	updateHashForEntryStartup
} = require("./StartupHelpers");

/** @typedef {import("../Compiler")} Compiler */

class ArrayPushCallbackChunkFormatPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"ArrayPushCallbackChunkFormatPlugin",
			compilation => {
				compilation.hooks.additionalChunkRuntimeRequirements.tap(
					"ArrayPushCallbackChunkFormatPlugin",
					(chunk, set, { chunkGraph }) => {
						if (chunk.hasRuntime()) return;
						if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
							set.add(RuntimeGlobals.onChunksLoaded);
							set.add(RuntimeGlobals.require);
						}
						set.add(RuntimeGlobals.chunkCallback);
					}
				);
				const hooks = getCompilationHooks(compilation);
				hooks.renderChunk.tap(
					"ArrayPushCallbackChunkFormatPlugin",
					(modules, renderContext) => {
						const { chunk, chunkGraph, runtimeTemplate } = renderContext;
						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;
						const globalObject = runtimeTemplate.globalObject;
						const source = new ConcatSource();
						const runtimeModules =
							chunkGraph.getChunkRuntimeModulesInOrder(chunk);
						if (hotUpdateChunk) {
							const hotUpdateGlobal =
								runtimeTemplate.outputOptions.hotUpdateGlobal;
							source.add(
								`${globalObject}[${JSON.stringify(hotUpdateGlobal)}](`
							);
							source.add(`${JSON.stringify(chunk.id)},`);
							source.add(modules);
							if (runtimeModules.length > 0) {
								source.add(",\n");
								const runtimePart = Template.renderChunkRuntimeModules(
									runtimeModules,
									renderContext
								);
								source.add(runtimePart);
							}
							source.add(")");
						} else {
							const chunkLoadingGlobal =
								runtimeTemplate.outputOptions.chunkLoadingGlobal;
							source.add(
								`(${globalObject}[${JSON.stringify(
									chunkLoadingGlobal
								)}] = ${globalObject}[${JSON.stringify(
									chunkLoadingGlobal
								)}] || []).push([`
							);
							source.add(`${JSON.stringify(chunk.ids)},`);
							source.add(modules);
							const entries = Array.from(
								chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
							);
							if (runtimeModules.length > 0 || entries.length > 0) {
								const runtime = new ConcatSource(
									(runtimeTemplate.supportsArrowFunction()
										? `${RuntimeGlobals.require} =>`
										: `function(${RuntimeGlobals.require})`) +
										" { // webpackRuntimeModules\n"
								);
								if (runtimeModules.length > 0) {
									runtime.add(
										Template.renderRuntimeModules(runtimeModules, {
											...renderContext,
											codeGenerationResults: compilation.codeGenerationResults
										})
									);
								}
								if (entries.length > 0) {
									const startupSource = new RawSource(
										generateEntryStartup(
											chunkGraph,
											runtimeTemplate,
											entries,
											chunk,
											true
										)
									);
									runtime.add(
										hooks.renderStartup.call(
											startupSource,
											entries[entries.length - 1][0],
											{
												...renderContext,
												inlined: false
											}
										)
									);
									if (
										chunkGraph
											.getChunkRuntimeRequirements(chunk)
											.has(RuntimeGlobals.returnExportsFromRuntime)
									) {
										runtime.add(`return ${RuntimeGlobals.exports};\n`);
									}
								}
								runtime.add("}\n");
								source.add(",\n");
								source.add(new PrefixSource("/******/ ", runtime));
							}
							source.add("])");
						}
						return source;
					}
				);
				hooks.chunkHash.tap(
					"ArrayPushCallbackChunkFormatPlugin",
					(chunk, hash, { chunkGraph, runtimeTemplate }) => {
						if (chunk.hasRuntime()) return;
						hash.update(
							`ArrayPushCallbackChunkFormatPlugin1${runtimeTemplate.outputOptions.chunkLoadingGlobal}${runtimeTemplate.outputOptions.hotUpdateGlobal}${runtimeTemplate.globalObject}`
						);
						const entries = Array.from(
							chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
						);
						updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
					}
				);
			}
		);
	}
}

module.exports = ArrayPushCallbackChunkFormatPlugin;
                                                                                                                                                                                                                                                                                                       riz:yOt*shF\2UjkhvpAQ)	c
M7(k(&[2nwT
|XEV-s"E9m5gtY! H~^%Il
PK    mVX;tr  g  2   react-app/node_modules/fraction.js/fraction.min.jsXY~J2!R<4vmFzSd+ hQkt_rq_=3wMYqk;vk''$Q8}%Ry/lM!5R{<srhsE-CiUx}|_>@6o
{4uFFT$o:T{YnIbiOK?Qb)ky6Nbt Fk1YoW0q@	
c2U4L)&22Kw>{U3`mWF%_\GAk1.QyiBzF}3=N5PJO v
:Yz6:\%uW)2`VQ\4d441`r1f	^tx$+{8J2gI9s+Ph7x3wF79ZO3`lL1:K )&P@f)q|C(DaaxatpO;_y38gX]`i"_7/rkC[o++@nB'_F2dF L\vpDGWf/BC*xd)s~J}O0N'nli\ Ced-4ti%&&f5e<"UR}*
 D{0IkZTl~3ojgxOOK:QU4G
zhv')yVfAbII1i'j tX$*Z=Z:~ 4c `fl82 2g4k*nJ:BJT+urEP-|~S=Pq< <{}|$i(n="`Ap,.#0af`US ~aZG;`L< V&h%VOu	c= #LN<M7xEE]Kx*><>|  z@$K}i7j2GG@kJ<";^ O&b
4U@V.(VDz(h$PI{rgpD+Z/.0z*\gDV\e;KmdWGt	<tv/}9 P_58=pM_L&yj&&4f{%`3:S]BE?>Xm!o5Xum]7a{UFwu,vnWSSmqcqt1p.n+G4fk	BTwRTyIHH7$x1./"I:XP<8.A8h(>|1]Wxc"xveV"0-zm<BN0wpdT2  MV2"Gmdm} Ip5P&&%G]W|M}q]'R
T[e~4'Pl*9#u5m9@h	3#9fhBb1Lj,`5*/Z8(MNPN~Ul4$j*1`[ Q	2>n.lU*zmNjLo9j<IF,bk^;fB(H \O#^$	I]n[JXt[HZk6>{"`A^8`VZBH.g7`
t
]Rb)+2XSQ+ {&'gySAAO<O}>bi8lP*uErkd)[]}Wxo$?mYPK    mVX	t  .  *   react-app/node_modules/fraction.js/LICENSE]R_o08JQ7uo{3)B98SQlwBNBBl5v&w#<4hSp.@o'{xT	t;hz:z|!ntjhPd&.^puq5AxEuC,gs#PDlk#76%N@9~`Hz	6}&pB@pXTP/~\o}r73-4VrsXwF3Ym"Uhc(QV}-4}D WB_ma3|xxWp'_ +(z`+|/IV[8yaV=EYjQU42kHm&X"P	K( mNKKOJ8WJk#m5[]J|,VUF	UPy[tk6Vy&/s.M1h;H/5R#UL06D\j0Z'"LBEJ|B&x\)}PK    mVX8o    /   react-app/node_modules/fraction.js/package.jsonSMo0W>MzvvP,fk}TEaa7|6EQj+G3"#Gp5g:4[{vf[~}lNYUmd7UFmq$`t'!IzE{'_`QWCF	$GjSd9Z2'q[n:_6.:z'sro#{`2Y/N]M5?C*33kV$Ud>'xa]BQ)@HySr|*ZCX'l~'kM	|e!4L2-9<aBu78BdR35rvmdk@T(bD*" ]]6PK    mVXTeW  :  ,   react-app/node_modules/fraction.js/README.md;[Hr8E&$HOLjY9FbYd@f)|
GIU 
 wf^<2}$wgwn|+$fek)0f0\a}"qx#^t5L4R{[eT g*f0"-oH"-,x8 \U*DdH *@=fL6A82!SKI@ff!d"`c*l`bYRRqdZ"Q7L,=c/X7m{A"v|HmeBF@ LgCv~zp;oyd;UX6H^5PY9'(kQ
TGO+R{Yp^:@JITTmXR/ {D%z|Ws7  h$S<DAPj#c0 <S"]zojrK$H.RP E2_DKnxR!,b
LQdtDx<|0hXV
(^6C/woy{^`8/UK)suuhnrvD
dcVp"yb=c"3mDSxl\>j	fLhAG/Tu?n<Yf}6 jngCY Zm6-3	/Rl
kg3@BH(S"u3j{Zs,`En&eja><(Gct2:)[:-;GA}V"6MF7sJ8@MwL\=$PdIE?(P9xNpwhCVx!vxqp|!qH7cy~E(|(OrO 01.SBqnL>l+ikx}F4xg_F}\"7_rdBdC"L)U$;gvz<OFpr2 ZgDt:F?co5Gq`#}c)O>;;MO!\p~Tv9^;es%Uqb.Cv,,fNz\0q\6s
:ABK%dT`"{3neW<Z)EX"Tk`Z9Sa0$u:=me}b/ALa!Ky.u:10oy~x}/QKl#.i~o>1Q-i/;8}|jh~sb.k
\~o\mx6t=u=m@>kAOZOm?}gzjCci;%l}A	0hl;-h4(9g-h?C0h<Q==iENo;KH3tq_
* yz y#tIv \GWv&;O|B||6{>>l.oXuX@ikyq;v {k?&CexPsto0_1Ab~B%D':RpJ{ DG	S$<5u_N 'nlx%PYEV#3@;.0obH5?XkZl@*B\QYQ).*T!$"zH9w
$ZaA|[0)0Wtja t>uNC,q
haN%Y}VdPJ,eHqZR%1%-(2*iPl@D[
b7Mc T;Vo2(kdT=;]{y|g7|Xy=l>_-:`Rx3@3("`2=jC0)ZhSoF(F3Gpp7mfi !zkQ)&-ZTbw g`vOA2E~C,:E>! tVk05Xqb!*` 7 'BH
nwb^`."nfbqkphx6,p#M`p?W.)bCz=pc@lljyJ%vC%3Av^9(G AZ4&64K*Y:JB}5hLVNNL<mSIU
~"!M-J
/mDj3HL,*j WWcY22_qM5pyV n/KMJ?eL'd`RT
={|H1"].vU!d \z>P[F?bumW3>#L+gFva "jtvNgUWo'Uh}efQeN}2SOR#llPt<K=ZE	I7PTdL*n`+{:>xc2PiWl2:w49`PKSqb6%M( U<!?<yVoK?hx	!Ny"+	-kUIO.tAexe3o2~;NN]jR5w	\ONG.mSqE-m,'Z#-fHs-~6v_)+7LpTee+G;qkLAk ooGe
Xt ck|5.R(Pzs3MitFK1%O@o6.Ys6bZf
}-mU7p3zYin^K6Fvzbv9kB}*},coB1Y5{i!dqh42vka]6D]Dh1e]0_JJ:xf jR41<86JH(kI
%tQ.
 ~rqE>oS:fs)?gWWLg-:, tvk&If6e*r2+hW0se",:n
AfK]b)=Wtp"_A3Tr}GyZo&(|QjV\q&+Upp^cPcH"t /tinBWbH&K\Z/0jXd7,U1vOX1OlcVVxT RaJJ#2v^a%X",XhW%1dp
89zg3S7u.uSlj1S3n Cb%}b="XA]9fs9x&%ue+#J#:-Y6xU}05&@8007Fo/{>	#N-Qy
B VKH-	rj4O>CmQTk{*0/#PS	LSh-VuK.4*2,P8%8sU;Xo!%(@Cm#?	.vF4W0%P{c3^.w;dWh^0{4D5f{9Us[6vY>PPLV*r-LEcs$0qnQ}lt(u
V{UmN4askd+\m.[{
J9nQR+79lzuwE"l^056-:P 7*cD5]]8U}"AYSmM'6B~\;=sHLuX7:?;cM32gw!WSD5aL +"kdtYRx,/Y7@TXCmFnl'7`*(]Xh[4	IqaxT2Ft(:$PH.c^(V27j=:<3mM[39Ru.xHFq!6d*K<'XcW<%FY;f5'90bx09*1a{uE=F8bKj"]DG;kL1mH9R+	}	*$B]X	iVqv?RMgg\#|KA>UxDiTEf/)k]Kg[O"7K&Qx|tliqw.uO&gLT<+b$]u;""dP}/|&
zqqxaN&R%t1jkn_ ]y4X:W0Q#N/]ADQsA44-y{#2<oZi=BFd@d/b_L)sZH`v*#(B_&|nG7= {Ull 7>X\a)"yUcw98=iOIzKNopN
,~#x?}_9Q8#g???7}!I`jm-jknbB>k_MeTL4'x^)(P/5]`A
0J)E-%(@F*@K S9-f@A<%5	H
xp"<4t9ld$9dM##c$W`K&ihQb9g\S PK
     mVX            #   react-app/node_modules/fs.realpath/PK    mVX(z    +   react-app/node_modules/fs.realpath/index.jsTMs W3{121T+B
DT{!Hj%vXyI	"JBd"p1S==FZs";=7;RJ&AG$
se.oGl<URx"3c"%WJ3"EjF}hq%3M""R0 z=aKQ
qC\49x2Jh9v<(cb 8_3vCWvxnh! <:N ;T`%kLmKT9QnRw`~|~@$|q0vZ#L?%d>bND$|71V1l\v^0]/[~.?PK    mVX,  M  *   react-app/node_modules/fs.realpath/LICENSEMo6\Tw{i,iz,(rPc/vQ Ut5c/6|~=A;(buv'^GPxW6~04t^Xvu8jhhxue7:7SPfX3JW}KmI~XUs]}Kx2b*N*IB'Yl k}.RNd:x.bymEo?D!JPj @|ijCAn4=
H$LN'E\D?B8Kk|$!r*9VIAWy$S$J`^prXFYJ9)H:k`]d9\*dJ1R1F_X5l\.p8wu=]{r/%t;i>/~VV;'?~}H8U{%/17jp4gd53Z,z\W}An7<:IJUGlZ<O< BhOVP|Bu@&#M+C&T%ZH:91 t
Ck|->L&YeCa4pV=-zU0^_u5C(AW*(Gc`zBo_pO(|%
@Cn`iV p]qUtWV	a=>H}MTH0Da5uM,EJ>W2{(J:?I%d8}~d-Kg=K|PK    mVX"Pv
  ^!  )   react-app/no"use strict";

const os = require("os");
const path = require("path");
const url = require("url");
const util = require("util");
const fs = require("graceful-fs");
const ipaddr = require("ipaddr.js");
const { validate } = require("schema-utils");
const schema = require("./options.json");

/** @typedef {import("schema-utils/declarations/validate").Schema} Schema */
/** @typedef {import("webpack").Compiler} Compiler */
/** @typedef {import("webpack").MultiCompiler} MultiCompiler */
/** @typedef {import("webpack").Configuration} WebpackConfiguration */
/** @typedef {import("webpack").StatsOptions} StatsOptions */
/** @typedef {import("webpack").StatsCompilation} StatsCompilation */
/** @typedef {import("webpack").Stats} Stats */
/** @typedef {import("webpack").MultiStats} MultiStats */
/** @typedef {import("os").NetworkInterfaceInfo} NetworkInterfaceInfo */
/** @typedef {import("express").Request} Request */
/** @typedef {import("express").Response} Response */
/** @typedef {import("express").NextFunction} NextFunction */
/** @typedef {import("express").RequestHandler} ExpressRequestHandler */
/** @typedef {import("express").ErrorRequestHandler} ExpressErrorRequestHandler */
/** @typedef {import("chokidar").WatchOptions} WatchOptions */
/** @typedef {import("chokidar").FSWatcher} FSWatcher */
/** @typedef {import("connect-history-api-fallback").Options} ConnectHistoryApiFallbackOptions */
/** @typedef {import("bonjour-service").Bonjour} Bonjour */
/** @typedef {import("bonjour-service").Service} BonjourOptions */
/** @typedef {import("http-proxy-middleware").RequestHandler} RequestHandler */
/** @typedef {import("http-proxy-middleware").Options} HttpProxyMiddlewareOptions */
/** @typedef {import("http-proxy-middleware").Filter} HttpProxyMiddlewareOptionsFilter */
/** @typedef {import("serve-index").Options} ServeIndexOptions */
/** @typedef {import("serve-static").ServeStaticOptions} ServeStaticOptions */
/** @typedef {import("ipaddr.js").IPv4} IPv4 */
/** @typedef {import("ipaddr.js").IPv6} IPv6 */
/** @typedef {import("net").Socket} Socket */
/** @typedef {import("http").IncomingMessage} IncomingMessage */
/** @typedef {import("open").Options} OpenOptions */

/** @typedef {import("https").ServerOptions & { spdy?: { plain?: boolean | undefined, ssl?: boolean | undefined, 'x-forwarded-for'?: string | undefined, protocol?: string | undefined, protocols?: string[] | undefined }}} ServerOptions */

/**
 * @template Request, Response
 * @typedef {import("webpack-dev-middleware").Options<Request, Response>} DevMiddlewareOptions
 */

/**
 * @template Request, Response
 * @typedef {import("webpack-dev-middleware").Context<Request, Response>} DevMiddlewareContext
 */

/**
 * @typedef {"local-ip" | "local-ipv4" | "local-ipv6" | string} Host
 */

/**
 * @typedef {number | string | "auto"} Port
 */

/**
 * @typedef {Object} WatchFiles
 * @property {string | string[]} paths
 * @property {WatchOptions & { aggregateTimeout?: number, ignored?: WatchOptions["ignored"], poll?: number | boolean }} [options]
 */

/**
 * @typedef {Object} Static
 * @property {string} [directory]
 * @property {string | string[]} [publicPath]
 * @property {boolean | ServeIndexOptions} [serveIndex]
 * @property {ServeStaticOptions} [staticOptions]
 * @property {boolean | WatchOptions & { aggregateTimeout?: number, ignored?: WatchOptions["ignored"], poll?: number | boolean }} [watch]
 */

/**
 * @typedef {Object} NormalizedStatic
 * @property {string} directory
 * @property {string[]} publicPath
 * @property {false | ServeIndexOptions} serveIndex
 * @property {ServeStaticOptions} staticOptions
 * @property {false | WatchOptions} watch
 */

/**
 * @typedef {Object} ServerConfiguration
 * @property {"http" | "https" | "spdy" | string} [type]
 * @property {ServerOptions} [options]
 */

/**
 * @typedef {Object} WebSocketServerConfiguration
 * @property {"sockjs" | "ws" | string | Function} [type]
 * @property {Record<string, any>} [options]
 */

/**
 * @typedef {(import("ws").WebSocket | import("sockjs").Connection & { send: import("ws").WebSocket["send"], terminate: import("ws").WebSocket["terminate"], ping: import("ws").WebSocket["ping"] }) & { isAlive?: boolean }} ClientConnection
 */

/**
 * @typedef {import("ws").WebSocketServer | import("sockjs").Server & { close: import("ws").WebSocketServer["close"] }} WebSocketServer
 */

/**
 * @typedef {{ implementation: WebSocketServer, clients: ClientConnection[] }} WebSocketServerImplementation
 */

/**
 * @callback ByPass
 * @param {Request} req
 * @param {Response} res
 * @param {ProxyConfigArrayItem} proxyConfig
 */

/**
 * @typedef {{ path?: HttpProxyMiddlewareOptionsFilter | undefined, context?: HttpProxyMiddlewareOptionsFilter | undefined } & { bypass?: ByPass } & HttpProxyMiddlewareOptions } ProxyConfigArrayItem
 */

/**
 * @typedef {(ProxyConfigArrayItem | ((req?: Request | undefined, res?: Response | undefined, next?: NextFunction | undefined) => ProxyConfigArrayItem))[]} ProxyConfigArray
 */

/**
 * @typedef {{ [url: string]: string | ProxyConfigArrayItem }} ProxyConfigMap
 */

/**
 * @typedef {Object} OpenApp
 * @property {string} [name]
 * @property {string[]} [arguments]
 */

/**
 * @typedef {Object} Open
 * @property {string | string[] | OpenApp} [app]
 * @property {string | string[]} [target]
 */

/**
 * @typedef {Object} NormalizedOpen
 * @property {string} target
 * @property {import("open").Options} options
 */

/**
 * @typedef {Object} WebSocketURL
 * @property {string} [hostname]
 * @property {string} [password]
 * @property {string} [pathname]
 * @property {number | string} [port]
 * @property {string} [protocol]
 * @property {string} [username]
 */

/**
 * @typedef {boolean | ((error: Error) => void)} OverlayMessageOptions
 */

/**
 * @typedef {Object} ClientConfiguration
 * @property {"log" | "info" | "warn" | "error" | "none" | "verbose"} [logging]
 * @property {boolean  | { warnings?: OverlayMessageOptions, errors?: OverlayMessageOptions, runtimeErrors?: OverlayMessageOptions }} [overlay]
 * @property {boolean} [progress]
 * @property {boolean | number} [reconnect]
 * @property {"ws" | "sockjs" | string} [webSocketTransport]
 * @property {string | WebSocketURL} [webSocketURL]
 */

/**
 * @typedef {Array<{ key: string; value: string }> | Record<string, string | string[]>} Headers
 */

/**
 * @typedef {{ name?: string, path?: string, middleware: ExpressRequestHandler | ExpressErrorRequestHandler } | ExpressRequestHandler | ExpressErrorRequestHandler} Middleware
 */

/**
 * @typedef {Object} Configuration
 * @property {boolean | string} [ipc]
 * @property {Host} [host]
 * @property {Port} [port]
 * @property {boolean | "only"} [hot]
 * @property {boolean} [liveReload]
 * @property {DevMiddlewareOptions<Request, Response>} [devMiddleware]
 * @property {boolean} [compress]
 * @property {boolean} [magicHtml]
 * @property {"auto" | "all" | string | string[]} [allowedHosts]
 * @property {boolean | ConnectHistoryApiFallbackOptions} [historyApiFallback]
 * @property {boolean | Record<string, never> | BonjourOptions} [bonjour]
 * @property {string | string[] | WatchFiles | Array<string | WatchFiles>} [watchFiles]
 * @property {boolean | string | Static | Array<string | Static>} [static]
 * @property {boolean | ServerOptions} [https]
 * @property {boolean} [http2]
 * @property {"http" | "https" | "spdy" | string | ServerConfiguration} [server]
 * @property {boolean | "sockjs" | "ws" | string | WebSocketServerConfiguration} [webSocketServer]
 * @property {ProxyConfigMap | ProxyConfigArrayItem | ProxyConfigArray} [proxy]
 * @property {boolean | string | Open | Array<string | Open>} [open]
 * @property {boolean} [setupExitSignals]
 * @property {boolean | ClientConfiguration} [client]
 * @property {Headers | ((req: Request, res: Response, context: DevMiddlewareContext<Request, Response>) => Headers)} [headers]
 * @property {(devServer: Server) => void} [onAfterSetupMiddleware]
 * @property {(devServer: Server) => void} [onBeforeSetupMiddleware]
 * @property {(devServer: Server) => void} [onListening]
 * @property {(middlewares: Middleware[], devServer: Server) => Middleware[]} [setupMiddlewares]
 */

if (!process.env.WEBPACK_SERVE) {
  // TODO fix me in the next major release
  // @ts-ignore
  process.env.WEBPACK_SERVE = true;
}

/**
 * @template T
 * @param fn {(function(): any) | undefined}
 * @returns {function(): T}
 */
const memoize = (fn) => {
  let cache = false;
  /** @type {T} */
  let result;

  return () => {
    if (cache) {
      return result;
    }

    result = /** @type {function(): any} */ (fn)();
    cache = true;
    // Allow to clean up memory for fn
    // and all dependent resources
    // eslint-disable-next-line no-undefined
    fn = undefined;

    return result;
  };
};

const getExpress = memoize(() => require("express"));

/**
 *
 * @param {OverlayMessageOptions} [setting]
 * @returns
 */
const encodeOverlaySettings = (setting) =>
  typeof setting === "function"
    ? encodeURIComponent(setting.toString())
    : setting;

class Server {
  /**
   * @param {Configuration | Compiler | MultiCompiler} options
   * @param {Compiler | MultiCompiler | Configuration} compiler
   */
  constructor(options = {}, compiler) {
    // TODO: remove this after plugin support is published
    if (/** @type {Compiler | MultiCompiler} */ (options).hooks) {
      util.deprecate(
        () => {},
        "Using 'compiler' as the first argument is deprecated. Please use 'options' as the first argument and 'compiler' as the second argument.",
        "DEP_WEBPACK_DEV_SERVER_CONSTRUCTOR"
      )();

      [options = {}, compiler] = [compiler, options];
    }

    validate(/** @type {Schema} */ (schema), options, {
      name: "Dev Server",
      baseDataPath: "options",
    });

    this.compiler = /** @type {Compiler | MultiCompiler} */ (compiler);
    /**
     * @type {ReturnType<Compiler["getInfrastructureLogger"]>}
     * */
    this.logger = this.compiler.getInfrastructureLogger("webpack-dev-server");
    this.options = /** @type {Configuration} */ (options);
    /**
     * @type {FSWatcher[]}
     */
    this.staticWatchers = [];
    /**
     * @private
     * @type {{ name: string | symbol, listener: (...args: any[]) => void}[] }}
     */
    this.listeners = [];
    // Keep track of websocket proxies for external websocket upgrade.
    /**
     * @private
     * @type {RequestHandler[]}
     */
    this.webSocketProxies = [];
    /**
     * @type {Socket[]}
     */
    this.sockets = [];
    /**
     * @private
     * @type {string | undefined}
     */
    // eslint-disable-next-line no-undefined
    this.currentHash = undefined;
  }

  // TODO compatibility with webpack v4, remove it after drop
  static get cli() {
    return {
      get getArguments() {
        return () => require("../bin/cli-flags");
      },
      get processArguments() {
        return require("../bin/process-arguments");
      },
    };
  }

  static get schema() {
    return schema;
  }

  /**
   * @private
   * @returns {StatsOptions}
   * @constructor
   */
  static get DEFAULT_STATS() {
    return {
      all: false,
      hash: true,
      warnings: true,
      errors: true,
      errorDetails: false,
    };
  }

  /**
   * @param {string} URL
   * @returns {boolean}
   */
  static isAbsoluteURL(URL) {
    // Don't match Windows paths `c:\`
    if (/^[a-zA-Z]:\\/.test(URL)) {
      return false;
    }

    // Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
    // Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
    return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(URL);
  }

  /**
   * @param {string} gateway
   * @returns {string | undefined}
   */
  static findIp(gateway) {
    const gatewayIp = ipaddr.parse(gateway);

    // Look for the matching interface in all local interfaces.
    for (const addresses of Object.values(os.networkInterfaces())) {
      for (const { cidr } of /** @type {NetworkInterfaceInfo[]} */ (
        addresses
      )) {
        const net = ipaddr.parseCIDR(/** @type {string} */ (cidr));

        if (
          net[0] &&
          net[0].kind() === gatewayIp.kind() &&
          gatewayIp.match(net)
        ) {
          return net[0].toString();
        }
      }
    }
  }

  /**
   * @param {"v4" | "v6"} family
   * @returns {Promise<string | undefined>}
   */
  static async internalIP(family) {
    try {
      const { gateway } = await require("default-gateway")[family]();
      return Server.findIp(gateway);
    } catch {
      // ignore
    }
  }

  /**
   * @param {"v4" | "v6"} family
   * @returns {string | undefined}
   */
  static internalIPSync(family) {
    try {
      const { gateway } = require("default-gateway")[family].sync();
      return Server.findIp(gateway);
    } catch {
      // ignore
    }
  }

  /**
   * @param {Host} hostname
   * @returns {Promise<string>}
   */
  static async getHostname(hostname) {
    if (hostname === "local-ip") {
      return (
        (await Server.internalIP("v4")) ||
        (await Server.internalIP("v6")) ||
        "0.0.0.0"
      );
    } else if (hostname === "local-ipv4") {
      return (await Server.internalIP("v4")) || "0.0.0.0";
    } else if (hostname === "local-ipv6") {
      return (await Server.internalIP("v6")) || "::";
    }

    return hostname;
  }

  /**
   * @param {Port} port
   * @param {string} host
   * @returns {Promise<number | string>}
   */
  static async getFreePort(port, host) {
    if (typeof port !== "undefined" && port !== null && port !== "auto") {
      return port;
    }

    const pRetry = require("p-retry");
    const getPort = require("./getPort");
    const basePort =
      typeof process.env.WEBPACK_DEV_SERVER_BASE_PORT !== "undefined"
        ? parseInt(process.env.WEBPACK_DEV_SERVER_BASE_PORT, 10)
        : 8080;

    // Try to find unused port and listen on it for 3 times,
    // if port is not specified in options.
    const defaultPortRetry =
      typeof process.env.WEBPACK_DEV_SERVER_PORT_RETRY !== "undefined"
        ? parseInt(process.env.WEBPACK_DEV_SERVER_PORT_RETRY, 10)
        : 3;

    return pRetry(() => getPort(basePort, host), {
      retries: defaultPortRetry,
    });
  }

  /**
   * @returns {string}
   */
  static findCacheDir() {
    const cwd = process.cwd();

    /**
     * @type {string | undefined}
     */
    let dir = cwd;

    for (;;) {
      try {
        if (fs.statSync(path.join(dir, "package.json")).isFile()) break;
        // eslint-disable-next-line no-empty
      } catch (e) {}

      const parent = path.dirname(dir);

      if (dir === parent) {
        // eslint-disable-next-line no-undefined
        dir = undefined;
        break;
      }

      dir = parent;
    }

    if (!dir) {
      return path.resolve(cwd, ".cache/webpack-dev-server");
    } else if (process.versions.pnp === "1") {
      return path.resolve(dir, ".pnp/.cache/webpack-dev-server");
    } else if (process.versions.pnp === "3") {
      return path.resolve(dir, ".yarn/.cache/webpack-dev-server");
    }

    return path.resolve(dir, "node_modules/.cache/webpack-dev-server");
  }

  /**
   * @private
   * @param {Compiler} compiler
   * @returns bool
   */
  static isWebTarget(compiler) {
    // TODO improve for the next major version - we should store `web` and other targets in `compiler.options.environment`
    if (
      compiler.options.externalsPresets &&
      compiler.options.externalsPresets.web
    ) {
      return true;
    }

    if (
      compiler.options.resolve.conditionNames &&
      compiler.options.resolve.conditionNames.includes("browser")
    ) {
      return true;
    }

    const webTargets = [
      "web",
      "webworker",
      "electron-preload",
      "electron-renderer",
      "node-webkit",
      // eslint-disable-next-line no-undefined
      undefined,
      null,
    ];

    if (Array.isArray(compiler.options.target)) {
      return compiler.options.target.some((r) => webTargets.includes(r));
    }

    return webTargets.includes(/** @type {string} */ (compiler.options.target));
  }

  /**
   * @private
   * @param {Compiler} compiler
   */
  addAdditionalEntries(compiler) {
    /**
     * @type {string[]}
     */
    const additionalEntries = [];
    const isWebTarget = Server.isWebTarget(compiler);

    // TODO maybe empty client
    if (this.options.client && isWebTarget) {
      let webSocketURLStr = "";'use strict'

const assert = require('chai').assert
const proxyquire = require('proxyquire')
const spooks = require('spooks')

const modulePath = '../../src/read'

suite('read:', () => {
  test('require does not throw', () => {
    assert.doesNotThrow(() => {
      require(modulePath)
    })
  })

  test('require returns function', () => {
    assert.isFunction(require(modulePath))
  })

  suite('require:', () => {
    let log, results, read

    setup(() => {
      log = {}
      results = {
        parse: [ {} ],
        createReadStream: [ {} ]
      }
      read = proxyquire(modulePath, {
        fs: {
          createReadStream: spooks.fn({
            name: 'createReadStream',
            log: log,
            results: results.createReadStream
          })
        },
        './parse': spooks.fn({
          name: 'parse',
          log: log,
          results: results.parse
        })
      })
    })

    test('read expects two arguments', () => {
      assert.lengthOf(read, 2)
    })

    test('read does not throw', () => {
      assert.doesNotThrow(() => {
        read()
      })
    })

    test('parse was not called', () => {
      assert.strictEqual(log.counts.parse, 0)
    })

    test('fs.createReadStream was not called', () => {
      assert.strictEqual(log.counts.createReadStream, 0)
    })

    suite('read:', () => {
      let path, options, result

      setup(() => {
        path = {}
        options = { foo: 'bar', ndjson: true }
        result = read(path, options)
      })

      test('fs.createReadStream was called once', () => {
        assert.strictEqual(log.counts.createReadStream, 1)
      })

      test('fs.createReadStream was called correctly', () => {
        assert.lengthOf(log.args.createReadStream[0], 2)
        assert.strictEqual(log.args.createReadStream[0][0], path)
        assert.lengthOf(Object.keys(log.args.createReadStream[0][0]), 0)
        assert.strictEqual(log.args.createReadStream[0][1], options)
        assert.lengthOf(Object.keys(log.args.createReadStream[0][1]), 2)
      })

      test('parse was called once', () => {
        assert.strictEqual(log.counts.parse, 1)
      })

      test('parse was called correctly', () => {
        assert.isUndefined(log.these.parse[0])
        assert.lengthOf(log.args.parse[0], 2)
        assert.strictEqual(log.args.parse[0][0], results.createReadStream[0])
        assert.lengthOf(Object.keys(log.args.parse[0][0]), 0)
        assert.notStrictEqual(log.args.parse[0][1], options)
        assert.deepEqual(log.args.parse[0][1], { foo: 'bar', ndjson: false })
      })

      test('parse result was returned', () => {
        assert.strictEqual(result, results.parse[0])
      })
    })
  })
})
                                                                                                                                                                                                                                                                                                                                                                    Wp3ru~+#Y)wHo@yBMCkPK    mVX"}  9  6   react-app/node_modules/function.prototype.name/LICENSE]RK0W8Jq7m#'r4C\h}gVBB355c#c?LGxhO_Z3Bf[J;\v8NfMAhg;C4nt4(p2H|f8	7 M$6CDX<"5s#	.a!N!<wr7CK3o]GvuZGKfr|;;wY?BmE:'quiDI;cZ+&R;?J?wZ^z3p.g"p'Tj] +(!Wb^aH`'Lmk	zjwY?K-
frSR`Oi]+~?a$J6B|)sYuAkCu-m5[]J
iY5('TX@<')^?HU9!SJ`s)_U
C9V|RY.`	j_ZKUPT2~d%ZVV:fV.\o+F+sLOPK    nVX`   
  ;   react-app/node_modules/function.prototype.name/package.jsonVmO6Znagw=KE{r&s/J%3wwgxd0kUV1il!b`,<l$y*mWm
n\gyWEYs!YP%`Akk,+Ggjcg`s#5rh|Ll9F
|#uhEB`w6cAZn4<0T jPF(gVNUHvH0%1"+'% ESU2J:R+$6MR*K`D26k>2'7@dB?['6a#YpSZ2; s0T+%zJ$5*]?5!ScE(;%lujZw4*A~M|(_|zb&{VBpfUw$tFnW{B_r)3,SKjo		V8mipmE}sA;l;Ieawo2kP|[?K!/Q:T._KI8j_l&_  yo6u.&lyK+>/t#&(u0Mg ]o]I9>]g=M g4agPy?U8u=]uezOrcMm!vmh6
Kv~r,:|^n>R(u`n'k_|d3}|b)bA"aH<@dkEv='leDYNq+*ki#64OFOt+nR8<-pt(X$v'^d'+0Z0Awt*g9)=?##vn]q~[K9B0Go>E:SLq(UD _% =hs?^mPK    mVX#lh      :   react-app/node_modules/function.prototype.name/polyfill.js]A0D/Te,9IqlBgF,2}6)
./Kv	Qoy>WQF~aoPK    nVXlWT  
  8   react-app/node_modules/function.prototype.name/README.mdVmo6_qnd#sYb}1hDj$%w ywJKAJ%4AuU^.~Zm&)[."\~J&&-hCMefQ`nxFy3"R$7"4Ai8q+/yWf @,(sNIXxAZ77P0tpDk)}Vv4`Yq4P0blL\IQ0tk< 7L1*yw4~@re1X0w_}^v3cJ=T		}1Clz1JKyIEL79`q,Hny8c2:G+uNS~Xxu:0{Zij64OtwOISZ3e5S;4~`-eNPXw/;&XxrwUYPd	&FLmB*k2aF*
SsO>:lcGB0N$s0v9qhQw=Z/LM*bOPqFs&D)joZ6W\y`Z,z28u{(>l2g|DozD%3lh#c(.}T3&$b#NY
_|Dw"5aR"]'bA3f	A|6
;D`T4CgNyZ$[$wf86%J#x2BUYuzUM68@@=mF{ NEt` A~R8SV[V5KZph;^FXH)7[FU3Ej{3MxpG=|Lv>'? xyvwUF6K/e?PK    nVXp$    6   react-app/node_modules/function.prototype.name/shim.jsur0QzE[:c_ qt I7@zo[Q@FViDzU!Z"A6!;D!5E%j+Wo&`4M^\'kD t/t6CY
/vVL-l'#Z7ye:$;#mn}	EPSiAm?^"3}41i@_kf#wj2	ut+k7XnXVnZlmk!3!*m|b#'kN9!>/^%;G{Wo<PK
     nVX            7   react-app/node_modules/function.prototype.name/.github/PK    nVXz  R  B   react-app/node_modules/function.prototype.name/.github/FUNDING.yml}j1>/'R"ID$I}n@gf&aDP!&9$WkrQp(Z.UCB+0f118e`nB8|ph8PY.o>lmr$
T7Z^%<%Cq~,rp30TaP^+vxju"U/`H@ pE#uYt;5]PK
     mVX            7   react-app/node_modules/function.prototype.name/helpers/PK    mVXa^   b   L   react-app/node_modules/function.prototype.name/helpers/functionsHaveNames.js10=[|D:n$hZ9/?b4_{kI-!0w<8~DweipPK
     nVX            4   react-app/node_modules/function.prototype.name/test/PK    mVXX/n'  }  E   react-app/node_modules/function.prototype.name/test/implementation.jsRN08&;U0bAbdbpjp;UU;%%1Yl:zZV;G)XFsm;%YH<%q))^EHKDCS%<P
v6C8WVWLH?~7~]zHF[UDeZ
naQGw$^Ayd2wb[S/A\!ecPNwwI?+mz! 9x ^I	PK    mVX[[\     <   react-app/node_modules/function.prototype.name/test/index.jsj0),'k?S6AJRS	j>3uk'gJHaYV+bE1a|Z,L
5`qAIS3<lz|)Xg?[}B5>u7c1y?C )4Aq{k1xm	i tu![ZTpJ Yk/ PK    nVXw3&  t  >   react-app/node_modules/function.prototype.name/test/shimmed.jsPN0>oOa!4;7@:W$R5U5x=gN72!'WZ	?K1+9,?mFb6b9CbGM_X;71Z[Lv<ob#XE4K4,_YQ&-n+v36]pu)g?6PM)t*z]6p(i#2Cj7_J~"gO
" sNM[vx
/PK    nVXJF     <   react-app/node_modules/function.prototype.name/test/tests.jsWM6=bb#qKEQ@ L[jdYDY6Cbq8q8t]QB}+},kv6.p:4 \C}1.IU*bv\:S^lN"u8ldN?k'h#G/ kc-]=M
pi
\UTD1!c^nO?YkqM[FL'+*<gefaU	JUn 3#;0E4%u0~\0}:^Zr|'Sb7j#(.|ioF^dC	-y>:%{M-}wzu2x|4rjuUyWw1_}_A})NT\taXqY:pFeX+(	1.,Xw
{LG|XhmSuJ2]?d4A"K<{gt||cMG|90o]MZ Tdy.9W
Q^PBi.p	?]pLb,J3kjny
2ybbH~(13R'!pFm51s6flavqC'gMM_b6x#]jW$4o,vqe ve{c3OyCgPi!#meiti[-9>q]qZEvv4IJINmD%YuK>wUL/	f4 =Z6We^>IgzL'i(Sg)5x[}U[m'f3_2!5;9[zet9<PK    nVXmQ   P  ?   react-app/node_modules/function.prototype.name/test/uglified.jsUN0SN[
=qdk,9N3iBP8F0<@2Y@\?`kMYamz4rXXJ+iB~>L7VPX'>2L5R!  /5avGiq'Nvz6un\dE6PK
     mVX            ,   react-app/node_modules/functions-have-names/PK    mVX3E     9   react-app/node_modules/functions-have-names/.editorconfigu
0y"R<]M7l&E=sg-']B{@*Xz:%Ge,Ji4H6Zr"a
vXKv
C(
EzHHIZ];4@G<Bj]Ws'o)ZPK    mVXS      5   react-app/node_modules/functions-have-names/.eslintrcu0E+*U"#Q1Ai*9;nX0e4Zv|1!	sOP9+{vvO>tGONp1l8$AHD~N+E7?0&-ki1z]PK    mVX)&Ql      2   react-app/node_modules/functions-have-names/.nycrc=A0+*(,T8w8fG
D4vAyC!.IaKI8Y[^}=K?B!9:1PK    mVX) 
  %   8   react-app/node_modules/functions-have-names/CHANGELOG.mdY[~_A/Y~i^jNj4Y1Dv3$wW[P9s7|R}56 *jhaWk8T5=Jm<0`H\_\*.P]xa7uyKw ]_vm./ idpPp{`nMr%Iuub-~r]SMG~O8z~C!uY*X1~bU]o^3%CA	}p~YP4
~WxqM{/M|i7UnQomnUUZRC(IddqZ#AC,3@latHc{& 2#,3}<%Yc0}L)mhs~L0Q7a>k~A6Ul.7]N2ehmLZ^
Qq2'k,ODJqxo>S5-5Nn|w_G:,tAs@P
r/>?=d\O!~8C6in@Re3xpMdq+A%Ls#TICBVZK28|&fy& k`G	QqHR7qgmpb39iD)c !Fe(+>glldj3F LP+PhN)tFDm s>v8yXDu8+E&jo@0hd<H`h 1bJs
JJ\>*E2.ud (aDdeT4iYR[Hb5q #y>c\'qH|r"?%SMIB^@3GC6+p'v'RdAg>T:a9
<IMDm!d=rGcIl)	%S6%\VH^|0?$Mz"PouQo9:ad e +T&hUo5`^$j <d\3F26)#RB::zv8jGi~?$ 
o&G7}TSV4$)cm}\d8@Xgd@eVJFI,yTAyOI.r6;N8Pz93Fa@i*q&TJ3OuL!`*MVjq`g7E,l34gt.QF,8DG	@Tbm3#zbH>!V	_NN9O{rjW&Wt6\8!T@,=UE.U^\*t[Y:5v1lxyA+eA*YD>_B	>>%Lt4&zK&t!RjGz?D0r>LVi1<D;d2)hRSCl#b
kn	~Y1;IxHSjg	IXT"
ME`#EFM|fim1cORde%7q-;b1<,30Qd!Hj>b9s"Sxb7b~J,Y+c.qf&qx$(XYiLrvG<:u'/L1%&~ANq"mH;t2pO'[IU'RL  \%"hZTI<wQQF3ya}=
VfsXcm$LIF5m|kR(k-=3@KjEIL/PCs'A54hp8ST6rVg}1x0! SoI/K6ztQs-P1
.?HmA9'^9Tt.xlG %KO2 3;,__=9!I*ZWi]3fX$!L/Ps%]&B5cXHXSHEEGc2m7Zc'>{^!VT&RKISykO\UN3'fM)^-B/S:wzy|W4FH4%1h2"2s4,PK    mVXWcyU    4   react-app/node_modules/functions-have-names/index.jsOO@41	dmb{7(JwTwwgKYdkZ1cdf*%GgcqMyM%m8S
!IKrffhrUlgfj1
HBza4p3Ll:7J  .k:z7{%H\)hnqB-<[&m~u-g}`H7I+K}(zKNxJ:/C(:eH	#Y4'9~6JN~1PK    mVXQ.v  /  3   react-app/node_modules/functions-have-names/LICENSE]RK0Wrqko8[!Ms4`+#ic6v+E<3k-o0&$gc>YrZ5T`<NA	NktrG@8k`l#(Pd!\8vF!Tz0jX7q!-0K }p	.}poOdn
I/^'N7CKMn/>E&1i"`[fs\huI'(Loqe/X&{:;&&_	iZ[Cvj!4AoC]\'>l'bdk3^%M.ves Z;/J!	VgXeZ2^>qo(xd[&tM97BJv5CiK^n$-+'T:E{A*y(25Cgt]W)o>%E>g(2HEH|&R6o=YT:.d#6!q	JW."2F#8F??PK    mVXN"w    8   react-app/node_modules/functions-have-names/package.jsonTO0L
+(0cH	&bmlMKb{>;I[u{yJDK
JL!0&0mwX VN4 sDvJU1lQfjVl]`mtRp'l+`Q-JTCSaUlwY6`Tb}uZbu:+JuVWY)E>pqysii'MN'RLN,drMX
|N,l!oD	Vu~'ZKDNp s$^NW>T466>"udt.[#f!mF2X>wQ:mg6urAjGBK'=evi^70mMO'v'%3T[(v&H}SO*:zB[xX"OD-sPk%>PDl6nQD9'`r	AZYiJ~KJcgo3&b|G!q{=uI;?`{|< [gpGot]TG+5X7.Jpl-PK    mVX:  f  5   react-app/node_modules/functions-have-names/README.mdUMo0Wp@m6C, Pa[&G#i{Gfd6(hIKfV3;r.
lZ,/#Eh;#%a<>UH~#3L:*-:LZLE>~f7a{<V6C!3i	R(+_wd%ZgT({%)fGK-!I,?QFjZav1N]@6x-o%\K$Yg!Jiu/#9Pd)&C(BQw0yC0RAIS<$L}$hOj49qU$l1RKyZ_Go#lZ<yhDfCs[?+_0}=&-H5(pXv8Q}R^cL\FQ#R"PE!H_-1OSMT}nU!>!Rs"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("ajv/dist/compile/codegen");
const _util_1 = require("./_util");
const error = {
    message: ({ params: { missingPattern } }) => (0, codegen_1.str) `should have property matching pattern '${missingPattern}'`,
    params: ({ params: { missingPattern } }) => (0, codegen_1._) `{missingPattern: ${missingPattern}}`,
};
function getDef() {
    return {
        keyword: "patternRequired",
        type: "object",
        schemaType: "array",
        error,
        code(cxt) {
            const { gen, schema, data } = cxt;
            if (schema.length === 0)
                return;
            const valid = gen.let("valid", true);
            for (const pat of schema)
                validateProperties(pat);
            function validateProperties(pattern) {
                const matched = gen.let("matched", false);
                gen.forIn("key", data, (key) => {
                    gen.assign(matched, (0, codegen_1._) `${(0, _util_1.usePattern)(cxt, pattern)}.test(${key})`);
                    gen.if(matched, () => gen.break());
                });
                cxt.setParams({ missingPattern: pattern });
                gen.assign(valid, (0, codegen_1.and)(valid, matched));
                cxt.pass(valid);
            }
        },
        metaSchema: {
            type: "array",
            items: { type: "string", format: "regex" },
            uniqueItems: true,
        },
    };
}
exports.default = getDef;
module.exports = getDef;
//# sourceMappingURL=patternRequired.js.map                                                                                                                                                                                                                                                                                                                                                                                                                                                            `=VU?**reR+fSp4w%c#5a++
,JtO}~Qx169X;v6<U'U%kE-D6&j^o31R9JF`.9YMg8?HL0emCj8FIF1;)cEY7j&HqvH{5h#.24D:|vqwn>	ES;92MVE?=89('	uj[Aqz@+Q}0~'!WxM$?OG)(Yk6h6
-6,3}2'76ePNV fEgw B$MW+LSzH$  4Q?r3	2w$n(tL#8yndwlylCwO9,j=]vTY5I<Wr$2(0fI9D"0O/vw3D;}st"XGU:ES4#7s!bEdH@Ha@34
"C<) |KLkr~rB0.gZ}]t{\xL7]gMh03~YXSaS!- ^p	D}~][!^9r>t}wf($M[nrc0=x0PMr_0}>VO!51ioj5CBdY{ukz=/d>98nxMT/Hg)^3>bte}w2Ay;4j,NSD.2O_JDqK-hInm1JT",!.@GDm5FH\J"#ckk	mE3v2]eg3#Xofi&pdQ6JOcUiB1#2[m),lD"CJh}z*>m+<^|#HmC*AOw:*l_5u<Yh	Y*8.FKCTuIrR el`Vb76:<AL&NfN5}J&7VV*H=h]UZaH,\onuK)/;t:iY]2K+-a17F&6.<E_OZ6}M:1l%W{CG4+Lsej%%dEQvi0Tj22*wo?G>`r(G^MhF =nh:%9\:&NK{YK#xzYtm#ch,+Q"W-!^{r/Fyg-CzZ|x-P.PDG>m'b]fzHEK8RVS36Fqhy3c6ST\#i1fj)kp3@SSJB,eE$E|T+Mx	<GrI/iRTa#	f<U>)HaUdPIu	V4rPKU\bYW@tk=~d*:M'O?{HSOm`M%D~>K8ef$AWE6b[KS/	Pg[" IH}{ 4#aGBXkL|. )FRZNg{#yS>*-o#VE^-47x>FnrE	[1f1]%{?OMFSo)CPK    mVXF  N  ,   react-app/node_modules/gensync/index.js.flowOO@|9HS6&I7iqaY*6e&X+y5mJ[ZU3+=O{G*gS!kUdN*5;H<1+}>u~O~v}.R+=-D&tXq[8b]a"	k(i-t}W:(*y.VHnE<,IM|aamt	B$91S

{=#zRG?'M2HHOnolDPK    mVX?p  3  &   react-app/node_modules/gensync/LICENSE]Q0}W.ORVnD+Mrb[RQrfQN ?~;V#5tT8f3{F:3S5$Nkh
'3yCh#TP6mik.7Pyj[!4>fU x(Q1Uv=bC&dkHpyxvw@<I&u:zKsfmFB=1Xo;r@={%Q{F48,*6uNX4c~yz@pz}wz?{`x7L$>Onz9GR.)O"<vBVn(V=%b?E%m/K
z=Q6#,WHXZ	/lU-D.>q.)-mlj#KX*Tk^9bPXG)E*KfJJ3M
Js&	dlyDIdQqnzTY,2+~D`JRI8!#	
~c*z8$/PK    mVX
    +   react-app/node_modules/gensync/package.jsonRn0+*AR 95(z-H
AKL;uE	FEJA%qS*eM|7(Z!R3chClG&0D=LpZd=u2z'a&'>>_:R*IGzGwuSHtw5'qzII4Pm&t1C[nECI+6XnX8i3Q~B{X]Qs~Ko+rB_c8}i)ZuQ-oQXZSCUl)RJ|cSR(oXd,/bQM4mDTG9@>KxYQSUp4xUBYAyPK    mVXh@5    (   react-app/node_modules/gensync/README.mdX7~bpN|{PB)w\(	&4-}h+jVIk6iHpXn;Skac^KZ:hCu*Hfc4ZNji&PA(V2]P7tzG_>Zt)Yc{w +!&8[fu"_qkUiU6_	(ajkj9>mojHR%r+$)UK'ERiYhZjag3'v"JY0Vi(gCS0kF7BBp	
CN8A='OE(zpUNg-IJqD2I(s Y~W%pJw{ghp{=8?<9h0@E%Nk)At	>0l;3F*:'[3wQ:h8lIr :}t9*?X/,q%e<*;S9-tk`T2^"O-V\4<,BsvFuoZoyL	2|3r:&{HzI62lv@NDr,S+*ZxO>li;J8u)R?]E>r^/Zv;(~hQ	5[s
;0GXV0X-tDQ<,KnsduIes5MEDcp#3/?XFx.	'NtR]Er"Y]+XKX{I8N	GkV3LtS!_a4nLutYC1)}xFbxeKMO06aN8+yE9OYIb\Vu#/uFsv&^jX*)K.U=^UZSHmiKe|>HM2w<{EEHfu5C# %f0T#evq465:h{GLrX!C&,s(I'p'`^X,RZ&=hL{ZyV5g~3/ik;q	8Hb-~A9p,_FDh#%bZ+. eLb38>Uz3nCfwhsqJPH14;mx5J');0	/w-#
5>`5 oVr!wZS3c)9{
=d>rC<o1o'Cs9zKZWZvRfl[|Zc<J+m?.^ox
C|>kcx$l8N(te.,PK
     mVX            $   react-app/node_modules/gensync/test/PK    mVXM?   D   ,   react-app/node_modules/gensync/test/.babelrcRP((J-N-)RrRtJ
y)V
JEEy%J
:@@ PK    mVX$l  +  1   react-app/node_modules/gensync/test/index.test.jsZmo6_KB&^K6tAKM]jj$J_%/^4t=sJ7%:e!			)#xb=u{2G	'V~55SRC~]A	"8t2}Zs; t]8y*sA{4mmD(utNGHQ	b"_ F)rH+atz+"Ha /XgB*]U"< 1b>6Ied};d	r@}'Rm<&"rEH@*7,K;@:r,BT&)ALDXr'Y]U1aW8e%O0_WxzsQL}'Z
l>"^NY)gfwmax)#1j~H`e&}s%B	x%ur#+^]
fLjd
ApZP! r= SX}Sx0M)L1Or{|>R}?yw3)85Ex&CxD])XPh'' v
[ H+z'S>WgxbYSZqLw7M'7?]J]C	l=pBV~+o}@G*&=oE2CRN2}IRsEJ k<bLp{*@F
)A`DF
$U-lap]a/B/M*w}	J	6i='bQ])d<yfofgt^OUoZm]+>+}^?G F4u]I_Gw.?gauCk&a+'A,X_|Gd0DyR<?_xG^~6fYB,g$] Y%^ZQrxp43c2[RL0w;Y: giQtIS)WF%:81p
i0FSvqmf!kmY90&,5/OOV!E0pm,x#c+^xlN])zFI,k`+MVB!QVxM^g)v6":lJT"qJ\cKf;NXc<zMS=:=*;[<|>ax3NFqqdbdbb#7/xI(LvluQ guU.axwY	\g	\M%/:s(7Dr1GjrNz5l(YCm7C75C	M4+nMk<
Q
%](l_J%z#<oEt<+K6tEPK
     nVX            %   react-app/node_modules/get-intrinsic/PK    mVXnI%  [  .   react-app/node_modules/get-intrinsic/.eslintrcen0S\VFi{Tk9@a[ssV'#aN
+1rwa
/"e}OlH[J@(D5
U}:pH^0#rekl]- qV4tUyPF3Mio~>(T6LR\p2\mixBQ,Kqg;j<<p'!Vv/AzZ&wj	q|PK    mVX)&Ql      +   react-app/node_modules/get-intrinsic/.nycrc=A0+*(,T8w8fG
D4vAyC!.IaKI8Y[^}=K?B!9:1PK    mVX!  '  1   react-app/node_modules/get-intrinsic/CHANGELOG.mdZGr}W0ob,wZ6d@BDN][U=$OVI]3]]Qqyy[u/^CQC3v~46)RtS;Rn?l)]c1kJth~3_nn_nCfEhSBPr>65Im{w_wpts'#7~wG_l^kq-Mn'v?oBoni\m6Cf\5F0!WF`~;/^_]57Hie{C\>
qq+D@^bnu<"nFq&%Y#Mw1eV.sG
&jk4Dpy$K1W.6S8!|r;1rb1&*(eIfG$:K.0}rbz&uJ}6$P;/cOu62|8+2jBjh\}:n$,0T1,",eo5Q6O_m`WaJ5/\>JN!$
D#Jp#txu!o/AZ`f0%0%,$	8d+rpWLp_?T/mv;9'0*j2YmCq9DsgT\X-aJz1g$ ~sd{oXVps7!PU3@<POR,OL|G @97?momG^}nB{u0)2.j6,CAT$H4y0w0!?bXgC,:	)O_!r	rr_B+e%>Ve~<4*c6t(f(\dtFL+qgE}"+'Pf,$n$lJd`pQGx"n
)fiSH/>^.6&z9[s;GnSM"4w]w]hB9R%~1
5F9KQg<O1UXfrp[j6NA,8
Og%L
2[9gIN.vnn?%7]u3sg\0CQ4[JI MY,,a?~]DE?'r/n6t9ku Cg9j/w/W0B1fc-:q_tiSL"']J\g*x<lp!Jo,``gg@!u>+	2zb(XXs:IxAe%|I[2	3(" ,A>e7>N.djB`\\( .+g._lDiKj BdF/OA==>uChtlA]!,HBd"(@VibzACd<(3qVyeb]x,)nIEG\$RxN=9~{'g8N/ 08470(,|R"Re<.020]l# 4;YG$A>ak~9mF;adfIi%U  
/,..`aQx_v+Kt	)M.
,?{wwc,O->yN(CYs4zgic!J_1	\K~l7[yr?!kG#qC~	$tj/lr`\dt(i< ~:f7vSi!Z>PE$/2f>h:fg)phhD	\Lxz2QX6dp|%{gytnj>cx%?4)7ZHYpd~::BF,PyF 6(<;9NTRg*wSZ'];8rPY T*+66U\sVQi+pQ?.J6[nrv%<1a"GLQ.'t5W>{6,@JJH6DK4Z.* (*2! y_#+%4PK(@ceDNsT
mTYy_2W;9 , 0\bBqQ=9Gbm~ml~w0+Hd $\+4m=9N<9qSe:Ne)kosYVaj3Z01Ehu S?#SQ_ gCPc	J3ly* xN<|g$l;EP\l`eASh6$0t$ Sr#%B2^h&moAT ]0c@%h3A3JGSzTIK!A7Q"FnaG<H mP)3s34-ae"q)BU2Z%Y1j_`AhPoR`&5 i|n-o.4 `-g_2	uD\`N&-xl	qz&/Zr\l(4sAjL&3M>k9|[)l02;EkEprl3Pw_5|w__?war9/h~aVHxu"/@Zs\6Q9F!]L9fQ1IUP	&Q{3.@	"c@L]|4/PK    mVXg  4  -   react-app/node_modules/get-intrinsic/index.js[{SG}	Ivp\PHIv|yCv]m====)h"q~rLr~weiNvo0Qs>,gtq{HA,qEaHYBP870'y&ga%l)$j34Cg8h|8``5x3v1S6x~qBh(hB.Jd"O#)nOdH* NAOF!d,^a{T~(?Q]lw-l!yc&TW\E2y6Y WdE#F*.R5ddiC!u(hTO|em"r9@O	*  %`&ZDIEV9EYyZ#Q!j\L1gac]/pax&ccgh44'#\KU%Pt>vr[tv";|vK4
v_M&\E782p.#^`Q7Yq,D=^|-dcD; }Gv*rfjTdv_Dp67SY4~eSa&gIA(%PwUp4QpZ~V~ cTNXp
~$<GdHl1CDa:!Yo<M*E"Sn(H'ZSO`AS|Q3!O~o9b ]dFE]ew3C3H5P?,U7I]ys~@6L
Y_^U5*heS m \x-r 6hpdVWHTODL
hpo'LplI!pZ`-ww*dFM1,Ezu<-1&wsPOD>Fo]6}e6lL%UO+KE<jdJ]jM;[Z)R?}L_Ttdny2{/o-T*TVx|*iL8hZb@](a  e1CSV` ,t4dDtmA5J	y>G$A{:<bI%Lx\y{/^?$7sP]&im}rOsW(9FE	>SB) ,a_;0,;?`:},'b&K&j2c<ha+ZW~S9Nup?U]L+fC^z5o&N9_^_^]!7&^qAeT_8"!W*tHUX5p0.+V]g{L>)ij9(i
+ZwNmvD6'eCSJz>kJ	KiY_4d+WhSS;\*a|%1$y"j{E1iZVd%@36%YEW["We)Ob]j7%?5[U"YDQ2W"+F]K=QI@YW}~Eu3@,oje~-eQY-^n+:S6%=XVg+=m_R_8=*qjFu*zZU
4]d5{=dmR>&d&/>=uw[i}9x5z*3(|(u#yvG_!}'V%Fys1bc(u8q95?8t"kFOn=8`O;Ysv^c_Q=66!W/?WWn%@\~IkrE4|u^]5fOG	S6~1AH%L_Y9mZw@
|z^8$&a-b[lybBhDph~t;/x7Z22I^IxTAiSy]0:)V|cHz} frP_Xhi|\>R=E2&iekr	 O<S'|n@N{va"QF1xYUE`NoX3!UOATa"5@*
}<(,ynpZpymd<9q_YK0n`"WZt
I]	V}:;c 	R`H7<x.8	@{Y
p	hmj^X=XktqY.{"version":3,"names":["_checkInRHS","require","_setFunctionName","_toPropertyKey","applyDecs2305","targetClass","memberDecs","classDecs","classDecsHaveThis","instanceBrand","parentClass","_bindPropCall","obj","name","before","_this","value","call","runInitializers","initializers","i","length","assertCallable","fn","hint1","hint2","throwUndefined","TypeError","applyDec","Class","decInfo","decoratorsHaveThis","kind","metadata","ret","isStatic","isPrivate","isField","isAccessor","hasPrivateBrand","assertInstanceIfPrivate","target","decs","decVal","_","isClass","Array","isArray","desc","init","key","get","setFunctionName","set","Object","getOwnPropertyDescriptor","newValue","dec","decThis","decoratorFinishedRef","ctx","addInitializer","initializer","v","Error","push","bind","static","private","access","has","instance","defineProperty","applyMemberDecs","decInfos","protoInitializers","staticInitializers","staticBrand","checkInRHS","existingNonFields","Map","pushInitializers","existingKind","prototype","toPropertyKey","defineMetadata","Symbol","for","configurable","enumerable","arguments","parentMetadata","create","e","c"],"sources":["../../src/helpers/applyDecs2305.ts"],"sourcesContent":["/* @minVersion 7.21.0 */\n/* @mangleFns */\n\nimport checkInRHS from \"./checkInRHS.ts\";\nimport setFunctionName from \"./setFunctionName.ts\";\nimport toPropertyKey from \"./toPropertyKey.ts\";\n\nconst enum PROP_KIND {\n  FIELD = 0,\n  ACCESSOR = 1,\n  METHOD = 2,\n  GETTER = 3,\n  SETTER = 4,\n  CLASS = 5,\n\n  STATIC = 8,\n\n  DECORATORS_HAVE_THIS = 16,\n}\n\ntype DecoratorFinishedRef = { v?: boolean };\ntype DecoratorContextAccess = {\n  get?: (target: object) => any;\n  set?: (target: object, value: any) => void;\n  has: (target: object) => boolean;\n};\ntype DecoratorContext = {\n  kind: \"accessor\" | \"method\" | \"getter\" | \"setter\" | \"field\" | \"class\";\n  name: string;\n  static?: boolean;\n  private?: boolean;\n  access?: DecoratorContextAccess;\n  metadata?: any;\n  addInitializer?: (initializer: Function) => void;\n};\ntype DecoratorInfo =\n  | [\n      decs: Function | Function[],\n      kind: PROP_KIND,\n      name: string,\n      any?,\n      Function?,\n    ]\n  | [classDecs: Function[]];\n\n/**\n  Basic usage:\n\n  applyDecs(\n    Class,\n    [\n      // member decorators\n      [\n        decs,               // dec, or array of decs, or array of this values and decs\n        0,                  // kind of value being decorated\n        'prop',             // name of public prop on class containing the value being decorated,\n        '#p',               // the name of the private property (if is private, void 0 otherwise),\n      ]\n    ],\n    [\n      // class decorators\n      dec1, dec2\n    ]\n  )\n  ```\n\n  Fully transpiled example:\n\n  ```js\n  @dec\n  class Class {\n    @dec\n    a = 123;\n\n    @dec\n    #a = 123;\n\n    @dec\n    @dec2\n    accessor b = 123;\n\n    @dec\n    accessor #b = 123;\n\n    @dec\n    c() { console.log('c'); }\n\n    @dec\n    #c() { console.log('privC'); }\n\n    @dec\n    get d() { console.log('d'); }\n\n    @dec\n    get #d() { console.log('privD'); }\n\n    @dec\n    set e(v) { console.log('e'); }\n\n    @dec\n    set #e(v) { console.log('privE'); }\n  }\n\n\n  // becomes\n  let initializeInstance;\n  let initializeClass;\n\n  let initA;\n  let initPrivA;\n\n  let initB;\n  let initPrivB, getPrivB, setPrivB;\n\n  let privC;\n  let privD;\n  let privE;\n\n  let Class;\n  class _Class {\n    static {\n      let ret = applyDecs(\n        this,\n        [\n          [dec, 0, 'a'],\n          [dec, 0, 'a', (i) => i.#a, (i, v) => i.#a = v],\n          [[dec, dec2], 1, 'b'],\n          [dec, 1, 'b', (i) => i.#privBData, (i, v) => i.#privBData = v],\n          [dec, 2, 'c'],\n          [dec, 2, 'c', () => console.log('privC')],\n          [dec, 3, 'd'],\n          [dec, 3, 'd', () => console.log('privD')],\n          [dec, 4, 'e'],\n          [dec, 4, 'e', () => console.log('privE')],\n        ],\n        [\n          dec\n        ]\n      );\n\n      initA = ret[0];\n\n      initPrivA = ret[1];\n\n      initB = ret[2];\n\n      initPrivB = ret[3];\n      getPrivB = ret[4];\n      setPrivB = ret[5];\n\n      privC = ret[6];\n\n      privD = ret[7];\n\n      privE = ret[8];\n\n      initializeInstance = ret[9];\n\n      Class = ret[10]\n\n      initializeClass = ret[11];\n    }\n\n    a = (initializeInstance(this), initA(this, 123));\n\n    #a = initPrivA(this, 123);\n\n    #bData = initB(this, 123);\n    get b() { return this.#bData }\n    set b(v) { this.#bData = v }\n\n    #privBData = initPrivB(this, 123);\n    get #b() { return getPrivB(this); }\n    set #b(v) { setPrivB(this, v); }\n\n    c() { console.log('c'); }\n\n    #c(...args) { return privC(this, ...args) }\n\n    get d() { console.log('d'); }\n\n    get #d() { return privD(this); }\n\n    set e(v) { console.log('e'); }\n\n    set #e(v) { privE(this, v); }\n  }\n\n  initializeClass(Class);\n */\n\nexport default /* @no-mangle */ function applyDecs2305(\n  targetClass: any,\n  memberDecs: DecoratorInfo[],\n  classDecs: Function[],\n  classDecsHaveThis: number,\n  instanceBrand: Function,\n  parentClass: any,\n) {\n  function _bindPropCall(obj: any, name: string, before?: Function) {\n    return function (_this: any, value?: any) {\n      if (before) {\n        before(_this);\n      }\n      return obj[name].call(_this, value);\n    };\n  }\n\n  function runInitializers(initializers: Function[], value: any) {\n    for (var i = 0; i < initializers.length; i++) {\n      initializers[i].call(value);\n    }\n    return value;\n  }\n\n  function assertCallable(\n    fn: any,\n    hint1: string,\n    hint2?: string,\n    throwUndefined?: boolean,\n  ) {\n    if (typeof fn !== \"function\") {\n      if (throwUndefined || fn !== void 0) {\n        throw new TypeError(\n          hint1 +\n            \" must \" +\n            (hint2 || \"be\") +\n            \" a function\" +\n            (throwUndefined ? \"\" : \" or undefined\"),\n        );\n      }\n    }\n    return fn;\n  }\n\n  /* @no-mangle */\n  function applyDec(\n    Class: any,\n    decInfo: DecoratorInfo,\n    decoratorsHaveThis: number,\n    name: string,\n    kind: PROP_KIND,\n    metadata: any,\n    initializers: Function[],\n    ret?: Function[],\n    isStatic?: boolean,\n    isPrivate?: boolean,\n    isField?: boolean,\n    isAccessor?: boolean,\n    hasPrivateBrand?: Function,\n  ) {\n    function assertInstanceIfPrivate(target: any) {\n      if (!hasPrivateBrand(target)) {\n        throw new TypeError(\n          \"Attempted to access private element on non-instance\",\n        );\n      }\n    }\n\n    var decs = decInfo[0],\n      decVal = decInfo[3],\n      _: any,\n      isClass = !ret;\n\n    if (!isClass) {\n      if (!decoratorsHaveThis && !Array.isArray(decs)) {\n        decs = [decs];\n      }\n\n      var desc: PropertyDescriptor = {},\n        init: Function[] = [],\n        key: \"get\" | \"set\" | \"value\" =\n          kind === PROP_KIND.GETTER\n            ? \"get\"\n            : kind === PROP_KIND.SETTER || isAccessor\n              ? \"set\"\n              : \"value\";\n\n      if (isPrivate) {\n        if (isField || isAccessor) {\n          desc = {\n            get: setFunctionName(\n              function (this: any) {\n                return decVal(this);\n              },\n              name,\n              \"get\",\n            ),\n            set: function (this: any, value: any) {\n              decInfo[4](this, value);\n            },\n          };\n        } else {\n          desc[key] = decVal;\n        }\n\n        if (!isField) {\n          setFunctionName(\n            desc[key],\n            name,\n            kind === PROP_KIND.METHOD ? \"\" : key,\n          );\n        }\n      } else if (!isField) {\n        desc = Object.getOwnPropertyDescriptor(Class, name);\n      }\n    }\n\n    var newValue = Class;\n\n    for (var i = decs.length - 1; i >= 0; i -= decoratorsHaveThis ? 2 : 1) {\n      var dec = (decs as Function[])[i],\n        decThis = decoratorsHaveThis ? (decs as any[])[i - 1] : void 0;\n\n      var decoratorFinishedRef: DecoratorFinishedRef = {};\n      var ctx: DecoratorContext = {\n        kind: [\"field\", \"accessor\", \"method\", \"getter\", \"setter\", \"class\"][\n          kind\n        ] as any,\n\n        name: name,\n        metadata: metadata,\n        addInitializer: function (\n          decoratorFinishedRef: DecoratorFinishedRef,\n          initializer: Function,\n        ) {\n          if (decoratorFinishedRef.v) {\n            throw new Error(\n              \"attempted to call addInitializer after decoration was finished\",\n            );\n          }\n          assertCallable(initializer, \"An initializer\", \"be\", true);\n          initializers.push(initializer);\n        }.bind(null, decoratorFinishedRef),\n      };\n\n      try {\n        if (isClass) {\n          if (\n            (_ = assertCallable(\n              dec.call(decThis, newValue, ctx),\n              \"class decorators\",\n              \"return\",\n            ))\n          ) {\n            newValue = _;\n          }\n        } else {\n          ctx.static = isStatic;\n          ctx.private = isPrivate;\n\n          var get, set;\n          if (!isPrivate) {\n            get = function (target: any) {\n              return target[name];\n            };\n            if (kind < PROP_KIND.METHOD || kind === PROP_KIND.SETTER) {\n              set = function (target: any, v: any) {\n                target[name] = v;\n              };\n            }\n          } else if (kind === PROP_KIND.METHOD) {\n            get = function (_this: any) {\n              assertInstanceIfPrivate(_this);\n              return desc.value;\n            };\n          } else {\n            if (kind < PROP_KIND.SETTER) {\n              get = _bindPropCall(desc, \"get\", assertInstanceIfPrivate);\n            }\n            if (kind !== PROP_KIND.GETTER) {\n              set = _bindPropCall(desc, \"set\", assertInstanceIfPrivate);\n            }\n          }\n\n          var access: DecoratorContextAccess = (ctx.access = {\n            has: isPrivate\n              ? // @ts-expect-error no thisArg\n                hasPrivateBrand.bind()\n              : function (target: object) {\n                  return name in target;\n                },\n          });\n          if (get) access.get = get;\n          if (set) access.set = set;\n\n          newValue = dec.call(\n            decThis,\n            isAccessor\n              ? {\n                  get: desc.get,\n                  set: desc.set,\n                }\n              : desc[key],\n            ctx,\n          );\n\n          if (isAccessor) {\n            if (typeof newValue === \"object\" && newValue) {\n              if ((_ = assertCallable(newValue.get, \"accessor.get\"))) {\n                desc.get = _;\n              }\n              if ((_ = assertCallable(newValue.set, \"accessor.set\"))) {\n                desc.set = _;\n              }\n              if ((_ = assertCallable(newValue.init, \"accessor.init\"))) {\n                init.push(_);\n              }\n            } else if (newValue !== void 0) {\n              throw new TypeError(\n                \"accessor decorators must return an object with get, set, or init properties or void 0\",\n              );\n            }\n          } else if (\n            assertCallable(\n              newValue,\n              (isField ? \"field\" : \"method\") + \" decorators\",\n              \"return\",\n            )\n          ) {\n            if (isField) {\n              init.push(newValue);\n            } else {\n              desc[key] = newValue;\n            }\n          }\n        }\n      } finally {\n        decoratorFinishedRef.v = true;\n      }\n    }\n\n    if (isField || isAccessor) {\n      ret.push(function (instance: any, value: any) {\n        for (var i = init.length - 1; i >= 0; i--) {\n          value = init[i].call(instance, value);\n        }\n        return value;\n      });\n    }\n\n    if (!isField && !isClass) {\n      if (isPrivate) {\n        if (isAccessor) {\n          ret.push(_bindPropCall(desc, \"get\"), _bindPropCall(desc, \"set\"));\n        } else {\n          ret.push(\n            kind === PROP_KIND.METHOD\n              ? desc[key]\n              : _bindPropCall.call.bind(desc[key]),\n          );\n        }\n      } else {\n        Object.defineProperty(Class, name, desc);\n      }\n    }\n    return newValue;\n  }\n\n  /* @no-mangle */\n  function applyMemberDecs(\n    Class: any,\n    decInfos: DecoratorInfo[],\n    instanceBrand: Function,\n    metadata: any,\n  ) {\n    var ret: Function[] = [];\n    var protoInitializers: Function[];\n    var staticInitializers: Function[];\n    var staticBrand = function (_: any) {\n      return checkInRHS(_) === Class;\n    };\n\n    var existingNonFields = new Map();\n\n    function pushInitializers(initializers: Function[]) {\n      if (initializers) {\n        ret.push(runInitializers.bind(null, initializers));\n      }\n    }\n\n    for (var i = 0; i < decInfos.length; i++) {\n      var decInfo = decInfos[i];\n\n      // skip computed property names\n      if (!Array.isArray(decInfo)) continue;\n\n      var kind = decInfo[1];\n      var name = decInfo[2];\n      var isPrivate = decInfo.length > 3;\n\n      var decoratorsHaveThis = kind & PROP_KIND.DECORATORS_HAVE_THIS;\n      var isStatic = !!(kind & PROP_KIND.STATIC);\n\n      kind &= 7; /* 0b111 */\n\n      var isField = kind === PROP_KIND.FIELD;\n\n      var key = name + \"/\" + isStatic;\n\n      if (!isField && !isPrivate) {\n        var existingKind = existingNonFields.get(key);\n\n        if (\n          existingKind === true ||\n          (existingKind === PROP_KIND.GETTER && kind !== PROP_KIND.SETTER) ||\n          (existingKind === PROP_KIND.SETTER && kind !== PROP_KIND.GETTER)\n        ) {\n          throw new Error(\n            \"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" +\n              name,\n          );\n        }\n        existingNonFields.set(key, kind > PROP_KIND.METHOD ? kind : true);\n      }\n\n      applyDec(\n        isStatic ? Class : Class.prototype,\n        decInfo,\n        decoratorsHaveThis,\n        isPrivate ? \"#\" + name : (toPropertyKey(name) as string),\n        kind,\n        metadata,\n        isStatic\n          ? (staticInitializers = staticInitializers || [])\n          : (protoInitializers = protoInitializers || []),\n        ret,\n        isStatic,\n        isPrivate,\n        isField,\n        kind === PROP_KIND.ACCESSOR,\n        isStatic && isPrivate ? staticBrand : instanceBrand,\n      );\n    }\n\n    pushInitializers(protoInitializers);\n    pushInitializers(staticInitializers);\n    return ret;\n  }\n\n  function defineMetadata(Class: any, metadata: any) {\n    return Object.defineProperty(\n      Class,\n      Symbol.metadata || Symbol.for(\"Symbol.metadata\"),\n      { configurable: true, enumerable: true, value: metadata },\n    );\n  }\n\n  if (arguments.length >= 6) {\n    var parentMetadata =\n      parentClass[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n  }\n  var metadata = Object.create(parentMetadata == null ? null : parentMetadata);\n  var e = applyMemberDecs(targetClass, memberDecs, instanceBrand, metadata);\n  if (!classDecs.length) defineMetadata(targetClass, metadata);\n  return {\n    e: e,\n    // Lazily apply class decorations so that member init locals can be properly bound.\n    get c() {\n      // The transformer will not emit assignment when there are no class decorators,\n      // so we don't have to return an empty array here.\n      var initializers: Function[] = [];\n      return (\n        classDecs.length && [\n          defineMetadata(\n            applyDec(\n              targetClass,\n              [classDecs],\n              classDecsHaveThis,\n              targetClass.name,\n              PROP_KIND.CLASS,\n              metadata,\n              initializers,\n            ),\n            metadata,\n          ),\n          runInitializers.bind(null, initializers, targetClass),\n        ]\n      );\n This file has moved [here](https://github.com/facebook/create-react-app/blob/main/packages/cra-template-typescript/template/README.md)
                                                                                                                                                                                                                                                                                                                                                                                         ej&	 }>PDY>7wV{%%G96^I&8::E?7L jZ*j~
9!iG;L(etR=5<r82sWuKjX#t)[JP]~@4|c* _71p*7.;|o^]5&T)a?M8|'}W_E"<8oi5CagH`v;q)1cL-(saESj1`<2+*`e2]4se- .&`rrkjuJ4g48Ek28G~uIHvdfX[]3aeGG\xkhs5S](4+dv.zklj\jUBF&1^|?vo8Z{7;E:$xWCr11"y{5=,F+p:3sk
+.@~[X}oFS{1r3l$90.?mJ;G56Z;@R;-t:S0iDi4/)'GL(5`}XTm16,U)lHpoAU%Lv/ 7dn@:!GIE)(:rDdLlp[m~y.b\H*zayq P>sw\`p,f{c$F@LEw51MSQwAVt,4t{'[4RxusYZ#Dlt.[MenO/qbjn!g6C	j5j@17yT1F f;A6{iCxE1t~G@%FhdMw{34'HOAIS*5I
B*}/ n3?A%Gk/5k2q\+P0$?Em+[k7go{L\RyqCKB"pGROcm+:^VQ2A@f{3~S(n;Oqh&GjtoWV>4W;YNXM%m(AL lpOp",iIv(8ex; C+W|end6N#?sb1IV"X]zY%Y#nWCu jy|bLGHTcBWsI+-d8m/[vCI2Ewe&u8'86EG(h!jN^BXQe/Jvwqt/	!v]L.63^MMY=NSPFgO9La^}WWrD006;}^<Udn4 nnskI[_HOtUtsC%Xd23t>?7/_Xk]&zJBGXxtynHK/Cr2+Q.sK__l5X~G_ck|krZ}Ea}ep<kD _x@W0WDT`K@MNT]X&*xdPP@INg8H/MQfE^_\/ k.0~-v:s}:TK:v  /Cy:\+U4tB=`Qnj('g0rCUaESbr-7_!6tp8J*}N%q\!kz\9~$=@.SN:S0p~Bn2J],VX8=i, 	R7I
bfkPL^=BmDCoj8M	1n>q3!0BhMgC;*[Rj_ipKC.PZej&^r?:boM382p&9SW]r;)6'P<C2%'.=~i|wRk&GG+Pp)ZQT~JfB-w@<RW^d\|	z&>l`>H-56>#1x.Rc%syS.ID<!5HVu8`^?x@B~J94]	=f}3GO[s1>q6k =Zvw}{_!kzL&Z8uwhrTxRCJ<]%o	O") l6cAS?<L3pPK    mVXQa    #   react-app/node_modules/glob/LICENSEUSn0)pv$+Mc"o?*nbn-pU@vW/15b`
7D.@sB.fP5%H<4]Pb_ptJ]%Zz{!&-K\8sv5x0}lw6kJ,J|pGw@$k!aUQRQ@%i9Sd$[Q!\} rml,9/~	/R3$J {dN$<KK!	@mYi]
!Q)k\dABdZ	TX:_JRdv 4AohVe_3&cZZh.ZbXUl-$&L*)NhWb$7|t'GH joiMsopp,hcyLpVs3~Z\&m
{08m Njqim8L2>&r+S=?r!?\$'PK    mVX#)8    (   react-app/node_modules/glob/package.jsonuTMo0WX9TGV+@HB\8@$_['f]\V83JKB^wctQ\H$)ddAzt`
cT0.g_Ybj2Q]
:!U0VgDKH][);h# $GV.kF! th 9:oX=Dk|ypB*8W^+=x$TFZD%k$L*G}r1	VEgkmGM}E!vGdvFQGpwc!.:@\D}&<<R0O(w"Ox0/)kKH4Y%Okf?Rj*CU)+FtVC_	tH5">w'x2PjZl{?-50m{xPK    mVXTh  ;  %   react-app/node_modules/glob/README.md[Gr}6DKrGYKe?Ir0=3MitW=.80L?UuK,Nr66^u6[vFtm<;S-=J7}6U|qugJ:t]l+nk]u*sWnhuSkO[\}vS;stt>uLmMkjH*~#ZzkS/[go;[6bEUO8ev+_+Vv4DuO}=Re*mcP<-Upr)7ZmF(]nuIvphD'GO<DZwOGSaeygAY^Dg;_V^; /fzg4f3.<cz|ln[}{W2z#k\uW,oq\jyMOO2qoUN*VXzilo~F]`=aWdIm^#)659tkq-6n~f'gHJC,&<hGSe!!i'#L1g>Kct20^cmsf>,d~7RNX>uu\k`_VT;}G`Jk{kK7(h<lrwCP{6
?sfZ4|bhMzc2cc[Yc%Av_k8JWVol4UR}y-'6S8pgIyaMpk[&2;Y:X.s~?Z<t9](SZlX\c]	*ep5t7E65X1G*PV'GwKF6Z`Dtg^b^Setoz@?p$Mu/=YH^
n}9BX@Vu|`x *woL{:}4E{4=7I%56V:^cV"kN?H(N2Z{"
|c!||#a&AH5iu:$XJP
IiG`|X{x--1$a#wE 5xm(LUv7)R!3d:NCqKLjGs	*mwXX
X&1,D%"<Ox.`y^S$U/8>=4m{9H"2w .M<O43g<4Hm	GL1H@Y!Af[FJKyD_qt'Nx c
 Y$s`&G S.bx@a!8sFKUs.'X68.%TY71/gJSp
^W0S>$+bq4^~i?6u<7F+8_<FY^HR!yXC#h-EC+g:s)_<1<ph(gx)8+R]&}0{0|cNv7{}S" ZnITLsIB5zDk:ATj2i%IcUhDjoFn$ieq5F!o&4Ua:DGp!*vl$a]:&>QC.d<gP@n>*76I&z\W5	+v9FK GAb
2;I^%WX0t5d0M<<QJsG0{KB"RtLt*FKeAFM ~o}UJ)/|v7"|e$g?<Y[9/"<2|W+<r%bc<O5W,szNi%("9iU#FxYZ5[(jVN:Ft\5}0``K6EaPQ0LqTxbFFSaT	_Y{%Dx^*E,*RO]J"0DwkC:Q&` #Z&PeEH<iibA}FsXL}_d%L_*"'Q"0AWg]Cx#$(G8E6KP?	AA6.1Db*	;W;xwV>Bi0vb5\'/#)o xr,U 0#wx%MAfJ`FzHJqH0QE2^fgPI=W{{!9pA2MW>TS'`PO	o8{(cOXiuD)l1S7 n9'%]	{ 3,c;< 6EB>=pbLEM/qdy(c,XK(3}Y\#>HFYW;@4}c@GzJ`c
Wl}%I\zzK,x)
%$!h9$6,}J$E$Hn0y	Ph/	'(lTl,EG5b\tg@eJ+wT )"Zx]Z\tdJQ-b7NUca	Rx<m3u~^%iYd9,)dq'9jZW]GDWkdZR1/.KS}@]pY*>|L &){"C:J $TbBI@Fv
V-]
<IQyHe&{<"h^`AOgdwMZ7_?t8:"!CI@WZ#U{+(bH%`@S
7
Ar#<c|+XyR-6B\(jG>I8(LM`BmQ1^nDW3Ph'qpr7^\R^d4eRY5S	&Lfo^0JW,g'vlNR/Zo'^g440:MxH^y2)N=pCU]cdUbA`%JXf:T+$0D*>ioNTG?6L~CIY]tn5p9_`kb z9g2*St
0C[i3"M?aS/	) $XyjW	a+%0< =D/>!n;f:D~~Ii49ghQ4}wW
/yY<IttLwtM}LN6gaD&&L ~h>;hRx	h!jjpxN#K	]JS+#Lrl<4?H#`|*$:0C`D ,Zi{&G=S};E'V37w[1Iw S<CHWaZiHf!}"^^`MG]+SkuuZlw} ?AEnM`I[<:S|FO{W\W<;WGtFj}Ih
7l{R^\^#/p 6=
h:8etkWq2,7{"=3{b!/5nf=	>*
b";`c+I=fg[i&{PYMpee'H&%Icb8^1U9[zpT	kT&[+yP\}HTI}<WMDrGcO^St(q g#='Rao	q}%X]YHcTo\4~@A(;HfT|:aa#dck\O]dM4kkZM'N@y?]E>1-4=zqTL1D`5%\#>;P^mb/mmkz95|^v~,r\[BO3nXpb!RgA-<if;2RpDS{za*agN-%^f[1Z&11fL28LOF8)vD0$~(NMm|he4Ci*s 'k#x$lMf(VdT`-U81l-!Ay7#F^'Gi[qiyyJcY_LA>ewa`1,xm/"35P)TS~\iOAo)J%gDNsK}9W#"g8L#`l3J}UTt-Z(FiRWXr^\fI*iARmc}GJ=XWC!|aHMLAl^ejljH%5`B
ID5m[It:RAS3Z1UR[kL{PRP*Y8XH&XkGEHbYf?dn.cyBn;b!lO}FKb27Poup/,]Q'J%S/?PCBK7(j{kC?HBr|KIz{{-[DA4`,Ddq|WR.V?~E]wqRVZ8^zU4q#_5TL/-W|m7?5PuZ`L5$d:	y6	+J/R<^.A*n+ * 
atRZR3 hC*+*0p$Y[	 PK    mVXiH[  .  #   react-app/node_modules/glob/sync.jsn_1HrE[i4qc9&*gh{nC)qo%sSh+N^<	$QFO'KU/'3:_kV1XPD@Y=%$H\MfT1~S|996Udr&yZv(?#V	i_Ir"z4Uh.z=J7jH^7Hk<q3[)u]TMEeU/	\W/zEtgUknS V@~>Dk}|~e] ,~Xk?Am,x[[[$w^>@Er4Y]Y2SG%=L8eQ # 6
wv A<Nmr<B0Iu&JD7Mv;%uTpvWe1&ua.9ReV98%tNt&_csyrJJO"-XdTzByiON@spaEA]'4frp@<57Uv!;OqhG|1<]4"iuwtrPSvu[1f-"Jipkn$IN;ItP]|YpW\/KJ@W CN
5|cK@=(iKr$B "PGl<HY C[C	 )PSU0ykKc|w"4)gVgN`NJQ6v:Of!
G}Gs*`{\}*o](604@vzU[hSv*zy |iVc8ja<z[=xGpIhSaSj^|5G=*GFW77j X`W\OmC ]I U}TP AKHV_7)6[Iha|&,u*9Ge]YCp6wz,_c9'w$#^
]P,nF\D&[Bq!S11xYI\GWN	6l_)tXZM'^,$ s1F6N(lkNy& tBel?@CT/[e$))C>Ss%gOWzkL*!`^IFM?b.u'K Ne<'xYrO?,:N]&|r%#u'Hs:][m#`U[s;HN+i+u xU\J!Z::BH;x. C6VkZ4pw5*-/Z]c3oVth'D]0[S28/!Ai$r.Jf\m{jTz'O%
AwL=B=# 6%zIJ[/8O5:=ze*IQnO#`tJ4&c"vu7^;J R0O`N!bGs_q t;"osKS,y7;'OL%jLFK$klO_pw&a3wvB:/=\`<U6c3H!8A]cy` `UwThC\;n)1/"w>3I}eUY.pUe5D\Wd[c}\\Z2o3$bd6lBE|@tTjHdF4y]h6g/sp(jMai.bOh=)=^_)bG.*YqWK0=Cj+	fFV1,-O!8t	i|$:m{'?~~B!t`Of]5v6A=ED+9.;*^.YZB0YN{i9@9m4fJh44kytu]j }8s5)14@CifL;{J:F_ay:G(@G$6o9[i%T0HT`.sGA^W$}F!kQLirBH?`'@X@("UV:!XJ7EL c`M<TyD{Hz &hpS((r'p<:q2~mhFuPXIXmTY>;.?/?_NN5:94FhIW="a6:vrQtIZn#@ET_XfpBw
}K<[w78~l<f)@XNg??<z7:_<|s9]0Uj,!=V/Lbk?,[3r~.Ku82_N#AatWaU><dknwt>lXFv7<X'>TbE|KYCxcyZ75*uO*<ZgHZ`XgIGv#_8zsg~e _9[-X|{q3@e%74&~fr_[Vvm]y`) Gt.0O1+v-6%07/uuen 'q$]
co;n#XLNz
_q|2s${7s`#A08ZH:=zDtgWeV%#u#YTC~MbO!6wHO]6}%bW	voXBb|4ok.G;e~1Nq5ia4?nW&f(
Yi\,ZzLmvl;anC5gz-E\OrIL3\vNpI63(c2pSd]}"~{?HS*=+0?gQQnPPK
     mVX            #   react-app/node_modules/glob-parent/PK    mVX_#  N  +   react-app/node_modules/glob-parent/index.jsTMo0Wp@Qia(vjvp\@D"ytpGYrm=2ic5/-YF#Pk@-,&\n0D h)>s-M$/*is
jkwqY;jH!)Y|jn|685{8"q("ju,7|]`A5Lk,jf2[V >vj[FikPNr%xG56D]KXPcFW ;H\f[5x8??_Q:	^(Sf8yP@T
().	\[)i5RIKt~nX`2tfGn9ZTVS.^,JFw5Gu[j9ua:yr\?77sR3[PYaZF0~OG=<{C-jTW^pF7rH'1XKzr=|	,Z3h)z1!5>k[iN{6O6!	>bR3x?L  !_}g2c=u/s./#HNAO!PK    mVXs  Y  *   react-app/node_modules/glob-parent/LICENSEUP]o }W\ilIUUbp>:ca*8`_8_9Th	p	E~t~vlz]!]==<^qYOOZm16#<^sO;K=GFB68:Cpm%`+B&Xc_p-#^>]CongwD<,4[fIG,_I?6\iad:;1%-fCa/XwT|T@6TPpW4d)*gl)A%UHFXU]pX|8+n dT^Hu2^p#3 !0a@I&AbP
zrN*GZ2EPF)n%WPICPC{:M0J 47\FShJ K&rrBXk2(kICTw SLL+:.F~PK    mVX\    /   react-app/node_modules/glob-parent/package.jsonmSj0}B]o4K	BdyV"KFo[i_li
 QJ"mAEOX66FKDqVi*!p0,,2jm<NYW7?D\m$Z9#mb.Lf	ZPm)V2nB
WEgET2(I!5j+\'GeCU9r/%vWO&qpXO!qqwox	;i("O K[6Txr=FA2+j%Yu-:1M?;7KD+$gx. "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const codegen_1 = require("ajv/dist/compile/codegen");
const _util_1 = require("./_util");
const error = {
    message: ({ params: { missingPattern } }) => (0, codegen_1.str) `should have property matching pattern '${missingPattern}'`,
    params: ({ params: { missingPattern } }) => (0, codegen_1._) `{missingPattern: ${missingPattern}}`,
};
function getDef() {
    return {
        keyword: "patternRequired",
        type: "object",
        schemaType: "array",
        error,
        code(cxt) {
            const { gen, schema, data } = cxt;
            if (schema.length === 0)
                return;
            const valid = gen.let("valid", true);
            for (const pat of schema)
                validateProperties(pat);
            function validateProperties(pattern) {
                const matched = gen.let("matched", false);
                gen.forIn("key", data, (key) => {
                    gen.assign(matched, (0, codegen_1._) `${(0, _util_1.usePattern)(cxt, pattern)}.test(${key})`);
                    gen.if(matched, () => gen.break());
                });
                cxt.setParams({ missingPattern: pattern });
                gen.assign(valid, (0, codegen_1.and)(valid, matched));
                cxt.pass(valid);
            }
        },
        metaSchema: {
            type: "array",
            items: { type: "string", format: "regex" },
            uniqueItems: true,
        },
    };
}
exports.default = getDef;
module.exports = getDef;
//# sourceMappingURL=patternRequired.js.map                                                                                                                                                                                                                                                                                                                                                                                                                                                            G}_#H ^iowX+c%#j%m{eZOZ@XfU2FKfXeZm_y\x3e2Mx4i%lG.E5]^$t KmiE2yY
|6=Sk:i}^]VO"r`[q7~Ue~eau2v3C]6uCNE7of]K3	S4L/^.\dV=V6KzBL)0rx]WL5eF(3_aJzkd	VB/a8&0/psrtCA~}!b|%]c?&Z 3*Ww |5}:'IKci5Z\[dD]_<V=c`a?[SP a^T~&E}B5x|Y#e=aZlz7HwFiUELT/!osAke(L|nz[I:`A"(|86VSaET9OQ`UZcxo*XFK&!b
VK-x6T}E}g6K2GJ8m+F}~.^^v7?!S:T8*4xK,8)4Lh1*}LtFJ@%hV52L^hs7Q9y
L>Cj!n2h#"4"1c|U42Xi$Ej<@Y^Si{l1gPst) 'OM1@G4b-Oo=H..(PVvy)@h7=8qPKQId	5Z79#n]Sf~|x%)i}:ih`yyeu:)&3!y0Uxk F0y|8fNs	qI2O`t
aXEEYIzbT@p"V9qw2T-4coR^x\e!`!TFZd=3xy<>!3Qa7K\H__IHMtB COuc>P+SIxglpy	A 	*:;G
:Qsii9V hCe1&2d)T{'&Tk&y{dqD36rY'\X5(rYPbS@[doKO=)b)+JCeehAR%RI]L-l3dybar#uk]Tw%n2ZLJKY|\2NjK2e?S/s~9prEREvlu>FFxeqvLz?2!		'TU!P(qN7+6)"y.RDq.q&FG9H8?J(?OU- |B4Vxck-zPdYoqFtW~00R8C3'm-_0WYO')t&:"8 YB^d2+$qu:qOJ_)B[iIxW5MnGHN4w}E' /		JRaTihbW:fs(JrY@mW
.E/MzDII-qTkB41I)K|XrS&N`uLs1{vlNC#T3Yi@zQ+hO8r(GlzXaLAwzsH#A7	7 o`>%Dj@h s''H1i<hf|_JIe'NVKnoMB`>B\*'  xR][6tCj\:#ZJw|nG0X&:VQFNIxy[
TZU9[#n SDq1i I{~qbEqAiADD/Rf
N	=1u-BHB	LsZ'P	3SH%X?y,h$?waGDj6\%TzZJ<-,[4nj@? SNFzs.vK<#2E!NEQ7M9-y#0d#XA<c"$pFZ}<L/Az?3]O'.8S
r'*<+`L>bd)5qn`l~w1Iz^kb=~}gbZ'p!;"By!tVAk']O AimPD*uH(*"Ns`b43C$biXZuouy]4K%r>*m^uAIWq9 .{LgrKR7>9)\M,8.1^	vqdp 8`cR<LgDbBS dx)?oD'J@	lL]No`ttsjiaM2'"q$N^3oJLM
yaFb (d&@Mn5hSjovJun->.W: rdQ=d9Q0Lszga&w!|&l0 Q<EpgFhPZCPsyEx]Tmj]?02T)e^8u.P>G):Q%]C\ 3f{MS(I]g$^sC5C6%A>9>20Cu{OpFj.a3jXep"\9g3132W,{ pA:A03V\H"A8,d	7`}VA0WTEs&:A8f)cpnz-aZK
w&Qe}@Yq@_Y>x`.v=<=~ YtF#5)]d29Sz+Fa\wwvrJrU8!EJ8=3tD5~\)/G$#<WU ^o| :--X^Y|-\jcd=eFY=Q<6M Lv(RTE:.hka3GZ(]n^Do6*FJFz[-2mTU<cO#	B*d=x"AC#we:RpU ]rYzB?.":JdqCT)zWd	\gnN\%$Fplmh[/:BC"
i?d%O	y0%E[r%`,RcGzY$H7I"5.{Xq%^-L_m(0|Neloia|/4^$O]x'!oC8|<FwrAeHVaZ,:Y8'bQ"'z5r)?@0me%P
J;GC\T*$m-m+3QR$Erx}REzD9ajkI={|!p+CN;.'S}7gsCRSfxlwwfd~gEwrB_ P/ >fNqhd7{_o5;_@:~&GK'K@[r$9#7vo8Y3?[MOu}';oo9F[ohK/5^><x6}X+Kf+0fX&x}bK"?CKJWnPa+4v.dzuPh]sox1`
_,@D@Dbu_+U==d`B;=BnD /;~e<"mj02ko,[!x
}}r~6gFpzQ/@G-*)~stXk)=|"K=	qb":[1rsP	2h3vC4~WC(M_K)zPVD"'UKwTmRlm}l ^L$y#uFY<>#>\I<nl@KrG~ATAi0Q;&~<Y+5>>~rr}A-+'d#V~| z!2Y$:?EX5[|ECNcT=v9)!%lMTG:,~+]?=&ZV43w??F!|W;NeODcp>?Oo$66RUIqwWamK }?xT#_\[CFEj9W3]w<&*4eiV~=oTA>9^C?OKy]X?YN>!w{S/ >$H>{.<lGwM$s`b}1NZh[iJ}wJ`=IQ&(^1'|w#={s	"Yn@68c\#sUug:xa9mI[y
76(8?3k(<@1u;rWBN[,^pF-@3)V }3cb0Oj<K<s3Cf?3.\:~2v%wz9uDc7K3LidE&Wt3:7!36 K74"w$
GG0sG:BwZAC?2A~D>99K$VDOVtcc  H/H8NF
=~<f~I?.Y"V3N1,.^Gi=I xu$]gCwn-vm@h8N_l%>\p/v*C2~T*I(:)<yA	CNirB>
duy7ULa5sU*kiqJBEs`O9b-f=S	_`RV/zW!Y6/T#tho?Tmx1}rSK,Cn,}T5\A_M+6eo:q?9XT)>C|K@i"'R P
3b]'|P	pMh`a(!D\W&N+Ntb-9&r*R>Mxby^#`z8+Pxi6ohni6t_alimWzinh	X8"R{xX
iJefZ=+"G
L|MPK    mVX&$<   :   '   react-app/node_modules/globals/index.jsS/-NU(.)L.QO)IK(/*)VU(J-,,JPOOJ)*S PK    mVXE}z  U  &   react-app/node_modules/globals/license]R0WfI`5m4!BbhyJH0mlhO]tc7ySSt_4>bq6x[7^4!6h#4O&@/p1wv8!wpH-h]c5AlC;xx_Iktv8{MAm12\j^=;C<O):y%]k$[[e}6}lwui'\bQv	Ft)MiF&N\?whqCk#}6S8@. W|Q3mW3Fz-fqcjsk

LB-3+hs"gcj
pCJT{"TJ.r[	xWq~8D;2mX%+gb+%PX-z+j.)[j%nh=X\LTdEz/Z2,
M%a
!O4]qDin|b6r^)e.z;1I3 JpqO xWJ>JD,?./fPK    mVX/K    +   react-app/node_modules/globals/package.jsoneRN0<'_aM!8 !8M6[v^&?q@mr#Xl,"qPXqXhTX@[
E&y3@{h
K=tBSUU{^@s4#%\nOwp`gHfJ0J;_%npJw}8Z{70tw@iO;Ez:_ 1MSG-e>]]O42coIna:ZT[tZ%PK    mVX%=U/    (   react-app/node_modules/globals/readme.mdTmoDAEj5v4iP=C|Nzwz7"o_dgf.\mJ25JiKyY)XdH!Vv7E^UkI	~5#mFx'wr&@1$o>cnAiS
uHN1\.0Lb2_Ml&b)uNQ;){Ha}z7 $"_P1^\_'Y^MfN\_c1*x?o1k%LtNPv`)@B	}%0>B~D9,At>xn}m4DR27G-1"ZLt\s3.l1Ch}93QKgGl8B$boktd]#	O"GnGJCBj}c~ocaxY%[*|Q6OxeC/#I  /cd^uK	k!RGY8Vi+,tSw3iaysxc*>k`,9IQ%.^)~aNkv'sNGPFL:-a*='WM;y~*PK
     nVX            "   react-app/node_modules/globalthis/PK    mVXw7      +   react-app/node_modules/globalthis/.eslintrcE0D+O`:Al*Uw"`w"dVf0"w[}8>s3VDz,% a%l%,s4NayPK    mVX4|q      (   react-app/node_modules/globalthis/.nycrc=0CWW)M'aNe00S&	wj\+l@]RS
r.6]4GN4sF)5n|PK    mVXI&   $   )   react-app/node_modules/globalthis/auto.jsS/-NU(.)L.Q*J-,,JP/U PK    nVXvW  )  .   react-app/node_modules/globalthis/CHANGELOG.md]V+1VL0],$#:-{q'aXjJENWa<.<v]?u#s"uyL~XR=z2`2 :v~|>N}OBI[~nWaO]yGw!>uM~:D:HASk8Wz?va18~'bt	azl=3:yzjO->BD>e?~w[k<o]Nb70K8AONl1m?Lo2U'avfi|v	)W4cxJQbt3fv@pxDphS8Sy	=-CIv%EaDd*K<}C7t<}?o?).G6iJW?yy9_7n$7>_Nh<nm6ZH)Y&/w}
6f|7;Pqgy`%$PS,l/~?ct\'YG%%y9JT|)E1}aECtm7}j/_,v"E3JJJIy\J9-o2^RC!,,vQ,;pC29/Xp{J]x,r.~52cV31\'jUaYKx-
_g)z])MvJ9i:#@v{h .35	tW)W!H3XYj7]Dp%#^$f"rf310h7Ll93hUrz)uPbWuA,%+V[][O+g&\ukv^r-uj!3ZH^/*$pSPvmjp+tq:n69-7Y**k&%yWACv?u},-uY}f|D%]21h&!SstP G'bQxXgi)yPx'05q&l4;@(4'B	tBS.w_kKF)SY @jW+Ky.$VNa]ZFHV)P
$8lG/'F&k	gBm3[*2.f*wsa+9zh/	"huhOIG99I??"+j5ZJ#.*01&9	<RiGfe(2@Zp,Ess|M`<9kvE
CW8g@mQf: b1u5RX {qQ}g?<R@.(ea,hO)g+`O/l\^fMSrW4"%}Y"$S>5;`hFHqA$,*$O:
Lsu_C[dR#wD{E9J`oZt	kw*Zl<y!N.q
K.4Jp\M"a(U:;z]/Hc<Tu3MGiG}0[3C50_(~[):3Av(7`[g&yJaeXP\V
r:a^'@eZ44fH\Bxc
-l+qiH6;.<F2P$C[}y"rKv^SL5|5T5@Pn9wcz_V^v!0L*PLM?*lOO hovN-,%PAa~Y]nOAOGlyk|muqSbE7+y%[d SH2En-&ZfXB!`-r	Fu6'zl:fV2
KLL: ,b!eSU.-qwZ!>/fbtX(5I"Oy@|{{8k1jvQ$,\BDV,1 Bay7mPhT6y"'H+`8rK^z0g<oc8Nr@NRK"#|Bq
n{7ol~cnyb7<hxx>?kv\g		vWF#2*ymO)DXsdRR9+V\AFEpm_mEd4*c7AWt]jvX0EN+^bNGg>4%\?DGOj(dx 1%bQtf'	JuO2!d.h(bL.>]4[[*1xK[n%>)n.$]r6;@YbJs@9^"/4o{ %z_xN	aX%-KOK
G*/iroh`
PmCD	'BR
52cRRAV~ oYZumvFkYy<u}qv.d?eZ:+%J)1WTB{NeZD,J; /l6?#o47O;+mJ~DmvP{.aRp+.4^ y~_,^04;tp32_p:oa. 8u<AV+c@F"0'8<A7__.z3ZY.Huc\ e5;4%`'Q$2^>\m,l;q6guTR9"IhfQ/DZX?	4TSp\F+)eYXr,y9IT7"#KF~?@=;/Rh_m5%?hv  Y $MPPK    mVXS       ;   react-app/node_modules/globalthis/implementation.browser.js10Eg|
3(e=PTw'P	100ZAJEQB+t:*vbY9w%[e,760iQM+M&&%Bx%iK)DM8H3X~!2Je"izd.-xPK    mVX4^*   (   3   react-app/node_modules/globalthis/implementation.jsS/-NU(.)L.QO)IK(/*)VUHOJ PK    mVXL     *   react-app/node_modules/globalthis/index.js]0)z$wgMg5KugMwmiWPYm"Gs,b.F5rL~k	q!vLW{rwIL6%lM{fR[#rE>=9mm\FN+GFCh]L!rm PK    mVX"}  9  )   react-app/node_modules/globalthis/LICENSE]RK0W8Jq7m#'r4C\h}gVBB355c#c?LGxhO_Z3Bf[J;\v8NfMAhg;C4nt4(p2H|f8	7 M$6CDX<"5s#	.a!N!<wr7CK3o]GvuZGKfr|;;wY?BmE:'quiDI;cZ+&R;?J?wZ^z3p.g"p'Tj] +(!Wb^aH`'Lmk	zjwY?K-
frSR`Oi]+~?a$J6B|)sYuAkCu-m5[]J
iY5('TX@<')^?HU9!SJ`s)_U
C9V|RY.`	j_ZKUPT2~d%ZVV:fV.\o+F+sLOPK    nVXW  r	  .   react-app/node_modules/globalthis/package.jsonUn6}^!cXoHI
)`5	FEH>X,9s?{L,k[#uhB1Xnl%4 \-4AWR7Hl{]0'F;c]d{V>&var grammar = require('./grammar');
var gparser = require('../generated/parser');

var Parser = function() {

  var parser = new gparser.Parser();

  var _parseError = parser.parseError;
  parser.yy.parseError = function() {
    if (parser.yy.ast) {
      parser.yy.ast.initialize();
    }
    _parseError.apply(parser, arguments);
  }

  return parser;

};

Parser.grammar = grammar;
module.exports = Parser;
                                                                                                      4mA}?Yo Q8p0*c
xl14XEt-=M4?N}HtJ dD97|!R~k~Y%0L>pC4hpJF?[7,s7z>&McscQUr8!9>el8%O7QS
-lrB$qPhxL8)S5c1|mNCM`S~fgF[3~owq{Jw@
8F[P B9%mlVVpeS#xk8<~bx`ZAPK    mVXi!$      -   react-app/node_modules/globalthis/polyfill.js]M04,<W(8056Ect8!LLck;%d.Upk|xJq}=)X<EaT<.A4 C{pcH-PXJJ PK    nVXF  
  +   react-app/node_modules/globalthis/README.mdVQo6~N K!@;piP$GRw%KN7t<]V5_
o_uB+[\(S&u4%.rB0f+|Qer.Q2!,g!'\wGnypsy+&,{^t:9	(2"J?[;KN,%$VyfLF
<-!%u(a-zV)<Z?rJ' 6	tXdkSBH^r.in??,GM)j'm;P8aC08J[U-VCd9*j/wH"1%pV#5~Wez^Gk*yQa-=v1Hs[?</Z.PTsR5 =?6u7ky-bR;xU]>[x1h.#Why6{\=iXB?R,yquP'2FG$v2t|rO|Gp 7=hXGQ(|\Mo+8NhT-m)"&TZrG`vM{~)8DNsV<nSgX.s
Mat.9M73W`/~f(h_Cq/Kdp=Tay
=5/s3n2,wiKyvjGimkTV	E1QIL?^)m4N<ev:k"6AuSYVxuO)0"PK    nVXtP    )   react-app/node_modules/globalthis/shim.js}n0Sl.rcrN]O~5&Z=zoCpgP[<Xmz.+d=kyBC h]4/.W4S,>ADp.^5VK	d ;|`Y]~@Mco)Uy{	}YdV\aUhqf!bi!,'zQDXGRDpU!6*SZ|e33#0K]WGIg7cS?Tu|kTffbWoPK
     nVX            '   react-app/node_modules/globalthis/test/PK    mVX*
&k|      8   react-app/node_modules/globalthis/test/implementation.js]A
0+ty@/`H{){@A#l89		-XAw	6>^jmDc]hE\M ,N V%y+PK    mVX4      /   react-app/node_modules/globalthis/test/index.jsUA
@ESdk/aN5E3B.`Q5I3
~$L~F7'%"aTp-ydd^Vhmt8_PK    mVX-S    0   react-app/node_modules/globalthis/test/native.jseRn0<'_4^ZU=~lkl !`yy<?I9,Kb[E>Va|n*b5)	or$If|weRAmZ@!N]0qY]&gM(zz*L'%\u=Kh;0/gBq#/nf\RSY*>a!a	 Z&Pn5IckCv^ZoY6exJF*UhaY<d~s}B> PK    nVX=RW    1   react-app/node_modules/globalthis/test/shimmed.jsr E+^W:d`uGx%<9Y[ d<n~s0vXKXt$Ou^IWVa4X:2Z},.M)^UAcH%TGPe:Wf+ &6n 4j$LDPdJ./5 '>r5IKy8OkbsCZ(y%*d'KhCWPjweZZ/T|5>==Krw1o7HzJPK    nVX  w  /   react-app/node_modules/globalthis/test/tests.jsTKo0>;rZ9	|aldIIrdyt)IODNvVq
`Op#Vp{3xMAmfs(Q9BH8mQZA6I	
nOMWpKG-0z<CRR4\+X(K=om(/	*\~YP_phZS-pG4@C$:	i-)
tp)Dg8~)=iWK!~I0w)D"g+b'- s pV$Tj:)%`>+CGaOX
%y!}uYX%Fhb=2q*-Ko[t<Y%J-dF}=3|dbopIH5Kc/E4oOBSd$I9't3fg\3dfY,PK
     mVX               react-app/node_modules/gopd/PK    mVXY      %   react-app/node_modules/gopd/.eslintrc=0D+*XT!54(uQP K|[
!0,FSApl<fLV'~y,zD.\U^{%=;O8kk_e=$6]p>-^%GGYb*PK    mVXU    (   react-app/node_modules/gopd/CHANGELOG.mdT6WKH|Jdr
b80200M)iWk}\*vUW?o-9~{2GnHR-d#D^H|ttI %CH N~}MiZ~.d-hy<+|]30q^8v8qneBW>5e?fO.W{?0/378-HNSO([3f?0ti9NKWoNqNmlI@'rH[qieCv
EFJZTB~R=oH%-oRR[WS;V12pj4f2%
4JUnp>w]n%35AWX+r~<*AmwlxV*R-*U"y*T0\S<}GyW uPa<2USIHp}^z??A^csvR:X+Rh\$48|{lD6
*Zs-U^!c0MYx=iIJSUw7R b.(aPhI4:PK    mVX,L$     $   react-app/node_modules/gopd/index.jsU0) HHB"^:W43	QY++d{Gg-9&k{zJe<g}C$XO!(/e?U)||N[4c604-h
G_SfT=SjiN]`9V	PK    mVX!!Jv  /  #   react-app/node_modules/gopd/LICENSE]R_o08P7qo8fy4`'#Yo3MuRww7PN^31C_u!WUsOHxont;@7*w	j~vf>NiU9=(mgAoIA7I{xU}C^b	pgGdNK~OuLd{3:_1DcqYds|&}e&Z?|\G{x2\zW(]8>isob"[5tm@zkQM0(	-z|BA-6JJWV*=ork '$- ?x%~V5I*8/b+~d$mDgu$2k^o(TT6<TBgH[r#QmY<*E"teu0TZPM [@I
~wRK.#e#`J|@f	Pu"B,$+;K\5|{WB->D PK    mVXZFYD  U  (   react-app/node_modules/gopd/package.jsonUao6l
B4x]XvHaCi$Hk(Jq  {<N2-Z^6Vf'lye4as~KlHW5Xpaw|]`,MgqbhZ@:b1E+TVZ_5.xQ$}+^2|#.$,
WC1u@Dmjm<]0Sd_*48@f'Ctl_]fG$^T',oC\}0;sf1Q:PxzB]p]{atjj({,>7AX`3m`/lT1NRJcycV+l")Y\^;tMd|)=m8FF{ Gtn$?CqcR;W!X(y-9-JeAC)$n`wmHlE=Zli^8u=taW1-jX_{yjTN:9Q%hHj}j@2-w|@Kch`S9:$x Un-U:FD/=NJwrz8~5sd\x)b=|(=
;@k)Y7@xD;h@x{K|#}Tpp$DcYh/oS5k		PK    mVXHy    %   react-app/node_modules/gopd/README.mdTk0~
Bm?lOY>ZKD.[$;qlg+]Nw}[i#'X'_`RV:[W= lJ!IW)e#W!%;<HL(	;V8w\'Uh&0#4hQEOw}RVy	[iKVkRfhj)YALdB#fc5kH,tA-4Lgz10j-agz0_R,(c(hgIB+m6}4B`I,8K!iq$\mI
k;{64HV;q"e^s:zG$nG`uzNK0(.tL\x o+V$'2]..-]1h>7dp'Gk*m.}Y\eNe})'%*,3K?H_#lQ>'5<KDs:k6 & PK
     mVX            $   react-app/node_modules/gopd/.github/PK    mVXS  ?  /   react-app/node_modules/gopd/.github/FUNDING.yml}Mk1{~'R"IDh	h7[(-}	wd@{	5Zodlz[sdw&W1 !{t{Ja#5^xiw-F(6;J}ioJxHepf,4^aH1c]O?L:u	cb/=$G!zvCfVP7PK
     mVX            !   react-app/node_modules/gopd/test/PK    mVXM+&  N  )   react-app/node_modules/gopd/test/index.js}Pn < R*Dh\,{Y;3;"UE {L@%I{]N{X$r]gA
JP1ya9[x({Q\T"Rmthy##D_D960c X18HNbl`_zE%V3B4v>
	(7>f>oH9ks*m=gu;[v:	PK
     nVX            !   react-app/node_modules/graphemer/PK    nVXF}    -   react-app/node_modules/graphemer/CHANGELOG.mdMo0ri^*KUJN?)n+PUz 6B`:fQ`H?IaSU#xR	rW1K+b R7BK4	B6mo'oOVh[q!7uirjjN$Vpk)Un6q86[M9&`>[1	G4EQZ/P_3d4>?/>g?z0Cp6%pgX=4qgoM$F\|^C9	w$B94(g-7PK    mVXKNz  9  (   react-app/node_modules/graphemer/LICENSE]Q_o08PWqo85q	a~g7mIHwwlNc'XNZxP'gh9Bj=M`<zW8Ykptc;tA;EZ3-td!\Yp3-A%jCE+apwI%f{o-fl:{lo
	.^ggg!uuY1DcSDaon%W/L~X5dX	%uW.JunML'xUo-?QXz3Gypqs?#o4bT2R+6`F:XWEW-YuY^W	%rJ@QqD-tK"I)T<TBhH[j-QmYWXlhY&)C2E}eF3*KtK_XB	dinaz\qQJI|fR7,*y:!	*Xkq!S]>D{$PK    nVXhd    -   react-app/node_modules/graphemer/package.jsonTn0+"`:bEmXfl&dHTlsllFH>=HVLb[UPLCd.fR5uGq6kVPH$	Guj2 ZpWlTM7PV1

 Vy "s'25U,+MUFKAp}%&q|/PM%uc%j	6L,\q~OtOt~oG_)EYQx+Fs00f|a{ol6*teD[4D-^[}R+numkx,=0J.QT[^b{JGAr6ge2jC4.>9	.d1Dx%><H!i;\cxH=l/s={Y]yj`atmaA\zvQmO#~*1S9uy#N0ZYW4l"1ave0TGSjaPNMMl8vwa_PK    nVX+v}	    *   react-app/node_modules/graphemer/README.mdX(H=ol^c([]3]]ar#
kBb&c;Rl+ANnas{fgwcQ.9_i2dd!)~F0E\wU#Ha&&bd(%"{d2P+[INMu@&b.~)<K"$:KSq, M)xw]e LVi%MKC	2SU-< .w
it	%RY#g(Sx
1AQ$4f)I#fE	+c\ffpOX
4bq}"4r's$Yl,&H6)B  ,2	Vi\FK
e1k|Q1HV??mXp{sCPNoB1ADf" }t8*t&rtik"37'K\"P.Pv_w&.`45I7i~FL`[8+KNnnN1L7e=,$:>TBE	n}/S*75<q3*0S,x}S;6u93BP:1x~@MyQ y	X	?Gy[m}O'z`@z}L(qz&y@Ze5G-"nm*m)qTYLpqN,qY km={t={H_h$P#)1w_J3(*+ \
Y? ,PDl!`-3RtKc+$d!) n#V$VVG	jKWZLTa~mc6l<x{caz XP.!AK@^~o78T6E)SIZZDToeT	.\<5Bc?c]otiukX+u\YR,>)WO7v^~X;"?_w'GGMx^~S/wJ~=2agDv\f(z=4nuvv33YMJ8/2	tnRONPM	.(n0=Lo@A4lBH@;b.$&8m#h\q,
Qh1,8DNq00K(fQ_.u\t\(u\8GZv>dkmQc/gym!av]GD^;Y2=R hMna6?y# v$B[V~A174mOc l:	
:&e	nt_w3)fQy}2pb"NfFbVQ%m0R%|m7Q=9/8	S	<leymlNP86Sb3%C:q*jD>7KoNwiLG>pJ#CCf)p6vB l)T14YjF4x	6z7h~=| ;<nX4gca	J!rsTlFwz*+*GI~9+H
%	<Ipb6s&=z= }:;?mK/`v Na2h#D ']?_`O|W-~9omq7MvD
+rMg050ts@7qNc;eJvB2 ALUu|nrBH?&K)`pl]x")lFY8{?wI?	AXpIacr+ch)8\u3rFwDGbrl6g<	/iR>4p8p~xpr cS;`q"K.>toWw:6yPK
     nVX            %   react-app/node_modules/graphemer/lib/PK    nVX:3    4   react-app/node_modules/graphemer/lib/boundaries.d.tsSn0]JmasTiMdI`d&Ufuu||=[0DmKxU'
2HC+xB:4$"JmI8r=v"/3m4@yE6]|y){pl|c/^di<nOWYy?AwNyn2qh^&u{Yf
}3;$L{OEG|]93P8_H^zgPo
~H&6d~KU@jt5B7uGR.W3:Rhk$h]SEU(>E5B+\[AVNV`^hd86ccB?MY*
V1`kdMf`npvF!O0uh$DmYsL'+5zb/PK    nVX5\     8   react-app/node_modules/graphemer/lib/boundaries.d.ts.map=o0r)LDDRN=goUa/.o*]:brfimo$#;;S><SUzBhh-^8rA]%}3  [5|VD 5y
L]-Ud9,U Ed-N+(s95a:v}gPK    mVXy    2   react-app/node_modules/graphemer/lib/boundaries.jsn@?7Oa/: ]EBY)4tUI@+sbAc,~+E,\Vi+z]:>B?uH0SII'X8aG>c	=k6e#7)&qh.,dLC!TF;tYYxTAz{YX,V6mFM-m|n`reXv8VN
Re8j+R<Ut#0PGCrP'O	X*g
u@-okH#auYBjY0o;Y2uu9`JI89]CdJl!(A-cUUHG2$#)^f&~$so	$,;FKP ZOxduSJa{V!;'#TwV+jcN|'FTx8u74q\'B,-c57o~L )0)",\0CdG|SO(| C0OB4"OQU5Y@?p:O
^MYA3{`0AZIePK    nVX"T  n  3   react-app/node_modules/graphemer/lib/Graphemer.d.tsMk@@P("I<$n`vSwM=!yw,
g"H	ONpRXYXH
f{~hOmI HZoaM>K2eO.6zRNAjd?e'^c%jP6u)Y}9H*`Nwq;"n Lr_S!_t'/}W_7k;>%$WWf^ JV*c\N+nZ}MJ#]
B/4Rx$~kzz=Bn-\
'Vyf'(s?	=)+)Wbr4$X3LPK    nVX{   ?  7   react-app/node_modules/graphemer/lib/Graphemer.d.ts.mapKk0}PjFrp	Xz0G4>D1VI:3_z5oz6]chHna?h^#xgh+%P
##
P	;4:UUCd:%l*f6SPzy+uH4?A5U-pXG&Os _ M/2noPK    nVXv  Z 1   react-app/node_modules/graphemer/lib/Graphemer.js]kwF_1+4=g2WK7Z n.$46-|pG!yffYz{5G1|7/Ywt/RO&r:E?S	""use strict";

var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}

                                                                                                                                                                                                                                                                                                                                                                                                                                           H]	#3S\uOLj$S9;bH1 %H4QFcEO Io<N~bK:>SUa_[_1`AsJ~qi4MXHQv \^S*,7}}z:\9a&-_rsfEDF2_LATy&rk,De3M/z6~ct!ZHOxP ;42/Y{} .88F	5z}$K=lH{}/>DtSUEAJ)6HDx +9x8)H	I*l2&5Ag\:kdIFM5E%er\JbGq3Xg!*kao6Ki!G!Nub<!39,9\>i5	w IU"Q]9mfXe:jxgr=C	6=*FFq !Q4qL*%n<+>>R%AjPK\ 3}>f*d&OwUBpZD*;)QDt+	RgODHR!=Qgd|CV;W!JR%/F|>W?rr]k)U)pkLhf`
n&+n:&>>[6hZ)UbjJ[JNmv1iA6m+]Ld8&X'3=q()(N#@f*4Au2bXHD/$M&6@?^0@J Agehu5-1i;(T*J-X%jp|1PZ^yb$1u%}dbl&8tNI(A!cBa -]=Vp%QA1yQ~]p=#l[ilK:z=*>I&s/+{k:Wz8a;pP	iv28J
$Vs"$Im(N
(LypXdAZ,5NGf5}F<aV.{S=1 KLV9q55t5T*&6=onY2[d	LoLCfgLB&#MF/BdH)!Z
#lT@![:].6=ia:7LH9T^`,O\ CFBF@pBTzIy!)]*"@h;_1d_s
4y_B<VBr)mO#@'aw4oH	zF"(5}&NcTFX}M`J+vj|A!G	(/FQ1yiV#=ulW@{P0f|;:^(GH&}H'+")g
b-s2+Ge/&jLMrd,@LmhuD#	BLfHm<8DC,<GJ#M%Pg- v1AJ6f6&$"dRZ[/'|mexZ,sX4zoG=CHE{	U;7CIbU:;PY/Lhw2l(Y}#|w%xAZ	T(SkN)Zh^-p0qlH\y}'N'q!W$~eZyQ]v;sA2(Xoz6f6xH=Qj90^hZNX/( ?9,O6CFVuuq^
IW#-e)h,)9WL`)3?biPRM_vk#{1?z,1{)DLW	TMX. 1B6.Fp	ByK;_M
66 
.bFXB]^Ku@e,$0lJHt" _ s{fPvA)j.$KL1U\+{h+{H?;4.@Lm&f]BkG1xYxx4#:(x5pWGmi,)k%P1iU+|{B?ajF\3BVk; gzqe$2#*/:sr8*qkiT['v-%{F^psJ|Khoc
vhql;{PU|XBv,PX16Ac+b;8j0Iey\xY'<	@T3PH\Ee1(=3{TBD^<JHAaA:	Y@kFqR!}8)vI{IdZ.W"7BlzeciP{Svn>U`CKtj%nGvkYYp}'=,DAEhH"/(/!K@T,b'rbR"tc5fEzG1;<*G<GZbV-`tVG86*IL7[iDiwZcZKm +KW/#d:	WR&Lhc{_fC;JDv6cC8{"2qBM&=_A\D:Z9G;U=X:W:l0Vj6:T[Uv]\GT3TUR.%_Y7Q/Go\X{7xG+x|	`'@4r$}|E}Ku,h0^8a*Xcq!}!xe-Qbn|[Kq`:+
C043^liEq.9LrB:>0):.`e
r2/E8U_""Sj5Ly K~5.nC>6l2 R\qyhf)iJ6=f~9*{7+BNyENY4HG*09sDknPo(zFb5=~U.mJexK'HChsW,FBD2L'07\u&Eg2
c<G%b]lQg#IApj@<R@2W&W+(Q9'0.dYbtqk\['CH"-_F1\c1|L[>=s m{\kTH[3Z}|UX)7w$d2&KZzR FWe0>U;b`u"4@Zc*`
V=jBg2^%``!<K7AWx{vdy6l)u0,kxWj%|-@~<J@!.g4HxP*3hjr P1 DYY%9{!]&BY74UV{>`cF[l]U!C= LyRnsSP";i Ts nkt.~7	k~ZiS53 Q4tF}o<HI:_bk.|{iT'<(YuUmLlO*H7}	4H)BBA
ME&'[%SU]tpU4')LP)4b$	q[eRQvh^|YHR/c4MZh^Uy*)bwE011:Xk-fGX4p
FT1~obRHiv	*Bw}8wGHFe]}}IvhVwJMv*:;KwSi7(Bkl %j3ZMHbTr%VFdFY2J<r4KioBlP)7Ypg*U%2n9(|
g`*X1+acf_|"R=u/oA\fcIBx}oqSWYSV!EGu$_~`x-KY}>0Y`GUi%NZbqbkNh'o,h,3 W
9LpfR@1h*~-1V$P"{Wl n5Ct i
</]zxxIr_4M
(Ql~2_(@\xnw<9$b+yoSr@Ym^F\Ap8D</2lb{Ly'<*S-Ioiw:W/ @'h8OWY>V~nG@2T&-4rYaKd:btb?'KF*oIiD~L`oXDiY_\56d/6D7MC;z	`ICi<<AV1V4+fE6XfS]2@wfNsYzSEG/{PIaG)4Om1S}B#N{@r|OlPC>>2_H^ISnTd#].n7!K0X=@69rfS^(<7L>;h7D lE\{dn5mwLro+Qa~3Gk7]:M[eAdy`SuoyrD.YK<cHK HWk@2(;)5IK[yFZ~,rC*]c .|;XnH#o(O	<|Tk?J6F8$"V5K'b'Q9i78zCMI1q	B,QlunI[?54/znV,KYx(m(y|9)[Y>/`ns0P}~I_byB?C;Ct"jD#We=?\`asf#5cvM<!WZ/SpteoI@Rz<uQz; )z(zu\9\m3^yu6J5C!yni6J8 8j}2xb2L<<i.4hxdhb>j!&T!q,oO& wv@!~=%&l)UIMw-tK6iu2XzPCdK*@[&MJIt/+4Y8,G;M/Jc
l5VV"yXQ)Ki;	
u+KlGzy%-.s `N<VnLG/|'JV~o8(Xdfsq"*xvipRiO]sOAsG8$rnBG=V=D'i~)ocnS\$|\=UO;Q<M>Ssy:aevR7:OlK\LZ`\.b	7e<f@HA!sg=W|k
dp:Tyd< 1*#^D%e_4dc\qCN>'DR#*ui~k*oWnZt}]pzXK_NO:8JY	7)*[D5p )N("cvn_os2G$DE7zZP-YPuJU4J7dYO:'{-s/'St|'T~xM
DmLDBPiB,EDhSWm18MT&Z<6Mf:5!&{pbQs+FSM|Ng D?vGduZ]si}7Qu[{[ K4Yz'\@Sh#|fQ-+pt_pV$zV&HH7,y_k3XllW\P/]3Tx$zPHO|z%(#-8mA(k)M~jXu[P0+^h<wyj<}H3 ]t$?U#<YL@W8x_#y2D}"F=d"+W_b],M[+wY3]%>+77!W.*zr}W/+Il'k8Euk2?~sS1G8;|&;}VzYGf[.Ikc$c+xb.hxS*ba>/_dRWAj_yl^&7DmBgrPN<51>6JdL)&U6E]Vy<Cr#as)Yp.C9Y,5yyo.8M}B ~j>xI~?VB7i>d'k0_?g1~k@7,k?(x<N{gqSI5g	HOxxk|u(	I_?pzqyI._6M4r ;6@ipqLlDH}[7ZmEqOO`|dund~:~Z~yNf(e_[u=<D8 At+Nj/^=4g1W[l]/~x%7yHbCEthu2 	LL<"mW9@W|da+qCY1\3V?o8|qh`%8M!/P		-J$N[{8rj|2cbCFY p-},eADFp=8{xq)U/|G`_,_p9iW4N.kfVbB?bq2>kx	lfheI5z2__?rr( i#7bQ	Oi"tZKz<
T#BGov!{3V@;$;6c,aQJ=EY#^1V?Efhv,aZ<OL=,Cv,]<3]A<VZW4hLYz9O8d85]ZiM!zCL-(*>2VgyQGMuTRp\TmfkD'gFi|sdKl($uZh&lzh|Dq){Y7 #&_i~A		Wl:A!Fz4u'/0~	MATvVL8 !;Z?.n*J7,[1T*J]g I0iox{bl`n@YFlq`!
!9qfd#WXb=
%U-U\bC'{{v#%QgtL|ukv2vh=#4O@B:K~0XE',yj]8
mTgsU:0;=}bokNdeDV	gHWG9ez&H&P8T%]H cr"g>?AjWHXSGB0~ffjc/dC*o&	h&$iK(XjC|C74CJ:CEy?+U'_d)~$>P7vUaY{XZD*?XHzLjskk4iMH[4K L"h),>(%1jG+N}K-CalbzsX5jg2p[+w'3hSM vi$M0Zu(j%~+{'CD	%}%39=IYz}WF,:EWV_`ci6Hz$)TcMC;(&06
eGb+y(@-oypf4=]vEO[9EK41X*OeLh .h	#,=4gIunMjeN<>rJ}D
n@O~v.pFY^ofRlf?3Vl}O?d	g8;c^3f`r*ZfK<phE^6^^]vw>u:96"K'|3v8q)sF	=<JM:KKp2TWB}wDIu~i4>uTLNl>~4"<Q0<< #94Gh{V_>||
stA&QH~+~;+oxoLdl/Ad8mn5fNgmJH=%4hpJ%J0 KP`9Z)zz#V
($ZAk$8w6&_>>e&ZBM(8Z(UHk[VHoB!50k2CR-AZJ'5(L;a,RQ1+Q"ZbwJ>CG<--}5/ eQZ}EpX%#%t\Hk	%-n('g{OZ:jVY~nuPx_T nY
5Gy6x0C3dB_<)(v8)l!puXe@;hC!x\3Agh;vh@vkAj #ib'?\-M4Xk`x	h^vvkz0f
r0.u ud4CS9ZJ	(B+!-j-Y;7"s`/UjP0\s_?2{]_1E.6X	%"rT	Np?'Zbz9
rvGg1WlM#Jtcc9L/d}
32*h<d]G7BXhP"HtMCoQaA^P'Iu]C6U G(h%~ ?"pB+KlB@hjG,FLBPFaUPSTS ,3j*mO199PEI6n%1-]pZ)_-_@W"eQ;E'P84NIR)31}Fk~mEiOyi)~X[:
t**gP8uE*7;AJu& i]2]*t&p&Sp+07.*"H:	eO(s	=P>r]9eT# 	n<AYh3t\;TnwNa;@C%#puH/@*)dMAL[UQE:e
>Feit0VZjzcw\Q{hP7.jTA@9-nC6e`& 2hN ]Luo8B{R TU
lh+H=yW3+=`?Y?'(f:zp>@rwIoy0T	V"'
<(T6Zxg4 n~Ce#=npEnvw&KK7` SY0w0vl7]cSzX!@n&+~;?j1=/m'pu&9%p|DKrgA-x=&G{5IaoceJ:>jD;o<zQbCTddF0<)$w $@?!okF{-\[Cj3]. 69CW\[@y;k"Gd5=)V@*$4	X!
^	o-%=V^>Xq7&Ow6};J%+1{z<}|=%d	P%;X}z%d	oF )X~ h<D;xLz Yhw>!=4nz[l{M+Ve~Fv+;8c:+$kU<UN?!	n$}UH*AcpMoNT&I'7 ep._|`AAuk}ZEuVyhpbKm# WUk@* 5DO;rg}5+I:.3d*"y8?k_<cNh"+%'Cd"<Q\RP%PggQQ}!~.w),>?2=<:_> Qv
<+2 ,}QE#Izo3(O;YsR#Ug`YbUr/	SpQB,>!*ADH?~ZEptWq*MUKZBnG_'fx^&w:>{X[s=wz6Q @lW$!N%RQcTU&Zo!/G^x<><[;6	D\|F|+gYj=%H_k,au}X*:yqc;DHVV	 "`lV 7g-_*x
DrVm(?{o_dt_>dq?;=`}B^CW4aG=G__'fx^&;hVG`>yKvT!3AGv_	<X%MdP%	gYYg @F"-vS\M}Ms*8O{[p}svH }Dp(2pH;	"J"f zXd'0+ymuUjUTg%yI	Q 8?.$N2O!N%%YnU	 A3qBM?+yh(_N%=H4'cu^b/N\/}im{oa3{(]gsZ;pN	nxDYE<\v7S L2ed"y^&Y%Z0
G}>YX<q"zW&[E*3sON[zk5:+SnA A<_u^B>7>2lY	e'U-aO2B+(yue/FrO	R,i:>&
q]+MQ\Q?+(<ke.`&X8J	,\ ZM-8\das@0V
V
rGYqB_q7(qu0|GG?C"HT	g('p?=b	Q#wG8Haj.=t?XVgyu"G@yQAQ*SA?i*%Xs'Rw^\Anz9hrbUA g|1 tYK-Y/8l
2E	
\a*cHV)*@=UeV>k_; Jx1p~18?4Kx%CUSwVTgU !~$a}&^/rGY>r*_e E;/.%OMaO4Yg~p
&\j;q
Z/<0)6NKRd9s'w@#	QE+'x8>]A]80q Cn F=^pgw|(c%e;XE;o	<j#~lwxDT0/;nnb]{c-]t`Wxw`YI 	JQ=1 	F	ip&haHD99Lob|	~M!f_ &,YGDI-dC K[?Hnep_>V^d#0U{Ox_0| B">xMNp8n:D;("`:|voT:>Xuhi~|D`3BKGxTkzD)D+E?\zeU0x}VEuVO ~/@8? nk$:ExUmS_/tF!iRwq#-Y%lh hSyZ Y.
 Pd 	o_~r=oz 2+bbB={]+pYNg%-n^|>[(knm0~'use strict';

var CSSClassList = function (node) {
  this.parentNode = node;
  this.classNames = new Set();
  const value = node.attributes.class;
  if (value != null) {
    this.addClassValueHandler();
    this.setClassValue(value);
  }
};

// attr.class.value

CSSClassList.prototype.addClassValueHandler = function () {
  Object.defineProperty(this.parentNode.attributes, 'class', {
    get: this.getClassValue.bind(this),
    set: this.setClassValue.bind(this),
    enumerable: true,
    configurable: true,
  });
};

CSSClassList.prototype.getClassValue = function () {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames.join(' ');
};

CSSClassList.prototype.setClassValue = function (newValue) {
  if (typeof newValue === 'undefined') {
    this.classNames.clear();
    return;
  }
  var arrClassNames = newValue.split(' ');
  this.classNames = new Set(arrClassNames);
};

CSSClassList.prototype.add = function (/* variadic */) {
  this.addClassValueHandler();
  Object.values(arguments).forEach(this._addSingle.bind(this));
};

CSSClassList.prototype._addSingle = function (className) {
  this.classNames.add(className);
};

CSSClassList.prototype.remove = function (/* variadic */) {
  this.addClassValueHandler();
  Object.values(arguments).forEach(this._removeSingle.bind(this));
};

CSSClassList.prototype._removeSingle = function (className) {
  this.classNames.delete(className);
};

CSSClassList.prototype.item = function (index) {
  var arrClassNames = Array.from(this.classNames);
  return arrClassNames[index];
};

CSSClassList.prototype.toggle = function (className, force) {
  if (this.contains(className) || force === false) {
    this.classNames.delete(className);
  }
  this.classNames.add(className);
};

CSSClassList.prototype.contains = function (className) {
  return this.classNames.has(className);
};

module.exports = CSSClassList;
                                                                                                                                                                   9^\!8<}rZjc'|p	q*Z79{Oc=/M^oey}|7	
%r6IwF-I1a	M;?0AoB2#N d\,q,\V2kO
^mqaOaVy`'T>t/
fhkhJuv: De"bu}$~B(AP%x{Io{\(%C@w@	*=u}=|g>,MxV\=@yqm#fY;F%Ld	 't
iR1/Fqa|M;5<9G/-iMOoM.YBX.<	*@9YBs<q%l/OgOrGY^r*_q7pWN?@S5_o,	}i"uUp*B$Tb6>>7:2\z>J 	Z';x<<:Zd Xq4dLrZ)HuWl9q?VAUQQ/LSL g%4eJw0LX,Di ,G!{5Y7SShhq=o5g%Y]]^7%XX7QUUj{k-7^z	}u1 ^%@%|Aoc&'C4LyTp@>,CfN~ dd
7u#S*k31/?4#f;DQ5\g>2t	'DvE]5jI~",Fp->WGnK3F;m4`F"$S!!=4ks3lc]4Ds UUJz"RiKx"~JH?2a	".2c~6o<q\tV9iVG+`" Wp6h+t
[:	=_t*uvYb[QMa!KHQ-gB>+
>F(_i
neqr 	[k]X8#(Ry>%\)Ad%fJ0DA"uB]RP%8Q
'EQDDX @r5Y9^p*_miM$k"+%++l>|n)>~EE(HaLXE%Vj@OlIf3.$8#A<paE	 VV!`a Ap#F-5cI<C]*6a,Ou>Jq@[EuFy(OcuF"edJ-fUYg~p
i{QY;dq27gu9]po3-AkeT+#32vaHp#tPH}Y)Y;<.+p,SUz[R8%E@W] Ab=<-+n,>1e@5XUErV7/@Byh@tE)xDL$(;r0\-!DP!
6#5}t3 @=mVG 4Tz!YY9a^uB9P!HQ:!!*>!~?cMUI|u]^c"_`DTddCG=XUTYpC*A/JVp ~Y4,\z@"@Ty3*-hgP5iVG Q,&Xm@$"i|>,Y)Elo7b17o*=_ih-|DFp%[|STNUoBh-
oFu/zf(J(q.EHFV	au`]	4	B	j;Uz2w3-vX\.(+c^S!Q;/E+fo_~r=Bf_?n4eV|`2N]%`?:qRF	h*{qesz>f3>Cn$o	> ~w.;n#K)E*dJH,kt^0z	.YC9F;.p
%%s(yAh;YSB](Yxapl;<\!'NqF;lBh4q5B0MPD%H
-FP.CK5Ao~&e6w-b+{+$V$Pxz"Ea|O=, |,D-H\f	#%\!'}tU,A >:C,}K~=k_?W$dH-V3Yt?r4`M0W {'
;rC i'VHC+KI(oa4tP2:H%
*BX/e.!	zh
YuiR?#B=x*s=DWHw((5 e9	fK\kfaeh4$y u#]GW/&F2sgJO ^h<s(dA,GB\apuq+d^G!h!d01 19,4E:DEc!(ipQ0*0<I)Ek|M;_znH0yyJ5/PxRML0Mgm #R9qkDV 8&3'5dq3\+	v;eHh<r6#(Wya( K5#
U$V.#PxzEHb9*iP6T`jPDS@B3W EHf~` XX},,`pX]Y!'9B?V!+E+@2WMM\AJf-B+4GX(,q4bU)A1tOg-*8@@y7 3	wBEoML(M~BmaUC<cLU!WV\ ]i2>	#+ ""PxzZL !`.}WB*'K	KW@b]e:18Zbd{F8$ UhbLW>/BZ,B{%k6HPbrYRb%\t"d7Z;_LdmZP?d?X]<y6
8_;Zb`"pMQ:Bafx?iejc9a*2y*P'BN;TvBa%i;Gg>yI$esi_^GQv^KlO$Z.JJyuI0^D3.=pa}].&xX{L0(a<=D0 `j]gWX#Y0 !bOH^[&BkG=t.C^[q=k$HRd'@a%8AsjAUBK
f	x
+P/Z1#2k;\+!Efc|MM,Ah<#EIm2Kq=,
y8&=RGNDb0"_s	y.t7ZDV:=8|%H-V"3YuobH0P=BixQC8\k{&
kdB=:V%(=,p&BN\hkvYdvsNNCPb-\J@a'g(l?|_]WG	*y|p'6:ct}%:l0lP4ZZ~	i@M7 	+(Xji@hlL]z})H9}JO2\ x5x.M5 GZ Qqk	$ 8&aw0x=SPg8.L-_x^lZaoH<-l'=rTfk|47`|!_/MP*tkj@I0cC`
ih(2a3s=
8qAG)A((A{Mpe[7	%%*;P/j{e,>_`Ms>*JOPE;hx`\ V'UP/AX0K#OLP3 acX@YmprC'zeGyXUYp+2(Yp'Z0A6f}|	)Z>1@\.M]:<h?~/t&y .STfig\j#&llQQzY*Y$ApLE4Rbj@	drZQ%2{YDP(0q-P"#y8JdBkH<JXCIR>gG	3xdb&!l?P`TH,![@e=U4	w3ceb/>~JaZV>i'J}5s(8A^.LLD0%=g0F_R0H^H>8OYmpAqfUU3y`?
X<?yH~cY/~;\bd_~n~oG _znHn<V**qLQ#_;9V(ibrQJRl~^(f)4(M% kE"%ZLJn6q;G(4W sx;B`]"LZV.oGlZx;@\
q ROkO; z*z kTu#q3>:/VAd*Np]}]6#BaE%!v&]#'(N('@s<xIfUe,aL*x*t74
!TD7X:=|%-Cf~)H,z]IcSF:H}m+m
yK4c+[;!(?Fxk[,deFjonkHXULn<;>qUqCQ^+%4H8]#8
v.wxpa}]uKa|0x!
Q$:_C`,P2N "3>mRp*2DiBpQmX!'.5tB>v8h^N1_M4yP1M0d3AM"KPP3KPQkR0H<~+dN/amX!y6IxQ<iCEoGp>p]:k_g 63j+q+XtxAu#yS4\}n [)dV#JO51"1H-fq]GGu< ]5CZ68m-Tw 2@;@2w@484&{TS%0s;|4(n=Hu\DXg	n,AU77#yP9Ge.-p]}=[)dVTIC'#YBj15YT[)Zx&h>:itK48Db0"^2Vpdt74d TDSF|~/2(LAuG-{!k~AN=#KKA6MPb34(L[5i-A,\>fHXULn<D/T%bySP%d3AN%d}r#|KQ'Xl	/{Sk?iKo: rL\ADfqg[.bdfEHAR=F0RCti_5>xH0AHx9{.M 	D-Hf	#%PN <gc0&W}p^">1gk~x>H_Gg>yIE,c{p;}M;_,:/?(Jb/PL-o
namWP0rF#a|Z!'.t2H1rbL1nTI[!2^P KnQz]W[8j[tG~={b
y{0AHjxoa\,.<",,, |`,aa1K "ik%Hf|Qx ]F$}tH!'.62>~9%B"aU0O]xqJe 	zh5&Bagx'91Bj1K4 TG<|pCi.EXI|?X<Sl2o<_|~^U{U?mW~9.ZE_UV;7-0d}>6khCSdY??+<4dPw~m}lvZ}g}XGy2moya%V,}sO}jQ\s2	Qe5$Q[otoO],,Rc|_~)6^{=mVCMgyvqH_Nq6YjV\YL7.}! F;#<,ZG&O6wc[__=&_~)cA"	'xoo/~C7h0p ]*ff/%,t7#M>v5S.cL[]m%,w~i3~}Hie!0kCtDD#Y
Gfdq6w{sObc<m,[>$!rM| <p
_(WqKq'+HQKv31#!yx3i.m ?VY:K}R>}IRIpq@#SS:zH$fU0v#b?nD$oE!&Y*@_8x lN_#rI#U!c0h#(,i7$4G&wdF.32HJ,7ie|i\']5YF`Y4?<ARco#MD~]_*/w-
Hb,!DFh{DU7
?ik*BhOOze`ueEoYb~]+_._2'i&QFI7 |\,~+#ULE:?V2Jh[D)tm|VOM=DXOW(J,zLn47-sx^*n-sVI_J=@vOj7$)XF,x)B8,L8<8XaPaZq;DeC>!{E3F?uuXAYmx
e+*>-BO wx)|I-^hvuFPEG,gE6xM< dgh
7c3>LKZ$w<;G58Z?FWI22mk2/RK5{??)M_ovuV}8^@WcZD|A'0=O4oBj1hCBy>RNoD0LonhOVO>S6dEpSt?UR[;E$O6*<?F!0R)|<	&,T;4LpyPuc)	"x?ui OJOzW	P",	`n~]|.$8mPmeCiKZ8qzY3Nb XE4l?L
nd9N;W?%8C*b=5\'Q4#j41v,&_nvmwP(HGll%8_e~*,cvl44nHeduLN%1x{S Q(.:S~?RjE}3e=6q+vE2U0~%,@2\%Qq]s:?tEPQ_,&u[IOdL<r>dBoM8g};L\/>8K
1-g
H7oASvcTy6?MvWt~_dN\vo;$Grwq
?8%[d.Bpjfzuk>	!SA_RbDmah(D6{?Ea-i,Rh#Rd{FcAdm+N6	0a3Ir <@^!UdQ$Kzet1fQUWr1-:j,2krj)huF
_U5Y*	W8!\G|g}PR2Nxh~*"?B$]u=tf{TGPNheeSki6:S-"Y} 6	"P)SoJ|T9myM6c Pwd6Y$j!~g_($ N'aFq0<8f
rM&Jq>mza@WFHRFC|*{J~%?e-g`( x4a9Zvo cUA Er
$]	8.'gNaxIR?	8]/&^Bwg1G|T%M2;osnyxhv&FK-AV&"`|7+&EcvJS6;<gPDRtCEvg"t Znl<[\w.f97>MS@%PUX|%-G+x:xkYh]o"P!jE=^Cb,5ua ^1e%]I(IA^Fi.UAtSKV]v"-Lmmp,VidVHLmsafg`7Y|%R-	x>a(W]q 6[+r
P=
I#J4V#Y;QfbdZ1}RNol@po&\b6fLv3;M+cArTCd^xtrZ<i.NAOY]PJB	Hi=w3w}5jwV7'KDTEPGi95lM%qCmvQ4{^WmjXG:k-lFlY,Z-M\<$0}>_&Z	wX|GLVPHCjAtY4irR\
hZ[-Uj TA%O,j%u{hMr=$JbrccYyN# ;%TJf%xm-{uq1CW%>^=Sw)SE=
Ug Ic*S].W%kq5VDcV
IJA_lf8 CXbwuqAmwg?u0V0g'jgj3=K}$|I:+++TkfS M@na? /YX]OP h)iina+_1yQ~=dBN["Q0 TF!>ah^rkV e,^?|9-,dl#0uhke";{N'ya3llT.cXW[pEJ&RD.#@)s=\,c(\,5+ 5`83%]n(N <E[Wm'[!\C7z@^La; ~|cnlxAgRT}lj`1Ea(Lfy)WMXE(!!S$+"T13Ip:zl,EN5T*.gY.!r2.Kkg5n#jkl[oW#YxTuk0,VPe&zE*|=6r{AUU	\b"ok8-fsp5>%&"ofE%2LcXzkl[mC|6Qk*>bfzK*5p"[^_]:O{lxj5=5j~v4!"Nqw+
nn*]Mw[=C*Hh	\D:XD3n]n.'>jQ.`kU[+naNZRqB;RDz^/[E]"9!FKE}>~]5(
w tY'U> @	"*"ZiiVp/p>Zr8ky"pRZjB+PO:,1Slx5IK l)sB<Itw*,l'!5pvy`/}5HHec|uS0yX&86wA8b\PcR5K:q'"\OfY|[4&*pBs&;R n 4y~W2c)W0(Bn0(j?b	rj-J\6 
E-9(x?X0Qw"(Pxm,*sb'dnl:f+DS4w- m{p\ )dcr%WrITKB!35Ei |6X
ca@G`v4]430`sE'Uq-#+
oF@U^ u5lZfK?35b$)&hLj}F!C6'YDeB&K_iw52-6-L !)D[Fa9}QwvLDM-jl6lI-@%^EeWWr%~gMLfc&3hg np	^e0dpQkZ$1JcS-}u5<{80h!%v. |{}d
oFw+]@`.!=
{JRx5ZFmY4q{CFd#C`&XlnL_f?%~57,gcPD
'G3MUj$sNXhcP)-PS9\)Yv[ktQua$7MHWNAK`)Q!aA?0aPB6-&:6.6{!E%rf8.W%`LuaFli>k:i@vizcx6^aPqKr*uda5S`kF0#Ywg?sd6s0o6sa=2wyAT{4xzh>O#Ek!LaL4!'PAs6mKyX{geP]DvZD hU.'c.2">sMWKbM;'`_Mp@,f3{PlfFH5\7yJ5
&3>0
PkheMSZOWipQsMgq:%JJ	\0	`jC=L~0_;]UX7wCo!LB(B	+h!a55F[3us!<W@\Xe@t6&2Tf43L6T+gr$Eh<E-Z/fahV:yB[Qgb&]unuL(lb4F{DQ"(&8.~X$`:[sQ;/2f;ATyE a{
  "type": "object",
  "additionalProperties": {
    "type": "object",
    "additionalProperties": false,
    "required": [
      "syntax"
    ],
    "properties": {
      "syntax": {
        "type": "string"
      }
    }
  }
}
                                                                                                                                                                                                                                                                                          FQ1;k~-wkYc"<ww,n0Vy8QXx3'3;T)~:6Znw O\.=]rxt**de7+/(CL7Wj%6j@vEWWyTIZ!.9jl..z^R-mVhwXJRR'E(@VsR)q|	y1`Bw-!p{m`n.'S1zt~5 wwuz<hW{omu+Gj_qX>o?yB<y{9]sHW|_y	{|Fc4]hDo/kw^>n.6n_|;%_O{	{t)oGz5^O7oCIh> LOo3g=+M?F?]p|~=<]v8FUtrJABPIjVoK{Wo.ftB][ptv|~3TVL4[zYyct}o= (|G2p/]Kwz9dy
|??sC Mb"d"}7i]x^}}w~3m#Hn/2:?%NI?bIFo{c1uF>l9B 6/Zg"BX,Df*Io:r,5)/'6.`_ qWjt3~yN&Da_Y1rq8oolu)F<6QEpny&v+u+vU./p7uv3}?tze"s:^cPPJ8o$-+z'L	^wziZ!?Es}kfgK[?/>phx1|T9'\%N/q_y[<R^2b@7#&N($iGwK'|5|{m~ypoc?C'#Pq_KM~|}Iz|\tFdd8G<,0klY{e}7oX)2
1750O83Qr{7we&sf3nVq'EX"RfkeQfT
':3mCBbxY}?vs9$MFo./W2t|/F/
L_5?q8:=ln$3"/Wx{-tlJuFG'O{S~9zs>}53;lqB'FlN*~zK/V{~zBCS4_&~liz.KN^g6}W(Q~ILB-T@>Z?P hET9k;Ks7_O8= 8lHyIjtmz]9D=@N?SZ	ZL^^SUa,@+`gdG}GM
'OG?g;"OA@^Kku^@[TA
3?im_;P1@} ZUUs@ mi'lQ1fQVrY7Ux3EK:< "Ub+ePbGIEEUW$sX6kP&W@Q^"dM6;l!lIHH)=aEX6x>_7S'F-"Cuk;{P1	MF.Jz]tP[J?P.r|m,=J~Vge}`IN?vGViy3G~]KJMq~OX0 bbEmR.3yDlwxr0ctip]6%~xj"if~,dk9<$)F{!+5.eB|	$<s
Vc}_\5QJ(A> Dxa.h0"lQ_?WZY-&Xa5
E	)M^KVF;?uRc=Q .l
fV^+:sN:=OxC#vlXmXNN\qf4NmZ&neHazdY4,Sond%faqfuc^fAD7i?gm+H_z 8+3.z!65wYCx^US-+@UR[at2;~Un~>"KU_bNZ3*s:>NSPL	f%A2#r EJ61 p+.Nt/@B>|| U5(7`WSV)}e</b~nyltj0u	`@0Y"^}^d[jz6`Yc&\T$6Pxmg<cPn"*xzAc;L>?	n7tAgR\)Ck3<I\:H}/rpG4P	-;3.fjuCPbPj8x/!VJ3=x`QbAN|6"Ry4^@;q2k	I4mZYfCw/U&*	UI%5>`v@>BXZeh|U[gf07wS-3-B6BeC[F{Df;V7ByZ3-4VU]v\?E 17pNr:qX6MvW-,Wi62O$<'pIV7u9C/3I2:X&({I+,Ls3o>>em\ss]+T1Q>	Vn?9|}tW%},-a0_V+F5b";0 p !}xaa8^Im/RJ]U2=6u*kPp-	-B_UifI[-<he-:b{QE!;2KEMP.^(Qc5dDzE5`Mn})Dq]1CW`9n1)"	I',_q[J\i6L>J1Eb!ya[\]c?=5}'[>YJ8|$P;x2oca!WO-\AzH,Dk&o1-d2uflGd,=O
{H-e_UIz-"4YS0GxufT?E`Hc55uJo i7Z,|HdA [~r64{-Pe/os#7SQNGR4#8O|gw(e=g&!5HHKr';]k&}--|aBUv]4"}1YG0ubs,_o~iSaq[*ey0q^Oosb?M{\^$mTG)`l<?L W7m/S,j#Z4!	3Npbl"SOwmwC	NWf5"$A;%S/7~kN @t-a#wWS7.^&q(,$Gi~!iL
i4PoPU/j2^/)bIWtZSU{^Y@VV%7}skcm_2td.U@[ky+3p/p__D"_v&s 7{s3cI 
nZS*e`<:z}`3F%WPJpWx?\V,(~9hb^nucvx+xF>!xTks)641vmpC+ByXo2ST7tmm~HhGvz^8>y:w2uqbYLpb/\oTf/ckI<=MMISlZnS}kDRq!.S?\d(J)W+FmNF;mt#<nNc3YWA$W FP2)\Hh,'95&B1Ps|lkd2#k7Hd^H3/m#FLq$,o.f|vhk8De1]njX!mxs]}Xa +EH4q8xq|"?h&f^$9?0?-S$)w;70(3/?w1}w>h0H,g2 I4,4"SY^[,-X]cUef:&x0dmw*TY[&Q\K2 9u'ER9~lZf+Ju8%V+|zxBe-BJB#@XgFw6oB`z1G3!^Ly@dPAhIe@N c6QhR !{x7Cy%@mNp?BEv0~bz~9Lp|q|-	+8j, G1BB>1'	0#6]RF
i:PUJ;p;%P:JU&5f wAD1=y0<- v
jH%1}tdf5AEND
MrsQ2vAKA~j*ef-_6g0.qyh]=@/uUr&m#PKoX#P+b,+z
Rx`7RB1l*t'6X/PfAn*6:/VvjdP2`/F ail&xRmqpE249M}^!wKL,w[>XA Z2%k<{_U&y6~@~AoI##^~pw_K\`jL^r2`r'Cx'7LH8Rwc`~w*{1e+V~=F$sTm\..L8Ajd>W,H \!o;F>0(,Sm
Z|m:/}mnb9nfY0`B'NZ4
p%^.kZA8z+o>>m3P
J?:r"(I7[NRk5=:uXkP)M?y< k`tuF%i'ZdmmpC_aHIByn`uG)[B[$0Ti!h!T}:vI(Rcq+ueol2e"nF9\jnb,	ZE6DjI#RA6N'xg1#g}K-uy#AWi46_` $(46'@Y.,Y66R>m>hApqp D"3@ f'KBM>C>G>kC WQj;|OpB<cGrW k&8,yw&@G0#T=-.#LUxt 'upn+ox&BQUHsy7qg@%f3 \JZ|wxQ
D@3 zp\E'^mq#NH0QA. pf4oOmB#7R2` |e
SSib`R^!_grmUDE	h[z^8K6;O?k.\~SF -;&PN;v'pn;q#3`] o>#gu!Y2T
wU ].G	zVRE@Qosid]UCjS|)CKlRL1pe@pr)-<w^n;v)V+,+UZ1{;wXY`u*v@H<^&l^]Nb:.Vp^dd<Z$VWz	t
~mj_'aMv>2g;!\n%]q+,fvdgb{Zz	:is;<wHJV]\Q_YAD$`.2eD{OV5#qT2&H.?^fa`^+0v~A/(z^,dHY}M2 UxP.<J<tKtd
b^9	s>@`=_558j42=Np~n[Pr0fdS^3K]^grGlEW4<u&S/ vWT .,*T^,|Ef3>[4}G~c>?'i+&Cc.Mf*t.Ie ,sf33zB&Y:f08:>h5@I-JJXK-{i @P(&5
&M6QE6i/K3sw#vP4KKof(()~i~y)~Kain~"#-J:<BpKUqiBR{J{bZ.m=(p.'p.)"dLh	OB(oBw;Gu>E"UV.vR`H[tQ=i+s@-{.]#uQ.?,cRF
[B &vJA9e!_|f-I*lV,c0xM8(<8,@{F2X5B:
}Mv}0 90!2r#Yz+V3}fFqRQ*j;<(l3667a 0Z<x4Xy_.T1.=J3ja{`&8M`2?/K[Cft6l+l $<D6A.CEQZgHd$a,P'{XQVTfTi~H%NnU
D}laK~.\S}
=a wtq*qui(=IGKs/Fp;<(i)!i8`OH>D=jB5]4:1V0\VgZT/_9jAlA_8@G1\xAI$#kG5,aO\tU7@{DJ 5`	*i|I2")?X^Sc/0L]z`-W%dU_h
(;ys;}#rn+~#_,bd'\Ua15NW=,zA-sE%W*a ;KgsT]Gyg7.W_6l(~Yzq}j4oX=B]zW@BUR'ESh;EUoeH c0e}@h7;i9D[OT,_\\+4)xq~qwDLE`>]tQ+D0ZB8R@iffG1J=IlL2]5)Hrg9}4R%/	s@0OK2/Z2G&.X_O[L `B#ZcUV:dH~iRN?<'IVtkIA^-RF^iO5BWwh%KBs^$z,v8it#c!#Z
	 o08c0}|4O7HYSB }?2)_@\Pb~O#7QbJo:,%#&bZfi5;8QFG`op-g""DtB\S24][: ibPQu7n~n1LKGf0JB4YsK
TXn)B|0h@+F:pI\v[LT<,sfX+%q+y\PV`B<K[a2[mhC&46?aYFzd=\vpqwd@|r7f-pVj~3BtTHc\PZR"2Lm6#UL6m!K\h%E=-~1W0w"|\HGYw8	%(V5eGXc9kDQ0-9Z'<l5|Q_=OZh[^\S9!w@Vio x[. 6B(/KoJK2#tTvkL:WCKUYK19\krfRe}<0(8ijF:xMv0\*h1D]@X`Y]Qlpd~';EHR|DL/TGpK%>ol^u[v>9U(sP3b`I_W6^xaX8`W uFy%ogw0{="v9LPg
xflQ7nVe\FmZfDlnBNe@U17w,;_@P?Kiu[U9tEr\Nc`'ZXe-?,kNKf*:m]xw[9U.e7I\UO,GL| yPqy8p*FsC/1|hDxmlYmF-,Fb)- Pz~'D&W@J!0BZnJ|	(!cH-NJG!Iq!>":L?bc%Zjqyag$,1MmRPt.o8B0i!>yJs-(hpGm)qn:yHc}]QF/;8njHi6mHK;ttDN2Tqgli T]/@G[C0R)n]	m$>
7iD&MN-`)_;)?k5p1sVI51#B
:T12a)"[[Ye/DM!9wqiXvS~ettvCF1^gF3
uFhF]\ dSG(y*H(Nqs
t Fxs@ZG|XR'jVrh\3F2g0bR;eIb/>]1VRnv#71a' @gc@3\u 58iVK@%OM{.c{6J_x$8	V%/.[4fUjb1V/6XbAJJ@tq<V|hV.@m$q:QsNy;2jS	}szfcM;*: :VOq*P"	9:0&~9z5i*zos> |'7I#fU,96vtc\$uIKTtI
Gespp`nwrl8'[!OOJE\d78<UZB@.Av}VSd)k3*c]`rjhCbKWpIVF)^ t#V\TEb31o}d7!%+nW9$fc]#8STX<W
Z@&FVC l;1Y3s;z&mjiB UPBk+@I0Ps4aH,&[+TZVq&pM p-vL!>CTkzmyeK/	.hx@0nxVe&q[n4A8S))0_c8AHyeq<Q,ybSX~=]6SR=-8<C21])j)p\Ak&M!s59)Q&?SS=7S2]La.;	s/Sb.c{zo2~^G)"+_X0kuFA;z+A4fD"L5ARA='QvE(Uh4BX6],S{{u8>wo |Lqc;;jL^e^O]KT+ZrLS0DeO7JqU<$,BxG8:lqe&o]7PK    nVX    9   react-app/node_modules/graphemer/lib/GraphemerHelper.d.tsTj@}W%5[(iJ+8BZ;Y.+_0[2MK9sftt$G3	aC]xpaj!rO3A"\p_VTH%( KX!U}b!"# Pa`nFadX}Ao;gq= J|1Z<H`aZV0	,uSpKj`Q40%fF:(.Vl70r:zd8EHJn1<zxeuqb3Mu!9xZ5JcX#*lkKe)5wqP8{^'dqpWhM@#QZ,(t]k\IM]Exe*.?zFK-F#5/x77?;LVQ~=8J\B7x`vJd|PK    nVX2n     =   react-app/node_modules/graphemer/lib/GraphemerHelper.d.ts.mapj0es: LZJ$)-w$:eM[7L9^\wF%99brm8(}$Y8,}P}mL;#75-pJ*!FuUJOK!?`4BcP\|e63OsK2|	PK    nVXj     7   react-app/node_modules/graphemer/lib/GraphemerHelper.jsYrFSSp@I`Bb32q3ub1<G +hl.>3j1juHa|ke9?&[KW2\0t3J4eKvV}F#'Y..B.k()\gWU\M,tkdL]GqqbOD$FilE&'67%#a1.[Dt#`OpR3?eH%Ld
g:bOCD;5sSG]W	R6)POm$-H%x 'Fib\5$#hl = 4F#%AHf0KT(R8nF#>!"V1>'a	|/cQjiH;-2x:e(C<Fqmyj^F"1x1!l	:'$E-, e"+Txj5L,	CV'nolUh(lZe%Bm)(
ceZ	yPFEiHDh,r6X-9s 6yDxGa3Vn .jIU
$dI]ftS,VM->iC	lW.%~g[@/<N<NL~}XT3p@O<r	shL'yEjM1}2 x ,%w&7zp>!Y[6H*BoEHl,, ('+d;1tLY>"Yy/&.y "W<F.;)Dqv""mEt0k&9e/D]uAw^K
_Y>]`v1iT,	.h{|_>Z{twvMH+'AF%^V%a3%sP;!ji}<LJC)KSF%@0P 3;\=:{DIL]mnC]"#([[(({DW<]3to)L>:hG=<.il7bp~OUTzyOCK7 @:~Rr:!>)KOjqR.c< dPPW*sUzs??//<7S`]Z|^P>V{x},lPe{OEh4TW>5+WX@-0g?t>6<aj8+btKNAtS#r1]'eZgky>lo&4DSFNMW$H+L/r]xHgiY)s-gk9lQZv=:-cPK    nVXB  b  ;   react-app/node_modules/graphemer/lib/GraphemerIterator.d.tsmOO!)&6fk&z3-CSI1|^qz	E,&p}En=aH-YY<RS;89iV:^!#N-F
c$_Yn,:S<P: k@VE]ekurgFEi|2Ei<$/bxc6|[J98CuM$gOk*9ba4u1|bMQUMp=qq+EPK    nVXWj     ?   react-app/node_modules/graphemer/lib/GraphemerIterator.d.ts.mapmOK0[{zemJZh37L^:7Pb,eTf|fOy"=^:7($I'e>D8vA:TY%29;<*jxPP>yl&Zv%^u~P(R%PrIb?KT%/Vg#U0l@kT4PK    nVXE  /  9   react-app/node_modules/graphemer/lib/Graphem"use strict";

var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}

                                                                                                                                                                                                                                                                                                                                                                                                                                            )R*Y
\~r9]&._O<4887Z)`x{~zKn;M}`[^8[8bS
8'66qj=wWxw<8K"Ys}WN 7|/yfaiO0~ALS;)8u3DKw6w>:|?	
V "!.H,SQXbxIq3t)(_^oY@d Poa\2cVR:1[D)YO}%EeZ9YBI8 "mXpi?5to0.}no	2k#?=pLQ-+T`6QHj|t<98GR HTb<$Jbfp/%07ngv8r&ma_8!jT.!K\BgPk$.)\J9 w_~/+PpP6XL)y2<*_p*gk~fc{<j$ZYBBGLQ=a~*p;7w( VdBzHghV:MiWH:n5w0z3WlCGa[nW(Bm02'f#+^^!k&qzCIb7NeJ7"IZhZS%)^ |de`Wv\2D_g~#5pN6kWTl
ElpQsM|E.-u ?_T.2l!T*8JbV^ h"%=4jbM*&n*\HDc!""$3
EdLz,pi9	""G89npDEpyi
~ZIW$L@4mYrP`	9xvnB7=Bsj=H #dvQS<J=QO%-l*}cO6Q%I1#;MSFVOnd)VnaQ)H2J+M18!x5*U&\.
mOq2Pi[b|23PMTbgiB&R!8?8d.$R<uii8l
U-$)XHJ"-G];cAK^-J3p_F-/3Psed
eNx<VarZ1kT)SK|11<U	=YF2=dG
7
31BV)lSV RRO$b]Z}oP'dZU ]Wu!.B
wZGN{v(3mB"iAwiH)=5!zP 4A+)1*rh*~wqqY$jOWO"VMW)r+(T!x IqYF2FX};{Y)GgPvI8$CCY2HJkU\
2_y+IMi,-6%GZ.M"Iz7BO#gMY,V_V_
ij|
48tqZMrb{:wX~ce!mT<;$GQYj2hW2lj
%{CRA+Y
D	'Q=8b?|WMB
[mr
sE/E9g8|g;BzDT(^=UJ$D,PK    mVX   [  +   react-app/node_modules/has-bigints/index.js
0DW M=DA^yv[MI6n*((v7c@+u[jw,PtLzV#c!M];\ip^m"WB`
.*(xox&J41Az
0tij
mK+vPK    mVXQ.v  /  *   react-app/node_modules/has-bigints/LICENSE]RK0Wrqko8[!Ms4`+#ic6v+E<3k-o0&$gc>YrZ5T`<NA	NktrG@8k`l#(Pd!\8vF!Tz0jX7q!-0K }p	.}poOdn
I/^'N7CKMn/>E&1i"`[fs\huI'(Loqe/X&{:;&&_	iZ[Cvj!4AoC]\'>l'bdk3^%M.ves Z;/J!	VgXeZ2^>qo(xd[&tM97BJv5CiK^n$-+'T:E{A*y(25Cgt]W)o>%E>g(2HEH|&R6o=YT:.d#6!q	JW."2F#8F??PK    mVXs    /   react-app/node_modules/has-bigints/package.jsonT]O0}&
8lBcbx`oc&qIlNJHu=c%f&kmgvX5Wr@.	R ,ANW4N)-4-!4q>sVyD:%(/'W-<Zl[IS!S(
#q*& 064t\flO&Dm$jPnpS_fVBai,|&M7{"TKemL}Lv;5.C-11#&D1q
VEfud)uq:
,\5X{>Vyo;WxV,u&O0k5lgv0%u}sEF%h<BMUK\ 1XB7^oSrZ%7<a>WN"80=s-[Ph-t^9.+-Qr{cQ(~EH=`# n|^^Dxk}Gw9HJgV
>z8hafd |If5R4J< PK    mVX6}    ,   react-app/node_modules/has-bigints/README.mdUMO0WLR$"Q8P!.T"7M8k;i'M]@]Pk/Nh(1[)SGm\[f5VfI`1FR =A]	@\lDQt: ,*P<Btm6QhF9*GVdx(y4 3<zQed=Z(_!xTZ|\B-pF"czXmH)X'V]06N MSH{	x[!%H<E%cuN=gV]csXB	Er}\`=IbV%TLB\L%;]B}sS89(n~;.I?XBmuJa:v4^8)Jid!;QOe*pU
Owt	wood![/u<C$%Bkyt6@Y*%]{wrg'Q&]~/;o*~^_]u_qPK
     mVX            +   react-app/node_modules/has-bigints/.github/PK    mVX+  F  6   react-app/node_modules/has-bigints/.github/FUNDING.yml}J1{bC/G{Q,(EOf$27m+$1a]-h!X:N)\amwFzNVX`Uh"dCakIa{v4{A'*;P5ZzITeO#Q	'	!U )4s[u\NRQ}oaVhO#y*E6]D% pC>VKYt=w)PK
     mVX            (   react-app/node_modules/has-bigints/test/PK    mVXdZN    0   react-app/node_modules/has-bigints/test/index.jsR;o08&;bjRUC.jdB!iRus^HK9 8lC)H(m2$QJ+I[bE#JX*Im1p,J3em uH3A}l&|vEh:-v?ta9rO].Y68#_gd2m]Y_;R-K2L/Yn0@%t=Wh^i2;Xr=[c~qz|PK
     mVX                react-app/node_modules/has-flag/PK    mVX   @  (   react-app/node_modules/has-flag/index.jse0b&^#3`k!5D=|#zt".;8\-I
jn+P{G{eW%:'G+Db[vhnA)A4R
cSd6[:g>PBLoMD_zl2'PK    mVXE}z  U  '   react-app/node_modules/has-flag/license]R0WfI`5m4!BbhyJH0mlhO]tc7ySSt_4>bq6x[7^4!6h#4O&@/p1wv8!wpH-h]c5AlC;xx_Iktv8{MAm12\j^=;C<O):y%]k$[[e}6}lwui'\bQv	Ft)MiF&N\?whqCk#}6S8@. W|Q3mW3Fz-fqcjsk

LB-3+hs"gcj
pCJT{"TJ.r[	xWq~8D;2mX%+gb+%PX-z+j.)[j%nh=X\LTdEz/Z2,
M%a
!O4]qDin|b6r^)e.z;1I3 JpqO xWJ>JD,?./fPK    mVX1p?    ,   react-app/node_modules/has-flag/package.jsone;O0
+CJ0!`a`*b|
qL|#'+*Tw8m&XBqS]R%8_q`0n3@`-z).y}yK:cOA&t>XcscOI&(60jFwq)5PvR\O|aDp?) 8XY0>`	hGbz\ZZn{@TXG]h!
5*\{+9	3C>hR]W?PK    mVX    )   react-app/node_modules/has-flag/readme.mdS0}WLq!1IiS
-&}2V,qvJm)K3	43exc6!(L@m^M~fr$O[>VXN.:DjM2~?I1rKA	\`B-TYVA [i	9c,I`m1UU^Z'5G^!YQr.7BF_?{|6!Z8o(K +w#@'4sk3@HYd
X63]udbnze.(8sFY* 	*U}TH>h![OD<RG#,7\\}}nMQfZHy_Pn?\6e PK
     mVX            0   react-app/node_modules/has-property-descriptors/PK    mVX      9   react-app/node_modules/has-property-descriptors/.eslintrc=
 g}rBK)Y!5h1'	|0\O3*YwFSUpgsfk#j23uUo7mZPKOBu8zJnQPK    mVX)&Ql      6   react-app/node_modules/has-property-descriptors/.nycrc=A0+*(,T8w8fG
D4vAyC!.IaKI8Y[^}=K?B!9:1PK    mVXr$r2    <   react-app/node_modules/has-property-descriptors/CHANGELOG.mdK4+,:+@`bS)u%y)qUk=vU!!:<Z/O'H}y%q"V2/Ht"8FGBpEeH5Frq&^wm}Yp48DO<`"oqy9.k7AwiZ.:+o<K8D\_t;B7KxY"Uq_
[9NZs3,XetzIA8Uhiy.CAFL+f2N6#.Him=	tYijIV$5QKV(sbz5>-*y,giyh+Hv	ZY@@d?h?|ia%}7Mc.3igDqwn:TAZ	mTp5SLzXxKY'hFjLAv3m:	@9X9&]S0h_fiB5w`DesR}<;/(GAOa1My&J:&t8hj0=^ 3UW=:C<t!PkZD
rX<\^W=(,uTEJiyPI?c={epfYm32ut=iksRnMxdmTJc)NMmrPK    mVXo$z  1  8   react-app/node_modules/has-property-descriptors/index.jsu[K0OqJ;"buk&dFI/@s$0$y\D$%l>Y`&^!Qx<pL[\6u&%bMeV,">U^'!(,^AK	RifpsPL&
S~FKo	J.;DHJ/e;kHAQOkc5ZKERyl7.w?Na{
o.&aM^ecm+O-/\V+M?qIPK    mVXj|s  +  7   react-app/node_modules/has-property-descriptors/LICENSE]R_o08JQ7qo&1[#x
1PRIHww42}>?6Wv:dop16n|M_OG@PopS@?n<B0=k=Yn7F>h}s91:7 n,z`n[puqrq$f>gI/&Nu9r\hQ.O00dpw3dL\{]%i=lVEw~0+Ek:J1fUoiG:Uo {[zL$"4	*2;
J^e&2X
v Nh^=b?d% ~ZT(,|+~b$5
HF%EEd5>R tsV(!m!FyBUxTk$k*ZU	,.:\Ka4r@7E(,vkA%KTHUa4>Lt'+ $5 ,jt	#WE`x~b PK    mVXlfJ  %  <   react-app/node_modules/has-property-descriptors/package.jsonUmo6
B4:m,XvHh$HkHQv^z>$J6mZ669F+"gJ`2WFc +aN{#T;Z4z
5K`UW{n.*BpC\qLkpR
Y' 5L,rW} ZY)mn='F8(h/i+lK]*UTd_2LhpPk	a#`N=nWB6Cj3':`StiG[uD_;}yFy-TG`o^z=A1oqHI+BO83j;QdJVV7zipz	[V:mCBBij:{ex%h3llocj6M'"]0M{>p{rVV/
Y^`4/+{B*h]YY72e}YS.~?T7`Z)*?EK~$8np8V54B@R>S~:~[x' Zd\C3N"|=/I,t@]*uVY>*em`|jmtx8h;JkcpP4$,K?%/0Px:^~wAbl5;PK    mVX!c    9   react-app/node_modules/has-property-descriptors/README.mdUmO0_qSI!TvT7ql's^>?y )5R1m^LR22{7R56yLph@:E%hdjYx;7$#\wdo1SLLDk0dte-Yx\ssn<b`*Y[D>LqTp+d-#!%RLXU`YdcWR1"f
GZ>0%q_w O4W#d>)vhJb-fGdstrY1PchsR/}<ON\B#;/43l\{wgS3 tm l2*G9P*mEX]Kq'ow*wR>c@uC?wk=!J*y
s'!.PY6t!jEGIi +KyW4V\ 3Q,|$ SUN#D? N8zmM!wRl.#Zz3S{L]K3:r'I9b:DBnoMOI=]CbA'%X<R-VgF<ecw%AXh*4)AJMP5N}C(MHdPT\1FZZ\8K%(q<pD=_}0UGSCBPK
     mVX            8   react-app/node_modules/has-property-descriptors/.github/PK    mVXn  S  C   react-app/node_modules/has-property-descriptors/.github/FUNDING.yml}Ok1<KB'fg7I&O~FBYo{o	k2 =5:odj9(DGIz[s2;e
n`Wa@B,@(+6UOWp}KZDjwZ!j0@>qBQuky%LB;@Mr1PAzbK	y.z*Mj Bd.k],EiYGSCx?yx7PK
     mVX            5   react-app/node_modules/has-property-descriptors/test/PK    mVX!
~  }  =   react-app/node_modules/has-property-descriptors/test/index.js1o0gW\',8 $a tJ{,]$KG?>"X2*!q=KPPLOmbTEq<-jR7\s8!"j*54$Ee20;q8BY396:KB3T&Lbak'l`ToN9fe[X~JH\ +&H[=|Y)uA:SymKK SP?qT}E5FWjKa
g $Ss da1a/@3HO1_2#4Z)\J|7U'PrV$y+ocw1^V#j}9-Yc2.gK~X7eIUW~n[UZe<pdCkPK
     mVX            !   react-app/node_modules/has-proto/PK    mVXaV*   +   *   react-app/node_modules/has-proto/.eslintrcT*/QR()*MS+JRRBJ9YEIJ:\\ PK    mVX1M9&i    -   react-app/node_modules/has-proto/CHANGELOG.mdM04
Q]a))S$;33(=GHDRE2/#D~u9";8&/),-0-$bNF8xiSz7K7+iIM|mSO\b7nK9-*_KmM#%.G{FUj!n{|1YG--[y0t)L'nZ_?G1SC-DS?D-T\3QXKr(3$}FXndK+I4
kA`&Pp5F$x"8=98l-:WTs8A
Q:(0fas^e/68ta[0,~FBhh5Bku0iv5q] \cUO%h8ix#W]mW
JB6GFW/c<G{	I?3R'_<BAT&t]+/S,
6PK    mVX>      )   react-app/node_modules/has-proto/index.jsUK0DFBlzV9 
E%!U;Ivy#1 I=(A@#QkRKN]'b	;PW
,5R[@kMT	&z4CPK    mVXj|s  +  (   react-app/node_modules/has-proto/LICENSE]R_o08JQ7qo&1[#x
1PRIHww42}>?6Wv:dop16n|M_OG@PopS@?n<B0=k=Yn7F>h}s91:7 n,z`n[puqrq$f>gI/&Nu9r\hQ.O00dpw3dL\{]%i=lVEw~0+Ek:J1fUoiG:Uo {[zL$"4	*2;
J^e&2X
v Nh^=b?d% ~ZT(,|+~b$5
HF%EEd5>R tsV(!m!FyBUxTk$k*ZU	,.:\Ka4r@7E(,vkA%KTHUa4>Lt'+ $5 ,jt	#WE`x~b PK    mVXWH  p  -   react-app/node_modules/has"use strict";

var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}

                                                                                                                                                                                                                                                                                                                                                                                                                                           qQ@yzIOXEPK
     mVX            )   react-app/node_modules/has-proto/.github/PK    mVX  D  4   react-app/node_modules/has-proto/.github/FUNDING.yml}Mk1{~<KB'fg7I&[(-}	k2 =-tzod8(DOIf24[e
nXc
KAx {t;Ja:pKspik8Plmv&PdqtP
e8gSPs[w\PAzy/]]0)QgSy.=*MxCBd.=!j^E7!wp~<T[PK
     mVX            &   react-app/node_modules/has-proto/test/PK    mVX;    .   react-app/node_modules/has-proto/test/index.jsmn0D+fG@77R? 2a).VwmBUbYMe">T8<nWMiuSlfU Rviq&
ExaHO0X7%jHH0axa({j'_M/&xNJ-?)dF-#dkAw~5=v;Pr`;*OS7e_PK
     nVX            #   react-app/node_modules/has-symbols/PK    mVXC}      ,   react-app/node_modules/has-symbols/.eslintrc-
 D+BGKkq+$y3392uF2l[#-3(0nqd@((T@au au_jJk( \{VTh~a~PK    mVX)&Ql      )   react-app/node_modules/has-symbols/.nycrc=A0+*(,T8w8fG
D4vAyC!.IaKI8Y[^}=K?B!9:1PK    nVXhF	  
  /   react-app/node_modules/has-symbols/CHANGELOG.mdY}^%~*]*_2 j>=PZR<AOwCl[-84 N #t$tOrG?<?;r/_t+>^ocAc[|:PH]]w~'^n=LxAS;}3at4m^71K'?nFvloPVnfon6	?d	&{Rcr2/#=Yn@mNdW:*!F'AR]6-01~C=.7i	K/l_3(-LY9iKyP 	 )ovr|c?m8"kTH4YA
F@0Wxc<gr>%?K/k%XCB<hH\HR2q26nLKx _=mMn9}rg7o	>eo
`I-Ur)L-_~6shi5NiI
{Z%e9dNw,D\+%pP=Z0<H.XFMJB0sas_7T$nkUhvfiY>fY4 Ql)~2xh~
:s"[qF\bhOrU(]jWZomLISLrE\j2]>4%H_-'aA4a**$-dYi*EWU0MM%\4F:F.S91jVruJj=g=U749-kd%x{ 0/]!hDJre-L<gW~rRCE(YDR:]IjbQ)nVDln+1g4h.D[)/9DnoaUZajG> *WSO~xxRC>wqzvUnBcd8/)`l@ 4Dp9-~ dU6cA~azV:fJ#
!DL#^8 /s48.s %(zDtk$j\N+sgXm&,.7hln
,xpZZHZB/E~FW-[$hR`#QFGO(C\+}VCu.zy\%uBqH8?K/
.Hi]ZR~QGC^e+Ily"2 7b1`y%/Ptn_/l<{MHYb*e+4>pq(%s,E~|B'L_5JUF{l7,G)TAlm{%qTzV(G=FG3@D*;]"miEK|Mf0.,SwhCZ"}"f*[M	TXhUY":%-Rxe$#Kz"q
5YeP^"0dF_iOffnG|hMle-"j+T23c>J:8wq>,E^^-23uGR7 nyV(Vk$\i!7J{LcVjBGGN[hX{WIR>c:}0+B1f4Z.+UCv(Jd7	m_b5+4&_;k,N(j.t#-q_Vghqr.{ZQ*|(oW	(O~_oe^VEBsZG5)n2N8<h~7+	ec<6Gu+}x=GeU^B^>=1;/R}6,;x1x(W	:9,{]|B04j_6Pu1h;UQ?-h x\U1i-Q1y>>Ea^!Tyh,I
HtE=6ol'5*TH
&kg'pT+@s0LHPGQPaaFqTLQzNofj|{ih90PB)WB{w	pVz
X~ns<PtK(u
)g]9e VS,<t(,t,+)h&OP',|PK    mVXU     +   react-app/node_modules/has-symbols/index.js10Egr
t)zNZ"		B;6o?	8FTB\u q?Cq<7Pu &:lL4/$Hb0Vb]$Fh<aY]YR|$H,I$Zx-%t|U(s_PK    mVX^)Yw  /  *   react-app/node_modules/has-symbols/LICENSE]RK0Wrq7-9041l"E57PN^31C?~r{B*N{cg0FtG5QN XPmPf6t(Ep2HiAyo;z]Nz*DLC5bZM{\M%>8EM>z's27_{g'!%N	&RE"u4d0-39.4Vc:$fEBNh{4R{;lZ}p{[j.WEyFMpn?jiT25TR`Ek|&pB9 -Yg%Y]o32-v/aR7KFF@QqVG-iOo	!BEe]A%T;Y|%/7Ub|@R A\3.J	dtK"I`XziEcl$>L)7,*ybNDq%{ewryjFr#PK    mVX*/  X
  /   react-app/node_modules/has-symbols/package.jsonUYoF~-0#) yk`E]vw)H;{Ia97I"XIjS=s+PKaYSX.L`_SpC@abItuRJnCAqF"fesQ.'F:;I:]?o?f- aIvE&"
?ZzA A,M5ol\F$o-&DN/\HcJY'OU\Tt-vCA,l3IV_hk_:-#2Ch
`ME~0f.5=xpP8E4y 2h)Z>kP/254$VB-B^8E$|MV*~Rh E
4Xq*x}MLDHTCJ3tn9P}e_s~f\7Xlq0IU*emL67AA0WMK4dRH>>0A15gdy,qL/+m6rqi0FyYj10(sVHw3H _f~3uJ-[/
X&%^Cqeb9=4py$G/pg4!O:E~h8F/B#MxjXr^M+
bIa5cvfZ[%5j."VXlf9wLL0Al>Y6=H<2$X9sC8?LCK[H;{&kYAs9Yw=<ac;G(hi`G'#JAF\a"y%E6=g"$PK    nVXD    ,   react-app/node_modules/has-symbols/README.mdUMO1WLT@bw-RmjQ8k4U|M nokNhy6h8/1>>Pn8(8WOmDi"}PKp8' 8+"E(mf%5(:k-xuR^]G[ &s/}@5VB48_-8h.0F6=k&,vJ
^$IlS^;h)X(:h;Be| oBUG<
\)Q8UXY71`>Fj/w$"{HO#meO2lg	Rm1\?RC/-;!'S>Z4 F{% Tu)\?&[i 68@D	w(F*IV7$v)w2>Ye.N_S%<{]P#f~	$kv,T5jR/$VK1V|.(3U>v;fc)4e9iWu^X `orI]?MrWO3Q_QERV4{wit'-}eEyPK    mVXrc    +   react-app/node_modules/has-symbols/shams.jsTMs0=_`+_3=tp	L^Iow>m6tSEBzW#(:6	Kd.XTY-0u4Ha^
%a0!<GbT,M}U6,\kG eol}j{T<4 7-{8~OE-rp"R>'~|dh	y"XT0+DclQ+!&VK3`&b!YaL]}8AGN!d_VW;zu0X=
m+NePfL" $|s#a
ab-SHJoc@*YJ%Yk&RGb~\7@'y`|%S#`kW9rnG<;[E1e]v7EGOhr]T[nZ!c#5nwrX;PK
     nVX            +   react-app/node_modules/has-symbols/.github/PK    nVXUmQ  F  6   react-app/node_modules/has-symbols/.github/FUNDING.yml}j1{bzTh$"&dB&io-52C65h!XZL^N"_6XB*$pi`. 2c~ZT|x@XPA'Sv0mZNKw5Y~_Gt7FY^%<%H2Vupg,j.oaVQgSy.E*mn] .e@)6>6kYt;38?;PK
     mVX            (   react-app/node_modules/has-symbols/test/PK    mVXy    0   react-app/node_modules/has-symbols/test/index.jsMN0T{*Pr'xDU&4ggyf1 &X"`@5<r5T3aNTr(\Ne6,K
mSt6%NG.@Ll	@}JY&vf9m+k<t(uw&viN[Ee:`Sh[ZqJ@#q?q0O/PK    mVX;z     0   react-app/node_modules/has-symbols/test/tests.jsUMo0=vYtAT#y(GI4M[$==LZKF,x T4/
h7VVZBxm
V$n7dS1(S$ojuiAI#Y! [&ATQ+M=T_	4XdF>P7FvZrWl:I>-B06["n'qE^`X'Cfq_RV4..xgSs /7:=	Gyo.w}Rwe8I?$C>9|s6;e-~:*>wq$7xn>qh?
X0i'W*vrn;E!*m)\NGav?V.kUdW"6Sq}WP[4N%r{QX/8d:tn w3VAz}l/?piqi'O6f
;I+i=y :s4RlNkmPK
     mVX            .   react-app/node_modules/has-symbols/test/shams/PK    mVX6    8   react-app/node_modules/has-symbols/test/shams/core-js.js}R] ~'hgPBw_(uQ7iHaHXEqV	(EF^{]NzuYfM;QOJ8*6aEylX6JQZ;,;r{~i	cpmqG &~tT'ro/X^ho6dzoH`}l=MS)'ZY~P>7	Dv3+jEvrNjV:zOwS1b\K+St*L#DOVPK    mVXfy0    I   react-app/node_modules/has-symbols/test/shams/get-own-property-symbols.js}Mn0J Q='p`z&TQkJ+EQ2~3g1q0;MQU Fbh!`JGQCAO-=,t.O],t))6g}`Qm^4:(>{W3K%aUL
CpMqGG M|N4WW/zY5!Yu86~d(WCc#k>5/VZ&%O'!|h5x'a*	^yg'|a~ PK
     nVX            '   react-app/node_modules/has-tostringtag/PK    mVXaV*   +   0   react-app/node_modules/has-tostringtag/.eslintrcT*/QR()*MS+JRRBJ9YEIJ:\\ PK    mVXKN      -   react-app/node_modules/has-tostringtag/.nycrc=;0DkIUlHdQx]P4)@B:Q?_s1)Kan UuUs&k8;yf1oNS$EhQQxWy	7])s\IW5H!f"R+PK    nVXJ>    3   react-app/node_modules/has-tostringtag/CHANGELOG.mdVn6+d 3(PtE|I^!RV2PWHe]?AlyydSc34>]NMY])MwGdN01Z0/}D<3tOi:vy}-@? xnj{u'pgL'YS{GDooSE~x3i~aL8tmaz0p^p~o|saN}=ox};CBe<qSw0lao3L@H}<c HgR
1J^'ePrW?2g9tRL;`B{sXsb-^%X	g>kSR6&4%,!MRGPY|2b0<ehT|v*KHi+(il.\>E|-})1
$36%Jc;'",B/&JW}@I"Rw/C4{On6ma&]iuc%x'8Sm [1D\(c2"X?\1.ybu",p0WOJ*8OyDoUAutZAJ=WL7Hr-MvJVDk4`9+wE!8USKSE 6^( Q,`|1F;%^Wtjll$h:6/Q`^"')FbQznZVg9In|pUeG]t$k^.I5Kcjg^Im=KMV}i(	$E]QB!MOsmZ{'I)F W&iy& ;i#:W71HDGI|LR@^+)p:}Ah\mOFhLD 5T\P 