ateAliasedSymbol(symbol) {
    Debug.assert((symbol.flags & 2097152 /* Alias */) !== 0, "Should only get Alias here.");
    const links = getSymbolLinks(symbol);
    if (!links.immediateTarget) {
      const node = getDeclarationOfAliasSymbol(symbol);
      if (!node)
        return Debug.fail();
      links.immediateTarget = getTargetOfAliasDeclaration(
        node,
        /*dontRecursivelyResolve*/
        true
      );
    }
    return links.immediateTarget;
  }
  function checkObjectLiteral(node, checkMode = 0 /* Normal */) {
    var _a;
    const inDestructuringPattern = isAssignmentTarget(node);
    checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
    const allPropertiesTable = strictNullChecks ? createSymbolTable() : void 0;
    let propertiesTable = createSymbolTable();
    let propertiesArray = [];
    let spread = emptyObjectType;
    pushCachedContextualType(node);
    const contextualType = getApparentTypeOfContextualType(
      node,
      /*contextFlags*/
      void 0
    );
    const contextualTypeHasPattern = contextualType && contextualType.pattern && (contextualType.pattern.kind === 206 /* ObjectBindingPattern */ || contextualType.pattern.kind === 210 /* ObjectLiteralExpression */);
    const inConstContext = isConstContext(node);
    const checkFlags = inConstContext ? 8 /* Readonly */ : 0;
    const isInJavascript = isInJSFile(node) && !isInJsonFile(node);
    const enumTag = isInJavascript ? getJSDocEnumTag(node) : void 0;
    const isJSObjectLiteral = !contextualType && isInJavascript && !enumTag;
    let objectFlags = freshObjectLiteralFlag;
    let patternWithComputedProperties = false;
    let hasComputedStringProperty = false;
    let hasComputedNumberProperty = false;
    let hasComputedSymbolProperty = false;
    for (const elem of node.properties) {
      if (elem.name && isComputedPropertyName(elem.name)) {
        checkComputedPropertyName(elem.name);
      }
    }
    let o