, signatureToString(
                t,
                /*enclosingDeclaration*/
                void 0,
                /*flags*/
                void 0,
                kind
              ));
            }
            return 0 /* False */;
          }
      }
      return result2;
    }
    function shouldReportUnmatchedPropertyError(source2, target2) {
      const typeCallSignatures = getSignaturesOfStructuredType(source2, 0 /* Call */);
      const typeConstructSignatures = getSignaturesOfStructuredType(source2, 1 /* Construct */);
      const typeProperties = getPropertiesOfObjectType(source2);
      if ((typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length) {
        if (getSignaturesOfType(target2, 0 /* Call */).length && typeCallSignatures.length || getSignaturesOfType(target2, 1 /* Construct */).length && typeConstructSignatures.length) {
          return true;
        }
        return false;
      }
      return true;
    }
    function reportIncompatibleCallSignatureReturn(siga, sigb) {
      if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
        return (source2, target2) => reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source2), typeToString(target2));
      }
      return (source2, target2) => reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source2), typeToString(target2));
    }
    function reportIncompatibleConstructSignatureReturn(siga, sigb) {
      if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
        return (source2, target2) => reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source2), typeToString(target2));
      }
      return (source2, target2) => reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source2), typeToString(target2));
    }
    function signatureRelatedTo(source2, target2, erase, reportErrors2, intersectionState, incompatibleReporter) {
      const checkMode = relation === subtypeRelation ? 16 /* StrictTopSignature */ : relation === strictSubtypeRelation ? 16 /* StrictTopSignature */ | 8 /* StrictArity */ : 0 /* None */;
      return compareSignaturesRelated(erase ? getErasedSignature(source2) : source2, erase ? getErasedSignature(target2) : target2, checkMode, reportErrors2, reportError, incompatibleReporter, isRelatedToWorker2, reportUnreliableMapper);
      function isRelatedToWorker2(source3, target3, reportErrors3) {
        return isRelatedTo(
          source3,
          target3,
          3 /* Both */,
          reportErrors3,
          /*headMessage*/
          void 0,
          intersectionState
        );
      }
    }
    function signaturesIdenticalTo(source2, target2, kind) {
      const sourceSignatures = getSignaturesOfType(source2, kind);
      const targetSignatures = getSignaturesOfType(target2, kind);
      if (sourceSignatures.length !== targetSignatures.length) {
        return 0 /* False */;
      }
      let result2 = -1 /* True */;
      for (let i = 0; i < sourceSignatures.length; i++) {
        const related = compareSignaturesIdentical(
          sourceSignatures[i],
          targetSignatures[i],
          /*partialMatch*/
          false,
          /*ignoreThisTypes*/
          false,
          /*ignoreReturnTypes*/
          false,
          isRelatedTo
        );
        if (!related) {
          return 0 /* False */;
        }
        result2 &= related;
      }
      return result2;
    }
    function membersRelatedToIndexInfo(source2, targetInfo, reportErrors2, intersectionState) {
      let result2 = -1 /* True */;
      const keyType = targetInfo.keyType;
      const props = source2.flags & 2097152 /* Intersection */ ? getPropertiesOfUnionOrIntersectionType(source2) : getPropertiesOfObjectType(source2);
      for (const prop of props) {
        if (isIgnoredJsxProperty(source2, prop)) {
          continue;
        }
        if (isApplicableIndexType(getLiteralTypeFromProperty(prop, 8576 /* StringOrNumberLiteralOrUnique */), keyType)) {
          const propType = getNonMissingTypeOfSymbol(prop);
          const type = exactOptionalPropertyTypes || propType.flags & 32768 /* Undefined */ || keyType === numberType || !(prop.flags & 16777216 /* Optional */) ? propType : getTypeWithFacts(propType, 524288 /* NEUndefined */);
          const related = isRelatedTo(
            type,
            targetInfo.type,
            3 /* Both */,
            reportErrors2,
            /*headMessage*/
            void 0,
            intersectionState
          );
          if (!related) {
            if (reportErrors2) {
              reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));
            }
            return 0 /* False */;
          }
          result2 &= related;
        }
      }
      for (const info of getIndexInfosOfType(source2)) {
        if (isApplicableIndexType(info.keyType, keyType)) {
          const related = indexInfoRelatedTo(info, targetInfo, reportErrors2, intersectionState);
          if (!related) {
            return 0 /* False */;
          }
          result2 &= related;
        }
      }
      return result2;
    }
    function indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors2, intersectionState) {
      const related = isRelatedTo(
        sourceInfo.type,
        targetInfo.type,
        3 /* Both */,
        reportErrors2,
        /*headMessage*/
        void 0,
        intersectionState
      );
      if (!related && reportErrors2) {
        if (sourceInfo.keyType === targetInfo.keyType) {
          reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType));
        } else {
          reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType));
        }
      }
      return related;
    }
    function indexSignaturesRelatedTo(source2, target2, sourceIsPrimitive, reportErrors2, intersectionState) {
      if (relation === identityRelation) {
        return indexSignaturesIdenticalTo(source2, target2);
      }
      const indexInfos = getIndexInfosOfType(target2);
      const targetHasStringIndex = some(indexInfos, (info) => info.keyType === stringType);
      let result2 = -1 /* True */;
      for (const targetInfo of indexInfos) {
        const related = relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & 1 /* Any */ ? -1 /* True */ : isGenericMappedType(source2) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source2), targetInfo.type, 3 /* Both */, reportErrors2) : typeRelatedToIndexInfo(source2, targetInfo, reportErrors2, intersectionState);
        if (!related) {
          return 0 /* False */;
        }
        result2 &= related;
      }
      return result2;
    }
    function typeRelatedToIndexInfo(source2, targetInfo, reportErrors2, intersectionState) {
      const sourceInfo = getApplicableIndexInfo(source2, targetInfo.keyType);
      if (sourceInfo) {
        return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors2, intersectionState);
      }
      if (!(intersectionState & 1 /* Source */) && (relation !== strictSubtypeRelation || getObjectFlags(source2) & 8192 /* FreshLiteral */) && isObjectTypeWithInferableIndex(source2)) {
        return membersRelatedToIndexInfo(source2, targetInfo, reportErrors2, intersectionState);
      }
      if (reportErrors2) {
        reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source2));
      }
      return 0 /* False */;
    }
    function indexSignaturesIdenticalTo(source2, target2) {
      const sourceInfos = getIndexInfosOfType(source2);
      const targetInfos = getIndexInfosOfType(target2);
      if (sourceInfos.length !== targetInfos.length) {
        return 0 /* False */;
      }
      for (const targetInfo of targetInfos) {
        const sourceInfo = getIndexInfoOfType(source2, targetInfo.keyType);
        if (!(sourceInfo && isRelatedTo(sourceInfo.type, targetInfo.type, 3 /* Both */) && sourceInfo.isReadonly === targetInfo.isReadonly)) {
          return 0 /* False */;
        }
      }
      return -1 /* True */;
    }
    function constructorVisibilitiesAreCompatible(sourceSignature, targetSignature, reportErrors2) {
      if (!sourceSignature.declaration || !targetSignature.declaration) {
        return true;
      }
      const sourceAccessibility = getSelectedEffectiveModifierFlags(sourceSignature.declaration, 6 /* NonPublicAccessibilityModifier */);
      const targetAccessibility = getSelectedEffectiveModifierFlags(targetSignature.declaration, 6 /* NonPublicAccessibilityModifier */);
      if (targetAccessibility === 2 /* Private */) {
        return true;
      }
      if (targetAccessibility === 4 /* Protected */ && sourceAccessibility !== 2 /* Private */) {
        return true;
      }
      if (targetAccessibility !== 4 /* Protected */ && !sourceAccessibility) {
        return true;
      }
      if (reportErrors2) {
        reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), v