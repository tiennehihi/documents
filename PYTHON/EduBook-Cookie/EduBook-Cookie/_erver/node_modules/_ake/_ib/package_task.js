eturn errorReported;
  }
  function reportImplicitAny(declaration, type, wideningKind) {
    const typeAsString = typeToString(getWidenedType(type));
    if (isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions)) {
      return;
    }
    let diagnostic;
    switch (declaration.kind) {
      case 226 /* BinaryExpression */:
      case 172 /* PropertyDeclaration */:
      case 171 /* PropertySignature */:
        diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
        break;
      case 169 /* Parameter */:
        const param = declaration;
        if (isIdentifier(param.name)) {
          const originalKeywordKind = identifierToKeywordKind(param.name);
          if ((isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) && param.parent.parameters.includes(param) && (resolveName(
            param,
            param.name.escapedText,
            788968 /* Type */,
            /*nameNotFoundMessage*/
            void 0,
            param.name.escapedText,
            /*isUse*/
            true
          ) || originalKeywordKind && isTypeNodeKind(originalKeywordKind))) {
            const newName = "arg" + param.parent.parameters.indexOf(param);
            const typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");
            errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);
            return;
          }
        }
        diagnostic = declaration.dotDotDotToken ? noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage : noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
        break;
      case 208 /* BindingElement */:
        diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;
        if (!noImplicitAny) {
          return;
        }
        break;
      case 324 /* JSDocFunctionType */:
        error2(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
        return;
      case 330 /* JSDocSignature */:
        if (noImplicitAny && isJSDocOverloadTag(declaration.parent)) {
          error2(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString);
        }
        return;
      case 262 /* FunctionDeclaration */:
      case 174 /* MethodDeclaration */:
      case 173 /* MethodSignature */:
      case 177 /* GetAccessor */:
      case 178 /* SetAccessor */:
      case 218 /* FunctionExpression */:
      case 219 /* ArrowFunction */:
        if (noImplicitAny && !declaration.name) {
          if (wideningKind === 3 /* GeneratorYield */) {
            error2(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);
          } else {
            error2(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
          }
          return;
        }
        diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage : wideningKind === 3 /* GeneratorYield */ ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type : Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
        break;
      case 200 /* MappedType */:
        if (noImplicitAny) {
          error2(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);
        }
        return;
      default:
        diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
    }
    errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString);
  }
  function reportErrorsFromWidening(declaration, type, wideningKind) {
    addLazyDiagnostic(() => {
      if (noImplicitAny && getObjectFlags(type) & 65536 /* ContainsWideningType */ && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration))) {
        if (!reportWideningErrorsInType(type)) {
          reportImplicitAny(declaration, type, wideningKind);
        }
      }
    });
  }
  function applyToParameterTypes(source, target, callback) {
    const sourceCount = getParameterCount(source);
    const targetCount = getParameterCount(target);
    const sourceRestType = getEffectiveRestType(source);
    const targetRestType = getEffectiveRestType(target);
    const targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
    const paramCount = sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount);
    const sourceThisType = getThisTypeOfSignature(source);
    if (sourceThisType) {
      const targetThisType = getThisTypeOfSignature(target);
      if (targetThisType) {
        callback(sourceThisType, targetThisType);
      }
    }
    for (let i = 0; i < paramCount; i++) {
      callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
    }
    if (targetRestType) {
      callback(getRestTypeAtPosition(
        source,
        paramCount,
        /*readonly*/
        isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)
      ), targetRestType);
    }
  }
  function applyToReturnTypes(source, target, callback) {
    const sourceTypePredicate = getTypePredicateOfSignature(source);
    const targetTypePredicate = getTypePredicateOfSignature(target);
    if (sourceTypePredicate && targetTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type) {
      callback(sourceTypePredicate.type, targetTypePredicate.type);
    } else {
      callback(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
    }
  }
  function createInferenceContext(typeParameters, signature, flags, compareTypes) {
    return createInferenceContextWorker(typeParameters.map(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable);
  }
  function cloneInferenceContext(context, extraFlags = 0) {
    return context && createInferenceContextWorker(map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes);
  }
  function createInferenceContextWorker(inferences, signature, flags, compareTypes) {
    const context = {
      inferences,
      signature,
      flags,
      compareTypes,
      mapper: reportUnmeasurableMapper,
      // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction
      nonFixingMapper: reportUnmeasurableMapper
    };
    context.mapper = makeFixingMapperForContext(context);
    context.nonFixingMapper = makeNonFixingMapperForContext(context);
    return context;
  }
  function makeFixingMapperForContext(context) {
    return makeDeferredTypeMapper(
      map(context.inferences, (i) => i.typeParameter),
      map(context.inferences, (inference, i) => () => {
        if (!inference.isFixed) {
          inferFromIntraExpressionSites(context);
          clearCachedInferences(context.inferences);
          inference.isFixed = true;
        }
        return getInferredType(context, i);
      })
    );
  }
  function makeNonFixingMapperForContext(context) {
    return makeDeferredTypeMapper(
      map(context.inferences, (i) => i.typeParameter),
      map(context.inferences, (_, i) => () => {
        return getInferredType(context, i);
      })
    );
  }
  function clearCachedInferences(inferences) {
    for (const inference of inferences) {
      if (!inference.isFixed) {
        inference.inferredType = void 0;
      }
    }
  }
  function addIntraExpressionInferenceSite(context, node, type) {
    (context.intraExpressionInferenceSites ?? (context.intraExpressionInferenceSites = [])).push({ node, type });
  }
  function inferFromIntraExpressionSites(context) {
    if (context.intraExpressionInferenceSites) {
      for (const { node, type } of context.intraExpressionInferenceSites) {
        const contextualType = node.kind === 174 /* MethodDeclaration */ ? getContextualTypeForObjectLiteralMethod(node, 2 /* NoConstraints */) : getContextualType2(node, 2 /* NoConstraints */);
        if (contextualType) {
          inferTypes(context.inferences, type, contextualType);
        }
      }
      context.intraExpressionInferenceSites = void 0;
    }
  }
  function createInferenceInfo(typeParameter) {
    return {
      typeParameter,
      candidates: void 0,
      contraCandidates: void 0,
      inferredType: void 0,
      priority: void 0,
      topLevel: true,
      isFixed: false,
      impliedArity: void 0
    };
  }
  function cloneInferenceInfo(inference) {
    return {
      typeParameter: inference.typeParameter,
      candidates: inference.candidates && inference.candidates.slice(),
      contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),
      inferredType: inference.inferredType,
      priority: inference.priority,
      topLevel: inference.topLevel,
      isFixed: inference.isFixed,
      impliedArity: inference.impliedArity
    };
  }
  function cloneInferredPartOfContext(context) {
    const inferences = filter(context.inferences, hasInferenceCandidates);
    return inferences.length ? createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) : void 0;
  }
  function getMapperFromContext(context) {
    return context && context.mapper;
  }
  function couldContainTypeVariables(type) {
    const objectFlags = getObjectFlags(type);
    if (objectFlags & 524288 /* CouldContainTypeVariablesComputed */) {
      return !!(objectFlags & 1048576 /* CouldContainTypeVariables */);
    }
    const result = !!(type.flags & 465829888 /* Instantiable */ || type.flags & 524288 /* Object */ && !isNonGenericTopLevelType(type) && (objectFlags & 4 /* Reference */ && (type.node || some(getTypeArguments(type), couldContainTypeVariables)) || objectFlags & 16 /* Anonymous */ && type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */ | 32 /* Class */ | 2048 /* TypeLiteral */ | 4096 /* ObjectLiteral */) && type.symbol.declarations || objectFlags & (32 /* Mapped */ | 1024 /* ReverseMapped */ | 4194304 /* ObjectRestType */ | 8388608 /* InstantiationExpressio