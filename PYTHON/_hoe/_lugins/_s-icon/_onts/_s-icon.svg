for debugging. Its maximum
     * output length is approximately 128 MiB. Inputs that result in longer output will
     * be truncated.
     * @since v0.3.0
     * @param object Any JavaScript primitive or `Object`.
     * @return The representation of `object`.
     */
    export function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;
    export function inspect(object: any, options?: InspectOptions): string;
    export namespace inspect {
        let colors: NodeJS.Dict<[number, number]>;
        let styles: {
            [K in Style]: string;
        };
        let defaultOptions: InspectOptions;
        /**
         * Allows changing inspect settings from the repl.
         */
        let replDefaults: InspectOptions;
        /**
         * That can be used to declare custom inspect functions.
         */
        const custom: unique symbol;
    }
    /**
     * Alias for [`Array.isArray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).
     *
     * Returns `true` if the given `object` is an `Array`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isArray([]);
     * // Returns: true
     * util.isArray(new Array());
     * // Returns: true
     * util.isArray({});
     * // Returns: false
     * ```
     * @since v0.6.0
     * @deprecated Since v4.0.0 - Use `isArray` instead.
     */
    export function isArray(object: unknown): object is unknown[];
    /**
     * Returns `true` if the given `object` is a `RegExp`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isRegExp(/some regexp/);
     * // Returns: true
     * util.isRegExp(new RegExp('another regexp'));
     * // Returns: true
     * util.isRegExp({});
     * // Returns: false
     * ```
     * @since v0.6.0
     * @deprecated Since v4.0.0 - Deprecated
     */
    export function isRegExp(object: unknown): object is RegExp;
    /**
     * Returns `true` if the given `object` is a `Date`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isDate(new Date());
     * // Returns: true
     * util.isDate(Date());
     * // false (without 'new' returns a String)
     * util.isDate({});
     * // Returns: false
     * ```
     * @since v0.6.0
     * @deprecated Since v4.0.0 - Use {@link types.isDate} instead.
     */
    export function isDate(object: unknown): object is Date;
    /**
     * Returns `true` if the given `object` is an `Error`. Otherwise, returns`false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isError(new Error());
     * // Returns: true
     * util.isError(new TypeError());
     * // Returns: true
     * util.isError({ name: 'Error', message: 'an error occurred' });
     * // Returns: false
     * ```
     *
     * This method relies on `Object.prototype.toString()` behavior. It is
     * possible to obtain an incorrect result when the `object` argument manipulates`@@toStringTag`.
     *
     * ```js
     * const util = require('node:util');
     * const obj = { name: 'Error', message: 'an error occurred' };
     *
     * util.isError(obj);
     * // Returns: false
     * obj[Symbol.toStringTag] = 'Error';
     * util.isError(obj);
     * // Returns: true
     * ```
     * @since v0.6.0
     * @deprecated Since v4.0.0 - Use {@link types.isNativeError} instead.
     */
    export function isError(object: unknown): object is Error;
    /**
     * Usage of `util.inherits()` is discouraged. Please use the ES6 `class` and`extends` keywords to get language level inheritance support. Also note
     * that the two styles are [semantically incompatible](https://github.com/nodejs/node/issues/4179).
     *
     * Inherit the prototype methods from one [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) into another. The
     * prototype of `constructor` will be set to a new object created from`superConstructor`.
     *
     * This mainly adds some input validation on top of`Object.setPrototypeOf(constructor.prototype, superConstructor.prototype)`.
     * As an additional convenience, `superConstructor` will be accessible
     * through the `constructor.super_` property.
     *
     * ```js
     * const util = require('node:util');
     * const EventEmitter = require('node:events');
     *
     * function MyStream() {
     *   EventEmitter.call(this);
     * }
     *
     * util.inherits(MyStream, EventEmitter);
     *
     * MyStream.prototype.write = function(data) {
     *   this.emit('data', data);
     * };
     *
     * const stream = new MyStream();
     *
     * console.log(stream instanceof EventEmitter); // true
     * console.log(MyStream.super_ === EventEmitter); // true
     *
     * stream.on('data', (data) => {
     *   console.log(`Received data: "${data}"`);
     * });
     * stream.write('It works!'); // Received data: "It works!"
     * ```
     *
     * ES6 example using `class` and `extends`:
     *
     * ```js
     * const EventEmitter = require('node:events');
     *
     * class MyStream extends EventEmitter {
     *   write(data) {
     *     this.emit('data', data);
     *   }
     * }
     *
     * const stream = new MyStream();
     *
     * stream.on('data', (data) => {
     *   console.log(`Received data: "${data}"`);
     * });
     * stream.write('With ES6');
     * ```
     * @since v0.3.0
     * @legacy Use ES2015 class syntax and `extends` keyword instead.
     */
    export function inherits(constructor: unknown, superConstructor: unknown): void;
    export type DebugLoggerFunction = (msg: string, ...param: unknown[]) => void;
    export interface DebugLogger extends DebugLoggerFunction {
        enabled: boolean;
    }
    /**
     * The `util.debuglog()` method is used to create a function that conditionally
     * writes debug messages to `stderr` based on the existence of the `NODE_DEBUG`environment variable. If the `section` name appears within the value of that
     * environment variable, then the returned function operates similar to `console.error()`. If not, then the returned function is a no-op.
     *
     * ```js
     * const util = require('node:util');
     * const debuglog = util.debuglog('foo');
     *
     * debuglog('hello from foo [%d]', 123);
     * ```
     *
     * If this program is run with `NODE_DEBUG=foo` in the environment, then
     * it will output something like:
     *
     * ```console
     * FOO 3245: hello from foo [123]
     * ```
     *
     * where `3245` is the process id. If it is not run with that
     * environment variable set, then it will not print anything.
     *
     * The `section` supports wildcard also:
     *
     * ```js
     * const util = require('node:util');
     * const debuglog = util.debuglog('foo-bar');
     *
     * debuglog('hi there, it\'s foo-bar [%d]', 2333);
     * ```
     *
     * if it is run with `NODE_DEBUG=foo*` in the environment, then it will output
     * something like:
     *
     * ```console
     * FOO-BAR 3257: hi there, it's foo-bar [2333]
     * ```
     *
     * Multiple comma-separated `section` names may be specified in the `NODE_DEBUG`environment variable: `NODE_DEBUG=fs,net,tls`.
     *
     * The optional `callback` argument can be used to replace the logging function
     * with a different function that doesn't have any initialization or
     * unnecessary wrapping.
     *
     * ```js
     * const util = require('node:util');
     * let debuglog = util.debuglog('internals', (debug) => {
     *   // Replace with a logging function that optimizes out
     *   // testing if the section is enabled
     *   debuglog = debug;
     * });
     * ```
     * @since v0.11.3
     * @param section A string identifying the portion of the application for which the `debuglog` function is being created.
     * @param callback A callback invoked the first time the logging function is called with a function argument that is a more optimized logging function.
     * @return The logging function
     */
    export function debuglog(section: string, callback?: (fn: DebugLoggerFunction) => void): DebugLogger;
    export const debug: typeof debuglog;
    /**
     * Returns `true` if the given `object` is a `Boolean`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isBoolean(1);
     * // Returns: false
     * util.isBoolean(0);
     * // Returns: false
     * util.isBoolean(false);
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `typeof value === 'boolean'` instead.
     */
    export function isBoolean(object: unknown): object is boolean;
    /**
     * Returns `true` if the given `object` is a `Buffer`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isBuffer({ length: 0 });
     * // Returns: false
     * util.isBuffer([]);
     * // Returns: false
     * util.isBuffer(Buffer.from('hello world'));
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `isBuffer` instead.
     */
    export function isBuffer(object: unknown): object is Buffer;
    /**
     * Returns `true` if the given `object` is a `Function`. Otherwise, returns`false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * function Foo() {}
     * const Bar = () => {};
     *
     * util.isFunction({});
     * // Returns: false
     * util.isFunction(Foo);
     * // Returns: true
     * util.isFunction(Bar);
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `typeof value === 'function'` instead.
     */
    export function isFunction(object: unknown): boolean;
    /**
     * Returns `true` if the given `object` is strictly `null`. Otherwise, returns`false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isNull(0);
     * // Returns: false
     * util.isNull(undefined);
     * // Returns: false
     * util.isNull(null);
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `value === null` instead.
     */
    export function isNull(object: unknown): object is null;
    /**
     * Returns `true` if the given `object` is `null` or `undefined`. Otherwise,
     * returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isNullOrUndefined(0);
     * // Returns: false
     * util.isNullOrUndefined(undefined);
     * // Returns: true
     * util.isNullOrUndefined(null);
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `value === undefined || value === null` instead.
     */
    export function isNullOrUndefined(object: unknown): object is null | undefined;
    /**
     * Returns `true` if the given `object` is a `Number`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isNumber(false);
     * // Returns: false
     * util.isNumber(Infinity);
     * // Returns: true
     * util.isNumber(0);
     * // Returns: true
     * util.isNumber(NaN);
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `typeof value === 'number'` instead.
     */
    export function isNumber(object: unknown): object is number;
    /**
     * Returns `true` if the given `object` is strictly an `Object`**and** not a`Function` (even though functions are objects in JavaScript).
     * Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isObject(5);
     * // Returns: false
     * util.isObject(null);
     * // Returns: false
     * util.isObject({});
     * // Returns: true
     * util.isObject(() => {});
     * // Returns: false
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `value !== null && typeof value === 'object'` instead.
     */
    export function isObject(object: unknown): boolean;
    /**
     * Returns `true` if the given `object` is a primitive type. Otherwise, returns`false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isPrimitive(5);
     * // Returns: true
     * util.isPrimitive('foo');
     * // Returns: true
     * util.isPrimitive(false);
     * // Returns: true
     * util.isPrimitive(null);
     * // Returns: true
     * util.isPrimitive(undefined);
     * // Returns: true
     * util.isPrimitive({});
     * // Returns: false
     * util.isPrimitive(() => {});
     * // Returns: false
     * util.isPrimitive(/^$/);
     * // Returns: false
     * util.isPrimitive(new Date());
     * // Returns: false
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead.
     */
    export function isPrimitive(object: unknown): boolean;
    /**
     * Returns `true` if the given `object` is a `string`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isString('');
     * // Returns: true
     * util.isString('foo');
     * // Returns: true
     * util.isString(String('foo'));
     * // Returns: true
     * util.isString(5);
     * // Returns: false
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `typeof value === 'string'` instead.
     */
    export function isString(object: unknown): object is string;
    /**
     * Returns `true` if the given `object` is a `Symbol`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * util.isSymbol(5);
     * // Returns: false
     * util.isSymbol('foo');
     * // Returns: false
     * util.isSymbol(Symbol('foo'));
     * // Returns: true
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `typeof value === 'symbol'` instead.
     */
    export function isSymbol(object: unknown): object is symbol;
    /**
     * Returns `true` if the given `object` is `undefined`. Otherwise, returns `false`.
     *
     * ```js
     * const util = require('node:util');
     *
     * const foo = undefined;
     * util.isUndefined(5);
     * // Returns: false
     * util.isUndefined(foo);
     * // Returns: true
     * util.isUndefined(null);
     * // Returns: false
     * ```
     * @since v0.11.5
     * @deprecated Since v4.0.0 - Use `value === undefined` instead.
     */
    export function isUndefined(object: unknown): object is undefined;
    /**
     * The `util.deprecate()` method wraps `fn` (which may be a function or class) in
     * such a way that it is marked as deprecated.
     *
     * ```js
     * const util = require('node:util');
     *
     * exports.obsoleteFunction = util.deprecate(() => {
     *   // Do something here.
     * }, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');
     * ```
     *
     * When called, `util.deprecate()` will return a function that will emit a`DeprecationWarning` using the `'warning'` event. The warning will
     * be emitted and printed to `stderr` the first time the returned function is
     * called. After the warning is emitted, the wrapped function is called without
     * emitting a warning.
     *
     * If the same optional `code` is supplied in multiple calls to `util.deprecate()`,
     * the warning will be emitted only once for that `code`.
     *
     * ```js
     * const util = require('node:util');
     *
     * const fn1 = util.deprecate(someFunction, someMessage, 'DEP0001');
     * const fn2 = util.deprecate(someOtherFunction, someOtherMessage, 'DEP0001');
     * fn1(); // Emits a deprecation warning with code DEP0001
     * fn2(); // Does not emit a deprecation warning because it has the same code
     * ```
     *
     * If either the `--no-deprecation` or `--no-warnings` command-line flags are
     * used, or if the `process.noDeprecation` property is set to `true`_prior_ to
     * the first deprecation warning, the `util.deprecate()` method does nothing.
     *
     * If the `--trace-deprecation` or `--trace-warnings` command-line flags are set,
     * or the `process.traceDeprecation` p"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const meta = {
  messages: {
    readonlySpre