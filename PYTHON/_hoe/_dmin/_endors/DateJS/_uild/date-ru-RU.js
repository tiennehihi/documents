3, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69376, 69404, 69415, 69415, 69424, 69445, 69600, 69622, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70751, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71680, 71723, 71840, 71903, 71935, 71935, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 123136, 123180, 123191, 123197, 123214, 123214, 123584, 123627, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101];
var unicodeESNextIdentifierPart = [48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2208, 2228, 2230, 2237, 2259, 2273, 2275, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3328, 3331, 3333, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7673, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43047, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69376, 69404, 69415, 69415, 69424, 69456, 69600, 69622, 69632, 69702, 69734, 69743, 69759, 69818, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69958, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70096, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70206, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70751, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71680, 71738, 71840, 71913, 71935, 71935, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 119141, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123584, 123641, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999];
var commentDirectiveRegExSingleLine = /^\/\/\/?\s*@(ts-expect-error|ts-ignore)/;
var commentDirectiveRegExMultiLine = /^(?:\/|\*)*\s*@(ts-expect-error|ts-ignore)/;
var jsDocSeeOrLink = /@(?:see|link)/i;
function lookupInUnicodeMap(code, map2) {
  if (code < map2[0]) {
    return false;
  }
  let lo = 0;
  let hi = map2.length;
  let mid;
  while (lo + 1 < hi) {
    mid = lo + (hi - lo) / 2;
    mid -= mid % 2;
    if (map2[mid] <= code && code <= map2[mid + 1]) {
      return true;
    }
    if (code < map2[mid]) {
      hi = mid;
    } else {
      lo = mid + 2;
    }
  }
  return false;
}
function isUnicodeIdentifierStart(code, languageVersion) {
  return languageVersion >= 2 /* ES2015 */ ? lookupInUnicodeMap(code, unicodeESNextIdentifierStart) : languageVersion === 1 /* ES5 */ ? lookupInUnicodeMap(code, unicodeES5IdentifierStart) : lookupInUnicodeMap(code, unicodeES3IdentifierStart);
}
function isUnicodeIdentifierPart(code, languageVersion) {
  return languageVersion >= 2 /* ES2015 */ ? lookupInUnicodeMap(code, unicodeESNextIdentifierPart) : languageVersion === 1 /* ES5 */ ? lookupInUnicodeMap(code, unicodeES5IdentifierPart) : lookupInUnicodeMap(code, unicodeES3IdentifierPart);
}
function makeReverseMap(source) {
  const result = [];
  source.forEach((value, name) => {
    result[value] = name;
  });
  return result;
}
var tokenStrings = makeReverseMap(textToToken);
function tokenToString(t) {
  return tokenStrings[t];
}
function stringToToken(s) {
  return textToToken.get(s);
}
function computeLineStarts(text) {
  const result = [];
  let pos = 0;
  let lineStart = 0;
  while (pos < text.length) {
    const ch = text.charCodeAt(pos);
    pos++;
    switch (ch) {
      case 13 /* carriageReturn */:
        if (text.charCodeAt(pos) === 10 /* lineFeed */) {
          pos++;
        }
      case 10 /* lineFeed */:
        result.push(lineStart);
        lineStart = pos;
        break;
      default:
        if (ch > 127 /* maxAsciiCharacter */ && isLineBreak(ch)) {
          result.push(lineStart);
          lineStart = pos;
        }
        break;
    }
  }
  result.push(lineStart);
  return result;
}
function getPositionOfLineAndCharacter(sourceFile, line, character, allowEdits) {
  return sourceFile.getPositionOfLineAndCharacter ? sourceFile.getPositionOfLineAndCharacter(line, character, allowEdits) : computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text, allowEdits);
}
function computePositionOfLineAndCharacter(lineStarts, line, character, debugText, allowEdits) {
  if (line < 0 || line >= lineStarts.length) {
    if (allowEdits) {
      line = line < 0 ? 0 : line >= lineStarts.length ? lineStarts.length - 1 : line;
    } else {
      Debug.fail(`Bad line number. Line: ${line}, lineStarts.length: ${lineStarts.length} , line map is correct? ${debugText !== void 0 ? arraysEqual(lineStarts, computeLineStarts(debugText)) : "unknown"}`);
    }
  }
  const res = lineStarts[line] + character;
  if (allowEdits) {
    return res > lineStarts[line + 1] ? lineStarts[line + 1] : typeof debugText === "string" && res > debugText.length ? debugText.length : res;
  }
  if (line < lineStarts.length - 1) {
    Debug.assert(res < lineStarts[line + 1]);
  } else if (debugText !== void 0) {
    Debug.assert(res <= debugText.length);
  }
  return res;
}
function getLineStarts(sourceFile) {
  return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));
}
function computeLineAndCharacterOfPosition(lineStarts, position) {
  const lineNumber = computeLineOfPosition(lineStarts, position);
  return {
    line: lineNumber,
    character: position - lineStarts[lineNumber]
  };
}
function computeLineOfPosition(lineStarts, position, lowerBound) {
  let lineNumber = binarySearch(lineStarts, position, identity, compareValues, lowerBound);
  if (lineNumber < 0) {
    lineNumber = ~lineNumber - 1;
    Debug.assert(lineNumber !== -1, "position cannot precede the beginning of the file");
  }
  return lineNumber;
}
function getLinesBetweenPositions(sourceFile, pos1, pos2) {
  if (pos1 === pos2)
    return 0;
  const lineStarts = getLineStarts(sourceFile);
  const lower = Math.min(pos1, pos2);
  const isNegative = lower === pos2;
  const upper = isNegative ? pos1 : pos2;
  const lowerLine = computeLineOfPosition(lineStarts, lower);
  const upperLine = computeLineOfPosition(lineStarts, upper, lowerLine);
  return isNegative ? lowerLine - upperLine : upperLine - lowerLine;
}
function getLineAndCharacterOfPosition(sourceFile, position) {
  return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);
}
function isWhiteSpaceLike(ch) {
  return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
}
function isWhiteSpaceSingleLine(ch) {
  return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ || ch === 160 /* nonBreakingSpace */ || ch === 133 /* nextLine */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ || ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
}
function isLineBreak(ch) {
  return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
}
function isDigit(ch) {
  return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
}
function isHexDigit(ch) {
  return isDigit(ch) || ch >= 65 /* A */ && ch <= 70 /* F */ || ch >= 97 /* a */ && ch <= 102 /* f */;
}
function isCodePoint(code) {
  return code <= 1114111;
}
function isOctalDigit(ch) {
  return ch >= 48 /* _0 */ && ch <= 55 /* _7 */;
}
function skipTrivia(text, pos, stopAfterLineBreak, stopAtComments, inJSDoc) {
  if (positionIsSynthesized(pos)) {
    return pos;
  }
  let canConsumeStar = false;
  while (true) {
    const ch = text.charCodeAt(pos);
    switch (ch) {
      case 13 /* carriageReturn */:
        if (text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
          pos++;
        }
      case 10 /* lineFeed */:
        pos++;
        if (stopAfterLineBreak) {
          return pos;
        }
        canConsumeStar = !!inJSDoc;
        continue;
      case 9 /* tab */:
      case 11 /* verticalTab */:
      case 12 /* formFeed */:
      case 32 /* space */:
        pos++;
        continue;
      case 47 /* slash */:
        if (stopAtComments) {
          break;
        }
        if (text.charCodeAt(pos + 1) === 47 /* slash */) {
          pos += 2;
          while (pos < text.length) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          canConsumeStar = false;
          continue;
        }
        if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
          pos += 2;
          while (pos < text.length) {
            if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
              pos += 2;
              break;
            }
            pos++;
          }
          canConsumeStar = false;
          continue;
        }
        break;
      case 60 /* lessThan */:
      case 124 /* bar */:
      case 61 /* equals */:
      case 62 /* greaterThan */:
        if (isConflictMarkerTrivia(text, pos)) {
          pos = scanConflictMarkerTrivia(text, pos);
          canConsumeStar = false;
          continue;
        }
        break;
      case 35 /* hash */:
        if (pos === 0 && isShebangTrivia(text, pos)) {
          pos = scanShebangTrivia(text, pos);
          canConsumeStar = false;
          continue;
        }
        break;
      case 42 /* asterisk */:
        if (canConsumeStar) {
          pos++;
          canConsumeStar = false;
          continue;
        }
        break;
      default:
        if (ch > 127 /* maxAsciiCharacter */ && isWhiteSpaceLike(ch)) {
          pos++;
          continue;
        }
        break;
    }
    return pos;
  }
}
var mergeConflictMarkerLength = "<<<<<<<".length;
function isConflictMarkerTrivia(text, pos) {
  Debug.assert(pos >= 0);
  if (pos === 0 || isLineBreak(text.charCodeAt(pos - 1))) {
    const ch = text.charCodeAt(pos);
    if (pos + mergeConflictMarkerLength < text.length) {
      for (let i = 0; i < mergeConflictMarkerLength; i++) {
        if (text.charCodeAt(pos + i) !== ch) {
          return false;
        }
      }
      return ch === 61 /* equals */ || text.charCodeAt(pos + mergeConflictMarkerLength) === 32 /* space */;
    }
  }
  return false;
}
function scanConflictMarkerTrivia(text, pos, error) {
  if (error) {
    error(Diagnostics.Merge_conflict_marker_encountered, pos, mergeConflictMarkerLength);
  }
  const ch = text.charCodeAt(pos);
  const len = text.length;
  if (ch === 60 /* lessThan */ || ch === 62 /* greaterThan */) {
    while (pos < len && !isLineBreak(text.charCodeAt(pos))) {
      pos++;
    }
  } else {
    Debug.assert(ch === 124 /* bar */ || ch === 61 /* equals */);
    while (pos < len) {
      const currentChar = text.charCodeAt(pos);
      if ((currentChar === 61 /* equals */ || currentChar === 62 /* greaterThan */) && currentChar !== ch && isConflictMarkerTrivia(text, pos)) {
        break;
      }
      pos++;
    }
  }
  return pos;
}
var shebangTriviaRegex = /^#!.*/;
function isShebangTrivia(text, pos) {
  Debug.assert(pos === 0);
  return shebangTriviaRegex.test(text);
}
function scanShebangTrivia(text, pos) {
  const shebang = shebangTriviaRegex.exec(text)[0];
  pos = pos + shebang.length;
  return pos;
}
function iterateCommentRanges(reduce, text, pos, trailing, cb, state, initial) {
  let pendingPos;
  let pendingEnd;
  let pendingKind;
  let pendingHasTrailingNewLine;
  let hasPendingCommentRange = false;
  let collecting = trailing;
  let accumulator = initial;
  if (pos === 0) {
    collecting = true;
    const shebang = getShebang(text);
    if (shebang) {
      pos = shebang.length;
    }
  }
  scan:
    while (pos >= 0 && pos < text.length) {
      const ch = text.charCodeAt(pos);
      switch (ch) {
        case 13 /* carriageReturn */:
          if (text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
            pos++;
          }
        case 10 /* lineFeed */:
          pos++;
          if (trailing) {
            break scan;
          }
          collecting = true;
          if (hasPendingCommentRange) {
            pendingHasTrailingNewLine = true;
          }
          continue;
        case 9 /* tab */:
        case 11 /* verticalTab */:
        case 12 /* formFeed */:
        case 32 /* space */:
          pos++;
          continue;
        case 47 /* slash */:
          const nextChar = text.charCodeAt(pos + 1);
          let hasTrailingNewLine = false;
          if (nextChar === 47 /* slash */ || nextChar === 42 /* asterisk */) {
            const kind = nextChar === 47 /* slash */ ? 2 /* SingleLineCommentTrivia */ : 3 /* MultiLineCommentTrivia */;
            const startPos = pos;
            pos += 2;
            if (nextChar === 47 /* slash */) {
              while (pos < text.length) {
                if (isLineBreak(text.charCodeAt(pos))) {
                  hasTrailingNewLine = true;
                  break;
                }
                pos++;
              }
            } else {
              while (pos < text.length) {
                if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                  pos += 2;
                  break;
                }
                pos++;
              }
            }
            if (collecting) {
              if (hasPendingCommentRange) {
                accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);
                if (!reduce && accumulator) {
                  return accumulator;
                }
              }
              pendingPos = startPos;
              pendingEnd = pos;
              pendingKind = kind;
              pendingHasTrailingNewLine = hasTrailingNewLine;
              hasPendingCommentRange = true;
            }
            continue;
          }
          break scan;
        default:
          if (ch > 127 /* maxAsciiCharacter */ && isWhiteSpaceLike(ch)) {
            if (hasPendingCommentRange && isLineBreak(ch)) {
              pendingHasTrailingNewLine = true;
            }
            pos++;
            continue;
          }
          break scan;
      }
    }
  if (hasPendingCommentRange) {
    accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);
  }
  return accumulator;
}
function forEachLeadingCommentRange(text, pos, cb, state) {
  return iterateCommentRanges(
    /*reduce*/
    false,
    text,
    pos,
    /*trailing*/
    false,
    cb,
    state
  );
}
function forEachTrailingCommentRange(text, pos, cb, state) {
  return iterateCommentRanges(
    /*reduce*/
    false,
    text,
    pos,
    /*trailing*/
    true,
    cb,
    state
  );
}
function reduceEachLeadingCommentRange(text, pos, cb, state, initial) {
  return iterateCommentRanges(
    /*reduce*/
    true,
    text,
    pos,
    /*trailing*/
    false,
    cb,
    state,
    initial
  );
}
function reduceEachTrailingCommentRange(text, pos, cb, state, initial) {
  return iterateCommentRanges(
    /*reduce*/
    true,
    text,
    pos,
    /*trailing*/
    true,
    cb,
    state,
    initial
  );
}
function appendCommentRange(pos, end, kind, hasTrailingNewLine, _state, comments = []) {
  comments.push({ kind, pos, end, hasTrailingNewLine });
  return comments;
}
function getLeadingCommentRanges(text, pos) {
  return reduceEachLeadingCommentRange(
    text,
    pos,
    appendCommentRange,
    /*state*/
    void 0,
    /*initial*/
    void 0
  );
}
function getTrailingCommentRanges(text, pos) {
  return reduceEachTrailingCommentRange(
    text,
    pos,
    appendCommentRange,
    /*state*/
    void 0,
    /*initial*/
    void 0
  );
}
function getShebang(text) {
  const match = shebangTriviaRegex.exec(text);
  if (match) {
    return match[0];
  }
}
function isIdentifierStart(ch, languageVersion) {
  return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
}
function isIdentifierPart(ch, languageVersion, identifierVariant) {
  return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || // "-" and ":" are valid in JSX Identifiers
  (identifierVariant === 1 /* JSX */ ? ch === 45 /* minus */ || ch === 58 /* colon */ : false) || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
}
function isIdentifierText(name, languageVersion, identifierVariant) {
  let ch = codePointAt(name, 0);
  if (!isIdentifierStart(ch, languageVersion)) {
    return false;
  }
  for (let i = charSize(ch); i < name.length; i += charSize(ch)) {
    if (!isIdentifierPart(ch = codePointAt(name, i), languageVersion, identifierVariant)) {
      return false;
    }
  }
  return true;
}
function createScanner(languageVersion, skipTrivia2, languageVariant = 0 /* Standard */, textInitial, onError, start, length2) {
  var text = textInitial;
  var pos;
  var end;
  var fullStartPos;
  var tokenStart;
  var token;
  var tokenValue;
  var tokenFlags;
  var commentDirectives;
  var inJSDocType = 0;
  var scriptKind = 0 /* Unknown */;
  var jsDocParsingMode = 0 /* ParseAll */;
  setText(text, start, length2);
  var scanner = {
    getTokenFullStart: () => fullStartPos,
    getStartPos: () => fullStartPos,
    getTokenEnd: () => pos,
    getTextPos: () => pos,
    getToken: () => token,
    getTokenStart: () => tokenStart,
    getTokenPos: () => tokenStart,
    getTokenText: () => text.substring(tokenStart, pos),
    getTokenValue: () => tokenValue,
    hasUnicodeEscape: () => (tokenFlags & 1024 /* UnicodeEscape */) !== 0,
    hasExtendedUnicodeEscape: () => (tokenFlags & 8 /* ExtendedUnicodeEscape */) !== 0,
    hasPrecedingLineBreak: () => (tokenFlags & 1 /* PrecedingLineBreak */) !== 0,
    hasPrecedingJSDocComment: () => (tokenFlags & 2 /* PrecedingJSDocComment */) !== 0,
    isIdentifier: () => token === 80 /* Identifier */ || token > 118 /* LastReservedWord */,
    isReservedWord: () => token >= 83 /* FirstReservedWord */ && token <= 118 /* LastReservedWord */,
    isUnterminated: () => (tokenFlags & 4 /* Unterminated */) !== 0,
    getCommentDirectives: () => commentDirectives,
    getNumericLiteralFlags: () => tokenFlags & 25584 /* NumericLiteralFlags */,
    getTokenFlags: () => tokenFlags,
    reScanGreaterToken,
    reScanAsteriskEqualsToken,
    reScanSlashToken,
    reScanTemplateToken,
    reScanTemplateHeadOrNoSubstitutionTemplate,
    scanJsxIdentifier,
    scanJsxAttributeValue,
    reScanJsxAttributeValue,
    reScanJsxToken,
    reScanLessThanToken,
    reScanHashToken,
    reScanQuestionToken,
    reScanInvalidIdentifier,
    scanJsxToken,
    scanJsDocToken,
    scanJSDocCommentTextToken,
    scan,
    getText,
    clearCommentDirectives,
    setText,
    setScriptTarget,
    setLanguageVariant,
    setScriptKind,
    setJSDocParsingMode,
    setOnError,
    resetTokenState,
    setTextPos: resetTokenState,
    setInJSDocType,
    tryScan,
    lookAhead,
    scanRange
  };
  if (Debug.isDebugging) {
    Object.defineProperty(scanner, "__debugShowCurrentPositionInText", {
      get: () => {
        const text2 = scanner.getText();
        return text2.slice(0, scanner.getTokenFullStart()) + "\u2551" + text2.slice(scanner.getTokenFullStart());
      }
    });
  }
  return scanner;
  function error(message, errPos = pos, length3, arg0) {
    if (onError) {
      const oldPos = pos;
      pos = errPos;
      onError(message, length3 || 0, arg0);
      pos = oldPos;
    }
  }
  function scanNumberFragment() {
    let start2 = pos;
    let allowSeparator = false;
    let isPreviousTokenSeparator = false;
    let result = "";
    while (true) {
      const ch = text.charCodeAt(pos);
      if (ch === 95 /* _ */) {
        tokenFlags |= 512 /* ContainsSeparator */;
        if (allowSeparator) {
          allowSeparator = false;
          isPreviousTokenSeparator = true;
          result += text.substring(start2, pos);
        } else {
          tokenFlags |= 16384 /* ContainsInvalidSeparator */;
          if (isPreviousTokenSeparator) {
            error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
          } else {
            error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
          }
        }
        pos++;
        start2 = pos;
        continue;
      }
      if (isDigit(ch)) {
        allowSeparator = true;
        isPreviousTokenSeparator = false;
        pos++;
        continue;
      }
      break;
    }
    if (text.charCodeAt(pos - 1) === 95 /* _ */) {
      tokenFlags |= 16384 /* ContainsInvalidSeparator */;
      error(Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
    }
    return result + text.substring(start2, pos);
  }
  function scanNumber() {
    let start2 = pos;
    let mainFragment;
    if (text.charCodeAt(pos) === 48 /* _0 */) {
      pos++;
      if (text.charCodeAt(pos) === 95 /* _ */) {
        tokenFlags |= 512 /* ContainsSeparator */ | 16384 /* ContainsInvalidSeparator */;
        error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
        pos--;
        mainFragment = scanNumberFragment();
      } else if (!scanDigits()) {
        tokenFlags |= 8192 /* ContainsLeadingZero */;
        mainFragment = "" + +tokenValue;
      } else if (!tokenValue) {
        mainFragment = "0";
      } else {
        tokenValue = "" + parseInt(tokenValue, 8);
        tokenFlags |= 32 /* Octal */;
        const withMinus = token === 41 /* MinusToken */;
        const literal = (withMinus ? "-" : "") + "0o" + (+tokenValue).toString(8);
        if (withMinus)
          start2--;
        error(Diagnostics.Octal_literals_are_not_allowed_Use_the_syntax_0, start2, pos - start2, literal);
        return 9 /* NumericLiteral */;
      }
    } else {
      mainFragment = scanNumberFragment();
    }
    let decimalFragment;
    let scientificFragment;
    if (text.charCodeAt(pos) === 46 /* dot */) {
      pos++;
      decimalFragment = scanNumberFragment();
    }
    let end2 = pos;
    if (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */) {
      pos++;
      tokenFlags |= 16 /* Scientific */;
      if (text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */)
        pos++;
      const preNumericPart = pos;
      const finalFragment = scanNumberFragment();
      if (!finalFragment) {
        error(Diagnostics.Digit_expected);
      } else {
        scientificFragment = text.substring(end2, preNumericPart) + finalFragment;
        end2 = pos;
      }
    }
    let result;
    if (tokenFlags & 512 /* ContainsSeparator */) {
      result = mainFragment;
      if (decimalFragment) {
        result += "." + decimalFragment;
      }
      if (scientificFragment) {
        result += scientificFragment;
      }
    } else {
      result = text.substring(start2, end2);
    }
    if (tokenFlags & 8192 /* ContainsLeadingZero */) {
      error(Diagnostics.Decimals_with_leading_zeros_are_not_allowed, start2, end2 - start2);
      tokenValue = "" + +result;
      return 9 /* NumericLiteral */;
    }
    if (decimalFragment !== void 0 || tokenFlags & 16 /* Scientific */) {
      checkForIdentifierStartAfterNumericLiteral(start2, decimalFragment === void 0 && !!(tokenFlags & 16 /* Scientific */));
      tokenValue = "" + +result;
      return 9 /* NumericLiteral */;
    } else {
      tokenValue = result;
      const type = checkBigIntSuffix();
      checkForIdentifierStartAfterNumericLiteral(start2);
      return type;
    }
  }
  function checkForIdentifierStartAfterNumericLiteral(numericStart, isScientific) {
    if (!isIdentifierStart(codePointAt(text, pos), languageVersion)) {
      return;
    }
    const identifierStart = pos;
    const { length: length3 } = scanIdentifierParts();
    if (length3 === 1 && text[identifierStart] === "n") {
      if (isScientific) {
        error(Diagnostics.A_bigint_literal_cannot_use_exponential_notation, numericStart, identifierStart - numericStart + 1);
      } else {
        error(Diagnostics.A_bigint_literal_must_be_an_integer, numericStart, identifierStart - numericStart + 1);
      }
    } else {
      error(Diagnostics.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal, identifierStart, length3);
      pos = identifierStart;
    }
  }
  function scanDigits() {
    const start2 = pos;
    let isOctal = true;
    while (isDigit(text.charCodeAt(pos))) {
      if (!isOctalDigit(text.charCodeAt(pos))) {
        isOctal = false;
      }
      pos++;
    }
    tokenValue = text.substring(start2, pos);
    return isOctal;
  }
  function scanExactNumberOfHexDigits(count, canHaveSeparators) {
    const valueString = scanHexDigits(
      /*minCount*/
      count,
      /*scanAsManyAsPossible*/
      false,
      canHaveSeparators
    );
    return valueString ? parseInt(valueString, 16) : -1;
  }
  function scanMinimumNumberOfHexDigits(count, canHaveSeparators) {
    return scanHexDigits(
      /*minCount*/
      count,
      /*scanAsManyAsPossible*/
      true,
      canHaveSeparators
    );
  }
  function scanHexDigits(minCount, scanAsManyAsPossible, canHaveSeparators) {
    let valueChars = [];
    let allowSeparator = false;
    let isPreviousTokenSeparator = false;
    while (valueChars.length < minCount || scanAsManyAsPossible) {
      let ch = text.charCodeAt(pos);
      if (canHaveSeparators && ch === 95 /* _ */) {
        tokenFlags |= 512 /* ContainsSeparator */;
        if (allowSeparator) {
          allowSeparator = false;
          isPreviousTokenSeparator = true;
        } else if (isPreviousTokenSeparator) {
          error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
        } else {
          error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
        }
        pos++;
        continue;
      }
      allowSeparator = canHaveSeparators;
      if (ch >= 65 /* A */ && ch <= 70 /* F */) {
        ch += 97 /* a */ - 65 /* A */;
      } else if (!(ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch >= 97 /* a */ && ch <= 102 /* f */)) {
        break;
      }
      valueChars.push(ch);
      pos++;
      isPreviousTokenSeparator = false;
    }
    if (valueChars.length < minCount) {
      valueChars = [];
    }
    if (text.charCodeAt(pos - 1) === 95 /* _ */) {
      error(Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
    }
    return String.fromCharCode(...valueChars);
  }
  function scanString(jsxAttributeString = false) {
    const quote = text.charCodeAt(pos);
    pos++;
    let result = "";
    let start2 = pos;
    while (true) {
      if (pos >= end) {
        result += text.substring(start2, pos);
        tokenFlags |= 4 /* Unterminated */;
        error(Diagnostics.Unterminated_string_literal);
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === quote) {
        result += text.substring(start2, pos);
        pos++;
        break;
      }
      if (ch === 92 /* backslash */ && !jsxAttributeString) {
        result += text.substring(start2, pos);
        result += scanEscapeSequence(
          /*shouldEmitInvalidEscapeError*/
          true
        );
        start2 = pos;
        continue;
      }
      if ((ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */) && !jsxAttributeString) {
        result += text.substring(start2, pos);
        tokenFlags |= 4 /* Unterminated */;
        error(Diagnostics.Unterminated_string_literal);
        break;
      }
      pos++;
    }
    return result;
  }
  function scanTemplateAndSetTokenValue(shouldEmitInvalidEscapeError) {
    const startedWithBacktick = text.charCodeAt(pos) === 96 /* backtick */;
    pos++;
    let start2 = pos;
    let contents = "";
    let resultingToken;
    while (true) {
      if (pos >= end) {
        contents += text.substring(start2, pos);
        tokenFlags |= 4 /* Unterminated */;
        error(Diagnostics.Unterminated_template_literal);
        resultingToken = startedWithBacktick ? 15 /* NoSubstitutionTemplateLiteral */ : 18 /* TemplateTail */;
        break;
      }
      const currChar = text.charCodeAt(pos);
      if (currChar === 96 /* backtick */) {
        contents += text.substring(start2, pos);
        pos++;
        resultingToken = startedWithBacktick ? 15 /* NoSubstitutionTemplateLiteral */ : 18 /* TemplateTail */;
        break;
      }
      if (currChar === 36 /* $ */ && pos + 1 < end && text.charCodeAt(pos + 1) === 123 /* openBrace */) {
        contents += text.substring(start2, pos);
        pos += 2;
        resultingToken = startedWithBacktick ? 16 /* TemplateHead */ : 17 /* TemplateMiddle */;
        break;
      }
      if (currChar === 92 /* backslash */) {
        contents += text.substring(start2, pos);
        contents += scanEscapeSequence(shouldEmitInvalidEscapeError);
        start2 = pos;
        continue;
      }
      if (currChar === 13 /* carriageReturn */) {
        contents += text.substring(start2, pos);
        pos++;
        if (pos < end && text.charCodeAt(pos) === 10 /* lineFeed */) {
          pos++;
        }
        contents += "\n";
        start2 = pos;
        continue;
      }
      pos++;
    }
    Debug.assert(resultingToken !== void 0);
    tokenValue = contents;
    return resultingToken;
  }
  function scanEscapeSequence(shouldEmitInvalidEscapeError) {
    const start2 = pos;
    pos++;
    if (pos >= end) {
      error(Diagnostics.Unexpected_end_of_text);
      return "";
    }
    const ch = text.charCodeAt(pos);
    pos++;
    switch (ch) {
      case 48 /* _0 */:
        if (pos >= end || !isDigit(text.charCodeAt(pos))) {
          return "\0";
        }
      case 49 /* _1 */:
      case 50 /* _2 */:
      case 51 /* _3 */:
        if (pos < end && isOctalDigit(text.charCodeAt(pos))) {
          pos++;
        }
      case 52 /* _4 */:
      case 53 /* _5 */:
      case 54 /* _6 */:
      case 55 /* _7 */:
        if (pos < end && isOctalDigit(text.charCodeAt(pos))) {
          pos++;
        }
        tokenFlags |= 2048 /* ContainsInvalidEscape */;
        if (shouldEmitInvalidEscapeError) {
          const code = parseInt(text.substring(start2 + 1, pos), 8);
          error(Diagnostics.Octal_escape_sequences_are_not_allowed_Use_the_syntax_0, start2, pos - start2, "\\x" + code.toString(16).padStart(2, "0"));
          return String.fromCharCode(code);
        }
        return text.substring(start2, pos);
      case 56 /* _8 */:
      case 57 /* _9 */:
        tokenFlags |= 2048 /* ContainsInvalidEscape */;
        if (shouldEmitInvalidEscapeError) {
          error(Diagnostics.Escape_sequence_0_is_not_allowed, start2, pos - start2, text.substring(start2, pos));
          return String.fromCharCode(ch);
        }
        return text.substring(start2, pos);
      case 98 /* b */:
        return "\b";
      case 116 /* t */:
        return "	";
      case 110 /* n */:
        return "\n";
      case 118 /* v */:
        return "\v";
      case 102 /* f */:
        return "\f";
      case 114 /* r */:
        return "\r";
      case 39 /* singleQuote */:
        return "'";
      case 34 /* doubleQuote */:
        return '"';
      case 117 /* u */:
        if (pos < end && text.charCodeAt(pos) === 123 /* openBrace */) {
          pos++;
          const escapedValueString = scanMinimumNumberOfHexDigits(
            1,
            /*canHaveSeparators*/
            false
          );
          const escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
          if (escapedValue < 0) {
            tokenFlags |= 2048 /* ContainsInvalidEscape */;
            if (shouldEmitInvalidEscapeError) {
              error(Diagnostics.Hexadecimal_digit_expected);
            }
            return text.substring(start2, pos);
          }
          if (!isCodePoint(escapedValue)) {
            tokenFlags |= 2048 /* ContainsInvalidEscape */;
            if (shouldEmitInvalidEscapeError) {
              error(Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);
            }
            return text.substring(start2, pos);
          }
          if (pos >= end) {
            tokenFlags |= 2048 /* ContainsInvalidEscape */;
            if (shouldEmitInvalidEscapeError) {
              error(Diagnostics.Unexpected_end_of_text);
            }
            return text.substring(start2, pos);
          }
          if (text.charCodeAt(pos) !== 125 /* closeBrace */) {
            tokenFlags |= 2048 /* ContainsInvalidEscape */;
            if (shouldEmitInvalidEscapeError) {
              error(Diagnostics.Unterminated_Unicode_escape_sequence);
            }
            return text.substring(start2, pos);
          }
          pos++;
          tokenFlags |= 8 /* ExtendedUnicodeEscape */;
          return utf16EncodeAsString(escapedValue);
        }
        for (; pos < start2 + 6; pos++) {
          if (!(pos < end && isHexDigit(text.charCodeAt(pos)))) {
            tokenFlags |= 2048 /* ContainsInvalidEscape */;
            if (shouldEmitInvalidEscapeError) {
              error(Diagnostics.Hexadecimal_digit_expected);
            }
            return text.substring(start2, pos);
          }
        }
        tokenFlags |= 1024 /* UnicodeEscape */;
        return String.fromCharCode(parseInt(text.substring(start2 + 2, pos), 16));
      case 120 /* x */:
        for (; pos < start2 + 4; pos++) {
          if (!(pos < end && isHexDigit(text.charCodeAt(pos)))) {
            tokenFlags |= 2048 /* ContainsInvalidEscape */;
            if (shouldEmitInvalidEscapeError) {
              error(Diagnostics.Hexadecimal_digit_expected);
            }
            return text.substring(start2, pos);
          }
        }
        tokenFlags |= 4096 /* HexEscape */;
        return String.fromCharCode(parseInt(text.substring(start2 + 2, pos), 16));
      case 13 /* carriageReturn */:
        if (pos < end && text.charCodeAt(pos) === 10 /* lineFeed */) {
          pos++;
        }
      case 10 /* lineFeed */:
      case 8232 /* lineSeparator */:
      case 8233 /* paragraphSeparator */:
        return "";
      default:
        return String.fromCharCode(ch);
    }
  }
  function scanExtendedUnicodeEscape() {
    const escapedValueString = scanMinimumNumberOfHexDigits(
      1,
      /*canHaveSeparators*/
      false
    );
    const escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
    let isInvalidExtendedEscape = false;
    if (escapedValue < 0) {
      error(Diagnostics.Hexadecimal_digit_expected);
      isInvalidExtendedEscape = true;
    } else if (escapedValue > 1114111) {
      error(Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);
      isInvalidExtendedEscape = true;
    }
    if (pos >= end) {
      error(Diagnostics.Unexpected_end_of_text);
      isInvalidExtendedEscape = true;
    } else if (text.charCodeAt(pos) === 125 /* closeBrace */) {
      pos++;
    } else {
      error(Diagnostics.Unterminated_Unicode_escape_sequence);
      isInvalidExtendedEscape = true;
    }
    if (isInvalidExtendedEscape) {
      return "";
    }
    return utf16EncodeAsString(escapedValue);
  }
  function peekUnicodeEscape() {
    if (pos + 5 < end && text.charCodeAt(pos + 1) === 117 /* u */) {
      const start2 = pos;
      pos += 2;
      const value = scanExactNumberOfHexDigits(
        4,
        /*canHaveSeparators*/
        false
      );
      pos = start2;
      return value;
    }
    return -1;
  }
  function peekExtendedUnicodeEscape() {
    if (codePointAt(text, pos + 1) === 117 /* u */ && codePointAt(text, pos + 2) === 123 /* openBrace */) {
      const start2 = pos;
      pos += 3;
      const escapedValueString = scanMinimumNumberOfHexDigits(
        1,
        /*canHaveSeparators*/
        false
      );
      const escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
      pos = start2;
      return escapedValue;
    }
    return -1;
  }
  function scanIdentifierParts() {
    let result = "";
    let start2 = pos;
    while (pos < end) {
      let ch = codePointAt(text, pos);
      if (isIdentifierPart(ch, languageVersion)) {
        pos += charSize(ch);
      } else if (ch === 92 /* backslash */) {
        ch = peekExtendedUnicodeEscape();
        if (ch >= 0 && isIdentifierPart(ch, languageVersion)) {
          pos += 3;
          tokenFlags |= 8 /* ExtendedUnicodeEscape */;
          result += scanExtendedUnicodeEscape();
          start2 = pos;
          continue;
        }
        ch = peekUnicodeEscape();
        if (!(ch >= 0 && isIdentifierPart(ch, languageVersion))) {
          break;
        }
        tokenFlags |= 1024 /* UnicodeEscape */;
        result += text.substring(start2, pos);
        result += utf16EncodeAsString(ch);
        pos += 6;
        start2 = pos;
      } else {
        break;
      }
    }
    result += text.substring(start2, pos);
    return result;
  }
  function getIdentifierToken() {
    const len = tokenValue.length;
    if (len >= 2 && len <= 12) {
      const ch = tokenValue.charCodeAt(0);
      if (ch >= 97 /* a */ && ch <= 122 /* z */) {
        const keyword = textToKeyword.get(tokenValue);
        if (keyword !== void 0) {
          return token = keyword;
        }
      }
    }
    return token = 80 /* Identifier */;
  }
  function scanBinaryOrOctalDigits(base) {
    let value = "";
    let separatorAllowed = false;
    let isPreviousTokenSeparator = false;
    while (true) {
      const ch = text.charCodeAt(pos);
      if (ch === 95 /* _ */) {
        tokenFlags |= 512 /* ContainsSeparator */;
        if (separatorAllowed) {
          separatorAllowed = false;
          isPreviousTokenSeparator = true;
        } else if (isPreviousTokenSeparator) {
          error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
        } else {
          error(Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
        }
        pos++;
        continue;
      }
      separatorAllowed = true;
      if (!isDigit(ch) || ch - 48 /* _0 */ >= base) {
        break;
      }
      value += text[pos];
      pos++;
      isPreviousTokenSeparator = false;
    }
    if (text.charCodeAt(pos - 1) === 95 /* _ */) {
      error(Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
    }
    return value;
  }
  function checkBigIntSuffix() {
    if (text.charCodeAt(pos) === 110 /* n */) {
      tokenValue += "n";
      if (tokenFlags & 384 /* BinaryOrOctalSpecifier */) {
        tokenValue = parsePseudoBigInt(tokenValue) + "n";
      }
      pos++;
      return 10 /* BigIntLiteral */;
    } else {
      const numericValue = tokenFlags & 128 /* BinarySpecifier */ ? parseInt(tokenValue.slice(2), 2) : tokenFlags & 256 /* OctalSpecifier */ ? parseInt(tokenValue.slice(2), 8) : +tokenValue;
      tokenValue = "" + numericValue;
      return 9 /* NumericLiteral */;
    }
  }
  function scan() {
    fullStartPos = pos;
    tokenFlags = 0 /* None */;
    let asteriskSeen = false;
    while (true) {
      tokenStart = pos;
      if (pos >= end) {
        return token = 1 /* EndOfFileToken */;
      }
      const ch = codePointAt(text, pos);
      if (pos === 0) {
        if (text.slice(0, 256).includes("\uFFFD")) {
          error(Diagnostics.File_appears_to_be_binary);
          pos = end;
          return token = 8 /* NonTextFileMarkerTrivia */;
        }
        if (ch === 35 /* hash */ && isShebangTrivia(text, pos)) {
          pos = scanShebangTrivia(text, pos);
          if (skipTrivia2) {
            continue;
          } else {
            return token = 6 /* ShebangTrivia */;
          }
        }
      }
      switch (ch) {
        case 10 /* lineFeed */:
        case 13 /* carriageReturn */:
          tokenFlags |= 1 /* PrecedingLineBreak */;
          if (skipTrivia2) {
            pos++;
            continue;
          } else {
            if (ch === 13 /* carriageReturn */ && pos + 1 < end && text.charCodeAt(pos + 1) === 10 /* lineFeed */) {
              pos += 2;
            } else {
              pos++;
            }
            return token = 4 /* NewLineTrivia */;
          }
        case 9 /* tab */:
        case 11 /* verticalTab */:
        case 12 /* formFeed */:
        case 32 /* space */:
        case 160 /* nonBreakingSpace */:
        case 5760 /* ogham */:
        case 8192 /* enQuad */:
        case 8193 /* emQuad */:
        case 8194 /* enSpace */:
        case 8195 /* emSpace */:
        case 8196 /* threePerEmSpace */:
        case 8197 /* fourPerEmSpace */:
        case 8198 /* sixPerEmSpace */:
        case 8199 /* figureSpace */:
        case 8200 /* punctuationSpace */:
        case 8201 /* thinSpace */:
        case 8202 /* hairSpace */:
        case 8203 /* zeroWidthSpace */:
        case 8239 /* narrowNoBreakSpace */:
        case 8287 /* mathematicalSpace */:
        case 12288 /* ideographicSpace */:
        case 65279 /* byteOrderMark */:
          if (skipTrivia2) {
            pos++;
            continue;
          } else {
            while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
              pos++;
            }
            return token = 5 /* WhitespaceTrivia */;
          }
        case 33 /* exclamation */:
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 38 /* ExclamationEqualsEqualsToken */;
            }
            return pos += 2, token = 36 /* ExclamationEqualsToken */;
          }
          pos++;
          return token = 54 /* ExclamationToken */;
        case 34 /* doubleQuote */:
        case 39 /* singleQuote */:
          tokenValue = scanString();
          return token = 11 /* StringLiteral */;
        case 96 /* backtick */:
          return token = scanTemplateAndSetTokenValue(
            /*shouldEmitInvalidEscapeError*/
            false
          );
        case 37 /* percent */:
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 70 /* PercentEqualsToken */;
          }
          pos++;
          return token = 45 /* PercentToken */;
        case 38 /* ampersand */:
          if (text.charCodeAt(pos + 1) === 38 /* ampersand */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 77 /* AmpersandAmpersandEqualsToken */;
            }
            return pos += 2, token = 56 /* AmpersandAmpersandToken */;
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 74 /* AmpersandEqualsToken */;
          }
          pos++;
          return token = 51 /* AmpersandToken */;
        case 40 /* openParen */:
          pos++;
          return token = 21 /* OpenParenToken */;
        case 41 /* closeParen */:
          pos++;
          return token = 22 /* CloseParenToken */;
        case 42 /* asterisk */:
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 67 /* AsteriskEqualsToken */;
          }
          if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 68 /* AsteriskAsteriskEqualsToken */;
            }
            return pos += 2, token = 43 /* AsteriskAsteriskToken */;
          }
          pos++;
          if (inJSDocType && !asteriskSeen && tokenFlags & 1 /* PrecedingLineBreak */) {
            asteriskSeen = true;
            continue;
          }
          return token = 42 /* AsteriskToken */;
        case 43 /* plus */:
          if (text.charCodeAt(pos + 1) === 43 /* plus */) {
            return pos += 2, token = 46 /* PlusPlusToken */;
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 65 /* PlusEqualsToken */;
          }
          pos++;
          return token = 40 /* PlusToken */;
        case 44 /* comma */:
          pos++;
          return token = 28 /* CommaToken */;
        case 45 /* minus */:
          if (text.charCodeAt(pos + 1) === 45 /* minus */) {
            return pos += 2, token = 47 /* MinusMinusToken */;
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 66 /* MinusEqualsToken */;
          }
          pos++;
          return token = 41 /* MinusToken */;
        case 46 /* dot */:
          if (isDigit(text.charCodeAt(pos + 1))) {
            scanNumber();
            return token = 9 /* NumericLiteral */;
          }
          if (text.charCodeAt(pos + 1) === 46 /* dot */ && text.charCodeAt(pos + 2) === 46 /* dot */) {
            return pos += 3, token = 26 /* DotDotDotToken */;
          }
          pos++;
          return token = 25 /* DotToken */;
        case 47 /* slash */:
          if (text.charCodeAt(pos + 1) === 47 /* slash */) {
            pos += 2;
            while (pos < end) {
              if (isLineBreak(text.charCodeAt(pos))) {
                break;
              }
              pos++;
            }
            commentDirectives = appendIfCommentDirective(
              commentDirectives,
              text.slice(tokenStart, pos),
              commentDirectiveRegExSingleLine,
              tokenStart
            );
            if (skipTrivia2) {
              continue;
            } else {
              return token = 2 /* SingleLineCommentTrivia */;
            }
          }
          if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
            pos += 2;
            const isJSDoc2 = text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) !== 47 /* slash */;
            let commentClosed = false;
            let lastLineStart = tokenStart;
            while (pos < end) {
              const ch2 = text.charCodeAt(pos);
              if (ch2 === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                pos += 2;
                commentClosed = true;
                break;
              }
              pos++;
              if (isLineBreak(ch2)) {
                lastLineStart = pos;
                tokenFlags |= 1 /* PrecedingLineBreak */;
              }
            }
            if (isJSDoc2 && shouldParseJSDoc()) {
              tokenFlags |= 2 /* PrecedingJSDocComment */;
            }
            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(lastLineStart, pos), commentDirectiveRegExMultiLine, lastLineStart);
            if (!commentClosed) {
              error(Diagnostics.Asterisk_Slash_expected);
            }
            if (skipTrivia2) {
              continue;
            } else {
              if (!commentClosed) {
                tokenFlags |= 4 /* Unterminated */;
              }
              return token = 3 /* MultiLineCommentTrivia */;
            }
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 69 /* SlashEqualsToken */;
          }
          pos++;
          return token = 44 /* SlashToken */;
        case 48 /* _0 */:
          if (pos + 2 < end && (text.charCodeAt(pos + 1) === 88 /* X */ || text.charCodeAt(pos + 1) === 120 /* x */)) {
            pos += 2;
            tokenValue = scanMinimumNumberOfHexDigits(
              1,
              /*canHaveSeparators*/
              true
            );
            if (!tokenValue) {
              error(Diagnostics.Hexadecimal_digit_expected);
              tokenValue = "0";
            }
            tokenValue = "0x" + tokenValue;
            tokenFlags |= 64 /* HexSpecifier */;
            return token = checkBigIntSuffix();
          } else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 66 /* B */ || text.charCodeAt(pos + 1) === 98 /* b */)) {
            pos += 2;
            tokenValue = scanBinaryOrOctalDigits(
              /* base */
              2
            );
            if (!tokenValue) {
              error(Diagnostics.Binary_digit_expected);
              tokenValue = "0";
            }
            tokenValue = "0b" + tokenValue;
            tokenFlags |= 128 /* BinarySpecifier */;
            return token = checkBigIntSuffix();
          } else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 79 /* O */ || text.charCodeAt(pos + 1) === 111 /* o */)) {
            pos += 2;
            tokenValue = scanBinaryOrOctalDigits(
              /* base */
              8
            );
            if (!tokenValue) {
              error(Diagnostics.Octal_digit_expected);
              tokenValue = "0";
            }
            tokenValue = "0o" + tokenValue;
            tokenFlags |= 256 /* OctalSpecifier */;
            return token = checkBigIntSuffix();
          }
        case 49 /* _1 */:
        case 50 /* _2 */:
        case 51 /* _3 */:
        case 52 /* _4 */:
        case 53 /* _5 */:
        case 54 /* _6 */:
        case 55 /* _7 */:
        case 56 /* _8 */:
        case 57 /* _9 */:
          return token = scanNumber();
        case 58 /* colon */:
          pos++;
          return token = 59 /* ColonToken */;
        case 59 /* semicolon */:
          pos++;
          return token = 27 /* SemicolonToken */;
        case 60 /* lessThan */:
          if (isConflictMarkerTrivia(text, pos)) {
            pos = scanConflictMarkerTrivia(text, pos, error);
            if (skipTrivia2) {
              continue;
            } else {
              return token = 7 /* ConflictMarkerTrivia */;
            }
          }
          if (text.charCodeAt(pos + 1) === 60 /* lessThan */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 71 /* LessThanLessThanEqualsToken */;
            }
            return pos += 2, token = 48 /* LessThanLessThanToken */;
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 33 /* LessThanEqualsToken */;
          }
          if (languageVariant === 1 /* JSX */ && text.charCodeAt(pos + 1) === 47 /* slash */ && text.charCodeAt(pos + 2) !== 42 /* asterisk */) {
            return pos += 2, token = 31 /* LessThanSlashToken */;
          }
          pos++;
          return token = 30 /* LessThanToken */;
        case 61 /* equals */:
          if (isConflictMarkerTrivia(text, pos)) {
            pos = scanConflictMarkerTrivia(text, pos, error);
            if (skipTrivia2) {
              continue;
            } else {
              return token = 7 /* ConflictMarkerTrivia */;
            }
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 37 /* EqualsEqualsEqualsToken */;
            }
            return pos += 2, token = 35 /* EqualsEqualsToken */;
          }
          if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
            return pos += 2, token = 39 /* EqualsGreaterThanToken */;
          }
          pos++;
          return token = 64 /* EqualsToken */;
        case 62 /* greaterThan */:
          if (isConflictMarkerTrivia(text, pos)) {
            pos = scanConflictMarkerTrivia(text, pos, error);
            if (skipTrivia2) {
              continue;
            } else {
              return token = 7 /* ConflictMarkerTrivia */;
            }
          }
          pos++;
          return token = 32 /* GreaterThanToken */;
        case 63 /* question */:
          if (text.charCodeAt(pos + 1) === 46 /* dot */ && !isDigit(text.charCodeAt(pos + 2))) {
            return pos += 2, token = 29 /* QuestionDotToken */;
          }
          if (text.charCodeAt(pos + 1) === 63 /* question */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 78 /* QuestionQuestionEqualsToken */;
            }
            return pos += 2, token = 61 /* QuestionQuestionToken */;
          }
          pos++;
          return token = 58 /* QuestionToken */;
        case 91 /* openBracket */:
          pos++;
          return token = 23 /* OpenBracketToken */;
        case 93 /* closeBracket */:
          pos++;
          return token = 24 /* CloseBracketToken */;
        case 94 /* caret */:
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 79 /* CaretEqualsToken */;
          }
          pos++;
          return token = 53 /* CaretToken */;
        case 123 /* openBrace */:
          pos++;
          return token = 19 /* OpenBraceToken */;
        case 124 /* bar */:
          if (isConflictMarkerTrivia(text, pos)) {
            pos = scanConflictMarkerTrivia(text, pos, error);
            if (skipTrivia2) {
              continue;
            } else {
              return token = 7 /* ConflictMarkerTrivia */;
            }
          }
          if (text.charCodeAt(pos + 1) === 124 /* bar */) {
            if (text.charCodeAt(pos + 2) === 61 /* equals */) {
              return pos += 3, token = 76 /* BarBarEqualsToken */;
            }
            return pos += 2, token = 57 /* BarBarToken */;
          }
          if (text.charCodeAt(pos + 1) === 61 /* equals */) {
            return pos += 2, token = 75 /* BarEqualsToken */;
          }
          pos++;
          return token = 52 /* BarToken */;
        case 125 /* closeBrace */:
          pos++;
          return token = 20 /* CloseBraceToken */;
        case 126 /* tilde */:
          pos++;
          return token = 55 /* TildeToken */;
        case 64 /* at */:
          pos++;
          return token = 60 /* AtToken */;
        case 92 /* backslash */:
          const extendedCookedChar = peekExtendedUnicodeEscape();
          if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
            pos += 3;
            tokenFlags |= 8 /* ExtendedUnicodeEscape */;
            tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
            return token = getIdentifierToken();
          }
          const cookedChar = peekUnicodeEscape();
          if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
            pos += 6;
            tokenFlags |= 1024 /* UnicodeEscape */;
            tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
            return token = getIdentifierToken();
          }
          error(Diagnostics.Invalid_character);
          pos++;
          return token = 0 /* Unknown */;
        case 35 /* hash */:
          if (pos !== 0 && text[pos + 1] === "!") {
            error(Diagnostics.can_only_be_used_at_the_start_of_a_file);
            pos++;
            return token = 0 /* Unknown */;
          }
          const charAfterHash = codePointAt(text, pos + 1);
          if (charAfterHash === 92 /* backslash */) {
            pos++;
            const extendedCookedChar2 = peekExtendedUnicodeEscape();
            if (extendedCookedChar2 >= 0 && isIdentifierStart(extendedCookedChar2, languageVersion)) {
              pos += 3;
              tokenFlags |= 8 /* ExtendedUnicodeEscape */;
              tokenValue = "#" + scanExtendedUnicodeEscape() + scanIdentifierParts();
              return token = 81 /* PrivateIdentifier */;
            }
            const cookedChar2 = peekUnicodeEscape();
            if (cookedChar2 >= 0 && isIdentifierStart(cookedChar2, languageVersion)) {
              pos += 6;
              tokenFlags |= 1024 /* UnicodeEscape */;
              tokenValue = "#" + String.fromCharCode(cookedChar2) + scanIdentifierParts();
              return token = 81 /* PrivateIdentifier */;
            }
            pos--;
          }
          if (isIdentifierStart(charAfterHash, languageVersion)) {
            pos++;
            scanIdentifier(charAfterHash, languageVersion);
          } else {
            tokenValue = "#";
            error(Diagnostics.Invalid_character, pos++, charSize(ch));
          }
          return token = 81 /* PrivateIdentifier */;
        default:
          const identifierKind = scanIdentifier(ch, languageVersion);
          if (identifierKind) {
            return token = identifierKind;
          } else if (isWhiteSpaceSingleLine(ch)) {
            pos += charSize(ch);
            continue;
          } else if (isLineBreak(ch)) {
            tokenFlags |= 1 /* PrecedingLineBreak */;
            pos += charSize(ch);
            continue;
          }
          const size = charSize(ch);
          error(Diagnostics.Invalid_character, pos, size);
          pos += size;
          return token = 0 /* Unknown */;
      }
    }
  }
  function shouldParseJSDoc() {
    switch (jsDocParsingMode) {
      case 0 /* ParseAll */:
        return true;
      case 1 /* ParseNone */:
        return false;
    }
    if (scriptKind !== 3 /* TS */ && scriptKind !== 4 /* TSX */) {
      return true;
    }
    if (jsDocParsingMode === 3 /* ParseForTypeInfo */) {
      return false;
    }
    return jsDocSeeOrLink.test(text.slice(fullStartPos, pos));
  }
  function reScanInvalidIdentifier() {
    Debug.assert(token === 0 /* Unknown */, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'.");
    pos = tokenStart = fullStartPos;
    tokenFlags = 0;
    const ch = codePointAt(text, pos);
    const identifierKind = scanIdentifier(ch, 99 /* ESNext */);
    if (identifierKind) {
      return token = identifierKind;
    }
    pos += charSize(ch);
    return token;
  }
  function scanIdentifier(startCharacter, languageVersion2) {
    let ch = startCharacter;
    if (isIdentifierStart(ch, languageVersion2)) {
      pos += charSize(ch);
      while (pos < end && isIdentifierPart(ch = codePointAt(text, pos), languageVersion2))
        pos += charSize(ch);
      tokenValue = text.substring(tokenStart, pos);
      if (ch === 92 /* backslash */) {
        tokenValue += scanIdentifierParts();
      }
      return getIdentifierToken();
    }
  }
  function reScanGreaterToken() {
    if (token === 32 /* GreaterThanToken */) {
      if (text.charCodeAt(pos) === 62 /* greaterThan */) {
        if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {
          if (text.charCodeAt(pos + 2) === 61 /* equals */) {
            return pos += 3, token = 73 /* GreaterThanGreaterThanGreaterThanEqualsToken */;
          }
          return pos += 2, token = 50 /* GreaterThanGreaterThanGreaterThanToken */;
        }
        if (text.charCodeAt(pos + 1) === 61 /* equals */) {
          return pos += 2, token = 72 /* GreaterThanGreaterThanEqualsToken */;
        }
        pos++;
        return token = 49 /* GreaterThanGreaterThanToken */;
      }
      if (text.charCodeAt(pos) === 61 /* equals */) {
        pos++;
        return token = 34 /* GreaterThanEqualsToken */;
      }
    }
    return token;
  }
  function reScanAsteriskEqualsToken() {
    Debug.assert(token === 67 /* AsteriskEqualsToken */, "'reScanAsteriskEqualsToken' should only be called on a '*='");
    pos = tokenStart + 1;
    return token = 64 /* EqualsToken */;
  }
  function reScanSlashToken() {
    if (token === 44 /* SlashToken */ || token === 69 /* SlashEqualsToken */) {
      let p = tokenStart + 1;
      let inEscape = false;
      let inCharacterClass = false;
      while (true) {
        if (p >= end) {
          tokenFlags |= 4 /* Unterminated */;
          error(Diagnostics.Unterminated_regular_expression_literal);
          break;
        }
        const ch = text.charCodeAt(p);
        if (isLineBreak(ch)) {
          tokenFlags |= 4 /* Unterminated */;
          error(Diagnostics.Unterminated_regular_expression_literal);
          break;
        }
        if (inEscape) {
          inEscape = false;
        } else if (ch === 47 /* slash */ && !inCharacterClass) {
          p++;
          break;
        } else if (ch === 91 /* openBracket */) {
          inCharacterClass = true;
        } else if (ch === 92 /* backslash */) {
          inEscape = true;
        } else if (ch === 93 /* closeBracket */) {
          inCharacterClass = false;
        }
        p++;
      }
      while (p < end && isIdentifierPart(text.charCodeAt(p), languageVersion)) {
        p++;
      }
      pos = p;
      tokenValue = text.substring(tokenStart, pos);
      token = 14 /* RegularExpressionLiteral */;
    }
    return token;
  }
  function appendIfCommentDirective(commentDirectives2, text2, commentDirectiveRegEx, lineStart) {
    const type = getDirectiveFromComment(text2.trimStart(), commentDirectiveRegEx);
    if (type === void 0) {
      return commentDirectives2;
    }
    return append(
      commentDirectives2,
      {
        range: { pos: lineStart, end: pos },
        type
      }
    );
  }
  function getDirectiveFromComment(text2, commentDirectiveRegEx) {
    const match = commentDirectiveRegEx.exec(text2);
    if (!match) {
      return void 0;
    }
    switch (match[1]) {
      case "ts-expect-error":
        return 0 /* ExpectError */;
      case "ts-ignore":
        return 1 /* Ignore */;
    }
    return void 0;
  }
  function reScanTemplateToken(isTaggedTemplate) {
    pos = tokenStart;
    return token = scanTemplateAndSetTokenValue(!isTaggedTemplate);
  }
  function reScanTemplateHeadOrNoSubstitutionTemplate() {
    pos = tokenStart;
    return token = scanTemplateAndSetTokenValue(
      /*shouldEmitInvalidEscapeError*/
      true
    );
  }
  function reScanJsxToken(allowMultilineJsxText = true) {
    pos = tokenStart = fullStartPos;
    return token = scanJsxToken(allowMultilineJsxText);
  }
  function reScanLessThanToken() {
    if (token === 48 /* LessThanLessThanToken */) {
      pos = tokenStart + 1;
      return token = 30 /* LessThanToken */;
    }
    return token;
  }
  function reScanHashToken() {
    if (token === 81 /* PrivateIdentifier */) {
      pos = tokenStart + 1;
      return token = 63 /* HashToken */;
    }
    return token;
  }
  function reScanQuestionToken() {
    Debug.assert(token === 61 /* QuestionQuestionToken */, "'reScanQuestionToken' should only be called on a '??'");
    pos = tokenStart + 1;
    return token = 58 /* QuestionToken */;
  }
  function scanJsxToken(allowMultilineJsxText = true) {
    fullStartPos = tokenStart = pos;
    if (pos >= end) {
      return token = 1 /* EndOfFileToken */;
    }
    let char = text.charCodeAt(pos);
    if (char === 60 /* lessThan */) {
      if (text.charCodeAt(pos + 1) === 47 /* slash */) {
        pos += 2;
        return token = 31 /* LessThanSlashToken */;
      }
      pos++;
      return token = 30 /* LessThanToken */;
    }
    if (char === 123 /* openBrace */) {
      pos++;
      return token = 19 /* OpenBraceToken */;
    }
    let firstNonWhitespace = 0;
    while (pos < end) {
      char = text.charCodeAt(pos);
      if (char === 123 /* openBrace */) {
        break;
      }
      if (char === 60 /* lessThan */) {
        if (isConflictMarkerTrivia(text, pos)) {
          pos = scanConflictMarkerTrivia(text, pos, error);
          return token = 7 /* ConflictMarkerTrivia */;
        }
        break;
      }
      if (char === 62 /* greaterThan */) {
        error(Diagnostics.Unexpected_token_Did_you_mean_or_gt, pos, 1);
      }
      if (char === 125 /* closeBrace */) {
        error(Diagnostics.Unexpected_token_Did_you_mean_or_rbrace, pos, 1);
      }
      if (isLineBreak(char) && firstNonWhitespace === 0) {
        firstNonWhitespace = -1;
      } else if (!allowMultilineJsxText && isLineBreak(char) && firstNonWhitespace > 0) {
        break;
      } else if (!isWhiteSpaceLike(char)) {
        firstNonWhitespace = pos;
      }
      pos++;
    }
    tokenValue = text.substring(fullStartPos, pos);
    return firstNonWhitespace === -1 ? 13 /* JsxTextAllWhiteSpaces */ : 12 /* JsxText */;
  }
  function scanJsxIdentifier() {
    if (tokenIsIdentifierOrKeyword(token)) {
      while (pos < end) {
        const ch = text.charCodeAt(pos);
        if (ch === 45 /* minus */) {
          tokenValue += "-";
          pos++;
          continue;
        }
        const oldPos = pos;
        tokenValue += scanIdentifierParts();
        if (pos === oldPos) {
          break;
        }
      }
      return getIdentifierToken();
    }
    return token;
  }
  function scanJsxAttributeValue() {
    fullStartPos = pos;
    switch (text.charCodeAt(pos)) {
      case 34 /* doubleQuote */:
      case 39 /* singleQuote */:
        tokenValue = scanString(
          /*jsxAttributeString*/
          true
        );
        return token = 11 /* StringLiteral */;
      default:
        return scan();
    }
  }
  function reScanJsxAttributeValue() {
    pos = tokenStart = fullStartPos;
    return scanJsxAttributeValue();
  }
  function scanJSDocCommentTextToken(inBackticks) {
    fullStartPos = tokenStart = pos;
    tokenFlags = 0 /* None */;
    if (pos >= end) {
      return token = 1 /* EndOfFileToken */;
    }
    for (let ch = text.charCodeAt(pos); pos < end && (!isLineBreak(ch) && ch !== 96 /* backtick */); ch = codePointAt(text, ++pos)) {
      if (!inBackticks) {
        if (ch === 123 /* openBrace */) {
          break;
        } else if (ch === 64 /* at */ && pos - 1 >= 0 && isWhiteSpaceSingleLine(text.charCodeAt(pos - 1)) && !(pos + 1 < end && isWhiteSpaceLike(text.charCodeAt(pos + 1)))) {
          break;
        }
      }
    }
    if (pos === tokenStart) {
      return scanJsDocToken();
    }
    tokenValue = text.substring(tokenStart, pos);
    return token = 82 /* JSDocCommentTextToken */;
  }
  function scanJsDocToken() {
    fullStartPos = tokenStart = pos;
    tokenFlags = 0 /* None */;
    if (pos >= end) {
      return token = 1 /* EndOfFileToken */;
    }
    const ch = codePointAt(text, pos);
    pos += charSize(ch);
    switch (ch) {
      case 9 /* tab */:
      case 11 /* verticalTab */:
      case 12 /* formFeed */:
      case 32 /* space */:
        while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
          pos++;
        }
        return token = 5 /* WhitespaceTrivia */;
      case 64 /* at */:
        return token = 60 /* AtToken */;
      case 13 /* carriageReturn */:
        if (text.charCodeAt(pos) === 10 /* lineFeed */) {
          pos++;
        }
      case 10 /* lineFeed */:
        tokenFlags |= 1 /* PrecedingLineBreak */;
        return token = 4 /* NewLineTrivia */;
      case 42 /* asterisk */:
        return token = 42 /* AsteriskToken */;
      case 123 /* openBrace */:
        return token = 19 /* OpenBraceToken */;
      case 125 /* closeBrace */:
        return token = 20 /* CloseBraceToken */;
      case 91 /* openBracket */:
        return token = 23 /* OpenBracketToken */;
      case 93 /* closeBracket */:
        return token = 24 /* CloseBracketToken */;
      case 60 /* lessThan */:
        return token = 30 /* LessThanToken */;
      case 62 /* greaterThan */:
        return token = 32 /* GreaterThanToken */;
      case 61 /* equals */:
        return token = 64 /* EqualsToken */;
      case 44 /* comma */:
        return token = 28 /* CommaToken */;
      case 46 /* dot */:
        return token = 25 /* DotToken */;
      case 96 /* backtick */:
        return token = 62 /* BacktickToken */;
      case 35 /* hash */:
        return token = 63 /* HashToken */;
      case 92 /* backslash */:
        pos--;
        const extendedCookedChar = peekExtendedUnicodeEscape();
        if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
          pos += 3;
          tokenFlags |= 8 /* ExtendedUnicodeEscape */;
          tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
          return token = getIdentifierToken();
        }
        const cookedChar = peekUnicodeEscape();
        if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
          pos += 6;
          tokenFlags |= 1024 /* UnicodeEscape */;
          tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
          return token = getIdentifierToken();
        }
        pos++;
        return token = 0 /* Unknown */;
    }
    if (isIdentifierStart(ch, languageVersion)) {
      let char = ch;
      while (pos < end && isIdentifierPart(char = codePointAt(text, pos), languageVersion) || text.charCodeAt(pos) === 45 /* minus */)
        pos += charSize(char);
      tokenValue = text.substring(tokenStart, pos);
      if (char === 92 /* backslash */) {
        tokenValue += scanIdentifierParts();
      }
      return token = getIdentifierToken();
    } else {
      return token = 0 /* Unknown */;
    }
  }
  function speculationHelper(callback, isLookahead) {
    const savePos = pos;
    const saveStartPos = fullStartPos;
    const saveTokenPos = tokenStart;
    const saveToken = token;
    const saveTokenValue = tokenValue;
    const saveTokenFlags = tokenFlags;
    const result = callback();
    if (!result || isLookahead) {
      pos = savePos;
      fullStartPos = saveStartPos;
      tokenStart = saveTokenPos;
      token = saveToken;
      tokenValue = saveTokenValue;
      tokenFlags = saveTokenFlags;
    }
    return result;
  }
  function scanRange(start2, length3, callback) {
    const saveEnd = end;
    const savePos = pos;
    const saveStartPos = fullStartPos;
    const saveTokenPos = tokenStart;
    const saveToken = token;
    const saveTokenValue = tokenValue;
    const saveTokenFlags = tokenFlags;
    const saveErrorExpectations = commentDirectives;
    setText(text, start2, length3);
    const result = callback();
    end = saveEnd;
    pos = savePos;
    fullStartPos = saveStartPos;
    tokenStart = saveTokenPos;
    token = saveToken;
    tokenValue = saveTokenValue;
    tokenFlags = saveTokenFlags;
    commentDirectives = saveErrorExpectations;
    return result;
  }
  function lookAhead(callback) {
    return speculationHelper(
      callback,
      /*isLookahead*/
      true
    );
  }
  function tryScan(callback) {
    return speculationHelper(
      callback,
      /*isLookahead*/
      false
    );
  }
  function getText() {
    return text;
  }
  function clearCommentDirectives() {
    commentDirectives = void 0;
  }
  function setText(newText, start2, length3) {
    text = newText || "";
    end = length3 === void 0 ? text.length : start2 + length3;
    resetTokenState(start2 || 0);
  }
  function setOnError(errorCallback) {
    onError = errorCallback;
  }
  function setScriptTarget(scriptTarget) {
    languageVersion = scriptTarget;
  }
  function setLanguageVariant(variant) {
    languageVariant = variant;
  }
  function setScriptKind(kind) {
    scriptKind = kind;
  }
  function setJSDocParsingMode(kind) {
    jsDocParsingMode = kind;
  }
  function resetTokenState(position) {
    Debug.assert(position >= 0);
    pos = position;
    fullStartPos = position;
    tokenStart = position;
    token = 0 /* Unknown */;
    tokenValue = void 0;
    tokenFlags = 0 /* None */;
  }
  function setInJSDocType(inType) {
    inJSDocType += inType ? 1 : -1;
  }
}
function codePointAt(s, i) {
  return s.codePointAt(i);
}
function charSize(ch) {
  if (ch >= 65536) {
    return 2;
  }
  return 1;
}
function utf16EncodeAsStringFallback(codePoint) {
  Debug.assert(0 <= codePoint && codePoint <= 1114111);
  if (codePoint <= 65535) {
    return String.fromCharCode(codePoint);
  }
  const codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 55296;
  const codeUnit2 = (codePoint - 65536) % 1024 + 56320;
  return String.fromCharCode(codeUnit1, codeUnit2);
}
var utf16EncodeAsStringWorker = String.fromCodePoint ? (codePoint) => String.fromCodePoint(codePoint) : utf16EncodeAsStringFallback;
function utf16EncodeAsString(codePoint) {
  return utf16EncodeAsStringWorker(codePoint);
}

// src/compiler/utilitiesPublic.ts
function isExternalModuleNameRelative(moduleName) {
  return pathIsRelative(moduleName) || isRootedDiskPath(moduleName);
}
function sortAndDeduplicateDiagnostics(diagnostics) {
  return sortAndDeduplicate(diagnostics, compareDiagnostics);
}
function getDefaultLibFileName(options) {
  switch (getEmitScriptTarget(options)) {
    case 99 /* ESNext */:
      return "lib.esnext.full.d.ts";
    case 9 /* ES2022 */:
      return "lib.es2022.full.d.ts";
    case 8 /* ES2021 */:
      return "lib.es2021.full.d.ts";
    case 7 /* ES2020 */:
      return "lib.es2020.full.d.ts";
    case 6 /* ES2019 */:
      return "lib.es2019.full.d.ts";
    case 5 /* ES2018 */:
      return "lib.es2018.full.d.ts";
    case 4 /* ES2017 */:
      return "lib.es2017.full.d.ts";
    case 3 /* ES2016 */:
      return "lib.es2016.full.d.ts";
    case 2 /* ES2015 */:
      return "lib.es6.d.ts";
    default:
      return "lib.d.ts";
  }
}
function textSpanEnd(span) {
  return span.start + span.length;
}
function textSpanIsEmpty(span) {
  return span.length === 0;
}
function textSpanContainsPosition(span, position) {
  return position >= span.start && position < textSpanEnd(span);
}
function textRangeContainsPositionInclusive(span, position) {
  return position >= span.pos && position <= span.end;
}
function createTextSpan(start, length2) {
  if (start < 0) {
    throw new Error("start < 0");
  }
  if (length2 < 0) {
    throw new Error("length < 0");
  }
  return { start, length: length2 };
}
function createTextSpanFromBounds(start, end) {
  return createTextSpan(start, end - start);
}
function textChangeRangeNewSpan(range) {
  return createTextSpan(range.span.start, range.newLength);
}
function textChangeRangeIsUnchanged(range) {
  return textSpanIsEmpty(range.span) && range.newLength === 0;
}
function createTextChangeRange(span, newLength) {
  if (newLength < 0) {
    throw new Error("newLength < 0");
  }
  return { span, newLength };
}
var unchangedTextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0);
function isParameterPropertyDeclaration(node, parent) {
  return isParameter(node) && hasSyntacticModifier(node, 31 /* ParameterPropertyModifier */) && parent.kind === 176 /* Constructor */;
}
function walkUpBindingElementsAndPatterns(binding) {
  let node = binding.parent;
  while (isBindingElement(node.parent)) {
    node = node.parent.parent;
  }
  return node.parent;
}
function getCombinedFlags(node, getFlags) {
  if (isBindingElement(node)) {
    node = walkUpBindingElementsAndPatterns(node);
  }
  let flags = getFlags(node);
  if (node.kind === 260 /* VariableDeclaration */) {
    node = node.parent;
  }
  if (node && node.kind === 261 /* VariableDeclarationList */) {
    flags |= getFlags(node);
    node = node.parent;
  }
  if (node && node.kind === 243 /* VariableStatement */) {
    flags |= getFlags(node);
  }
  return flags;
}
function getCombinedModifierFlags(node) {
  return getCombinedFlags(node, getEffectiveModifierFlags);
}
function getCombinedNodeFlags(node) {
  return getCombinedFlags(node, getNodeFlags);
}
function getNodeFlags(node) {
  return node.flags;
}
var supportedLocaleDirectories = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"];
function validateLocaleAndSetLanguage(locale, sys2, errors) {
  const lowerCaseLocale = locale.toLowerCase();
  const matchResult = /^([a-z]+)([_-]([a-z]+))?$/.exec(lowerCaseLocale);
  if (!matchResult) {
    if (errors) {
      errors.push(createCompilerDiagnostic(Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"));
    }
    return;
  }
  const language = matchResult[1];
  const territory = matchResult[3];
  if (contains(supportedLocaleDirectories, lowerCaseLocale) && !trySetLanguageAndTerritory(language, territory, errors)) {
    trySetLanguageAndTerritory(
      language,
      /*territory*/
      void 0,
      errors
    );
  }
  setUILocale(locale);
  function trySetLanguageAndTerritory(language2, territory2, errors2) {
    const compilerFilePath = normalizePath(sys2.getExecutingFilePath());
    const containingDirectoryPath = getDirectoryPath(compilerFilePath);
    let filePath = combinePaths(containingDirectoryPath, language2);
    if (territory2) {
      filePath = filePath + "-" + territory2;
    }
    filePath = sys2.resolvePath(combinePaths(filePath, "diagnosticMessages.generated.json"));
    if (!sys2.fileExists(filePath)) {
      return false;
    }
    let fileContents = "";
    try {
      fileContents = sys2.readFile(filePath);
    } catch (e) {
      if (errors2) {
        errors2.push(createCompilerDiagnostic(Diagnostics.Unable_to_open_file_0, filePath));
      }
      return false;
    }
    try {
      setLocalizedDiagnosticMessages(JSON.parse(fileContents));
    } catch {
      if (errors2) {
        errors2.push(createCompilerDiagnostic(Diagnostics.Corrupted_locale_file_0, filePath));
      }
      return false;
    }
    return true;
  }
}
function getOriginalNode(node, nodeTest) {
  if (node) {
    while (node.original !== void 0) {
      node = node.original;
    }
  }
  if (!node || !nodeTest) {
    return node;
  }
  return nodeTest(node) ? node : void 0;
}
function findAncestor(node, callback) {
  while (node) {
    const result = callback(node);
    if (result === "quit") {
      return void 0;
    } else if (result) {
      return node;
    }
    node = node.parent;
  }
  return void 0;
}
function isParseTreeNode(node) {
  return (node.flags & 16 /* Synthesized */) === 0;
}
function getParseTreeNode(node, nodeTest) {
  if (node === void 0 || isParseTreeNode(node)) {
    return node;
  }
  node = node.original;
  while (node) {
    if (isParseTreeNode(node)) {
      return !nodeTest || nodeTest(node) ? node : void 0;
    }
    node = node.original;
  }
}
function escapeLeadingUnderscores(identifier) {
  return identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ ? "_" + identifier : identifier;
}
function unescapeLeadingUnderscores(identifier) {
  const id = identifier;
  return id.length >= 3 && id.charCodeAt(0) === 95 /* _ */ && id.charCodeAt(1) === 95 /* _ */ && id.charCodeAt(2) === 95 /* _ */ ? id.substr(1) : id;
}
function idText(identifierOrPrivateName) {
  return unescapeLeadingUnderscores(identifierOrPrivateName.escapedText);
}
function identifierToKeywordKind(node) {
  const token = stringToToken(node.escapedText);
  return token ? tryCast(token, isKeyword) : void 0;
}
function symbolName(symbol) {
  if (symbol.valueDeclaration && isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
    return idText(symbol.valueDeclaration.name);
  }
  return unescapeLeadingUnderscores(symbol.escapedName);
}
function nameForNamelessJSDocTypedef(declaration) {
  const hostNode = declaration.parent.parent;
  if (!hostNode) {
    return void 0;
  }
  if (isDeclaration(hostNode)) {
    return getDeclarationIdentifier(hostNode);
  }
  switch (hostNode.kind) {
    case 243 /* VariableStatement */:
      if (hostNode.declarationList && hostNode.declarationList.declarations[0]) {
        return getDeclarationIdentifier(hostNode.declarationList.declarations[0]);
      }
      break;
    case 244 /* ExpressionStatement */:
      let expr = hostNode.expression;
      if (expr.kind === 226 /* BinaryExpression */ && expr.operatorToken.kind === 64 /* EqualsToken */) {
        expr = expr.left;
      }
      switch (expr.kind) {
        case 211 /* PropertyAccessExpression */:
          return expr.name;
        case 212 /* ElementAccessExpression */:
          const arg = expr.argumentExpression;
          if (isIdentifier(arg)) {
            return arg;
          }
      }
      break;
    case 217 /* ParenthesizedExpression */: {
      return getDeclarationIdentifier(hostNode.expression);
    }
    case 256 /* LabeledStatement */: {
      if (isDeclaration(hostNode.statement) || isExpression(hostNode.statement)) {
        return getDeclarationIdentifier(hostNode.statement);
      }
      break;
    }
  }
}
function getDeclarationIdentifier(node) {
  const name = getNameOfDeclaration(node);
  return name && isIdentifier(name) ? name : void 0;
}
function nodeHasName(statement, name) {
  if (isNamedDeclaration(statement) && isIdentifier(statement.name) && idText(statement.name) === idText(name)) {
    return true;
  }
  if (isVariableStatement(statement) && some(statement.declarationList.declarations, (d) => nodeHasName(d, name))) {
    return true;
  }
  return false;
}
function getNameOfJSDocTypedef(declaration) {
  return declaration.name || nameForNamelessJSDocTypedef(declaration);
}
function isNamedDeclaration(node) {
  return !!node.name;
}
function getNonAssignedNameOfDeclaration(declaration) {
  switch (declaration.kind) {
    case 80 /* Identifier */:
      return declaration;
    case 355 /* JSDocPropertyTag */:
    case 348 /* JSDocParameterTag */: {
      const { name } = declaration;
      if (name.kind === 166 /* QualifiedName */) {
        return name.right;
      }
      break;
    }
    case 213 /* CallExpression */:
    case 226 /* BinaryExpression */: {
      const expr2 = declaration;
      switch (getAssignmentDeclarationKind(expr2)) {
        case 1 /* ExportsProperty */:
        case 4 /* ThisProperty */:
        case 5 /* Property */:
        case 3 /* PrototypeProperty */:
          return getElementOrPropertyAccessArgumentExpressionOrName(expr2.left);
        case 7 /* ObjectDefinePropertyValue */:
        case 8 /* ObjectDefinePropertyExports */:
        case 9 /* ObjectDefinePrototypeProperty */:
          return expr2.arguments[1];
        default:
          return void 0;
      }
    }
    case 353 /* JSDocTypedefTag */:
      return getNameOfJSDocTypedef(declaration);
    case 347 /* JSDocEnumTag */:
      return nameForNamelessJSDocTypedef(declaration);
    case 277 /* ExportAssignment */: {
      const { expression } = declaration;
      return isIdentifier(expression) ? expression : void 0;
    }
    case 212 /* ElementAccessExpression */:
      const expr = declaration;
      if (isBindableStaticElementAccessExpression(expr)) {
        return expr.argumentExpression;
      }
  }
  return declaration.name;
}
function getNameOfDeclaration(declaration) {
  if (declaration === void 0)
    return void 0;
  return getNonAssignedNameOfDeclaration(declaration) || (isFunctionExpression(declaration) || isArrowFunction(declaration) || isClassExpression(declaration) ? getAssignedName(declaration) : void 0);
}
function getAssignedName(node) {
  if (!node.parent) {
    return void 0;
  } else if (isPropertyAssignment(node.parent) || isBindingElement(node.parent)) {
    return node.parent.name;
  } else if (isBinaryExpression(node.parent) && node === node.parent.right) {
    if (isIdentifier(node.parent.left)) {
      return node.parent.left;
    } else if (isAccessExpression(node.parent.left)) {
      return getElementOrPropertyAccessArgumentExpressionOrName(node.parent.left);
    }
  } else if (isVariableDeclaration(node.parent) && isIdentifier(node.parent.name)) {
    return node.parent.name;
  }
}
function getDecorators(node) {
  if (hasDecorators(node)) {
    return filter(node.modifiers, isDecorator);
  }
}
function getModifiers(node) {
  if (hasSyntacticModifier(node, 98303 /* Modifier */)) {
    return filter(node.modifiers, isModifier);
  }
}
function getJSDocParameterTagsWorker(param, noCache) {
  if (param.name) {
    if (isIdentifier(param.name)) {
      const name = param.name.escapedText;
      return getJSDocTagsWorker(param.parent, noCache).filter((tag) => isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText === name);
    } else {
      const i = param.parent.parameters.indexOf(param);
      Debug.assert(i > -1, "Parameters should always be in their parents' parameter list");
      const paramTags = getJSDocTagsWorker(param.parent, noCache).filter(isJSDocParameterTag);
      if (i < paramTags.length) {
        return [paramTags[i]];
      }
    }
  }
  return emptyArray;
}
function getJSDocParameterTags(param) {
  return getJSDocParameterTagsWorker(
    param,
    /*noCache*/
    false
  );
}
function getJSDocParameterTagsNoCache(param) {
  return getJSDocParameterTagsWorker(
    param,
    /*noCache*/
    true
  );
}
function getJSDocTypeParameterTagsWorker(param, noCache) {
  const name = param.name.escapedText;
  return getJSDocTagsWorker(param.parent, noCache).filter((tag) => isJSDocTemplateTag(tag) && tag.typeParameters.some((tp) => tp.name.escapedText === name));
}
function getJSDocTypeParameterTags(param) {
  return getJSDocTypeParameterTagsWorker(
    param,
    /*noCache*/
    false
  );
}
function getJSDocTypeParameterTagsNoCache(param) {
  return getJSDocTypeParameterTagsWorker(
    param,
    /*noCache*/
    true
  );
}
function hasJSDocParameterTags(node) {
  return !!getFirstJSDocTag(node, isJSDocParameterTag);
}
function getJSDocAugmentsTag(node) {
  return getFirstJSDocTag(node, isJSDocAugmentsTag);
}
function getJSDocImplementsTags(node) {
  return getAllJSDocTags(node, isJSDocImplementsTag);
}
function getJSDocClassTag(node) {
  return getFirstJSDocTag(node, isJSDocClassTag);
}
function getJSDocPublicTagNoCache(node) {
  return getFirstJSDocTag(
    node,
    isJSDocPublicTag,
    /*noCache*/
    true
  );
}
function getJSDocPrivateTagNoCache(node) {
  return getFirstJSDocTag(
    node,
    isJSDocPrivateTag,
    /*noCache*/
    true
  );
}
function getJSDocProtectedTagNoCache(node) {
  return getFirstJSDocTag(
    node,
    isJSDocProtectedTag,
    /*noCache*/
    true
  );
}
function getJSDocReadonlyTagNoCache(node) {
  return getFirstJSDocTag(
    node,
    isJSDocReadonlyTag,
    /*noCache*/
    true
  );
}
function getJSDocOverrideTagNoCache(node) {
  return getFirstJSDocTag(
    node,
    isJSDocOverrideTag,
    /*noCache*/
    true
  );
}
function getJSDocDeprecatedTag(node) {
  return getFirstJSDocTag(node, isJSDocDeprecatedTag);
}
function getJSDocDeprecatedTagNoCache(node) {
  return getFirstJSDocTag(
    node,
    isJSDocDeprecatedTag,
    /*noCache*/
    true
  );
}
function getJSDocEnumTag(node) {
  return getFirstJSDocTag(node, isJSDocEnumTag);
}
function getJSDocThisTag(node) {
  return getFirstJSDocTag(node, isJSDocThisTag);
}
function getJSDocReturnTag(node) {
  return getFirstJSDocTag(node, isJSDocReturnTag);
}
function getJSDocSatisfiesTag(node) {
  return getFirstJSDocTag(node, isJSDocSatisfiesTag);
}
function getJSDocTypeTag(node) {
  const tag = getFirstJSDocTag(node, isJSDocTypeTag);
  if (tag && tag.typeExpression && tag.typeExpression.type) {
    return tag;
  }
  return void 0;
}
function getJSDocType(node) {
  let tag = getFirstJSDocTag(node, isJSDocTypeTag);
  if (!tag && isParameter(node)) {
    tag = find(getJSDocParameterTags(node), (tag2) => !!tag2.typeExpression);
  }
  return tag && tag.typeExpression && tag.typeExpression.type;
}
function getJSDocReturnType(node) {
  const returnTag = getJSDocReturnTag(node);
  if (returnTag && returnTag.typeExpression) {
    return returnTag.typeExpression.type;
  }
  const typeTag = getJSDocTypeTag(node);
  if (typeTag && typeTag.typeExpression) {
    const type = typeTag.typeExpression.type;
    if (isTypeLiteralNode(type)) {
      const sig = find(type.members, isCallSignatureDeclaration);
      return sig && sig.type;
    }
    if (isFunctionTypeNode(type) || isJSDocFunctionType(type)) {
      return type.type;
    }
  }
}
function getJSDocTagsWorker(node, noCache) {
  var _a;
  if (!canHaveJSDoc(node))
    return emptyArray;
  let tags = (_a = node.jsDoc) == null ? void 0 : _a.jsDocCache;
  if (tags === void 0 || noCache) {
    const comments = getJSDocCommentsAndTags(node, noCache);
    Debug.assert(comments.length < 2 || comments[0] !== comments[1]);
    tags = flatMap(comments, (j) => isJSDoc(j) ? j.tags : j);
    if (!noCache) {
      node.jsDoc ?? (node.jsDoc = []);
      node.jsDoc.jsDocCache = tags;
    }
  }
  return tags;
}
function getJSDocTags(node) {
  return getJSDocTagsWorker(
    node,
    /*noCache*/
    false
  );
}
function getFirstJSDocTag(node, predicate, noCache) {
  return find(getJSDocTagsWorker(node, noCache), predicate);
}
function getAllJSDocTags(node, predicate) {
  return getJSDocTags(node).filter(predicate);
}
function getTextOfJSDocComment(comment) {
  return typeof comment === "string" ? comment : comment == null ? void 0 : comment.map((c) => c.kind === 328 /* JSDocText */ ? c.text : formatJSDocLink(c)).join("");
}
function formatJSDocLink(link) {
  const kind = link.kind === 331 /* JSDocLink */ ? "link" : link.kind === 332 /* JSDocLinkCode */ ? "linkcode" : "linkplain";
  const name = link.name ? entityNameToString(link.name) : "";
  const space = link.name && link.text.startsWith("://") ? "" : " ";
  return `{@${kind} ${name}${space}${link.text}}`;
}
function getEffectiveTypeParameterDeclarations(node) {
  if (isJSDocSignature(node)) {
    if (isJSDocOverloadTag(node.parent)) {
      const jsDoc = getJSDocRoot(node.parent);
      if (jsDoc && length(jsDoc.tags)) {
        return flatMap(jsDoc.tags, (tag) => isJSDocTemplateTag(tag) ? tag.typeParameters : void 0);
      }
    }
    return emptyArray;
  }
  if (isJSDocTypeAlias(node)) {
    Debug.assert(node.parent.kind === 327 /* JSDoc */);
    return flatMap(node.parent.tags, (tag) => isJSDocTemplateTag(tag) ? tag.typeParameters : void 0);
  }
  if (node.typeParameters) {
    return node.typeParameters;
  }
  if (canHaveIllegalTypeParameters(node) && node.typeParameters) {
    return node.typeParameters;
  }
  if (isInJSFile(node)) {
    const decls = getJSDocTypeParameterDeclarations(node);
    if (decls.length) {
      return decls;
    }
    const typeTag = getJSDocType(node);
    if (typeTag && isFunctionTypeNode(typeTag) && typeTag.typeParameters) {
      return typeTag.typeParameters;
    }
  }
  return emptyArray;
}
function getEffectiveConstraintOfTypeParameter(node) {
  return node.constraint ? node.constraint : isJSDocTemplateTag(node.parent) && node === node.parent.typeParameters[0] ? node.parent.constraint : void 0;
}
function isMemberName(node) {
  return node.kind === 80 /* Identifier */ || node.kind === 81 /* PrivateIdentifier */;
}
function isGetOrSetAccessorDeclaration(node) {
  return node.kind === 178 /* SetAccessor */ || node.kind === 177 /* GetAccessor */;
}
function isPropertyAccessChain(node) {
  return isPropertyAccessExpression(node) && !!(node.flags & 64 /* OptionalChain */);
}
function isElementAccessChain(node) {
  return isElementAccessExpression(node) && !!(node.flags & 64 /* OptionalChain */);
}
function isCallChain(node) {
  return isCallExpression(node) && !!(node.flags & 64 /* OptionalChain */);
}
function isOptionalChain(node) {
  const kind = node.kind;
  return !!(node.flags & 64 /* OptionalChain */) && (kind === 211 /* PropertyAccessExpression */ || kind === 212 /* ElementAccessExpression */ || kind === 213 /* CallExpression */ || kind === 235 /* NonNullExpression */);
}
function isOptionalChainRoot(node) {
  return isOptionalChain(node) && !isNonNullExpression(node) && !!node.questionDotToken;
}
function isExpressionOfOptionalChainRoot(node) {
  return isOptionalChainRoot(node.parent) && node.parent.expression === node;
}
function isOutermostOptionalChain(node) {
  return !isOptionalChain(node.parent) || isOptionalChainRoot(node.parent) || node !== node.parent.expression;
}
function isNullishCoalesce(node) {
  return node.kind === 226 /* BinaryExpression */ && node.operatorToken.kind === 61 /* QuestionQuestionToken */;
}
function isConstTypeReference(node) {
  return isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText === "const" && !node.typeArguments;
}
function skipPartiallyEmittedExpressions(node) {
  return skipOuterExpressions(node, 8 /* PartiallyEmittedExpressions */);
}
function isNonNullChain(node) {
  return isNonNullExpression(node) && !!(node.flags & 64 /* OptionalChain */);
}
function isNamedExportBindings(node) {
  return node.kind === 280 /* NamespaceExport */ || node.kind === 279 /* NamedExports */;
}
function isUnparsedTextLike(node) {
  switch (node.kind) {
    case 309 /* UnparsedText */:
    case 310 /* UnparsedInternalText */:
      return true;
    default:
      return false;
  }
}
function isUnparsedNode(node) {
  return isUnparsedTextLike(node) || node.kind === 307 /* UnparsedPrologue */ || node.kind === 311 /* UnparsedSyntheticReference */;
}
function isJSDocPropertyLikeTag(node) {
  return node.kind === 355 /* JSDocPropertyTag */ || node.kind === 348 /* JSDocParameterTag */;
}
function isNodeKind(kind) {
  return kind >= 166 /* FirstNode */;
}
function isTokenKind(kind) {
  return kind >= 0 /* FirstToken */ && kind <= 165 /* LastToken */;
}
function isNodeArray(array) {
  return hasProperty(array, "pos") && hasProperty(array, "end");
}
function isLiteralKind(kind) {
  return 9 /* FirstLiteralToken */ <= kind && kind <= 15 /* LastLiteralToken */;
}
function isLiteralExpression(node) {
  return isLiteralKind(node.kind);
}
function isLiteralExpressionOfObject(node) {
  switch (node.kind) {
    case 210 /* ObjectLiteralExpression */:
    case 209 /* ArrayLiteralExpression */:
    case 14 /* RegularExpressionLiteral */:
    case 218 /* FunctionExpression */:
    case 231 /* ClassExpression */:
      return true;
  }
  return false;
}
function isTemplateLiteralKind(kind) {
  return 15 /* FirstTemplateToken */ <= kind && kind <= 18 /* LastTemplateToken */;
}
function isTemplateMiddleOrTemplateTail(node) {
  const kind = node.kind;
  return kind === 17 /* TemplateMiddle */ || kind === 18 /* TemplateTail */;
}
function isImportOrExportSpecifier(node) {
  return isImportSpecifier(node) || isExportSpecifier(node);
}
function isTypeOnlyImportDeclaration(node) {
  switch (node.kind) {
    case 276 /* ImportSpecifier */:
      return node.isTypeOnly || node.parent.parent.isTypeOnly;
    case 274 /* NamespaceImport */:
      return node.parent.isTypeOnly;
    case 273 /* ImportClause */:
    case 271 /* ImportEqualsDeclaration */:
      return node.isTypeOnly;
  }
  return false;
}
function isTypeOnlyExportDeclaration(node) {
  switch (node.kind) {
    case 281 /* ExportSpecifier */:
      return node.isTypeOnly || node.parent.parent.isTypeOnly;
    case 278 /* ExportDeclaration */:
      return node.isTypeOnly && !!node.moduleSpecifier && !node.exportClause;
    case 280 /* NamespaceExport */:
      return node.parent.isTypeOnly;
  }
  return false;
}
function isTypeOnlyImportOrExportDeclaration(node) {
  return isTypeOnlyImportDeclaration(node) || isTypeOnlyExportDeclaration(node);
}
function isImportAttributeName(node) {
  return isStringLiteral(node) || isIdentifier(node);
}
function isGeneratedIdentifier(node) {
  var _a;
  return isIdentifier(node) && ((_a = node.emitNode) == null ? void 0 : _a.autoGenerate) !== void 0;
}
function isGeneratedPrivateIdentifier(node) {
  var _a;
  return isPrivateIdentifier(node) && ((_a = node.emitNode) == null ? void 0 : _a.autoGenerate) !== void 0;
}
function isFileLevelReservedGeneratedIdentifier(node) {
  const flags = node.emitNode.autoGenerate.flags;
  return !!(flags & 32 /* FileLevel */) && !!(flags & 16 /* Optimistic */) && !!(flags & 8 /* ReservedInNestedScopes */);
}
function isPrivateIdentifierClassElementDeclaration(node) {
  return (isPropertyDeclaration(node) || isMethodOrAccessor(node)) && isPrivateIdentifier(node.name);
}
function isPrivateIdentifierPropertyAccessExpression(node) {
  return isPropertyAccessExpression(node) && isPrivateIdentifier(node.name);
}
function isModifierKind(token) {
  switch (token) {
    case 128 /* AbstractKeyword */:
    case 129 /* AccessorKeyword */:
    case 134 /* AsyncKeyword */:
    case 87 /* ConstKeyword */:
    case 138 /* DeclareKeyword */:
    case 90 /* DefaultKeyword */:
    case 95 /* ExportKeyword */:
    case 103 /* InKeyword */:
    case 125 /* PublicKeyword */:
    case 123 /* PrivateKeyword */:
    case 124 /* ProtectedKeyword */:
    case 148 /* ReadonlyKeyword */:
    case 126 /* StaticKeyword */:
    case 147 /* OutKeyword */:
    case 164 /* OverrideKeyword */:
      return true;
  }
  return false;
}
function isParameterPropertyModifier(kind) {
  return !!(modifierToFlag(kind) & 31 /* ParameterPropertyModifier */);
}
function isClassMemberModifier(idToken) {
  return isParameterPropertyModifier(idToken) || idToken === 126 /* StaticKeyword */ || idToken === 164 /* OverrideKeyword */ || idToken === 129 /* AccessorKeyword */;
}
function isModifier(node) {
  return isModifierKind(node.kind);
}
function isEntityName(node) {
  const kind = node.kind;
  return kind === 166 /* QualifiedName */ || kind === 80 /* Identifier */;
}
function isPropertyName(node) {
  const kind = node.kind;
  return kind === 80 /* Identifier */ || kind === 81 /* PrivateIdentifier */ || kind === 11 /* StringLiteral */ || kind === 9 /* NumericLiteral */ || kind === 167 /* ComputedPropertyName */;
}
function isBindingName(node) {
  const kind = node.kind;
  return kind === 80 /* Identifier */ || kind === 206 /* ObjectBindingPattern */ || kind === 207 /* ArrayBindingPattern */;
}
function isFunctionLike(node) {
  return !!node && isFunctionLikeKind(node.kind);
}
function isFunctionLikeOrClassStaticBlockDeclaration(node) {
  return !!node && (isFunctionLikeKind(node.kind) || isClassStaticBlockDeclaration(node));
}
function isFunctionLikeDeclaration(node) {
  return node && isFunctionLikeDeclarationKind(node.kind);
}
function isBooleanLiteral(node) {
  return node.kind === 112 /* TrueKeyword */ || node.kind === 97 /* FalseKeyword */;
}
function isFunctionLikeDeclarationKind(kind) {
  switch (kind) {
    case 262 /* FunctionDeclaration */:
    case 174 /* MethodDeclaration */:
    case 176 /* Constructor */:
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
    case 218 /* FunctionExpression */:
    case 219 /* ArrowFunction */:
      return true;
    default:
      return false;
  }
}
function isFunctionLikeKind(kind) {
  switch (kind) {
    case 173 /* MethodSignature */:
    case 179 /* CallSignature */:
    case 330 /* JSDocSignature */:
    case 180 /* ConstructSignature */:
    case 181 /* IndexSignature */:
    case 184 /* FunctionType */:
    case 324 /* JSDocFunctionType */:
    case 185 /* ConstructorType */:
      return true;
    default:
      return isFunctionLikeDeclarationKind(kind);
  }
}
function isFunctionOrModuleBlock(node) {
  return isSourceFile(node) || isModuleBlock(node) || isBlock(node) && isFunctionLike(node.parent);
}
function isClassElement(node) {
  const kind = node.kind;
  return kind === 176 /* Constructor */ || kind === 172 /* PropertyDeclaration */ || kind === 174 /* MethodDeclaration */ || kind === 177 /* GetAccessor */ || kind === 178 /* SetAccessor */ || kind === 181 /* IndexSignature */ || kind === 175 /* ClassStaticBlockDeclaration */ || kind === 240 /* SemicolonClassElement */;
}
function isClassLike(node) {
  return node && (node.kind === 263 /* ClassDeclaration */ || node.kind === 231 /* ClassExpression */);
}
function isAccessor(node) {
  return node && (node.kind === 177 /* GetAccessor */ || node.kind === 178 /* SetAccessor */);
}
function isAutoAccessorPropertyDeclaration(node) {
  return isPropertyDeclaration(node) && hasAccessorModifier(node);
}
function isClassInstanceProperty(node) {
  if (isInJSFile(node) && isExpandoPropertyDeclaration(node)) {
    return (!isBindableStaticAccessExpression(node) || !isPrototypeAccess(node.expression)) && !isBindableStaticNameExpression(
      node,
      /*excludeThisKeyword*/
      true
    );
  }
  return node.parent && isClassLike(node.parent) && isPropertyDeclaration(node) && !hasAccessorModifier(node);
}
function isMethodOrAccessor(node) {
  switch (node.kind) {
    case 174 /* MethodDeclaration */:
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
      return true;
    default:
      return false;
  }
}
function isModifierLike(node) {
  return isModifier(node) || isDecorator(node);
}
function isTypeElement(node) {
  const kind = node.kind;
  return kind === 180 /* ConstructSignature */ || kind === 179 /* CallSignature */ || kind === 171 /* PropertySignature */ || kind === 173 /* MethodSignature */ || kind === 181 /* IndexSignature */ || kind === 177 /* GetAccessor */ || kind === 178 /* SetAccessor */;
}
function isObjectLiteralElementLike(node) {
  const kind = node.kind;
  return kind === 303 /* PropertyAssignment */ || kind === 304 /* ShorthandPropertyAssignment */ || kind === 305 /* SpreadAssignment */ || kind === 174 /* MethodDeclaration */ || kind === 177 /* GetAccessor */ || kind === 178 /* SetAccessor */;
}
function isTypeNode(node) {
  return isTypeNodeKind(node.kind);
}
function isFunctionOrConstructorTypeNode(node) {
  switch (node.kind) {
    case 184 /* FunctionType */:
    case 185 /* ConstructorType */:
      return true;
  }
  return false;
}
function isBindingPattern(node) {
  if (node) {
    const kind = node.kind;
    return kind === 207 /* ArrayBindingPattern */ || kind === 206 /* ObjectBindingPattern */;
  }
  return false;
}
function isAssignmentPattern(node) {
  const kind = node.kind;
  return kind === 209 /* ArrayLiteralExpression */ || kind === 210 /* ObjectLiteralExpression */;
}
function isArrayBindingElement(node) {
  const kind = node.kind;
  return kind === 208 /* BindingElement */ || kind === 232 /* OmittedExpression */;
}
function isDeclarationBindingElement(bindingElement) {
  switch (bindingElement.kind) {
    case 260 /* VariableDeclaration */:
    case 169 /* Parameter */:
    case 208 /* BindingElement */:
      return true;
  }
  return false;
}
function isBindingOrAssignmentElement(node) {
  return isVariableDeclaration(node) || isParameter(node) || isObjectBindingOrAssignmentElement(node) || isArrayBindingOrAssignmentElement(node);
}
function isBindingOrAssignmentPattern(node) {
  return isObjectBindingOrAssignmentPattern(node) || isArrayBindingOrAssignmentPattern(node);
}
function isObjectBindingOrAssignmentPattern(node) {
  switch (node.kind) {
    case 206 /* ObjectBindingPattern */:
    case 210 /* ObjectLiteralExpression */:
      return true;
  }
  return false;
}
function isObjectBindingOrAssignmentElement(node) {
  switch (node.kind) {
    case 208 /* BindingElement */:
    case 303 /* PropertyAssignment */:
    case 304 /* ShorthandPropertyAssignment */:
    case 305 /* SpreadAssignment */:
      return true;
  }
  return false;
}
function isArrayBindingOrAssignmentPattern(node) {
  switch (node.kind) {
    case 207 /* ArrayBindingPattern */:
    case 209 /* ArrayLiteralExpression */:
      return true;
  }
  return false;
}
function isArrayBindingOrAssignmentElement(node) {
  switch (node.kind) {
    case 208 /* BindingElement */:
    case 232 /* OmittedExpression */:
    case 230 /* SpreadElement */:
    case 209 /* ArrayLiteralExpression */:
    case 210 /* ObjectLiteralExpression */:
    case 80 /* Identifier */:
    case 211 /* PropertyAccessExpression */:
    case 212 /* ElementAccessExpression */:
      return true;
  }
  return isAssignmentExpression(
    node,
    /*excludeCompoundAssignment*/
    true
  );
}
function isPropertyAccessOrQualifiedNameOrImportTypeNode(node) {
  const kind = node.kind;
  return kind === 211 /* PropertyAccessExpression */ || kind === 166 /* QualifiedName */ || kind === 205 /* ImportType */;
}
function isCallLikeOrFunctionLikeExpression(node) {
  return isCallLikeExpression(node) || isFunctionExpressionOrArrowFunction(node);
}
function isCallLikeExpression(node) {
  switch (node.kind) {
    case 286 /* JsxOpeningElement */:
    case 285 /* JsxSelfClosingElement */:
    case 213 /* CallExpression */:
    case 214 /* NewExpression */:
    case 215 /* TaggedTemplateExpression */:
    case 170 /* Decorator */:
      return true;
    default:
      return false;
  }
}
function isCallOrNewExpression(node) {
  return node.kind === 213 /* CallExpression */ || node.kind === 214 /* NewExpression */;
}
function isTemplateLiteral(node) {
  const kind = node.kind;
  return kind === 228 /* TemplateExpression */ || kind === 15 /* NoSubstitutionTemplateLiteral */;
}
function isLeftHandSideExpression(node) {
  return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);
}
function isLeftHandSideExpressionKind(kind) {
  switch (kind) {
    case 211 /* PropertyAccessExpression */:
    case 212 /* ElementAccessExpression */:
    case 214 /* NewExpression */:
    case 213 /* CallExpression */:
    case 284 /* JsxElement */:
    case 285 /* JsxSelfClosingElement */:
    case 288 /* JsxFragment */:
    case 215 /* TaggedTemplateExpression */:
    case 209 /* ArrayLiteralExpression */:
    case 217 /* ParenthesizedExpression */:
    case 210 /* ObjectLiteralExpression */:
    case 231 /* ClassExpression */:
    case 218 /* FunctionExpression */:
    case 80 /* Identifier */:
    case 81 /* PrivateIdentifier */:
    case 14 /* RegularExpressionLiteral */:
    case 9 /* NumericLiteral */:
    case 10 /* BigIntLiteral */:
    case 11 /* StringLiteral */:
    case 15 /* NoSubstitutionTemplateLiteral */:
    case 228 /* TemplateExpression */:
    case 97 /* FalseKeyword */:
    case 106 /* NullKeyword */:
    case 110 /* ThisKeyword */:
    case 112 /* TrueKeyword */:
    case 108 /* SuperKeyword */:
    case 235 /* NonNullExpression */:
    case 233 /* ExpressionWithTypeArguments */:
    case 236 /* MetaProperty */:
    case 102 /* ImportKeyword */:
    case 282 /* MissingDeclaration */:
      return true;
    default:
      return false;
  }
}
function isUnaryExpression(node) {
  return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);
}
function isUnaryExpressionKind(kind) {
  switch (kind) {
    case 224 /* PrefixUnaryExpression */:
    case 225 /* PostfixUnaryExpression */:
    case 220 /* DeleteExpression */:
    case 221 /* TypeOfExpression */:
    case 222 /* VoidExpression */:
    case 223 /* AwaitExpression */:
    case 216 /* TypeAssertionExpression */:
      return true;
    default:
      return isLeftHandSideExpressionKind(kind);
  }
}
function isLiteralTypeLiteral(node) {
  switch (node.kind) {
    case 106 /* NullKeyword */:
    case 112 /* TrueKeyword */:
    case 97 /* FalseKeyword */:
    case 224 /* PrefixUnaryExpression */:
      return true;
    default:
      return isLiteralExpression(node);
  }
}
function isExpression(node) {
  return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);
}
function isExpressionKind(kind) {
  switch (kind) {
    case 227 /* ConditionalExpression */:
    case 229 /* YieldExpression */:
    case 219 /* ArrowFunction */:
    case 226 /* BinaryExpression */:
    case 230 /* SpreadElement */:
    case 234 /* AsExpression */:
    case 232 /* OmittedExpression */:
    case 361 /* CommaListExpression */:
    case 360 /* PartiallyEmittedExpression */:
    case 238 /* SatisfiesExpression */:
      return true;
    default:
      return isUnaryExpressionKind(kind);
  }
}
function isAssertionExpression(node) {
  const kind = node.kind;
  return kind === 216 /* TypeAssertionExpression */ || kind === 234 /* AsExpression */;
}
function isIterationStatement(node, lookInLabeledStatements) {
  switch (node.kind) {
    case 248 /* ForStatement */:
    case 249 /* ForInStatement */:
    case 250 /* ForOfStatement */:
    case 246 /* DoStatement */:
    case 247 /* WhileStatement */:
      return true;
    case 256 /* LabeledStatement */:
      return lookInLabeledStatements && isIterationStatement(node.statement, lookInLabeledStatements);
  }
  return false;
}
function isScopeMarker(node) {
  return isExportAssignment(node) || isExportDeclaration(node);
}
function hasScopeMarker(statements) {
  return some(statements, isScopeMarker);
}
function needsScopeMarker(result) {
  return !isAnyImportOrReExport(result) && !isExportAssignment(result) && !hasSyntacticModifier(result, 32 /* Export */) && !isAmbientModule(result);
}
function isExternalModuleIndicator(result) {
  return isAnyImportOrReExport(result) || isExportAssignment(result) || hasSyntacticModifier(result, 32 /* Export */);
}
function isForInOrOfStatement(node) {
  return node.kind === 249 /* ForInStatement */ || node.kind === 250 /* ForOfStatement */;
}
function isConciseBody(node) {
  return isBlock(node) || isExpression(node);
}
function isForInitializer(node) {
  return isVariableDeclarationList(node) || isExpression(node);
}
function isModuleBody(node) {
  const kind = node.kind;
  return kind === 268 /* ModuleBlock */ || kind === 267 /* ModuleDeclaration */ || kind === 80 /* Identifier */;
}
function isNamedImportBindings(node) {
  const kind = node.kind;
  return kind === 275 /* NamedImports */ || kind === 274 /* NamespaceImport */;
}
function isModuleOrEnumDeclaration(node) {
  return node.kind === 267 /* ModuleDeclaration */ || node.kind === 266 /* EnumDeclaration */;
}
function canHaveSymbol(node) {
  switch (node.kind) {
    case 219 /* ArrowFunction */:
    case 226 /* BinaryExpression */:
    case 208 /* BindingElement */:
    case 213 /* CallExpression */:
    case 179 /* CallSignature */:
    case 263 /* ClassDeclaration */:
    case 231 /* ClassExpression */:
    case 175 /* ClassStaticBlockDeclaration */:
    case 176 /* Constructor */:
    case 185 /* ConstructorType */:
    case 180 /* ConstructSignature */:
    case 212 /* ElementAccessExpression */:
    case 266 /* EnumDeclaration */:
    case 306 /* EnumMember */:
    case 277 /* ExportAssignment */:
    case 278 /* ExportDeclaration */:
    case 281 /* ExportSpecifier */:
    case 262 /* FunctionDeclaration */:
    case 218 /* FunctionExpression */:
    case 184 /* FunctionType */:
    case 177 /* GetAccessor */:
    case 80 /* Identifier */:
    case 273 /* ImportClause */:
    case 271 /* ImportEqualsDeclaration */:
    case 276 /* ImportSpecifier */:
    case 181 /* IndexSignature */:
    case 264 /* InterfaceDeclaration */:
    case 345 /* JSDocCallbackTag */:
    case 347 /* JSDocEnumTag */:
    case 324 /* JSDocFunctionType */:
    case 348 /* JSDocParameterTag */:
    case 355 /* JSDocPropertyTag */:
    case 330 /* JSDocSignature */:
    case 353 /* JSDocTypedefTag */:
    case 329 /* JSDocTypeLiteral */:
    case 291 /* JsxAttribute */:
    case 292 /* JsxAttributes */:
    case 293 /* JsxSpreadAttribute */:
    case 200 /* MappedType */:
    case 174 /* MethodDeclaration */:
    case 173 /* MethodSignature */:
    case 267 /* ModuleDeclaration */:
    case 202 /* NamedTupleMember */:
    case 280 /* NamespaceExport */:
    case 270 /* NamespaceExportDeclaration */:
    case 274 /* NamespaceImport */:
    case 214 /* NewExpression */:
    case 15 /* NoSubstitutionTemplateLiteral */:
    case 9 /* NumericLiteral */:
    case 210 /* ObjectLiteralExpression */:
    case 169 /* Parameter */:
    case 211 /* PropertyAccessExpression */:
    case 303 /* PropertyAssignment */:
    case 172 /* PropertyDeclaration */:
    case 171 /* PropertySignature */:
    case 178 /* SetAccessor */:
    case 304 /* ShorthandPropertyAssignment */:
    case 312 /* SourceFile */:
    case 305 /* SpreadAssignment */:
    case 11 /* StringLiteral */:
    case 265 /* TypeAliasDeclaration */:
    case 187 /* TypeLiteral */:
    case 168 /* TypeParameter */:
    case 260 /* VariableDeclaration */:
      return true;
    default:
      return false;
  }
}
function canHaveLocals(node) {
  switch (node.kind) {
    case 219 /* ArrowFunction */:
    case 241 /* Block */:
    case 179 /* CallSignature */:
    case 269 /* CaseBlock */:
    case 299 /* CatchClause */:
    case 175 /* ClassStaticBlockDeclaration */:
    case 194 /* ConditionalType */:
    case 176 /* Constructor */:
    case 185 /* ConstructorType */:
    case 180 /* ConstructSignature */:
    case 248 /* ForStatement */:
    case 249 /* ForInStatement */:
    case 250 /* ForOfStatement */:
    case 262 /* FunctionDeclaration */:
    case 218 /* FunctionExpression */:
    case 184 /* FunctionType */:
    case 177 /* GetAccessor */:
    case 181 /* IndexSignature */:
    case 345 /* JSDocCallbackTag */:
    case 347 /* JSDocEnumTag */:
    case 324 /* JSDocFunctionType */:
    case 330 /* JSDocSignature */:
    case 353 /* JSDocTypedefTag */:
    case 200 /* MappedType */:
    case 174 /* MethodDeclaration */:
    case 173 /* MethodSignature */:
    case 267 /* ModuleDeclaration */:
    case 178 /* SetAccessor */:
    case 312 /* SourceFile */:
    case 265 /* TypeAliasDeclaration */:
      return true;
    default:
      return false;
  }
}
function isDeclarationKind(kind) {
  return kind === 219 /* ArrowFunction */ || kind === 208 /* BindingElement */ || kind === 263 /* ClassDeclaration */ || kind === 231 /* ClassExpression */ || kind === 175 /* ClassStaticBlockDeclaration */ || kind === 176 /* Constructor */ || kind === 266 /* EnumDeclaration */ || kind === 306 /* EnumMember */ || kind === 281 /* ExportSpecifier */ || kind === 262 /* FunctionDeclaration */ || kind === 218 /* FunctionExpression */ || kind === 177 /* GetAccessor */ || kind === 273 /* ImportClause */ || kind === 271 /* ImportEqualsDeclaration */ || kind === 276 /* ImportSpecifier */ || kind === 264 /* InterfaceDeclaration */ || kind === 291 /* JsxAttribute */ || kind === 174 /* MethodDeclaration */ || kind === 173 /* MethodSignature */ || kind === 267 /* ModuleDeclaration */ || kind === 270 /* NamespaceExportDeclaration */ || kind === 274 /* NamespaceImport */ || kind === 280 /* NamespaceExport */ || kind === 169 /* Parameter */ || kind === 303 /* PropertyAssignment */ || kind === 172 /* PropertyDeclaration */ || kind === 171 /* PropertySignature */ || kind === 178 /* SetAccessor */ || kind === 304 /* ShorthandPropertyAssignment */ || kind === 265 /* TypeAliasDeclaration */ || kind === 168 /* TypeParameter */ || kind === 260 /* VariableDeclaration */ || kind === 353 /* JSDocTypedefTag */ || kind === 345 /* JSDocCallbackTag */ || kind === 355 /* JSDocPropertyTag */;
}
function isDeclarationStatementKind(kind) {
  return kind === 262 /* FunctionDeclaration */ || kind === 282 /* MissingDeclaration */ || kind === 263 /* ClassDeclaration */ || kind === 264 /* InterfaceDeclaration */ || kind === 265 /* TypeAliasDeclaration */ || kind === 266 /* EnumDeclaration */ || kind === 267 /* ModuleDeclaration */ || kind === 272 /* ImportDeclaration */ || kind === 271 /* ImportEqualsDeclaration */ || kind === 278 /* ExportDeclaration */ || kind === 277 /* ExportAssignment */ || kind === 270 /* NamespaceExportDeclaration */;
}
function isStatementKindButNotDeclarationKind(kind) {
  return kind === 252 /* BreakStatement */ || kind === 251 /* ContinueStatement */ || kind === 259 /* DebuggerStatement */ || kind === 246 /* DoStatement */ || kind === 244 /* ExpressionStatement */ || kind === 242 /* EmptyStatement */ || kind === 249 /* ForInStatement */ || kind === 250 /* ForOfStatement */ || kind === 248 /* ForStatement */ || kind === 245 /* IfStatement */ || kind === 256 /* LabeledStatement */ || kind === 253 /* ReturnStatement */ || kind === 255 /* SwitchStatement */ || kind === 257 /* ThrowStatement */ || kind === 258 /* TryStatement */ || kind === 243 /* VariableStatement */ || kind === 247 /* WhileStatement */ || kind === 254 /* WithStatement */ || kind === 359 /* NotEmittedStatement */;
}
function isDeclaration(node) {
  if (node.kind === 168 /* TypeParameter */) {
    return node.parent && node.parent.kind !== 352 /* JSDocTemplateTag */ || isInJSFile(node);
  }
  return isDeclarationKind(node.kind);
}
function isDeclarationStatement(node) {
  return isDeclarationStatementKind(node.kind);
}
function isStatementButNotDeclaration(node) {
  return isStatementKindButNotDeclarationKind(node.kind);
}
function isStatement(node) {
  const kind = node.kind;
  return isStatementKindButNotDeclarationKind(kind) || isDeclarationStatementKind(kind) || isBlockStatement(node);
}
function isBlockStatement(node) {
  if (node.kind !== 241 /* Block */)
    return false;
  if (node.parent !== void 0) {
    if (node.parent.kind === 258 /* TryStatement */ || node.parent.kind === 299 /* CatchClause */) {
      return false;
    }
  }
  return !isFunctionBlock(node);
}
function isStatementOrBlock(node) {
  const kind = node.kind;
  return isStatementKindButNotDeclarationKind(kind) || isDeclarationStatementKind(kind) || kind === 241 /* Block */;
}
function isModuleReference(node) {
  const kind = node.kind;
  return kind === 283 /* ExternalModuleReference */ || kind === 166 /* QualifiedName */ || kind === 80 /* Identifier */;
}
function isJsxTagNameExpression(node) {
  const kind = node.kind;
  return kind === 110 /* ThisKeyword */ || kind === 80 /* Identifier */ || kind === 211 /* PropertyAccessExpression */ || kind === 295 /* JsxNamespacedName */;
}
function isJsxChild(node) {
  const kind = node.kind;
  return kind === 284 /* JsxElement */ || kind === 294 /* JsxExpression */ || kind === 285 /* JsxSelfClosingElement */ || kind === 12 /* JsxText */ || kind === 288 /* JsxFragment */;
}
function isJsxAttributeLike(node) {
  const kind = node.kind;
  return kind === 291 /* JsxAttribute */ || kind === 293 /* JsxSpreadAttribute */;
}
function isStringLiteralOrJsxExpression(node) {
  const kind = node.kind;
  return kind === 11 /* StringLiteral */ || kind === 294 /* JsxExpression */;
}
function isJsxOpeningLikeElement(node) {
  const kind = node.kind;
  return kind === 286 /* JsxOpeningElement */ || kind === 285 /* JsxSelfClosingElement */;
}
function isCaseOrDefaultClause(node) {
  const kind = node.kind;
  return kind === 296 /* CaseClause */ || kind === 297 /* DefaultClause */;
}
function isJSDocNode(node) {
  return node.kind >= 316 /* FirstJSDocNode */ && node.kind <= 357 /* LastJSDocNode */;
}
function isJSDocTag(node) {
  return node.kind >= 334 /* FirstJSDocTagNode */ && node.kind <= 357 /* LastJSDocTagNode */;
}
function isSetAccessor(node) {
  return node.kind === 178 /* SetAccessor */;
}
function isGetAccessor(node) {
  return node.kind === 177 /* GetAccessor */;
}
function hasJSDocNodes(node) {
  if (!canHaveJSDoc(node))
    return false;
  const { jsDoc } = node;
  return !!jsDoc && jsDoc.length > 0;
}
function hasType(node) {
  return !!node.type;
}
function hasInitializer(node) {
  return !!node.initializer;
}
function hasOnlyExpressionInitializer(node) {
  switch (node.kind) {
    case 260 /* VariableDeclaration */:
    case 169 /* Parameter */:
    case 208 /* BindingElement */:
    case 172 /* PropertyDeclaration */:
    case 303 /* PropertyAssignment */:
    case 306 /* EnumMember */:
      return true;
    default:
      return false;
  }
}
function isTypeReferenceType(node) {
  return node.kind === 183 /* TypeReference */ || node.kind === 233 /* ExpressionWithTypeArguments */;
}
var MAX_SMI_X86 = 1073741823;
function guessIndentation(lines) {
  let indentation = MAX_SMI_X86;
  for (const line of lines) {
    if (!line.length) {
      continue;
    }
    let i = 0;
    for (; i < line.length && i < indentation; i++) {
      if (!isWhiteSpaceLike(line.charCodeAt(i))) {
        break;
      }
    }
    if (i < indentation) {
      indentation = i;
    }
    if (indentation === 0) {
      return 0;
    }
  }
  return indentation === MAX_SMI_X86 ? void 0 : indentation;
}
function isStringLiteralLike(node) {
  return node.kind === 11 /* StringLiteral */ || node.kind === 15 /* NoSubstitutionTemplateLiteral */;
}
function isJSDocLinkLike(node) {
  return node.kind === 331 /* JSDocLink */ || node.kind === 332 /* JSDocLinkCode */ || node.kind === 333 /* JSDocLinkPlain */;
}
function hasRestParameter(s) {
  const last2 = lastOrUndefined(s.parameters);
  return !!last2 && isRestParameter(last2);
}
function isRestParameter(node) {
  const type = isJSDocParameterTag(node) ? node.typeExpression && node.typeExpression.type : node.type;
  return node.dotDotDotToken !== void 0 || !!type && type.kind === 325 /* JSDocVariadicType */;
}
function hasInternalAnnotation(range, sourceFile) {
  const comment = sourceFile.text.substring(range.pos, range.end);
  return comment.includes("@internal");
}
function isInternalDeclaration(node, sourceFile) {
  sourceFile ?? (sourceFile = getSourceFileOfNode(node));
  const parseTreeNode = getParseTreeNode(node);
  if (parseTreeNode && parseTreeNode.kind === 169 /* Parameter */) {
    const paramIdx = parseTreeNode.parent.parameters.indexOf(parseTreeNode);
    const previousSibling = paramIdx > 0 ? parseTreeNode.parent.parameters[paramIdx - 1] : void 0;
    const text = sourceFile.text;
    const commentRanges = previousSibling ? concatenate(
      // to handle
      // ... parameters, /** @internal */
      // public param: string
      getTrailingCommentRanges(text, skipTrivia(
        text,
        previousSibling.end + 1,
        /*stopAfterLineBreak*/
        false,
        /*stopAtComments*/
        true
      )),
      getLeadingCommentRanges(text, node.pos)
    ) : getTrailingCommentRanges(text, skipTrivia(
      text,
      node.pos,
      /*stopAfterLineBreak*/
      false,
      /*stopAtComments*/
      true
    ));
    return some(commentRanges) && hasInternalAnnotation(last(commentRanges), sourceFile);
  }
  const leadingCommentRanges = p