if (aRootUrl) {\n\t      aPathUrl.scheme = aRootUrl.scheme;\n\t    }\n\t    return urlGenerate(aPathUrl);\n\t  }\n\t\n\t  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t    return aPath;\n\t  }\n\t\n\t  // `join('http://', 'www.example.com')`\n\t  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t    aRootUrl.host = aPath;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t\n\t  var joined = aPath.charAt(0) === '/'\n\t    ? aPath\n\t    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t\n\t  if (aRootUrl) {\n\t    aRootUrl.path = joined;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t  return joined;\n\t}\n\texports.join = join;\n\t\n\texports.isAbsolute = function (aPath) {\n\t  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n\t};\n\t\n\t/**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */\n\tfunction relative(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t\n\t  aRoot = aRoot.replace(/\\/$/, '');\n\t\n\t  // It is possible for the path to be above the root. In this case, simply\n\t  // checking whether the root is a prefix of the path won't work. Instead, we\n\t  // need to remove components from the root one by one, until either we find\n\t  // a prefix that fits, or we run out of components to remove.\n\t  var level = 0;\n\t  while (aPath.indexOf(aRoot + '/') !== 0) {\n\t    var index = aRoot.lastIndexOf(\"/\");\n\t    if (index < 0) {\n\t      return aPath;\n\t    }\n\t\n\t    // If the only part of the root that is left is the scheme (i.e. http://,\n\t    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t    // have exhausted all components, so the path is not relative to the root.\n\t    aRoot = aRoot.slice(0, index);\n\t    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t      return aPath;\n\t    }\n\t\n\t    ++level;\n\t  }\n\t\n\t  // Make sure we add a \"../\" for each component we removed from the root.\n\t  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t}\n\texports.relative = relative;\n\t\n\tvar supportsNullProto = (function () {\n\t  var obj = Object.create(null);\n\t  return !('__proto__' in obj);\n\t}());\n\t\n\tfunction identity (s) {\n\t  return s;\n\t}\n\t\n\t/**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */\n\tfunction toSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return '$' + aStr;\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.toSetString = supportsNullProto ? identity : toSetString;\n\t\n\tfunction fromSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return aStr.slice(1);\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.fromSetString = supportsNullProto ? identity : fromSetString;\n\t\n\tfunction isProtoString(s) {\n\t  if (!s) {\n\t    return false;\n\t  }\n\t\n\t  var length = s.length;\n\t\n\t  if (length < 9 /* \"__proto__\".length */) {\n\t    return false;\n\t  }\n\t\n\t  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n\t      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n\t      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n\t      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n\t    return false;\n\t  }\n\t\n\t  for (var i = length - 10; i >= 0; i--) {\n\t    if (s.charCodeAt(i) !== 36 /* '$' */) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */\n\tfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t  var cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0 || onlyCompareOriginal) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByOriginalPositions = compareByOriginalPositions;\n\t\n\t/**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */\n\tfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0 || onlyCompareGenerated) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\t\n\tfunction strcmp(aStr1, aStr2) {\n\t  if (aStr1 === aStr2) {\n\t    return 0;\n\t  }\n\t\n\t  if (aStr1 === null) {\n\t    return 1; // aStr2 !== null\n\t  }\n\t\n\t  if (aStr2 === null) {\n\t    return -1; // aStr1 !== null\n\t  }\n\t\n\t  if (aStr1 > aStr2) {\n\t    return 1;\n\t  }\n\t\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */\n\tfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\t\n\t/**\n\t * Strip any JSON XSSI avoidance prefix from the string (as documented\n\t * in the source maps specification), and then parse the string as\n\t * JSON.\n\t */\n\tfunction parseSourceMapInput(str) {\n\t  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n\t}\n\texports.parseSourceMapInput = parseSourceMapInput;\n\t\n\t/**\n\t * Compute the URL of a source given the the source root, the source's\n\t * URL, and the source map's URL.\n\t */\n\tfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n\t  sourceURL = sourceURL || '';\n\t\n\t  if (sourceRoot) {\n\t    // This follows what Chrome does.\n\t    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n\t      sourceRoot += '/';\n\t    }\n\t    // The spec says:\n\t    //   Line 4: An optional source root, useful for relocating source\n\t    //   files on a server or removing repeated values in the\n\t    //   “sources” entry.  This value is prepended to the individual\n\t    //   entries in the “source” field.\n\t    sourceURL = sourceRoot + sourceURL;\n\t  }\n\t\n\t  // Historically, SourceMapConsumer did not take the sourceMapURL as\n\t  // a parameter.  This mode is still somewhat supported, which is why\n\t  // this code block is conditional.  However, it's preferable to pass\n\t  // the source map URL to SourceMapConsumer, so that this function\n\t  // can implement the source URL resolution algorithm as outlined in\n\t  // the spec.  This block is basically the equivalent of:\n\t  //    new URL(sourceURL, sourceMapURL).toString()\n\t  // ... except it avoids using URL, which wasn't available in the\n\t  // older releases of node still supported by this library.\n\t  //\n\t  // The spec says:\n\t  //   If the sources are not absolute URLs after prepending of the\n\t  //   “sourceRoot”, the sources are resolved relative to the\n\t  //   SourceMap (like resolving script src in a html document).\n\t  if (sourceMapURL) {\n\t    var parsed = urlParse(sourceMapURL);\n\t    if (!parsed) {\n\t      throw new Error(\"sourceMapURL could not be parsed\");\n\t    }\n\t    if (parsed.path) {\n\t      // Strip the last path component, but keep the \"/\".\n\t      var index = parsed.path.lastIndexOf('/');\n\t      if (index >= 0) {\n\t        parsed.path = parsed.path.substring(0, index + 1);\n\t      }\n\t    }\n\t    sourceURL = join(urlGenerate(parsed), sourceURL);\n\t  }\n\t\n\t  return normalize(sourceURL);\n\t}\n\texports.computeSourceURL = computeSourceURL;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(4);\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar hasNativeMap = typeof Map !== \"undefined\";\n\t\n\t/**\n\t * A data structure which is a combination of an array and a set. Adding a new\n\t * member is O(1), testing for membership is O(1), and finding the index of an\n\t * element is O(1). Removing elements from the set is not supported. Only\n\t * strings are supported for membership.\n\t */\n\tfunction ArraySet() {\n\t  this._array = [];\n\t  this._set = hasNativeMap ? new Map() : Object.create(null);\n\t}\n\t\n\t/**\n\t * Static method for creating ArraySet instances from an existing array.\n\t */\n\tArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t  var set = new ArraySet();\n\t  for (var i = 0, len = aArray.length; i < len; i++) {\n\t    set.add(aArray[i], aAllowDuplicates);\n\t  }\n\t  return set;\n\t};\n\t\n\t/**\n\t * Return how many unique items are in this ArraySet. If duplicates have been\n\t * added, than those do not count towards the size.\n\t *\n\t * @returns Number\n\t */\n\tArraySet.prototype.size = function ArraySet_size() {\n\t  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n\t};\n\t\n\t/**\n\t * Add the given string to this set.\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n\t  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n\t  var idx = this._array.length;\n\t  if (!isDuplicate || aAllowDuplicates) {\n\t    this._array.push(aStr);\n\t  }\n\t  if (!isDuplicate) {\n\t    if (hasNativeMap) {\n\t      this._set.set(aStr, idx);\n\t    } else {\n\t      this._set[sStr] = idx;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Is the given string a member of this set?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.has = function ArraySet_has(aStr) {\n\t  if (hasNativeMap) {\n\t    return this._set.has(aStr);\n\t  } else {\n\t    var sStr = util.toSetString(aStr);\n\t    return has.call(this._set, sStr);\n\t  }\n\t};\n\t\n\t/**\n\t * What is the index of the given string in the array?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t  if (hasNativeMap) {\n\t    var idx = this._set.get(aStr);\n\t    if (idx >= 0) {\n\t        return idx;\n\t    }\n\t  } else {\n\t    var sStr = util.toSetString(aStr);\n\t    if (has.call(this._set, sStr)) {\n\t      return this._set[sStr];\n\t    }\n\t  }\n\t\n\t  throw new Error('\"' + aStr + '\" is not in the set.');\n\t};\n\t\n\t/**\n\t * What is the element at the given index?\n\t *\n\t * @param Number aIdx\n\t */\n\tArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t  if (aIdx >= 0 && aIdx < this._array.length) {\n\t    return this._array[aIdx];\n\t  }\n\t  throw new Error('No element indexed by ' + aIdx);\n\t};\n\t\n\t/**\n\t * Returns the array representation of this set (which has the proper indices\n\t * indicated by indexOf). Note that this is a copy of the internal array used\n\t * for storing the members so that no one can mess with internal state.\n\t */\n\tArraySet.prototype.toArray = function ArraySet_toArray() {\n\t  return this._array.slice();\n\t};\n\t\n\texports.ArraySet = ArraySet;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2014 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(4);\n\t\n\t/**\n\t * Determine whether mappingB is after mappingA with respect to generated\n\t * position.\n\t */\n\tfunction generatedPositionAfter(mappingA, mappingB) {\n\t  // Optimized for most common case\n\t  var lineA = mappingA.generatedLine;\n\t  var lineB = mappingB.generatedLine;\n\t  var columnA = mappingA.generatedColumn;\n\t  var columnB = mappingB.generatedColumn;\n\t  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n\t         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n\t}\n\t\n\t/**\n\t * A data structure to provide a sorted view of accumulated mappings in a\n\t * performance conscious manner. It trades a neglibable overhead in general\n\t * case for a large speedup in case of mappings being added in order.\n\t */\n\tfunction MappingList() {\n\t  this._array = [];\n\t  this._sorted = true;\n\t  // Serves as infimum\n\t  this._last = {generatedLine: -1, generatedColumn: 0};\n\t}\n\t\n\t/**\n\t * Iterate through internal items. This method takes the same arguments that\n\t * `Array.prototype.forEach` takes.\n\t *\n\t * NOTE: The order of the mappings is NOT guaranteed.\n\t */\n\tMappingList.prototype.unsortedForEach =\n\t  function MappingList_forEach(aCallback, aThisArg) {\n\t    this._array.forEach(aCallback, aThisArg);\n\t  };\n\t\n\t/**\n\t * Add the given source mapping.\n\t *\n\t * @param Object aMapping\n\t */\n\tMappingList.prototype.add = function MappingList_add(aMapping) {\n\t  if (generatedPositionAfter(this._last, aMapping)) {\n\t    this._last = aMapping;\n\t    this._array.push(aMapping);\n\t  } else {\n\t    this._sorted = false;\n\t    this._array.push(aMapping);\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the flat, sorted array of mappings. The mappings are sorted by\n\t * generated position.\n\t *\n\t * WARNING: This method returns internal data without copying, for\n\t * performance. The return value must NOT be mutated, and should be treated as\n\t * an immutable borrow. If you want to take ownership, you must make your own\n\t * copy.\n\t */\n\tMappingList.prototype.toArray = function MappingList_toArray() {\n\t  if (!this._sorted) {\n\t    this._array.sort(util.compareByGeneratedPositionsInflated);\n\t    this._sorted = true;\n\t  }\n\t  return this._array;\n\t};\n\t\n\texports.MappingList = MappingList;
      return false;

    case tt.braceL:
      parseObj(false, false);
      return false;

    case tt._function:
      parseFunctionExpression();
      return false;

    case tt.at:
      parseDecorators();
    // Fall through.

    case tt._class:
      parseClass(false);
      return false;

    case tt._new:
      parseNew();
      return false;

    case tt.backQuote:
      parseTemplate();
      return false;

    case tt.doubleColon: {
      next();
      parseNoCallExpr();
      return false;
    }

    case tt.hash: {
      const code = lookaheadCharCode();
      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {
        parseMaybePrivateName();
      } else {
        next();
      }
      // Smart pipeline topic reference.
      return false;
    }

    default:
      unexpected();
      return false;
  }
}

function parseMaybePrivateName() {
  eat(tt.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  const functionStart = state.start;
  parseIdentifier();
  if (eat(tt.dot)) {
    // function.sent
    parseIdentifier();
  }
  parseFunction(functionStart, false);
}

export function parseLiteral() {
  next();
}

export function parseParenExpression() {
  expect(tt.parenL);
  parseExpression();
  expect(tt.parenR);
}

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = state.snapshot();

  const startTokenIndex = state.tokens.length;
  expect(tt.parenL);

  let first = true;

  while (!match(tt.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(tt.comma);
      if (match(tt.parenR)) {
        break;
      }
    }

    if (match(tt.ellipsis)) {
      parseRest(false /* isBlockScope */);
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }

  expect(tt.parenR);

  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      state.restoreFromSnapshot(snapshot);
      state.scopeDepth++;
      // Don't specify a context ID because arrow functions don't need a context ID.
      parseFunctionParams();
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }

  return false;
}

function shouldParseArrow() {
  return match(tt.colon) || !canInsertSemicolon();
}

// Returns whether there was an arrow token.
export function parseArrow() {
  if (isTypeScriptEnabled) {
    return tsParseArrow();
  } else if (isFlowEnabled) {
    return flowParseArrow();
  } else {
    return eat(tt.arrow);
  }
}

function parseParenItem() {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseParenItem();
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  expect(tt._new);
  if (eat(tt.dot)) {
    // new.target
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (isFlowEnabled) {
    flowStartParseNewArguments();
  }
  if (eat(tt.parenL)) {
    parseExprList(tt.parenR);
  }
}

function parseNewCallee() {
  parseNoCallExpr();
  eat(tt.questionDot);
}

export function parseTemplate() {
  // Finish `, read quasi
  nextTemplateToken();
  // Finish quasi, read ${
  nextTemplateToken();
  while (!match(tt.backQuote) && !state.error) {
    expect(tt.dollarBraceL);
    parseExpression();
    // Finish }, read quasi
    nextTemplateToken();
    // Finish quasi, read either ${ or `
    nextTemplateToken();
  }
  next();
}

// Parse an object literal or binding pattern.
export function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  const contextId = getNextContextId();
  let first = true;

  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;

  while (!eat(tt.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(tt.comma);
      if (eat(tt.braceR)) {
        break;
      }
    }

    let isGenerator = false;
    if (match(tt.ellipsis)) {
      const previousIndex = state.tokens.length;
      parseSpread();
      if (isPattern) {
        // Mark role when the only thing being spread over is an identifier.
        if (state.tokens.length === previousIndex + 2) {
          markPriorBindingIdentifier(isBlockScope);
        }
        if (eat(tt.braceR)) {
          break;
        }
      }
      continue;
    }

    if (!isPattern) {
      isGenerator = eat(tt.star);
    }

    if (!isPattern && isContextual(ContextualKeyword._async)) {
      if (isGenerator) unexpected();

      parseIdentifier();
      if (
        match(tt.colon) ||
        match(tt.parenL) ||
        match(tt.braceR) ||
        match(tt.eq) ||
        match(tt.comma)
      ) {
        // This is a key called "async" rather than an async function.
      } else {
        if (match(tt.star)) {
          next();
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }

    parseObjPropValue(isPattern, isBlockScope, contextId);
  }

  state.tokens[state.tokens.length - 1].contextId = contextId;
}

function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return (
    !isPattern &&
    (match(tt.string) || // get "string"() {}
      match(tt.num) || // get 1() {}
      match(tt.bracketL) || // get ["string"]() {}
      match(tt.name) || // get foo() {}
      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}
  );
}

// Returns true if this was a method.
function parseObjectMethod(isPattern, objectContextId) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  const functionStart = state.start;
  if (match(tt.parenL)) {
    if (isPattern) unexpected();
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }

  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }
  return false;
}

function parseObjectProperty(isPattern, isBlockScope) {
  if (eat(tt.colon)) {
    if (isPattern) {
      parseMaybeDefault(isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }

  // Since there's no colon, we assume this is an object shorthand.

  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as a normal object shorthand.
  let identifierRole;
  if (isPattern) {
    if (state.scopeDepth === 0) {
      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = IdentifierRole.ObjectShorthand