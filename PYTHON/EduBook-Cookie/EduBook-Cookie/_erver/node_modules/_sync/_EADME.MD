eConstraint(type2);
          if (baseType) {
            if (baseType !== type2) {
              different = true;
            }
            baseTypes.push(baseType);
          } else {
            different = true;
          }
        }
        if (!different) {
          return t;
        }
        return t.flags & 1048576 /* Union */ && baseTypes.length === types.length ? getUnionType(baseTypes) : t.flags & 2097152 /* Intersection */ && baseTypes.length ? getIntersectionType(baseTypes) : void 0;
      }
      if (t.flags & 4194304 /* Index */) {
        return keyofConstraintType;
      }
      if (t.flags & 134217728 /* TemplateLiteral */) {
        const types = t.types;
        const constraints = mapDefined(types, getBaseConstraint);
        return constraints.length === types.length ? getTemplateLiteralType(t.texts, constraints) : stringType;
      }
      if (t.flags & 268435456 /* StringMapping */) {
        const constraint = getBaseConstraint(t.type);
        return constraint && constraint !== t.type ? getStringMappingType(t.symbol, constraint) : stringType;
      }
      if (t.flags & 8388608 /* IndexedAccess */) {
        if (isMappedTypeGenericIndexedAccess(t)) {
          return getBaseConstraint(substituteIndexedMappedType(t.objectType, t.indexType));
        }
        const baseObjectType = getBaseConstraint(t.objectType);
        const baseIndexType = getBaseConstraint(t.indexType);
        const baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, t.accessFlags);
        return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
      }
      if (t.flags & 16777216 /* Conditional */) {
        const constraint = getConstraintFromConditionalType(t);
        return constraint && getBaseConstraint(constraint);
      }
      if (t.flags & 33554432 /* Substitution */) {
        return getBaseConstraint(getSubstitutionIntersection(t));
      }
      if (isGenericTupleType(t)) {
        const newElements = map(getElementTypes(t), (v, i) => {
          const constraint = v.flags & 262144 /* TypeParameter */ && t.target.elementFlags[i] & 8 /* Variadic */ && getBaseConstraint(v) || v;
          return constraint !== v && everyType(constraint, (c) => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v;
        });
        return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations);
      }
      return t;
    }
  }
  function getApparentTypeOfIntersectionType(type, thisArgument) {
    return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(
      type,
      thisArgument,
      /*needApparentType*/
      true
    ));
  }
  function getResolvedTypeParameterDefault(typeParameter) {
    if (!typeParameter.default) {
      if (typeParameter.target) {
        const targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
        typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
      } else {
        typeParameter.default = resolvingDefaultType;
        const defaultDeclaration = typeParameter.symbol && forEach(typeParameter.symbol.declarations, (decl) => isTypeParameterDeclaration(decl) && decl.default);
        const defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
        if (typeParameter.default === resolvingDefaultType) {
          typeParameter.default = defaultType;
        }
      }
    } else if (typeParameter.default === resolvingDefaultType) {
      typeParameter.default = circularConstraintType;
    }
    return typeParameter.default;
  }
  function getDefaultFromTypeParameter(typeParameter) {
    const defaultType = getResolvedTypeParameterDefault(typeParameter);
    return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : void 0;
  }
  function hasNonCircularTypeParameterDefault(typeParameter) {
    return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
  }
  function hasTypeParameterDefault(typeParameter) {
    return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, (decl) => isTypeParameterDeclaration(decl) && decl.default));
  }
  function getApparentTypeOfMappedType(type) {
    return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
  }
  function getResolvedApparentTypeOfMappedType(type) {
    const target = type.target ?? type;
    const typeVariable = getHomomorphicTypeVariable(target);
    if (typeVariable && !target.declaration.nameType) {
      const constraint = getConstraintTypeFromMappedType(type);
      if (constraint.flags & 4194304 /* Index */) {
        const baseConstraint = getBaseConstraintOfType(constraint.type);
        if (baseConstraint && everyType(baseConstraint, isArrayOrTupleType)) {
          return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type.mapper));
        }
      }
    }
    return type;
  }
  function isMappedTypeGenericIndexedAccess(type) {
    let objectType;
    return !!(type.flags & 8388608 /* IndexedAccess */ && getObjectFlags(objectType = type.objectType) & 32 /* Mapped */ && !isGenericMappedType(objectType) && isGenericIndexType(type.indexType) && !(getMappedTypeModifiers(objectType) & 8 /* ExcludeOptional */) && !objectType.declaration.nameType);
  }
  function getApparentType(type) {
    const t = type.flags & 465829888 /* Instantiable */ ? getBaseConstraintOfType(type) || unknownType : type;
    const objectFlags = getObjectFlags(t);
    return objectFlags & 32 /* Mapped */ ? getApparentTypeOfMappedType(t) : objectFlags & 4 /* Reference */ && t !== type ? getTypeWithThisArgument(t, type) : t.flags & 2097152 /* Intersection */ ? getApparentTypeOfIntersectionType(t, type) : t.flags & 402653316 /* StringLike */ ? globalStringType : t.flags & 296 /* NumberLike */ ? globalNumberType : t.flags & 2112 /* BigIntLike */ ? getGlobalBigIntType() : t.flags & 528 /* BooleanLike */ ? globalBooleanType : t.flags & 12288 /* ESSymbolLike */ ? getGlobalESSymbolType() : t.flags & 67108864 /* NonPrimitive */ ? emptyObjectType : t.flags & 4194304 /* Index */ ? keyofConstraintType : t.flags & 2 /* Unknown */ && !strictNullChecks ? emptyObjectType : t;
  }
  function getReducedApparentType(type) {
    return getReducedType(getApparentType(getReducedType(type)));
  }
  function createUnionOrIntersectionProperty(containingType, name, skipObjectFunctionPropertyAugment) {
    var _a, _b, _c;
    let singleProp;
    let propSet;
    let indexTypes;
    const isUnion = containingType.flags & 1048576 /* Union */;
    let optionalFlag;
    let syntheticFlag = 4 /* SyntheticMethod */;
    let checkFlags = isUnion ? 0 : 8 /* Readonly */;
    let mergedInstantiations = false;
    for (const current of containingType.types) {
      const type = getApparentType(current);
      if (!(isErrorType(type) || type.flags & 131072 /* Never */)) {
        const prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
        const modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;
        if (prop) {
          if (prop.flags & 106500 /* ClassMember */) {
            optionalFlag ?? (optionalFlag = isUnion ? 0 /* None */ : 16777216 /* Optional */);
            if (isUnion) {
              optionalFlag |= prop.flags & 16777216 /* Optional */;
            } else {
              optionalFlag &= prop.flags;
            }
          }
          if (!singleProp) {
            singleProp = prop;
          } else if (prop !== singleProp) {
            const isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
            if (isInstantiation && compareProperties2(singleProp, prop, (a, b) => a === b ? -1 /* True */ : 0 /* False */) === -1 /* True */) {
              mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
            } else {
              if (!propSet) {
                propSet = /* @__PURE__ */ new Map();
                propSet.set(getSymbolId(singleProp), singleProp);
              }
              const id = getSymbolId(prop);
              if (!propSet.has(id)) {
                propSet.set(id, prop);
              }
            }
          }
          if (isUnion && isReadonlySymbol(prop)) {
            checkFlags |= 8 /* Readonly */;
          } else if (!isUnion && !isReadonlySymbol(prop)) {
            checkFlags &= ~8 /* Readonly */;
          }
          checkFlags |= (!(modifiers & 6 /* NonPublicAccessibilityModifier */) ? 256 /* ContainsPublic */ : 0) | (modifiers & 4 /* Protected */ ? 512 /* ContainsProtected */ : 0) | (modifiers & 2 /* Private */ ? 1024 /* ContainsPrivate */ : 0) | (modifiers & 256 /* Static */ ? 2048 /* ContainsStatic */ : 0);
          if (!isPrototypeProperty(prop)) {
            syntheticFlag = 2 /* SyntheticProperty */;
          }
        } else if (isUnion) {
          const indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
          if (indexInfo) {
            checkFlags |= 32 /* WritePartial */ | (indexInfo.isReadonly ? 8 /* Readonly */ : 0);
            indexTypes = append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
          } else if (isObjectLiteralType2(type) && !(getObjectFlags(type) & 2097152 /* ContainsSpread */)) {
            checkFlags |= 32 /* WritePartial */;
            indexTypes = append(indexTypes, undefinedType);
          } else {
            checkFlags |= 16 /* ReadPartial */;
          }
        }
      }
    }
    if (!singleProp || isUnion && (propSet || checkFlags & 48 /* Partial */) && checkFlags & (1024 /* ContainsPrivate */ | 512 /* ContainsProtected */) && !(propSet && getCommonDeclarationsOfSymbols(propSet.values()))) {
      return void 0;
    }
    if (!propSet && !(checkFlags & 16 /* ReadPartial */) && !indexTypes) {
      if (mergedInstantiations) {
        const links = (_a = tryCast(singleProp, isTransientSymbol)) == null ? void 0 : _a.links;
        const clone2 = createSymbolWithType(singleProp, links == null ? void 0 : links.type);
        clone2.parent = (_c = (_b = singleProp.valueDeclaration) == null ? void 0 : _b.symbol) == null ? void 0 : _c.parent;
        clone2.links.containingType = containingType;
        clone2.links.mapper = links == null ? void 0 : links.mapper;
        clone2.links.writeType = getWriteTypeOfSymbol(singleProp);
        return clone2;
      } else {
        return singleProp;
      }
    }
    const props = propSet ? arrayFrom(propSet.values()) : [singleProp];
    let declarations;
    let firstType;
    let nameType;
    const propTypes = [];
    let writeTypes;
    let firstValueDeclaration;
    let hasNonUniformValueDeclaration = false;
    for (const prop of props) {
      if (!firstValueDeclaration) {
        firstValueDeclaration = prop.valueDeclaration;
      } else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
        hasNonUniformValueDeclaration = true;
      }
      declarations = addRange(declarations, prop.declarations);
      const type = getTypeOfSymbol(prop);
      if (!firstType) {
        firstType = type;
        nameType = getSymbolLinks(prop).nameType;
      }
      const writeType = getWriteTypeOfSymbol(prop);
      if (writeTypes || writeType !== type) {
        writeTypes = append(!writeTypes ? propTypes.slice() : writeTypes, writeType);
      }
      if (type !== firstType) {
        checkFlags |= 64 /* HasNonUniformType */;
      }
      if (isLiteralType(type) || isPatternLiteralType(type)) {
        checkFlags |= 128 /* HasLiteralType */;
      }
      if (type.flags & 131072 /* Never */ && type !== uniqueLiteralType) {
        checkFlags |= 131072 /* HasNeverType */;
      }
      propTypes.push(type);
    }
    addRange(propTypes, indexTypes);
    const result = createSymbol(4 /* Property */ | (optionalFlag ?? 0), name, syntheticFlag | checkFlags);
    result.links.containingType = containingType;
    if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
      result.valueDeclaration = firstValueDeclaration;
      if (firstValueDeclaration.symbol.parent) {
        result.parent = firstValueDeclaration.symbol.parent;
      }
    }
    result.declarations = declarations;
    result.links.nameType = nameType;
    if (propTypes.length > 2) {
      result.links.checkFlags |= 65536 /* DeferredType */;
      result.links.deferralParent = containingType;
      result.links.deferralConstituents = propTypes;
      result.links.deferralWriteConstituents = writeTypes;
    } else {
      result.links.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
      if (writeTypes) {
        result.links.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes);
      }
    }
    return result;
  }
  function getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment) {
    var _a, _b, _c;
    let property = ((_a = type.propertyCacheWithoutObjectFunctionPropertyAugment) == null ? void 0 : _a.get(name)) || !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) == null ? void 0 : _b.get(name) : void 0;
    if (!property) {
      property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
      if (property) {
        const properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = createSymbolTable()) : type.propertyCache || (type.propertyCache = createSymbolTable());
        properties.set(name, property);
        if (skipObjectFunctionPropertyAugment && !((_c = type.propertyCache) == null ? void 0 : _c.get(name))) {
          const properties2 = type.propertyCache || (type.propertyCache = createSymbolTable());
          properties2.set(name, property);
        }
      }
    }
    return property;
  }
  function getCommonDeclarationsOfSymbols(symbols) {
    let commonDeclarations;
    for (const symbol of symbols) {
      if (!symbol.declarations) {
        return void 0;
      }
      if (!commonDeclarations) {
        commonDeclarations = new Set(symbol.declarations);
        continue;
      }
      commonDeclarations.forEach((declaration) => {
        if (!contains(symbol.declarations, declaration)) {
          commonDeclarations.delete(declaration);
        }
      });
      if (commonDeclarations.size === 0) {
        return void 0;
      }
    }
    return commonDeclarations;
  }
  function getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment) {
    const property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
    return property && !(getCheckFlags(property) & 16 /* ReadPartial */) ? property : void 0;
  }
  function getReducedType(type) {
    if (type.flags & 1048576 /* Union */ && type.objectFlags & 16777216 /* ContainsIntersections */) {
      return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(type));
    } else if (type.flags & 2097152 /* Intersection */) {
      if (!(type.objectFlags & 16777216 /* IsNeverIntersectionComputed */)) {
        type.objectFlags |= 16777216 /* IsNeverIntersectionComputed */ | (some(getPropertiesOfUnionOrIntersectionType(type), isNeverReducedProperty) ? 33554432 /* IsNeverIntersection */ : 0);
      }
      return type.objectFlags & 33554432 /* IsNeverIntersection */ ? neverType : type;
    }
    return type;
  }
  function getReducedUnionType(unionType) {
    const reducedTypes = sameMap(unionType.types, getReducedType);
    if (reducedTypes === unionType.types) {
      return unionType;
    }
    const reduced = getUnionType(reducedTypes);
    if (reduced.flags & 1048576 /* Union */) {
      reduced.resolvedReducedType = reduced;
    }
    return reduced;
  }
  function isNeverReducedProperty(prop) {
    return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
  }
  function isDiscriminantWithNeverType(prop) {
    return !(prop.flags & 16777216 /* Optional */) && (getCheckFlags(prop) & (192 /* Discriminant */ | 131072 /* HasNeverType */)) === 192 /* Discriminant */ && !!(getTypeOfSymbol(prop).flags & 131072 /* Never */);
  }
  function isConflictingPrivateProperty(prop) {
    return !prop.valueDeclaration && !!(getCheckFlags(prop) & 1024 /* ContainsPrivate */);
  }
  function isGenericReducibleType(type) {
    return !!(type.flags & 1048576 /* Union */ && type.objectFlags & 16777216 /* ContainsIntersections */ && some(type.types, isGenericReducibleType) || type.flags & 2097152 /* Intersection */ && isReducibleIntersection(type));
  }
  function isReducibleIntersection(type) {
    const uniqueFilled = type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper));
    return getReducedType(uniqueFilled) !== uniqueFilled;
  }
  function elaborateNeverIntersection(errorInfo, type) {
    if (type.flags & 2097152 /* Intersection */ && getObjectFlags(type) & 33554432 /* IsNeverIntersection */) {
      const neverProp = find(getPropertiesOfUnionOrIntersectionType(type), isDiscriminantWithNeverType);
      if (neverProp) {
        return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(
          type,
          /*enclosingDeclaration*/
          void 0,
          536870912 /* NoTypeReduction */
        ), symbolToString(neverProp));
      }
      const privateProp = find(getPropertiesOfUnionOrIntersectionType(type), isConflictingPrivateProperty);
      if (privateProp) {
        return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(
          type,
          /*enclosingDeclaration*/
          void 0,
          536870912 /* NoTypeReduction */
        ), symbolToString(privateProp));
      }
    }
    return errorInfo;
  }
  function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment, includeTypeOnlyMembers) {
    var _a, _b;
    type = getReducedApparentType(type);
    if (type.flags & 524288 /* Object */) {
      const resolved = resolveStructuredTypeMembers(type);
      const symbol = resolved.members.get(name);
      if (symbol && !includeTypeOnlyMembers && ((_a = type.symbol) == null ? void 0 : _a.flags) & 512 /* ValueModule */ && ((_b = getSymbolLinks(type.symbol).typeOnlyExportStarMap) == null ? void 0 : _b.has(name))) {
        return void 0;
      }
      if (symbol && symbolIsValue(symbol, includeTypeOnlyMembers)) {
        return symbol;
      }
      if (skipObjectFunctionPropertyAugment)
        return void 0;
      const functionType = resolved === anyFunctionType ? globalFunctionType : resolved.callSignatures.length ? globalCallableFunctionType : resolved.constructSignatures.length ? globalNewableFunctionType : void 0;
      if (functionType) {
        const symbol2 = getPropertyOfObjectType(functionType, name);
        if (symbol2) {
          return symbol2;
        }
      }
      return getPropertyOfObjectType(globalObjectType, name);
    }
    if (type.flags & 2097152 /* Intersection */) {
      const prop = getPropertyOfUnionOrIntersectionType(
        type,
        name,
        /*skipObjectFunctionPropertyAugment*/
        true
      );
      if (prop) {
        return prop;
      }
      if (!skipObjectFunctionPropertyAugment) {
        return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
      }
      return void 0;
    }
    if (type.flags & 1048576 /* Union */) {
      return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
    }
    return void 0;
  }
  function getSignaturesOfStructuredType(type, kind) {
    if (type.flags & 3670016 /* StructuredType */) {
      const resolved = resolveStructuredTypeMembers(type);
      return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;
    }
    return emptyArray;
  }
  function getSignaturesOfType(type, kind) {
    const result = getSignaturesOfStructuredType(getReducedApparentType(type), kind);
    if (kind === 0 /* Call */ && !length(result) && type.flags & 1048576 /* Union */) {
      if (type.arrayFallbackSignatures) {
        return type.arrayFallbackSignatures;
      }
      let memberName;
      if (everyType(type, (t) => {
        var _a;
        return !!((_a = t.symbol) == null ? void 0 : _a.parent) && isArrayOrTupleSymbol(t.symbol.parent) && (!memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName);
      })) {
        const arrayArg = mapType(type, (t) => getMappedType((isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters[0], t.mapper));
        const arrayType = createArrayType(arrayArg, someType(type, (t) => isReadonlyArraySymbol(t.symbol.parent)));
        return type.arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName), kind);
      }
      type.arrayFallbackSignatures = result;
    }
    return result;
  }
  function isArrayOrTupleSymbol(symbol) {
    if (!symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol) {
      return false;
    }
    return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol);
  }
  function isReadonlyArraySymbol(symbol) {
    if (!symbol || !globalReadonlyArrayType.symbol) {
      return false;
    }
    return !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol);
  }
  function findIndexInfo(indexInfos, keyType) {
    return find(indexInfos, (info) => info.keyType === keyType);
  }
  function findApplicableIndexInfo(indexInfos, keyType) {
    let stringIndexInfo;
    let applicableInfo;
    let applicableInfos;
    for (const info of indexInfos) {
      if (info.keyType === stringType) {
        stringIndexInfo = info;
      } else if (isApplicableIndexType(keyType, info.keyType)) {
        if (!applicableInfo) {
          applicableInfo = info;
        } else {
          (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
        }
      }
    }
    return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, (info) => info.type)), reduceLeft(
      applicableInfos,
      (isReadonly, info) => isReadonly && info.isReadonly,
      /*initial*/
      true
    )) : applicableInfo ? applicableInfo : stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo : void 0;
  }
  function isApplicableIndexType(source, target) {
    return isTypeAssignableTo(source, target) || target === stringType && isTypeAssignableTo(source, numberType) || target === numberType && (source === numericStringType || !!(source.flags & 128 /* StringLiteral */) && isNumericLiteralName(source.value));
  }
  function getIndexInfosOfStructuredType(type) {
    if (type.flags & 3670016 /* StructuredType */) {
      const resolved = resolveStructuredTypeMembers(type);
      return resolved.indexInfos;
    }
    return emptyArray;
  }
  function getIndexInfosOfType(type) {
    return getIndexInfosOfStructuredType(getReducedApparentType(type));
  }
  function getIndexInfoOfType(type, keyType) {
    return findIndexInfo(getIndexInfosOfType(type), keyType);
  }
  function getIndexTypeOfType(type, keyType) {
    var _a;
    return (_a = getIndexInfoOfType(type, keyType)) == null ? void 0 : _a.type;
  }
  function getApplicableIndexInfos(type, keyType) {
    return getIndexInfosOfType(type).filter((info) => isApplicableIndexType(keyType, info.keyType));
  }
  function getApplicableIndexInfo(type, keyType) {
    return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
  }
  function getApplicableIndexInfoForName(type, name) {
    return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)));
  }
  function getTypeParametersFromDeclaration(declaration) {
    var _a;
    let result;
    for (const node of getEffectiveTypeParameterDeclarations(declaration)) {
      result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
    }
    return (result == null ? void 0 : result.length) ? result : isFunctionDeclaration(declaration) ? (_a = getSignatureOfTypeTag(declaration)) == null ? void 0 : _a.typeParameters : void 0;
  }
  function symbolsToArray(symbols) {
    const result = [];
    symbols.forEach((symbol, id) => {
      if (!isReservedMemberName(id)) {
        result.push(symbol);
      }
    });
    return result;
  }
  function tryFindAmbientModule(moduleName, withAugmentations) {
    if (isExternalModuleNameRelative(moduleName)) {
      return void 0;
    }
    const symbol = getSymbol2(globals, '"' + moduleName + '"', 512 /* ValueModule */);
    return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
  }
  function isOptionalParameter(node) {
    if (hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(node)) {
      return true;
    }
    if (node.initializer) {
      const signature = getSignatureFromDeclaration(node.parent);
      const parameterIndex = node.parent.parameters.indexOf(node);
      Debug.assert(parameterIndex >= 0);
      return parameterIndex >= getMinArgumentCount(signature, 1 /* StrongArityForUntypedJS */ | 2 /* VoidIsNonOptional */);
    }
    const iife = getImmediatelyInvokedFunctionExpression(node.parent);
    if (iife) {
      return !node.type && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length;
    }
    return false;
  }
  function isOptionalPropertyDeclaration(node) {
    return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken;
  }
  function createTypePredicate(kind, parameterName, parameterIndex, type) {
    return { kind, parameterName, parameterIndex, type };
  }
  function getMinTypeArgumentCount(typeParameters) {
    let minTypeArgumentCount = 0;
    if (typeParameters) {
      for (let i = 0; i < typeParameters.length; i++) {
        if (!hasTypeParameterDefault(typeParameters[i])) {
          minTypeArgumentCount = i + 1;
        }
      }
    }
    return minTypeArgumentCount;
  }
  function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScriptImplicitAny) {
    const numTypeParameters = length(typeParameters);
    if (!numTypeParameters) {
      return [];
    }
    const numTypeArguments = length(typeArguments);
    if (isJavaScriptImplicitAny || numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
      const result = typeArguments ? typeArguments.slice() : [];
      for (let i = numTypeArguments; i < numTypeParameters; i++) {
        result[i] = errorType;
      }
      const baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
      for (let i = numTypeArguments; i < numTypeParameters; i++) {
        let defaultType = getDefaultFromTypeParameter(typeParameters[i]);
        if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
          defaultType = anyType;
        }
        result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters, result)) : baseDefaultType;
      }
      result.length = typeParameters.length;
      return result;
    }
    return typeArguments && typeArguments.slice();
  }
  function getSignatureFromDeclaration(declaration) {
    const links = getNodeLinks(declaration);
    if (!links.resolvedSignature) {
      const parameters = [];
      let flags = 0 /* None */;
      let minArgumentCount = 0;
      let thisParameter;
      let thisTag = isInJSFile(declaration) ? getJSDocThisTag(declaration) : void 0;
      let hasThisParameter2 = false;
      const iife = getImmediatelyInvokedFunctionExpression(declaration);
      const isJSConstructSignature = isJSDocConstructSignature(declaration);
      const isUntypedSignatureInJSFile = !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration);
      if (isUntypedSignatureInJSFile) {
        flags |= 32 /* IsUntypedSignatureInJSFile */;
      }
      for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
        const param = declaration.parameters[i];
        if (isInJSFile(param) && isJSDocThisTag(param)) {
          thisTag = param;
          continue;
        }
        let paramSymbol = param.symbol;
        const type = isJSDocParameterTag(param) ? param.typeExpression && param.typeExpression.type : param.type;
        if (paramSymbol && !!(paramSymbol.flags & 4 /* Property */) && !isBindingPattern(param.name)) {
          const resolvedSymbol = resolveName(
            param,
            paramSymbol.escapedName,
            111551 /* Value */,
            /*nameNotFoundMessage*/
            void 0,
            /*nameArg*/
            void 0,
            /*isUse*/
            false
          );
          paramSymbol = resolvedSymbol;
        }
        if (i === 0 && paramSymbol.escapedName === "this" /* This */) {
          hasThisParameter2 = true;
          thisParameter = param.symbol;
        } else {
          parameters.push(paramSymbol);
        }
        if (type && type.kind === 201 /* LiteralType */) {
          flags |= 2 /* HasLiteralTypes */;
        }
        const isOptionalParameter2 = isOptionalJSDocPropertyLikeTag(param) || param.initializer || param.questionToken || isRestParameter(param) || iife && parameters.length > iife.arguments.length && !type || isJSDocOptionalParameter(param);
        if (!isOptionalParameter2) {
          minArgumentCount = parameters.length;
        }
      }
      if ((declaration.kind === 177 /* GetAccessor */ || declaration.kind === 178 /* SetAccessor */) && hasBindableName(declaration) && (!hasThisParameter2 || !thisParameter)) {
        const otherKind = declaration.kind === 177 /* GetAccessor */ ? 178 /* SetAccessor */ : 177 /* GetAccessor */;
        const other = getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind);
        if (other) {
          thisParameter = getAnnotatedAccessorThisParameter(other);
        }
      }
      if (thisTag && thisTag.typeExpression) {
        thisParameter = createSymbolWithType(createSymbol(1 /* FunctionScopedVariable */, "this" /* This */), getTypeFromTypeNode(thisTag.typeExpression));
      }
      const hostDeclaration = isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration;
      const classType = hostDeclaration && isConstructorDeclaration(hostDeclaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(hostDeclaration.parent.symbol)) : void 0;
      const typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
      if (hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
        flags |= 1 /* HasRestParameter */;
      }
      if (isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, 64 /* Abstract */) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, 64 /* Abstract */)) {
        flags |= 4 /* Abstract */;
      }
      links.resolvedSignature = createSignature(
        declaration,
        typeParameters,
        thisParameter,
        parameters,
        /*resolvedReturnType*/
        void 0,
        /*resolvedTypePredicate*/
        void 0,
        minArgumentCount,
        flags
      );
    }
    return links.resolvedSignature;
  }
  function maybeAddJsSyntheticRestParameter(declaration, parameters) {
    if (isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
      return false;
    }
    const lastParam = lastOrUndefined(declaration.parameters);
    const lastParamTags = lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag);
    const lastParamVariadicType = firstDefined(lastParamTags, (p) => p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : void 0);
    const syntheticArgsSymbol = createSymbol(3 /* Variable */, "args", 32768 /* RestParameter */);
    if (lastParamVariadicType) {
      syntheticArgsSymbol.links.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type));
    } else {
      syntheticArgsSymbol.links.checkFlags |= 65536 /* DeferredType */;
      syntheticArgsSymbol.links.deferralParent = neverType;
      syntheticArgsSymbol.links.deferralConstituents = [anyArrayType];
      syntheticArgsSymbol.links.deferralWriteConstituents = [anyArrayType];
    }
    if (lastParamVariadicType) {
      parameters.pop();
    }
    parameters.push(syntheticArgsSymbol);
    return true;
  }
  function getSignatureOfTypeTag(node) {
    if (!(isInJSFile(node) && isFunctionLikeDeclaration(node)))
      return void 0;
    const typeTag = getJSDocTypeTag(node);
    return (typeTag == null ? void 0 : typeTag.typeExpression) && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
  }
  function getParameterTypeOfTypeTag(func, parameter) {
    const signature = getSignatureOfTypeTag(func);
    if (!signature)
      return void 0;
    const pos = func.parameters.indexOf(parameter);
    return parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos);
  }
  function getReturnTypeOfTypeTag(node) {
    const signature = getSignatureOfTypeTag(node);
    return signature && getReturnTypeOfSignature(signature);
  }
  function containsArgumentsReference(declaration) {
    const links = getNodeLinks(declaration);
    if (links.containsArgumentsReference === void 0) {
      if (links.flags & 512 /* CaptureArguments */) {
        links.containsArgumentsReference = true;
      } else {
        links.containsArgumentsReference = traverse(declaration.body);
      }
    }
    return links.containsArgumentsReference;
    function traverse(node) {
      if (!node)
        return false;
      switch (node.kind) {
        case 80 /* Identifier */:
          return node.escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node) === argumentsSymbol;
        case 172 /* PropertyDeclaration */:
        case 174 /* MethodDeclaration */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
          return node.name.kind === 167 /* ComputedPropertyName */ && traverse(node.name);
        case 211 /* PropertyAccessExpression */:
        case 212 /* ElementAccessExpression */:
          return traverse(node.expression);
        case 303 /* PropertyAssignment */:
          return traverse(node.initializer);
        default:
          return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);
      }
    }
  }
  function getSignaturesOfSymbol(symbol) {
    if (!symbol || !symbol.declarations)
      return emptyArray;
    const result = [];
    for (let i = 0; i < symbol.declarations.length; i++) {
      const decl = symbol.declarations[i];
      if (!isFunctionLike(decl))
        continue;
      if (i > 0 && decl.body) {
        const previous = symbol.declarations[i - 1];
        if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
          continue;
        }
      }
      if (isInJSFile(decl) && decl.jsDoc) {
        const tags = getJSDocOverloadTags(decl);
        if (length(tags)) {
          for (const tag of tags) {
            const jsDocSignature = tag.typeExpression;
            if (jsDocSignature.type === void 0 && !isConstructorDeclaration(decl)) {
              reportImplicitAny(jsDocSignature, anyType);
            }
            result.push(getSignatureFromDeclaration(jsDocSignature));
          }
          continue;
        }
      }
      result.push(
        !isFunctionExpressionOrArrowFunction(decl) && !isObjectLiteralMethod(decl) && getSignatureOfTypeTag(decl) || getSignatureFromDeclaration(decl)
      );
    }
    return result;
  }
  function resolveExternalModuleTypeByLiteral(name) {
    const moduleSym = resolveExternalModuleName(name, name);
    if (moduleSym) {
      const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
      if (resolvedModuleSymbol) {
        return getTypeOfSymbol(resolvedModuleSymbol);
      }
    }
    return anyType;
  }
  function getThisTypeOfSignature(signature) {
    if (signature.thisParameter) {
      return getTypeOfSymbol(signature.thisParameter);
    }
  }
  function getTypePredicateOfSignature(signature) {
    if (!signature.resolvedTypePredicate) {
      if (signature.target) {
        const targetTypePredicate = getTypePredicateOfSignature(signature.target);
        signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper) : noTypePredicate;
      } else if (signature.compositeSignatures) {
        signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
      } else {
        const type = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
        let jsdocPredicate;
        if (!type) {
          const jsdocSignature = getSignatureOfTypeTag(signature.declaration);
          if (jsdocSignature && signature !== jsdocSignature) {
            jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
          }
        }
        signature.resolvedTypePredicate = type && isTypePredicateNode(type) ? createTypePredicateFromTypePredicateNode(type, signature) : jsdocPredicate || noTypePredicate;
      }
      Debug.assert(!!signature.resolvedTypePredicate);
    }
    return signature.resolvedTypePredicate === noTypePredicate ? void 0 : signature.resolvedTypePredicate;
  }
  function createTypePredicateFromTypePredicateNode(node, signature) {
    const parameterName = node.parameterName;
    const type = node.type && getTypeFromTypeNode(node.type);
    return parameterName.kind === 197 /* ThisType */ ? createTypePredicate(
      node.assertsModifier ? 2 /* AssertsThis */ : 0 /* This */,
      /*parameterName*/
      void 0,
      /*parameterIndex*/
      void 0,
      type
    ) : createTypePredicate(node.assertsModifier ? 3 /* AssertsIdentifier */ : 1 /* Identifier */, parameterName.escapedText, findIndex(signature.parameters, (p) => p.escapedName === parameterName.escapedText), type);
  }
  function getUnionOrIntersectionType(types, kind, unionReduction) {
    return kind !== 2097152 /* Intersection */ ? getUnionType(types, unionReduction) : getIntersectionType(types);
  }
  function getReturnTypeOfSignature(signature) {
    if (!signature.resolvedReturnType) {
      if (!pushTypeResolution(signature, 3 /* ResolvedReturnType */)) {
        return errorType;
      }
      let type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) : signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, 2 /* Subtype */), signature.mapper) : getReturnTypeFromAnnotation(signature.declaration) || (nodeIsMissing(signature.declaration.body) ? anyType : getReturnTypeFromBody(signature.declaration));
      if (signature.flags & 8 /* IsInnerCallChain */) {
        type = addOptionalTypeMarker(type);
      } else if (signature.flags & 16 /* IsOuterCallChain */) {
        type = getOptionalType(type);
      }
      if (!popTypeResolution()) {
        if (signature.declaration) {
          const typeNode = getEffectiveReturnTypeNode(signature.declaration);
          if (typeNode) {
            error2(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself);
          } else if (noImplicitAny) {
            const declaration = signature.declaration;
            const name = getNameOfDeclaration(declaration);
            if (name) {
              error2(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name));
            } else {
              error2(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
            }
          }
        }
        type = anyType;
      }
      signature.resolvedReturnType = type;
    }
    return signature.resolvedReturnType;
  }
  function getReturnTypeFromAnnotation(declaration) {
    if (declaration.kind === 176 /* Constructor */) {
      return getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol));
    }
    const typeNode = getEffectiveReturnTypeNode(declaration);
    if (isJSDocSignature(declaration)) {
      const root = getJSDocRoot(declaration);
      if (root && isConstructorDeclaration(root.parent) && !typeNode) {
        return getDeclaredTypeOfClassOrInterface(getMergedSymbol(root.parent.parent.symbol));
      }
    }
    if (isJSDocConstructSignature(declaration)) {
      return getTypeFromTypeNode(declaration.parameters[0].type);
    }
    if (typeNode) {
      return getTypeFromTypeNode(typeNode);
    }
    if (declaration.kind === 177 /* GetAccessor */ && hasBindableName(declaration)) {
      const jsDocType = isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
      if (jsDocType) {
        return jsDocType;
      }
      const setter = getDeclarationOfKind(getSymbolOfDeclaration(declaration), 178 /* SetAccessor */);
      const setterType = getAnnotatedAccessorType(setter);
      if (setterType) {
        return setterType;
      }
    }
    return getReturnTypeOfTypeTag(declaration);
  }
  function isResolvingReturnTypeOfSignature(signature) {
    return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) || !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3 /* ResolvedReturnType */) >= 0;
  }
  function getRestTypeOfSignature(signature) {
    return tryGetRestTypeOfSignature(signature) || anyType;
  }
  function tryGetRestTypeOfSignature(signature) {
    if (signatureHasRestParameter(signature)) {
      const sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
      const restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
      return restType && getIndexTypeOfType(restType, numberType);
    }
    return void 0;
  }
  function getSignatureInstantiation(signature, typeArguments, isJavascript, inferredTypeParameters) {
    const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
    if (inferredTypeParameters) {
      const returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
      if (returnSignature) {
        const newReturnSignature = cloneSignature(returnSignature);
        newReturnSignature.typeParameters = inferredTypeParameters;
        const newInstantiatedSignature = cloneSignature(instantiatedSignature);
        newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
        return newInstantiatedSignature;
      }
    }
    return instantiatedSignature;
  }
  function getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments) {
    const instantiations = signature.instantiations || (signature.instantiations = /* @__PURE__ */ new Map());
    const id = getTypeListId(typeArguments);
    let instantiation = instantiations.get(id);
    if (!instantiation) {
      instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
    }
    return instantiation;
  }
  function createSignatureInstantiation(signature, typeArguments) {
    return instantiateSignature(
      signature,
      createSignatureTypeMapper(signature, typeArguments),
      /*eraseTypeParameters*/
      true
    );
  }
  function createSignatureTypeMapper(signature, typeArguments) {
    return createTypeMapper(signature.typeParameters, typeArguments);
  }
  function getErasedSignature(signature) {
    return signature.typeParameters ? signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) : signature;
  }
  function createErasedSignature(signature) {
    return instantiateSignature(
      signature,
      createTypeEraser(signature.typeParameters),
      /*eraseTypeParameters*/
      true
    );
  }
  function getCanonicalSignature(signature) {
    return signature.typeParameters ? signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) : signature;
  }
  function createCanonicalSignature(signature) {
    return getSignatureInstantiation(
      signature,
      map(signature.typeParameters, (tp) => tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp),
      isInJSFile(signature.declaration)
    );
  }
  function getBaseSignature(signature) {
    const typeParameters = signature.typeParameters;
    if (typeParameters) {
      if (signature.baseSignatureCache) {
        return signature.baseSignatureCache;
      }
      const typeEraser = createTypeEraser(typeParameters);
      const baseConstraintMapper = createTypeMapper(typeParameters, map(typeParameters, (tp) => getConstraintOfTypeParameter(tp) || unknownType));
      let baseConstraints = map(typeParameters, (tp) => instantiateType(tp, baseConstraintMapper) || unknownType);
      for (let i = 0; i < typeParameters.length - 1; i++) {
        baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);
      }
      baseConstraints = instantiateTypes(baseConstraints, typeEraser);
      return signature.baseSignatureCache = instantiateSignature(
        signature,
        createTypeMapper(typeParameters, baseConstraints),
        /*eraseTypeParameters*/
        true
      );
    }
    return signature;
  }
  function getOrCreateTypeFromSignature(signature) {
    var _a;
    if (!signature.isolatedSignatureType) {
      const kind = (_a = signature.declaration) == null ? void 0 : _a.kind;
      const isConstructor = kind === void 0 || kind === 176 /* Constructor */ || kind === 180 /* ConstructSignature */ || kind === 185 /* ConstructorType */;
      const type = createObjectType(16 /* Anonymous */);
      type.members = emptySymbols;
      type.properties = emptyArray;
      type.callSignatures = !isConstructor ? [signature] : emptyArray;
      type.constructSignatures = isConstructor ? [signature] : emptyArray;
      type.indexInfos = emptyArray;
      signature.isolatedSignatureType = type;
    }
    return signature.isolatedSignatureType;
  }
  function getIndexSymbol(symbol) {
    return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : void 0;
  }
  function getIndexSymbolFromSymbolTable(symbolTable) {
    return symbolTable.get("__index" /* Index */);
  }
  function createIndexInfo(keyType, type, isReadonly, declaration) {
    return { keyType, type, isReadonly, declaration };
  }
  function getIndexInfosOfSymbol(symbol) {
    const indexSymbol = getIndexSymbol(symbol);
    return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray;
  }
  function getIndexInfosOfIndexSymbol(indexSymbol) {
    if (indexSymbol.declarations) {
      const indexInfos = [];
      for (const declaration of indexSymbol.declarations) {
        if (declaration.parameters.length === 1) {
          const parameter = declaration.parameters[0];
          if (parameter.type) {
            forEachType(getTypeFromTypeNode(parameter.type), (keyType) => {
              if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType)) {
                indexInfos.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, hasEffectiveModifier(declaration, 8 /* Readonly */), declaration));
              }
            });
          }
        }
      }
      return indexInfos;
    }
    return emptyArray;
  }
  function isValidIndexKeyType(type) {
    return !!(type.flags & (4 /* String */ | 8 /* Number */ | 4096 /* ESSymbol */)) || isPatternLiteralType(type) || !!(type.flags & 2097152 /* Intersection */) && !isGenericType(type) && some(type.types, isValidIndexKeyType);
  }
  function getConstraintDeclaration(type) {
    return mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0];
  }
  function getInferredTypeParameterConstraint(typeParameter, omitTypeReferences) {
    var _a;
    let inferences;
    if ((_a = typeParameter.symbol) == null ? void 0 : _a.declarations) {
      for (const declaration of typeParameter.symbol.declarations) {
        if (declaration.parent.kind === 195 /* InferType */) {
          const [childTypeParameter = declaration.parent, grandParent] = walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent);
          if (grandParent.kind === 183 /* TypeReference */ && !omitTypeReferences) {
            const typeReference = grandParent;
            const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReference);
            if (typeParameters) {
              const index = typeReference.typeArguments.indexOf(childTypeParameter);
              if (index < typeParameters.length) {
                const declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                if (declaredConstraint) {
                  const mapper = makeDeferredTypeMapper(
                    typeParameters,
                    typeParameters.map((_, index2) => () => {
                      return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index2);
                    })
                  );
                  const constraint = instantiateType(declaredConstraint, mapper);
                  if (constraint !== typeParameter) {
                    inferences = append(inferences, constraint);
                  }
                }
              }
            }
          } else if (grandParent.kind === 169 /* Parameter */ && grandParent.dotDotDotToken || grandParent.kind === 191 /* RestType */ || grandParent.kind === 202 /* NamedTupleMember */ && grandParent.dotDotDotToken) {
            inferences = append(inferences, createArrayType(unknownType));
          } else if (grandParent.kind === 204 /* TemplateLiteralTypeSpan */) {
            inferences = append(inferences, stringType);
          } else if (grandParent.kind === 168 /* TypeParameter */ && grandParent.parent.kind === 200 /* MappedType */) {
            inferences = append(inferences, keyofConstraintType);
          } else if (grandParent.kind === 200 /* MappedType */ && grandParent.type && skipParentheses(grandParent.type) === declaration.parent && grandParent.parent.kind === 194 /* ConditionalType */ && grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === 200 /* MappedType */ && grandParent.parent.checkType.type) {
            const checkMappedType2 = grandParent.parent.checkType;
            const nodeType = getTypeFromTypeNode(checkMappedType2.type);
