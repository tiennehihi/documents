(preset.presets,pass))return!0;preset.options.forEach((opts=>{(0,_util.mergeOptions)(optionDefaults,opts)}))}}}))(presetsDescriptors,pluginDescriptorsByPass[0]);if(ignored)return null;const opts=optionDefaults;(0,_util.mergeOptions)(opts,options);const pluginContext=Object.assign({},presetContext,{assumptions:null!=(_opts$assumptions=opts.assumptions)?_opts$assumptions:{}});return yield*enhanceError(context,(function*(){pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);for(const descs of pluginDescriptorsByPass){const pass=[];passes.push(pass);for(let i=0;i<descs.length;i++){const descriptor=descs[i];if(!1!==descriptor.options){try{var plugin=yield*loadPluginDescriptor(descriptor,pluginContext)}catch(e){throw"BABEL_UNKNOWN_PLUGIN_PROPERTY"===e.code&&(0,_options.checkNoUnwrappedItemOptionPairs)(descs,i,"plugin",e),e}pass.push(plugin),externalDependencies.push(plugin.externalDependencies)}}}}))(),opts.plugins=passes[0],opts.presets=passes.slice(1).filter((plugins=>plugins.length>0)).map((plugins=>({plugins}))),opts.passPerPreset=opts.presets.length>0,{options:opts,passes,externalDependencies:(0,_deepArray.finalize)(externalDependencies)}}));function enhanceError(context,fn){return function*(arg1,arg2){try{return yield*fn(arg1,arg2)}catch(e){var _context$filename;if(!/^\[BABEL\]/.test(e.message))e.message=`[BABEL] ${null!=(_context$filename=context.filename)?_context$filename:"unknown file"}: ${e.message}`;throw e}}}exports.default=_default;const makeDescriptorLoader=apiFactory=>(0,_caching.makeWeakCache)((function*({value,options,dirname,alias},cache){if(!1===options)throw new Error("Assertion failure");options=options||{};const externalDependencies=[];let item=value;if("function"==typeof value){const factory=(0,_async.maybeAsync)(value,"You appear to be using an async plugin/preset, but Babel has been called synchronously"),api=Object.assign({},context,apiFactory(cache,externalDependencies));try{item=yield*factory(api,options,dirname)}catch(e){throw alias&&(e.message+=` (While processing: ${JSON.stringify(alias)})`),e}}if(!item||"object"!=typeof item)throw new Error("Plugin/Preset did not return an object.");if((0,_async.isThenable)(item))throw yield*[],new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);if(externalDependencies.length>0&&(!cache.configured()||"forever"===cache.mode())){let error=`A plugin/preset has external untracked dependencies (${externalDependencies[0]}), but the cache `;throw cache.configured()?error+=" has been configured to never be invalidated. ":error+="has not been configured to be invalidated when the external dependencies change. ",error+=`Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`\n(While processing: ${JSON.stringify(alias)})`,new Error(error)}return{value:item,options,dirname,alias,externalDependencies:(0,_deepArray.finalize)(externalDependencies)}})),pluginDescriptorLoader=makeDescriptorLoader(_configApi.makePluginAPI),presetDescriptorLoader=makeDescriptorLoader(_configApi.makePresetAPI),instantiatePlugin=(0,_caching.makeWeakCache)((function*({value,options,dirname,alias,externalDependencies},cache){const pluginObj=(0,_plugins.validatePluginObject)(value),plugin=Object.assign({},pluginObj);if(plugin.visitor&&(plugin.visitor=_traverse().default.explode(Object.assign({},plugin.visitor))),plugin.inherits){const inheritsDescriptor={name:void 0,alias:`${alias}$inherits`,value:plugin.inherits,options,dirname},inherits=yield*(0,_async.forwardAsync)(loadPluginDescriptor,(run=>cache.invalidate((data=>run(inheritsDescriptor,data)))));plugin.pre=chain(inherits.pre,plugin.pre),plugin.post=chain(inherits.post,plugin.post),plugin.manipulateOptions=chain(inherits.manipulateOptions,plugin.manipulateOptions),plugin.visitor=_traverse().default.visitors.merge([inherits.visitor||{},plugin.visitor||{}]),inherits.externalDependencies.length>0&&(externalDependencies=0===externalDependencies.length?inherits.externalDependencies:(0,_deepArray.finalize)([externalDependencies,inherits.externalDependencies]))}return new _plugin.default(plugin,options,alias,externalDependencies)}));function*loadPluginDescriptor(descriptor,context){if(descriptor.value instanceof _plugin.default){if(descriptor.options)throw new Error("Passed options to an existing Plugin instance will not work.");return descriptor.value}return yield*instantiatePlugin(yield*pluginDescriptorLoader(descriptor,context),context)}const needsFilename=val=>val&&"function"!=typeof val,validateIfOptionNeedsFilename=(options,descriptor)=>{if(needsFilename(options.test)||needsFilename(options.include)||needsFilename(options.exclude)){const formattedPresetName=descriptor.name?`"${descriptor.name}"`:"/* your preset */";throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,"```",`babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,"```","See https://babeljs.io/docs/en/options#filename for more information."].join("\n"))}},validatePreset=(preset,context,descriptor)=>{if(!context.filename){var _options$overrides;const{options}=preset;validateIfOptionNeedsFilename(options,descriptor),null==(_options$overrides=options.overrides)||_options$overrides.forEach((overrideOptions=>validateIfOptionNeedsFilename(overrideOptions,descriptor)))}},instantiatePreset=(0,_caching.makeWeakCacheSync)((({value,dirname,alias,externalDependencies})=>({options:(0,_options.validate)("preset",value),alias,dirname,externalDependencies})));function*loadPresetDescriptor(descriptor,context){const preset=instantiatePreset(yield*presetDescriptorLoader(descriptor,context));return validatePreset(preset,context,descriptor),{chain:yield*(0,_configChain.buildPresetChain)(preset,context),externalDependencies:preset.externalDependencies}}function chain(a,b){const fns=[a,b].filter(Boolean);return fns.length<=1?fns[0]:function(...args){for(const fn of fns)fn.apply(this,