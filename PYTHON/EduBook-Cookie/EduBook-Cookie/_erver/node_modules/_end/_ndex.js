e: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#639",
      red: "#f00",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#fff",
      whitesmoke: "#f5f5f5",
      yellow: "#ff0",
      yellowgreen: "#9acd32"
    };
    exports2.colorsShortNames = {
      "#f0ffff": "azure",
      "#f5f5dc": "beige",
      "#ffe4c4": "bisque",
      "#a52a2a": "brown",
      "#ff7f50": "coral",
      "#ffd700": "gold",
      "#808080": "gray",
      "#008000": "green",
      "#4b0082": "indigo",
      "#fffff0": "ivory",
      "#f0e68c": "khaki",
      "#faf0e6": "linen",
      "#800000": "maroon",
      "#000080": "navy",
      "#808000": "olive",
      "#ffa500": "orange",
      "#da70d6": "orchid",
      "#cd853f": "peru",
      "#ffc0cb": "pink",
      "#dda0dd": "plum",
      "#800080": "purple",
      "#f00": "red",
      "#ff0000": "red",
      "#fa8072": "salmon",
      "#a0522d": "sienna",
      "#c0c0c0": "silver",
      "#fffafa": "snow",
      "#d2b48c": "tan",
      "#008080": "teal",
      "#ff6347": "tomato",
      "#ee82ee": "violet",
      "#f5deb3": "wheat"
    };
    exports2.colorsProps = [
      "color",
      "fill",
      "stroke",
      "stop-color",
      "flood-color",
      "lighting-color"
    ];
  }
});

// node_modules/svgo/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/svgo/lib/parser.js"(exports2) {
    "use strict";
    var SAX = require_sax();
    var { textElems } = require_collections();
    var SvgoParserError = class extends Error {
      /**
       * @param message {string}
       * @param line {number}
       * @param column {number}
       * @param source {string}
       * @param file {void | string}
       */
      constructor(message, line, column, source, file) {
        super(message);
        this.name = "SvgoParserError";
        this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
        this.reason = message;
        this.line = line;
        this.column = column;
        this.source = source;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, SvgoParserError);
        }
      }
      toString() {
        const lines = this.source.split(/\r?\n/);
        const startLine = Math.max(this.line - 3, 0);
        const endLine = Math.min(this.line + 2, lines.length);
        const lineNumberWidth = String(endLine).length;
        const startColumn = Math.max(this.column - 54, 0);
        const endColumn = Math.max(this.column + 20, 80);
        const code = lines.slice(startLine, endLine).map((line, index) => {
          const lineSlice = line.slice(startColumn, endColumn);
          let ellipsisPrefix = "";
          let ellipsisSuffix = "";
          if (startColumn !== 0) {
            ellipsisPrefix = startColumn > line.length - 1 ? " " : "\u2026";
          }
          if (endColumn < line.length - 1) {
            ellipsisSuffix = "\u2026";
          }
          const number = startLine + 1 + index;
          const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
          if (number === this.line) {
            const gutterSpacing = gutter.replace(/[^|]/g, " ");
            const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\t]/g, " ");
            const spacing = gutterSpacing + lineSpacing;
            return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}
 ${spacing}^`;
          }
          return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
        }).join("\n");
        return `${this.name}: ${this.message}

${code}
`;
      }
    };
    var entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
    var config = {
      strict: true,
      trim: false,
      normalize: false,
      lowercase: true,
      xmlns: true,
      position: true
    };
    var parseSvg = (data, from) => {
      const sax = SAX.parser(config.strict, config);
      const root = { type: "root", children: [] };
      let current = root;
      const stack = [root];
      const pushToContent = (node) => {
        Object.defineProperty(node, "parentNode", {
          writable: true,
          value: current
        });
        current.children.push(node);
      };
      sax.ondoctype = (doctype) => {
        const node = {
          type: "doctype",
          // TODO parse doctype for name, public and system to match xast
          name: "svg",
          data: {
            doctype
          }
        };
        pushToContent(node);
        const subsetStart = doctype.indexOf("[");
        if (subsetStart >= 0) {
          entityDeclaration.lastIndex = subsetStart;
          let entityMatch = entityDeclaration.exec(data);
          while (entityMatch != null) {
            sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
            entityMatch = entityDeclaration.exec(data);
          }
        }
      };
      sax.onprocessinginstruction = (data2) => {
        const node = {
          type: "instruction",
          name: data2.name,
          value: data2.body
        };
        pushToContent(node);
      };
      sax.oncomment = (comment) => {
        const node = {
          type: "comment",
          value: comment.trim()
        };
        pushToContent(node);
      };
      sax.oncdata = (cdata) => {
        const node = {
          type: "cdata",
          value: cdata
        };
        pushToContent(node);
      };
      sax.onopentag = (data2) => {
        let element = {
          type: "element",
          name: data2.name,
          attributes: {},
          children: []
        };
        for (const [name, attr] of Object.entries(data2.attributes)) {
          element.attributes[name] = attr.value;
        }
        pushToContent(element);
        current = element;
        stack.push(element);
      };
      sax.ontext = (text) => {
        if (current.type === "element") {
          if (textElems.includes(current.name)) {
            const node = {
              type: "text",
              value: text
            };
            pushToContent(node);
          } else if (/\S/.test(text)) {
            const node = {
              type: "text",
              value: text.trim()
            };
            pushToContent(node);
          }
        }
      };
      sax.onclosetag = () => {
        stack.pop();
        current = stack[stack.length - 1];
      };
      sax.onerror = (e) => {
        const error = new SvgoParserError(
          e.reason,
          e.line + 1,
          e.column,
          data,
          from
        );
        if (e.message.indexOf("Unexpected end") === -1) {
          throw error;
        }
      };
      sax.write(data).close();
      return root;
    };
    exports2.parseSvg = parseSvg;
  }
});

// node_modules/svgo/lib/stringifier.js
var require_stringifier2 = __commonJS({
  "node_modules/svgo/lib/stringifier.js"(exports2) {
    "use strict";
    var { textElems } = require_collections();
    var encodeEntity = (char) => {
      return entities[char];
    };
    var defaults = {
      doctypeStart: "<!DOCTYPE",
      doctypeEnd: ">",
      procInstStart: "<?",
      procInstEnd: "?>",
      tagOpenStart: "<",
      tagOpenEnd: ">",
      tagCloseStart: "</",
      tagCloseEnd: ">",
      tagShortStart: "<",
      tagShortEnd: "/>",
      attrStart: '="',
      attrEnd: '"',
      commentStart: "<!--",
      commentEnd: "-->",
      cdataStart: "<![CDATA[",
      cdataEnd: "]]>",
      textStart: "",
      textEnd: "",
      indent: 4,
      regEntities: /[&'"<>]/g,
      regValEntities: /[&"<>]/g,
      encodeEntity,
      pretty: false,
      useShortTags: true,
      eol: "lf",
      finalNewline: false
    };
    var entities = {
      "&": "&amp;",
      "'": "&apos;",
      '"': "&quot;",
      ">": "&gt;",
      "<": "&lt;"
    };
    var stringifySvg = (data, userOptions = {}) => {
      const config = { ...defaults, ...userOptions };
      const indent = config.indent;
      let newIndent = "    ";
      if (typeof indent === "number" && Number.isNaN(indent) === false) {
        newIndent = indent < 0 ? "	" : " ".repeat(indent);
      } else if (typeof indent === "string") {
        newIndent = indent;
      }
      const state = {
        indent: newIndent,
        textContext: null,
        indentLevel: 0
      };
      const eol = config.eol === "crlf" ? "\r\n" : "\n";
      if (config.pretty) {
        config.doctypeEnd += eol;
        config.procInstEnd += eol;
        config.commentEnd += eol;
        config.cdataEnd += eol;
        config.tagShortEnd += eol;
        config.tagOpenEnd += eol;
        config.tagCloseEnd += eol;
        config.textEnd += eol;
      }
      let svg = stringifyNode(data, config, state);
      if (config.finalNewline && svg.length > 0 && svg[svg.length - 1] !== "\n") {
        svg += eol;
      }
      return svg;
    };
    exports2.stringifySvg = stringifySvg;
    var stringifyNode = (data, config, state) => {
      let svg = "";
      state.indentLevel += 1;
      for (const item of data.children) {
        if (item.type === "element") {
          svg += stringifyElement(item, config, state);
        }
        if (item.type === "text") {
          svg += stringifyText(item, config, state);
        }
        if (item.type === "doctype") {
          svg += stringifyDoctype(item, config);
        }
        if (item.type === "instruction") {
          svg += stringifyInstruction(item, config);
        }
        if (item.type === "comment") {
          svg += stringifyComment(item, config);
        }
        if (item.type === "cdata") {
          svg += stringifyCdata(item, config, state);
        }
      }
      state.indentLevel -= 1;
      return svg;
    };
    var createIndent = (config, state) => {
      let indent = "";
      if (config.pretty && state.textContext == null) {
        indent = state.indent.repeat(state.indentLevel - 1);
      }
      return indent;
    };
    var stringifyDoctype = (node, config) => {
      return config.doctypeStart + node.data.doctype + config.doctypeEnd;
    };
    var stringifyInstruction = (node, config) => {
      return config.procInstStart + node.name + " " + node.value + config.procInstEnd;
    };
    var stringifyComment = (node, config) => {
      return config.commentStart + node.value + config.commentEnd;
    };
    var stringifyCdata = (node, config, state) => {
      return createIndent(config, state) + config.cdataStart + node.value + config.cdataEnd;
    };
    var stringifyElement = (node, config, state) => {
      if (node.children.length === 0) {
        if (config.useShortTags) {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagShortEnd;
        } else {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagOpenEnd + config.tagCloseStart + node.name + config.tagCloseEnd;
        }
      } else {
        let tagOpenStart = config.tagOpenStart;
        let tagOpenEnd = config.tagOpenEnd;
        let tagCloseStart = config.tagCloseStart;
        let tagCloseEnd = config.tagCloseEnd;
        let openIndent = createIndent(config, state);
        let closeIndent = createIndent(config, state);
        if (state.textContext) {
          tagOpenStart = defaults.tagOpenStart;
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          tagCloseEnd = defaults.tagCloseEnd;
          openIndent = "";
        } else if (textElems.includes(node.name)) {
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          closeIndent = "";
          state.textContext = node;
        }
        const children = stringifyNode(node, config, state);
        if (state.textContext === node) {
          state.textContext = null;
        }
        return openIndent + tagOpenStart + node.name + stringifyAttributes(node, config) + tagOpenEnd + children + closeIndent + tagCloseStart + node.name + tagCloseEnd;
      }
    };
    var stringifyAttributes = (node, config) => {
      let attrs = "";
      for (const [name, value] of Object.entries(node.attributes)) {
        if (value !== void 0) {
          const encodedValue = value.toString().replace(config.regValEntities, config.encodeEntity);
          attrs += " " + name + config.attrStart + encodedValue + config.attrEnd;
        } else {
          attrs += " " + name;
        }
      }
      return attrs;
    };
    var stringifyText = (node, config, state) => {
      return createIndent(config, state) + config.textStart + node.value.replace(config.regEntities, config.encodeEntity) + (state.textContext ? "" : config.textEnd);
    };
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports2.isTag = isTag;
    exports2.Root = ElementType.Root;
    exports2.Text = ElementType.Text;
    exports2.Directive = ElementType.Directive;
    exports2.Comment = ElementType.Comment;
    exports2.Script = ElementType.Script;
    exports2.Style = ElementType.Style;
    exports2.Tag = ElementType.Tag;
    exports2.CDATA = ElementType.CDATA;
    exports2.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node3 = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib2();
    var Node = (
      /** @class */
      function() {
        function Node2() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node2.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node2.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node2;
      }()
    );
    exports2.Node = Node;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node)
    );
    exports2.DataNode = DataNode;
    var Text = (
      /** @class */
      function(_super) {
        __extends(Text2, _super);
        function Text2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text2.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text2;
      }(DataNode)
    );
    exports2.Text = Text;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
     