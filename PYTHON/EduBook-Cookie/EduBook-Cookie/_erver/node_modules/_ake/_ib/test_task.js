 node.name,
            111551 /* Value */,
            /*ignoreErrors*/
            true,
            /*dontResolveAlias*/
            true
          );
          if (symbol && isParameterOrMutableLocalVariable(symbol)) {
            symbol.lastAssignmentPos = Number.MAX_VALUE;
          }
        }
        return;
      case 264 /* InterfaceDeclaration */:
      case 265 /* TypeAliasDeclaration */:
      case 266 /* EnumDeclaration */:
        return;
    }
    if (isTypeNode(node)) {
      return;
    }
    forEachChild(node, markNodeAssignments);
  }
  function extendAssignmentPosition(node, declaration) {
    let pos = node.pos;
    while (node && node.pos > declaration.pos) {
      switch (node.kind) {
        case 243 /* VariableStatement */:
        case 244 /* ExpressionStatement */:
        case 245 /* IfStatement */:
        case 246 /* DoStatement */:
        case 247 /* WhileStatement */:
        case 248 /* ForStatement */:
        case 249 /* ForInStatement */:
        case 250 /* ForOfStatement */:
        case 254 /* WithStatement */:
        case 255 /* SwitchStatement */:
        case 258 /* TryStatement */:
        case 263 /* ClassDeclaration */:
          pos = node.end;
      }
      node = node.parent;
    }
    return pos;
  }
  function isConstantVariable(symbol) {
    return symbol.flags & 3 /* Variable */ && (getDeclarationNodeFlagsFromSymbol(symbol) & 6 /* Constant */) !== 0;
  }
  function isParameterOrMutableLocalVariable(symbol) {
    const declaration = symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration);
    return !!declaration && (isParameter(declaration) || isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration)));
  }
  function isMutableLocalVariableDeclaration(declaration) {
    return !!(declaration.parent.flags & 1 /* Let */) && !(getCombinedModifierFlags(declaration) & 32 /* Export */ || declaration.parent.parent.kind === 243 /* VariableStatement */ && isGlobalSourceFile(declaration.parent.parent.parent));
  }
  function parameterInitializerContainsUndefined(declaration) {
    const links = getNodeLinks(declaration);
    if (links.parameterInitializerContainsUndefined === void 0) {
      if (!pushTypeResolution(declaration, 9 /* ParameterInitializerContainsUndefined */)) {
        reportCircularityError(declaration.symbol);
        return true;
      }
      const containsUndefined = !!hasTypeFacts(checkDeclarationInitializer(declaration, 0 /* Normal */), 16777216 /* IsUndefined */);
      if (!popTypeResolution()) {
        reportCircularityError(declaration.symbol);
        return true;
      }
      links.parameterInitializerContainsUndefined = containsUndefined;
    }
    return links.parameterInitializerContainsUndefined;
  }
  function removeOptionalityFromDeclaredType(declaredType, declaration) {
    const removeUndefined = strictNullChecks && declaration.kind === 169 /* Parameter */ && declaration.initializer && hasTypeFacts(declaredType, 16777216 /* IsUndefined */) && !parameterInitializerContainsUndefined(declaration);
    return removeUndefined ? getTypeWithFacts(declaredType, 524288 /* NEUndefined */) : declaredType;
  }
  function isConstraintPosition(type, node) {
    const parent2 = node.parent;
    return parent2.kind === 211 /* PropertyAccessExpression */ || parent2.kind === 166 /* QualifiedName */ || parent2.kind === 213 /* CallExpression */ && parent2.expression === node || parent2.kind === 212 /* ElementAccessExpression */ && parent2.expression === node && !(someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression(parent2.argumentExpression)));
  }
  function isGenericTypeWithUnionConstraint(type) {
    return type.flags & 2097152 /* Intersection */ ? some(type.types, isGenericTypeWithUnionConstraint) : !!(type.flags & 465829888 /* Instantiable */ && getBaseConstraintOrType(type).flags & (98304 /* Nullable */ | 1048576 /* Union */));
  }
  function isGenericTypeWithoutNullableConstraint(type) {
    return type.flags & 2097152 /* Intersection */ ? some(type.types, isGenericTypeWithoutNullableConstraint) : !!(type.flags & 465829888 /* Instantiable */ && !maybeTypeOfKind(getBaseConstraintOrType(type), 98304 /* Nullable */));
  }
  function hasContextualTypeWithNoGenericTypes(node, checkMode) {
    const contextualType = (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) && (checkMode && checkMode & 32 /* RestBindingElement */ ? getContextualType2(node, 8 /* SkipBindingPatterns */) : getContextualType2(
      node,
      /*contextFlags*/
      void 0
    ));
    return contextualType && !isGenericType(contextualType);
  }
  function getNarrowableTypeForReference(type, reference, checkMode) {
    const substituteConstraints = !(checkMode && checkMode & 2 /* Inferential */) && someType(type, isGenericTypeWithUnionConstraint) && (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode));
    return substituteConstraints ? mapType(type, getBaseConstraintOrType) : type;
  }
  function isExportOrExportExpression(location) {
    return !!findAncestor(location, (n) => {
      const parent2 = n.parent;
      if (parent2 === void 0) {
        return "quit";
      }
      if (isExportAssignment(parent2)) {
        return parent2.expression === n && isEntityNameExpression(n);
      }
      if (isExportSpecifier(parent2)) {
        return parent2.name === n || parent2.propertyName === n;
      }
      return false;
    });
  }
  function markAliasReferenced(symbol, location) {
    if (!canCollectSymbolAliasAccessabilityData) {
      return;
    }
    if (isNonLocalAlias(
      symbol,
      /*excludes*/
      111551 /* Value */
    ) && !isInTypeQuery(location)) {
      const target = resolveAlias(symbol);
      if (getSymbolFlags(
        symbol,
        /*excludeTypeOnlyMeanings*/
        true
      ) & (111551 /* Value */ | 1048576 /* ExportValue */)) {
        if (getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target))) {
          markAliasSymbolAsReferenced(symbol);
        } else {
          markConstEnumAliasAsReferenced(symbol);
        }
      }
    }
  }
  function getNarrowedTypeOfSymbol(symbol, location, checkMode) {
    var _a;
    const type = getTypeOfSymbol(symbol, checkMode);
    const declaration = symbol.valueDeclaration;
    if (declaration) {
      if (isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2) {
        const parent2 = declaration.parent.parent;
        const rootDeclaration = getRootDeclaration(parent2);
        if (rootDeclaration.kind === 260 /* VariableDeclaration */ && getCombinedNodeFlagsCached(rootDeclaration) & 6 /* Constant */ || rootDeclaration.kind === 169 /* Parameter */) {
          const links = getNodeLinks(parent2);
          if (!(links.flags & 4194304 /* InCheckIdentifier */)) {
            links.flags |= 4194304 /* InCheckIdentifier */;
            const parentType = getTypeForBindingElementParent(parent2, 0 /* Normal */);
            const parentTypeConstraint = parentType && mapType(parentType, getBaseConstraintOrType);
            links.flags &= ~4194304 /* InCheckIdentifier */;
            if (parentTypeConstraint && parentTypeConstraint.flags & 1048576 /* Union */ && !(rootDeclaration.kind === 169 /* Parameter */ && isSomeSymbolAssigned(rootDeclaration))) {
              const pattern = declaration.parent;
              const narrowedType = getFlowTypeOfReference(
                pattern,
                parentTypeConstraint,
                parentTypeConstraint,
                /*flowContainer*/
                void 0,
                location.flowNode
              );
              if (narrowedType.flags & 131072 /* Never */) {
                return neverType;
              }
              return getBindingElementTypeFromParentType(
                declaration,
                narrowedType,
                /*noTupleBoundsCheck*/
                true
              );
            }
          }
        }
      }
      if (isParameter(declaration) && !declaration.type && !declara