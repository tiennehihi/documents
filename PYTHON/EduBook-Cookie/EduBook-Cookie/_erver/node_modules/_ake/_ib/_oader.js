s, d) => modifiers | getEffectiveModifierFlags(d), 0 /* None */) & (8192 /* In */ | 16384 /* Out */ | 4096 /* Const */);
  }
  function hasCovariantVoidArgument(typeArguments, variances) {
    for (let i = 0; i < variances.length; i++) {
      if ((variances[i] & 7 /* VarianceMask */) === 1 /* Covariant */ && typeArguments[i].flags & 16384 /* Void */) {
        return true;
      }
    }
    return false;
  }
  function isUnconstrainedTypeParameter(type) {
    return type.flags & 262144 /* TypeParameter */ && !getConstraintOfTypeParameter(type);
  }
  function isNonDeferredTypeReference(type) {
    return !!(getObjectFlags(type) & 4 /* Reference */) && !type.node;
  }
  function isTypeReferenceWithGenericArguments(type) {
    return isNonDeferredTypeReference(type) && some(getTypeArguments(type), (t) => !!(t.flags & 262144 /* TypeParameter */) || isTypeReferenceWithGenericArguments(t));
  }
  function getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints) {
    const typeParameters = [];
    let constraintMarker = "";
    const sourceId = getTypeReferenceId(source, 0);
    const targetId = getTypeReferenceId(target, 0);
    return `${constraintMarker}${sourceId},${targetId}${postFix}`;
    function getTypeReferenceId(type, depth = 0) {
      let result = "" + type.target.id;
      for (const t of getTypeArguments(type)) {
        if (t.flags & 262144 /* TypeParameter */) {
          if (ignoreConstraints || isUnconstrainedTypeParameter(t)) {
            let index = typeParameters.indexOf(t);
            if (index < 0) {
              index = typeParameters.length;
              typeParameters.push(t);
            }
            result += "=" + index;
            continue;
          }
          constraintMarker = "*";
        } else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
          result += "<" + getTypeReferenceId(t, depth + 1) + ">";
          continue;
        }
        result += "-" + t.id;
      }
      return result;
    }
  }
  function getRelationKey(source, target, intersectionState, relation, ignoreConstraints) {
    if (relation === identityRelation && source.id > target.id) {
      const temp = source;
      source = target;
      target = temp;
    }
    const postFix = intersectionState ? ":" + intersectionState : "";
    return isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ? getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints) : `${source.id},${target.id}${postFix}`;
  }
  function forEachProperty2(prop, callback) {
    if (getCheckFlags(prop) & 6 /* Synthetic */) {
      for (const t of prop.links.containingType.types) {
        const p = getPropertyOfType(t, prop.escapedName);
        const result = p && forEachProperty2(p, callback);
        if (result) {
          return result;
        }
      }
      return void 0;
    }
    return callback(prop);
  }
  function getDeclaringClass(prop) {
    return prop.parent && prop.parent.flags & 32 /* Class */ ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)) : void 0;
  }
  function getTypeOfPropertyInBaseClass(property) {
    const classType = getDeclaringClass(property);
    const baseClassType = classType && getBaseTypes(classType)[0];
    return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName);
  }
  function isPropertyInClassDerivedFrom(prop, baseClass) {
    return forEachProperty2(prop, (sp) => {
      const sourceClass = getDeclaringClass(sp);
      return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
    });
  }
  function isValidOverrideOf(sourceProp, targetProp) {
    return !forEachProperty2(targetProp, (tp) => getDeclarationModifierFlagsFromSymbol(tp) & 4 /* Protected */ ? !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false);
  }
  function isClassDerivedFromDeclaringClasses(checkClass, prop, writing) {
    return forEachProperty2(prop, (p) => getDeclarationModifierFlagsFromSymbol(p, writing) & 4 /* Protected */ ? !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? void 0 : checkClass;
  }
  function isDeeplyNestedType(type, stack, depth, maxDepth = 3) {
    if (d