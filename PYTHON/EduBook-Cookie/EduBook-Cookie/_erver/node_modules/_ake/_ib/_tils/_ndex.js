  if (functionFlags & 1 /* Generator */) {
        return filterType(returnType2, (t) => {
          return !!(t.flags & (3 /* AnyOrUnknown */ | 16384 /* Void */ | 58982400 /* InstantiableNonPrimitive */)) || checkGeneratorInstantiationAssignabilityToReturnType(
            t,
            functionFlags,
            /*errorNode*/
            void 0
          );
        });
      }
      if (functionFlags & 2 /* Async */) {
        return filterType(returnType2, (t) => {
          return !!(t.flags & (3 /* AnyOrUnknown */ | 16384 /* Void */ | 58982400 /* InstantiableNonPrimitive */)) || !!getAwaitedTypeOfPromise(t);
        });
      }
      return returnType2;
    }
    const iife = getImmediatelyInvokedFunctionExpression(functionDecl);
    if (iife) {
      return getContextualType2(iife, contextFlags);
    }
    return void 0;
  }
  function getContextualTypeForArgument(callTarget, arg) {
    const args = getEffectiveCallArguments(callTarget);
    const argIndex = args.indexOf(arg);
    return argIndex === -1 ? void 0 : getContextualTypeForArgumentAtIndex(callTarget, argIndex);
  }
  function getContextualTypeForArgumentAtIndex(callTarget, argIndex) {
    if (isImportCall(callTarget)) {
      return argIndex === 0 ? stringType : argIndex === 1 ? getGlobalImportCallOptionsType(
        /*reportErrors*/
        false
      ) : anyType;
    }
    const signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);
    if (isJsxOpeningLikeElement(callTarget) && argIndex === 0) {
      return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
    }
    const restIndex = signature.parameters.length - 1;
    return signatureHasRestParameter(signature) && argIndex >= restIndex ? getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), 256 /* Contextual */) : getTypeAtPosition(signature, argIndex);
  }
  function getContextualTypeForDecorator(decorator) {
    const signature = getDecoratorCallSignature(decorator);
    return signature ? getOrCreateTypeFromSignature(signature) : void 0;
  }
  function getContextualTypeForSubstitutionExpression(template, substitutionExpression) {
    if (template.parent.kind === 215 /* TaggedTemplateExpression */) {
      return getContextualTypeForArgument(template.parent, substitutionExpression);
    }
    return void 0;
  }
  function getContextualTypeForBinaryOperand(node, contextFlags) {
    const binaryExpression = node.parent;
    const { left, operatorToken, right } = binaryExpression;
    switch (operatorToken.kind) {
      case 64 /* EqualsToken */:
      case 77 /* AmpersandAmpersandEqualsToken */:
      case 76 /* BarBarEqualsToken */:
      case 78 /* QuestionQuestionEqualsToken */:
        return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : void 0;
      case 57 /* BarBarToken */:
      case 61 /* QuestionQuestionToken */:
        const type = getContextualType2(binaryExpression, contextFlags);
        return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ? getTypeOfExpression(left) : type;
      case 56 /* AmpersandAmpersandToken */:
      case 28 /* CommaToken */:
        return node === right ? getContextualType2(binaryExpression, contextFlags) : void 0;
      default:
        return void 0;
    }
  }
  function getSymbolForExpression(e) {
    if (canHaveSymbol(e) && e.symbol) {
      return e.symbol;
    }
    if (isIdentifier(e)) {
      return getResolvedSymbol(e);
    }
    if (isPropertyAccessExpression(e)) {
      const lhsType = getTypeOfExpression(e.expression);
      return isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText);
    }
    if (isElementAccessExpression(e)) {
      const propType = checkExpressionCached(e.argumentExpression);
      if (!isTypeUsableAsPropertyName(propType)) {
        return void 0;
      }
      const lhsType = getTypeOfExpression(e.expression);
      return getPropertyOfType(lhsType, getPropertyNameFromType(propType));
    }
    return void 0;
    function tryGetPrivateIdentifierPropertyOfType(type, id) {
      const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id);
      return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type, lexicallyScopedSymbol);
    }
  }
  function getContextualTypeForAssignmentDeclaration(binaryExpression) {
    var _a, _b;
    const kind = getAssignmentDeclarationKind(binaryExpression);
    switch (kind) {
      case 0 /* None */:
      case 4 /* ThisProperty */:
        const lhsSymbol = getSymbolForExpression(binaryExpression.left);
        const decl = lhsSymbol && lhsSymbol.valueDeclaration;
        if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {
          const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
          return overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper) || (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : void 0);
        }
        if (kind === 0 /* None */) {
          return getTypeOfExpression(binaryExpression.left);
        }
        return getContextualTypeForThisPropertyAssignment(binaryExpression);
      case 5 /* Property */:
        if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {
          return getContextualTypeForThisPropertyAssignment(binaryExpression);
        } else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {
          return getTypeOfExpression(binaryExpression.left);
        } else {
          const decl2 = binaryExpression.left.symbol.valueDeclaration;
          if (!decl2) {
            return void 0;
          }
          const lhs = cast(binaryExpression.left, isAccessExpression);
          const overallAnnotation = getEffectiveTypeAnnotationNode(decl2);
          if (overallAnnotation) {
            return getTypeFromTypeNode(overallAnnotation);
          } else if (isIdentifier(lhs.expression)) {
            const id = lhs.expression;
            const parentSymbol = resolveName(
              id,
              id.escapedText,
              111551 /* Value */,
              /*nameNotFoundMessage*/
              void 0,
              id.escapedText,
              /*isUse*/
              true
            );
            if (parentSymbol) {
              const annotated2 = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);
              if (annotated2) {
                const nameStr = getElementOrPropertyAccessName(lhs);
                if (nameStr !== void 0) {
                  return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated2), nameStr);
                }
              }
              return void 0;
            }
          }
          return isInJSFile(decl2) || decl2 === binaryExpression.left ? void 0 : getTypeOfExpression(binaryExpression.left);
        }
      case 1 /* ExportsProperty */:
      case 6 /* Prototype */:
      case 3 /* PrototypeProperty */:
      case