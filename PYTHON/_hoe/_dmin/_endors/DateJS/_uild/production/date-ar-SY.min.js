'use strict';

const { collectStylesheet, computeStyle } = require('../lib/style.js');
const { pathElems } = require('./_collections.js');
const { path2js, js2path } = require('./_path.js');
const { applyTransforms } = require('./_applyTransforms.js');
const { cleanupOutData } = require('../lib/svgo/tools');

exports.name = 'convertPathData';
exports.type = 'visitor';
exports.active = true;
exports.description =
  'optimizes path data: writes in shorter form, applies transformations';

exports.params = {
  applyTransforms: true,
  applyTransformsStroked: true,
  makeArcs: {
    threshold: 2.5, // coefficient of rounding error
    tolerance: 0.5, // percentage of radius
  },
  straightCurves: true,
  lineShorthands: true,
  curveSmoothShorthands: true,
  floatPrecision: 3,
  transformPrecision: 5,
  removeUseless: true,
  collapseRepeated: true,
  utilizeAbsolute: true,
  leadingZero: true,
  negativeExtraSpace: true,
  noSpaceAfterFlags: false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20
  forceAbsolutePath: false,
};

let roundData;
let precision;
let error;
let arcThreshold;
let arcTolerance;

/**
 * Convert absolute Path to relative,
 * collapse repeated instructions,
 * detect and convert Lineto shorthands,
 * remove useless instructions like "l0,0",
 * trim useless delimiters and leading zeros,
 * decrease accuracy of floating-point numbers.
 *
 * @see https://www.w3.org/TR/SVG11/paths.html#PathData
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
exports.fn = (root, params) => {
  const stylesheet = collectStylesheet(root);
  return {
    element: {
      enter: (node) => {
        if (pathElems.includes(node.name) && node.attributes.d != null) {
          const computedStyle = computeStyle(stylesheet, node);
          precision = params.floatPrecision;
          error =
            precision !== false
              ? +Math.pow(0.1, precision).toFixed(precision)
              : 1e-2;
          roundData = precision > 0 && precision < 20 ? strongRound : round;
          if (params.makeArcs) {
            arcThreshold = params.makeArcs.threshold;
            arcTolerance = params.makeArcs.tolerance;
          }
          const hasMarkerMid = computedStyle['marker-mid'] != null;

          const maybeHasStroke =
            computedStyle.stroke &&
            (computedStyle.stroke.type === 'dynamic' ||
              computedStyle.stroke.value !== 'none');
          const maybeHasLinecap =
            computedStyle['stroke-linecap'] &&
            (computedStyle['stroke-linecap'].type === 'dynamic' ||
              computedStyle['stroke-linecap'].value !== 'butt');
          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;

          var data = path2js(node);

          // TODO: get rid of functions returns
          if (data.length) {
            if (params.applyTransforms) {
              applyTransforms(node, data, params);
            }

            convertToRelative(data);

            data = filters(data, params, {
              maybeHasStrokeAndLinecap,
              hasMarkerMid,
            });

            if (params.utilizeAbsolute) {
              data = convertToMixed(data, params);
            }

            js2path(node, data, params);
          }
        }
      },
    },
  };
};

/**
 * Convert absolute path data coordinates to relative.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
const convertToRelative = (pathData) => {
  let start = [0, 0];
  let cursor = [0, 0];
  let prevCoords = [0, 0];

  for (let i = 0; i < pathData.length; i += 1) {
    const pathItem = pathData[i];
    let { command, args } = pathItem;

    // moveto (x y)
    if (command === 'm') {
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }
    if (command === 'M') {
      // M → m
      // skip first moveto
      if (i !== 0) {
        command = 'm';
      }
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      // update start and cursor
      cursor[0] += args[0];
      cursor[1] += args[1];
      start[0] = cursor[0];
      start[1] = cursor[1];
    }

    // lineto (x y)
    if (command === 'l') {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === 'L') {
      // L → l
      command = 'l';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // horizontal lineto (x)
    if (command === 'h') {
      cursor[0] += args[0];
    }
    if (command === 'H') {
      // H → h
      command = 'h';
      args[0] -= cursor[0];
      cursor[0] += args[0];
    }

    // vertical lineto (y)
    if (command === 'v') {
      cursor[1] += args[0];
    }
    if (command === 'V') {
      // V → v
      command = 'v';
      args[0] -= cursor[1];
      cursor[1] += args[0];
    }

    // curveto (x1 y1 x2 y2 x y)
    if (command === 'c') {
      cursor[0] += args[4];
      cursor[1] += args[5];
    }
    if (command === 'C') {
      // C → c
      command = 'c';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      args[4] -= cursor[0];
      args[5] -= cursor[1];
      cursor[0] += args[4];
      cursor[1] += args[5];
    }

    // smooth curveto (x2 y2 x y)
    if (command === 's') {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === 'S') {
      // S → s
      command = 's';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // quadratic Bézier curveto (x1 y1 x y)
    if (command === 'q') {
      cursor[0] += args[2];
      cursor[1] += args[3];
    }
    if (command === 'Q') {
      // Q → q
      command = 'q';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      args[2] -= cursor[0];
      args[3] -= cursor[1];
      cursor[0] += args[2];
      cursor[1] += args[3];
    }

    // smooth quadratic Bézier curveto (x y)
    if (command === 't') {
      cursor[0] += args[0];
      cursor[1] += args[1];
    }
    if (command === 'T') {
      // T → t
      command = 't';
      args[0] -= cursor[0];
      args[1] -= cursor[1];
      cursor[0] += args[0];
      cursor[1] += args[1];
    }

    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
    if (command === 'a') {
      cursor[0] += args[5];
      cursor[1] += args[6];
    }
    if (command === 'A') {
      // A → a
      command = 'a';
      args[5] -= cursor[0];
      args[6] -= cursor[1];
      cursor[0] += args[5];
      cursor[1] += args[6];
    }

    // closepath
    if (command === 'Z' || command === 'z') {
      // reset cursor
      cursor[0] = start[0];
      cursor[1] = start[1];
    }

    pathItem.command = command;
    pathItem.args = args;
    // store absolute coordinates for later use
    // base should preserve reference from other element
    pathItem.base = prevCoords;
    pathItem.coords = [cursor[0], cursor[1]];
    prevCoords = pathItem.coords;
  }

  return pathData;
};

/**
 * Main filters loop.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
function filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {
  var stringify = data2Path.bind(null, params),
    relSubpoint = [0, 0],
    pathBase = [0, 0],
    prev = {};

  path = path.filter(function (item, index, path) {
    let command = item.command;
    let data = item.args;
    let next = path[index + 1];

    if (command !== 'Z' && command !== 'z') {
      var sdata = data,
        circle;

      if (command === 's') {
        sdata = [0, 0].concat(data);

        if (command === 'c' || command === 's') {
          var pdata = prev.args,
            n = pdata.length;

          // (-x, -y) of the prev tangent point relative to the current point
          sdata[0] = pdata[n - 2] - pdata[n - 4];
          sdata[1] = pdata[n - 1] - pdata[n - 3];
        }
      }

      // convert curves to arcs if possible
      if (
        params.makeArcs &&
        (command == 'c' || command == 's') &&
        isConvex(sdata) &&
        (circle = findCircle(sdata))
      ) {
        var r = roundData([circle.radius])[0],
          angle = findArcAngle(sdata, circle),
          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
          arc = {
            command: 'a',
            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
            coords: item.coords.slice(),
            base: item.base,
          },
          output = [arc],
          // relative coordinates to adjust the found circle
          relCenter = [
            circle.center[0] - sdata[4],
            circle.center[1] - sdata[5],
          ],
          relCircle = { center: relCenter, radius: circle.radius },
          arcCurves = [item],
          hasPrev = 0,
          suffix = '',
          nextLonghand;

        if (
          (prev.command == 'c' &&
            isConvex(prev.args) &&
            isArcPrev(prev.args, circle)) ||
          (prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle))
        ) {
          arcCurves.unshift(prev);
          arc.base = prev.base;
          arc.args[5] = arc.coords[0] - arc.base[0];
          arc.args[6] = arc.coords[1] - arc.base[1];
          var prevData = prev.command == 'a' ? prev.sdata : prev.args;
          var prevAngle = findArcAngle(prevData, {
            center: [
              prevData[4] + circle.center[0],
              prevData[5] + circle.center[1],
            ],
            radius: circle.radius,
          });
          angle += prevAngle;
          if (angle > Math.PI) arc.args[3] = 1;
          hasPrev = 1;
        }

        // check if next curves are fitting the arc
        for (
          var j = index;
          (next = path[++j]) && ~'cs'.indexOf(next.command);

        ) {
          var nextData = next.args;
          if (next.command == 's') {
            nextLonghand = makeLonghand(
              { command: 's', args: next.args.slice() },
              path[j - 1].args
            );
            nextData = nextLonghand.args;
            nextLonghand.args = nextData.slice(0, 2);
            suffix = stringify([nextLonghand]);
          }
          if (isConvex(nextData) && isArc(nextData, relCircle)) {
            angle += findArcAngle(nextData, relCircle);
            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°
            if (angle > Math.PI) arc.args[3] = 1;
            arcCurves.push(next);
            if (2 * Math.PI - angle > 1e-3) {
              // less than 360°
              arc.coords = next.coords;
              arc.args[5] = arc.coords[0] - arc.base[0];
              arc.args[6] = arc.coords[1] - arc.base[1];
            } else {
              // full circle, make a half-circle arc and add a second one
              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
              arc.coords = [
                arc.base[0] + arc.args[5],
                arc.base[1] + arc.args[6],
              ];
              arc = {
                command: 'a',
                args: [
                  r,
                  r,
                  0,
                  0,
                  sweep,
                  next.coords[0] - arc.coords[0],
                  next.coords[1] - arc.coords[1],
                ],
                coords: next.coords,
                base: arc.coords,
              };
              output.push(arc);
              j++;
              break;
            }
            relCenter[0] -= nextData[4];
            relCenter[1] -= nextData[5];
          } else break;
        }

        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
          if (path[j] && path[j].command == 's') {
            makeLonghand(path[j], path[j - 1].args);
          }
          if (hasPrev) {
            var prevArc = output.shift();
            roundData(prevArc.args);
            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
            prev.command = 'a';
            prev.args = prevArc.args;
            item.base = prev.coords = prevArc.coords;
          }
          arc = output.shift();
          if (arcCurves.length == 1) {
            item.sdata = sdata.slice(); // preserve curve data for future checks
          } else if (arcCurves.length - 1 - hasPrev > 0) {
            // filter out consumed next items
            path.splice.apply(
              path,
              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)
            );
          }
          if (!arc) return false;
          command = 'a';
          data = arc.args;
          item.coords = arc.coords;
        }
      }

      // Rounding relative coordinates, taking in account accummulating error
      // to get closer to absolute coordinates. Sum of rounded value remains same:
      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2
      if (precision !== false) {
        if (
          command === 'm' ||
          command === 'l' ||
          command === 't' ||
          command === 'q' ||
          command === 's' ||
          command === 'c'
        ) {
          for (var i = data.length; i--; ) {
            data[i] += item.base[i % 2] - relSubpoint[i % 2];
          }
        } else if (command == 'h') {
          data[0] += item.base[0] - relSubpoint[0];
        } else if (command == 'v') {
          data[0] += item.base[1] - relSubpoint[1];
        } else if (command == 'a') {
          data[5] += item.base[0] - relSubpoint[0];
          data[6] += item.base[1] - relSubpoint[1];
        }
        roundData(data);

        if (command == 'h') relSubpoint[0] += data[0];
        else if (command == 'v') relSubpoint[1] += data[0];
        else {
          relSubpoint[0] += data[data.length - 2];
          relSubpoint[1] += data[data.length - 1];
        }
        roundData(relSubpoint);

        if (command === 'M' || command === 'm') {
          pathBase[0] = relSubpoint[0];
          pathBase[1] = relSubpoint[1];
        }
      }

      // convert straight curves into lines segments
      if (params.straightCurves) {
        if (
          (command === 'c' && isCurveStraightLine(data)) ||
          (command === 's' && isCurveStraightLine(sdata))
        ) {
          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve
          command = 'l';
          data = data.slice(-2);
        } else if (command === 'q' && isCurveStraightLine(data)) {
          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve
          command = 'l';
          data = data.slice(-2);
        } else if (
          command === 't' &&
          prev.command !== 'q' &&
          prev.command !== 't'
        ) {
          command = 'l';
          data = data.slice(-2);
        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {
          command = 'l';
          data = data.slice(-2);
        }
      }

      // horizontal and vertical line shorthands
      // l 50 0 → h 50
      // l 0 50 → v 50
      if (params.lineShorthands && command === 'l') {
        if (data[1] === 0) {
          command = 'h';
          data.pop();
        } else if (data[0] === 0) {
          command = 'v';
          data.shift();
        }
      }

      // collapse repeated commands
      // h 20 h 30 -> h 50
      if (
        params.collapseRepeated &&
        hasMarkerMid === false &&
        (command === 'm' || command === 'h' || command === 'v') &&
        prev.command &&
        command == prev.command.toLowerCase() &&
        ((command != 'h' && command != 'v') ||
          prev.args[0] >= 0 == data[0] >= 0)
      ) {
        prev.args[0] += data[0];
        if (command != 'h' && command != 'v') {
          prev.args[1] += data[1];
        }
        prev.coords = item.coords;
        path[index] = prev;
        retlet util = require('util');

let logger = new (function () {
  let _output = function (type, out) {
    let quiet = typeof jake != 'undefined' && jake.program &&
        jake.program.opts && jake.program.opts.quiet;
    let msg;
    if (!quiet) {
      msg = typeof out == 'string' ? out : util.inspect(out);
      console[type](msg);
    }
  };

  this.log = function (out) {
    _output('log', out);
  };

  this.error = function (out) {
    _output('error', out);
  };

})();

module.exports = logger;
       b`כŵO&^nE-+i1ۣj	^AB1]wEvYƆp<V~yѫUL
`޶؉"jjJ'q\p49K6Ufwr߶8)6NgE\vd[.e]bB<v2;yNu"7<3|Qu(N{J̍o "KV"숥k^_(c6l b.7V:N0GW`ܕZs$̍	94a-~Y5c87(|%UA><D&͇͗LP Xɩ"6V!ͬFZ@@";,=>|vCM.[%Bz<1T60so멒.,G8"=z*lT"	b+akq {$2y#Ek7l݁2aU\4¦-2p'VS/riDqAcWjtEY,]W5V>95n3}!OU4X6O"[
bPm+8fYq*ބSfKpmi]\$bxuVMwm2vdҷf%PH&s~n&sWY:CbĄrU/%	K-#Dz;ȭ/.h]%UWȞky__vݟB+v<=	=6"^l%ptY {BNȭm/")tvTՃh,0<orݗ{wp>ZVSjTo
IԣQ1(Cj!@EW?޶_ܗ3l2! 
!g8*#V	qpD9Ӆ  6?R'lJ3̄5sL*:g4=Hfsoj3ѥ, O.$'x٣P9 cRO6l7/Pw[x]M%W*aBfѕNjzgļgm"^COԞдZfy;2eS@&А$6wybn4<cſW&IpA 茟օ>G1$7QxgBoԠVm.2oTLEuG
6+-[k)ץ(?,pyS:WL Fhy)"X͞jl5(T)?{ډRkh/uhɓEǢM>ĄWYK<-Mw\G{J-[Z~11Fz՘$*g
T\*gAۜzqhkWg1ϼ	1[0x?(k05YjukpHc GjA\3Z>J~Sbr>Őqzr@.6dKv<`z[%SL?ַ;ylMfct|>Q=nX#RB @W}W)׍Uq^v |Xv/kaXk{NMVڨ"7%j h󍼔;OjZ}{,bƹW5clǶLM:*\i
PݫZ=QTXZT_{M~>/i=(n0e?u3"ͮv8Wpud:B%/MF@>F>f7ITڊ\4c&a1VRL۽#?_蹛R
a>	l+3)	,'.oD@&nIր2e׃9F*t@HƋL|f@GcpڈV]fˡiXiCx7*gX9%}qj@-
o+CN5dިޯ6׃rEZ#EIcrݽkY`gRWgeђ5a0{!G GG?c	T9w+iC_LoZ1jBAbo2Rx>"4U?k:;Ї&9ȁ}{O
w-gr?@>Z0ș9Z(Gx=ubg%g(AY"l=eix#c;];c"&8Fi=5R@#5X<ӄ~\;@K$؛/3֧i߈[,4M1)cc_x:](!@bv9dY$c(^"NV ~[Qk u5̚7On+d#pVn`xXSG)>-Kۥ籟|?-gc0iLѳ9Nk$
jh?_[AeyjV⼜Rlu$@\@C#gs G>b{n6*iY:DI"yi%O^lhbh&I*mA{n-RIayF?l(w4ea@+6OQMU1$֚oE\dkKw͉-:5M/~znv4򻮎X׿r%p/-B*d:=%覟Y="4L4
P@儛(Y|Ƣt<)A~CFײp(BeOO>b(ܬU]:4Oȿ4aO4H8GzRYQ%B\QlwHB98,]3/FX׼rOEK-sD!lձ"fX%Yh|/m6{m`(KuݐC[	9"<]$:s'=	'A[Wr{pjw6 7&XQKF$nQgCerĂ7KLNdMQ;(yU6;܈YydNUEėgE\L߫0z}%oL<Q^ө_q18CzKgG\Simav9QK'X"kBr.mk$}^pf/q
Οw' Boq!Ǭ[ցo[^;9G/çRDB/Z\Gr?&̧~V}<yR|`T`\R&A;4q	@1`fhb.оx7wm_vsc=-91:(÷1˲["f(PDB}C8/ZAK%>rό};kܺB1ˬ24(׃DvW'j/!0>2ف=4ww&P_Toa*M[ޙhn-7jJ1^
Yٻ?*ukʈkӰ<ˈ^A~ q/OXpxfjfFz.S4[3cpQ}Ze)BGDhdq3L^i5ZT&O,/TE!INvE"f-m.[gK$i	uj*yUOJql8Ru4BBXѭVu$Q94V+Y*_wwo	gnޯAH,0Nɘ8$lN/xzJ]%n~VB[4,>_7+x>u
$k13X 0ȡlM`͋Jȳ~i˝9 Z$}kpzLNFwūyI'3BYYzt\C('[]fz3( `olmɅFlpM`j*-<+x{0|CvІ%1:GD2zE-ۖ)OTYL&6\cynGo?t)$ duu-	1sU9<v)jc0j0FOK]Gߏ[\*;.Cľau]%BB0Ls*YJXU6h|NV2g`/p۱ۡw#@|U}~ 9]ȔʤiN[XnG2alcۘ<09Ģ' ~hDxOd2x5A< JL@YO'@_$"XA΄J᭾(RSD4L*" ̻ҡ8m"q`j{/Rob;̽"-}m*/?4uxwdwqz8,j[XF+O
l6%ȯ}*/IF}lᔖ%7iVjmדT>	t1´Hڌe3s=#y#bNr8\v>ՎAMvѬȥ&< Tw.uKM2X['iP|O>TwB-{aE05%"\1mh.@4`Wp̖	|[ESddghtE:[}-vw0^ڴpp#18<QӣBF]ӆZf!Q2ծ=Jj@^]%8pŎ,<h2M)F}EsU EP>kl~9wNo?suQ1|
`pٚ4Hؐպ+9ùqR߁M_8v,rT0xd2ld=!=k&f{zmY=W-&--kw`1|}W
:+3ʣfQ^/g{'?HՒ6/7)vAtKXc"raY愕q2snbҼsI\'nzi\pW)G׺Ig?^o|J])ϼ.UyXſAp'cj	lVd^y;ϬQY7D^M[V8~fcquW/&;8x{3y	]d%!#ynEV{3v߮k@]P,;ac]yCŌ?M0qgi}3ǆ$z9rɿ[]QH{]BjXMϖj ~Yi#rm	';IB6L;v_Kau1zE90d0qU< #kj	ǳsK`(ImJٟA՚%Ɯ?(+gNX2(oOHXNFG-tTrUS=(*<>7eӈaW"edUݹ$k긅&;~,v@^͜C8I+Mhl@K2ynzP΁nW#1Ll;\MJU9ֿex}qGRCŲ/$ܬbjG--_#lݡzQ#Dx$            LAKgl"Iev4tӪPܶt]\(.9/?Iˢ<DR&QXDCn[2qNaQٸþ_ՁУQ0Ċs1%he9NDL}W=7$Ę B6(Lo3%Hu>!,CRzh K2Er#!d8*&ׁUbExCe݊h"$t9ťGݨɰ*_w\?=~T!>^+.HDZ朓Qmd KTwޫ%*/>åqUڟdɓb%<Os?d*8Cө9Gn PMbF;8!O/Qy贤VBi׾&)SEMuX)%C#wҫ#u"[E*2WÚJ_@TE pg|&1d;vT,GtMX()'*';_^0O&?AE6@jc^:D=˵
=	݆ ]~M-lTHz{\l+a!AgHwy6pWڅ9r *]߶y+ik=\˂1^w`.\RB}|	H\Yj4sM(V(^&y=AYi8q'HnG)\Gk?0Od{~;k}sp7q.8l/?J`_gj#Ä́Cz`tY}.1PQD)D:	4ܲIGh5%JmϦ);v.̄)AQ=	l}m젝աW2ץҐ0FF
l˷+D/yvdۍW^͚!*ٞyi4?QmQꞅsn~/.1hߙ^l:F͞y:|Xoۘp*})RB89Q^{*SQ[F>Q]1d;^FELM/}s֪UXLT18DChSݵWdp7Pz	&YS+.b=|yc֯0C|~XDC$Dyd9 9O}U!f|[	\]xbwC^h+$mOxC_kKEy߿S>{8CR';^}g~ཀྵẺ?X*6Ɲl#$#"PY lրBpe#N-&-X*t˲l*Y|˔1]\os$b-yr.;p4c/A|U楰pz U_48D:.Kho;RfPKCaɊ٧ޯDX4UxCsȪȳ1-.<mO]$.&rDJ7MǀWLcO^uC=.Ƅ--LwJR[vlnmPM+aO+_IʙbXO8XO%z=|.C|{:ce40lyd򭐖t`dC>^7*G3EaYuPoy~KR8w=yvo=ކX		Y 7iJNeoP4s#_g.;ȿ@(r7$7,~-EŖ61&1ܪkC1TOSĤ[S$eÂU[vp2O*ޙP(jUKLXci KHs#^?u(Z`M9^"3^u1R/sVڞR!%iZ8f6ФSTH!W.zEF/ETEQvX!BKJKk)Qk&"!-E!w8k24uC3q]CG_	'T>
YNwAh0|pKs*^"rc),Ye&!ŐN2AN%V&6&O,?a~o%IZ(5 \QK߬hmZĘT,e6A3BkC˥4
eߔJW_z':R|!0/\
O,[DJ((!|;Pf*ߝ")5>_N$dF$jܦi:Lw&˥rUψ`G4$11Q
:a:s`:i+8i#
J[OVq#9iA9~Exdx`L<oXqֻMkZE)R;@ǂMf>S=b]-[
'tMn4ݠ`$)[c.2?dmG-An+W9FG(AEA5tʫ$Yo0iNme^l`ǳ^aPU f /F	2qukO-oo|[3Y	0Х3&;=VEuL*?Z >AsKoU'w2J1̉~5-i)4е%'lST0AYZ1-u-.juK](p"98E*7}X,M>C)i~+mڤr]h5=lEǴ3B.%^pZt`FRh㓆7哶eU(?Fd &%7/V'뀑ت{=xiڠiNMph,%bXEKÞzJQǫug֠γRV7Tq辰`R[MQRR	dT$T1Юy.U/8QXUm@g3x~U}DbdGMYPJ~ER1+,sf
rm Mk_YweVɹ|=+3fDeMk9%\x0.*=(LV]t%04LNLwW%*r`"u:N%d"rTjof}:t7ZrXzx }1z푬/Lqmv@ٝ+~hؚלϧ>.u{{jAe3uv֨HVϘ0d'~ x\ŝZ#(B>9iSѶ}h}%5(4;wQUz;y<$Q#Խ::q?7Ie`lY=Z,e@Wdͼ)s6d <91~W-Zf@2W@J,%ZqS >NO3G~u6U ܪ3W;~Ԏks ޷i3 0M?zg>:)KtĖl򖢖xcJhe'mD	뚽# ;{njyZP/LC44{5*<(f)9sn~b8A::Ϗ8;FM0R;߻!C:Jhcc ɚ"WYId-aiɣ\xS|A֛;t@}IcSss2 i \Q*߀(Et˂7e˦VmdtBF7[)~s3o6ݪ~)O 粴%'I[W~[[D;Sli3V$J)HExw0X&üpNw0Mo.:|jA#S2HEa}Лq_5un;A,yKij:V kK7H=뜝oRQ.ߑEcތj-&=jq&'W7'*Z\[Oh;/`Q>/&	U	ov)9iCunG-{=g{$EUXM/΅ӌcχ\ӏ{uVf}hnvѺ]7 Y5/mr$_>A?qYanS?8#== 0 -RN4Ȳ,[KyFS2Q# rNˌ@u@4^G+'EoɦN m@%ӔdGr/EL`d0Hvc[rfQ0P?}5>*袷 7SYhk_1K4P*jA1P`rV+
Ǯ;E/x

̌ZVsUM6?cfh0.i+3ՎYdsY(ry!rB= si$3ZC u)AU1#ܰ9rm| &ZrPY׿;*OGS0o
>*j=֎uO34:ڟFBt@57x5xU@SbZ9S}]pV!O,AHap64P!3Q)뫳u^5ZFy2v}s3C&C}kiQmpK\%N?_UASjONz0VeLE.cc
ĈY/TgwiJfcA0
p^#ԕM8[n28$t,`j)}o&=	0wEɚ(B8#QsC/B=w
{QTN:/ztbmQ3:aŔƏ!@6G6ğI-SbQ}7|%i
1;4!a{5RrV|>vMwIz4v@yt#½<e @#ӷ(9SЧCz%`MW?iGXtOp?r4@:{c9V2}/ELFBmWhgo!o^;j@=qд<&~7wlu+!(73GD:>BB){(+;*IhkuNP&-#	aT0],"LkkY>fn|b
DTY/Ws^_褎,+%b,g!-ՙG.A-,G9sUsw##JYtS^?l(y@F `+	E~I6Q)J_2XY-$-d8$*5e_B30%Nګտw?BP_gd	 X7δ(1L5V7Dy!H{\
`m3R('~ݷLګ[:U<m/"yKvȒqު6~锿/vLA0Vr%௡/?R .qL-)x*\
ǊSS3"~mFE68(+Ex"jQHJ^.^L;e^\9uX٥e:uIH$!(&s``J@db!_]{'P$0yw4],䇕5v~ɠJg{ŨZo8-	s76Ҫ&6is6L}h~<EHIqj>kR<dFo᧼V*з[o(FH]Ά4ǣQޣ-t&+Ubt# կFq}9O)<VCtS"p;%JK좧:)c/>k	et#BZ54R>FKxy%"P+E3=>#q~6>fo/i´(tU_ovQ6{<)KBHr5UDsgۆB3TAt\Z,6HmǴj>FPFߠ,\G~0S!aE_nj51В/IWg^c뤇m|A`=,a72	x͊6"AHMpH6sN /65&߻[;T+/E;jÖ!ɖt)P'at`NYAtz@Rv
OxWi8ɕ}C#$#=Qڊɛ ͙QXdЬ7`܉oVF8e %t*䦿ir)v9!ˮ\#zӨ6>A.IV;#?H!`[H
X
,spMgQ 'OLaXG2C;П%Q-<܅qC[PׁDrVX&f\!0Iz)uToR6e[WMi=0sn7׃a8Q}UU-MDE# f; nhFN:S{%51|/565@X<^SҲt'4`U'7#r@SP"YcV4Y6ڜz^DX{`p=?p8g3pB ^x-YޥCGJ8Vm".څbn+߂iÖ:"ￜ"1p!)(ͳEPvyfW\K?^) dIGB@>z_/OyV4i&uQ9Ǹ^{ֶ!Y5t|EB]YqǓVq TbEidOSdGcߤe\X-`Lmg 論XK{^~&A\d_Ð6^,.mO)P4 |9mH8Lt9H:HA,7n80{+x6t>+ ēy@HKW[Ȯ0]aIɉL$|    !$	dd
A=ъJ 
xͻ;wnjC{a|X⮦3o@S${xWLb(,Rogw_WoK(Wu^ZtPx#0mJU|ko[7W_,G7Z`903vŋ>9Uʇ._+"Q9=Tf_%ӫhPM}7,s MwnLbu_J2w?7+ĦuT[=FF!H;L	|%Zp!( ̭9u&*EDIR2sT\jGfWw޶"bu<wB=tȲ>)Fc6\81_@A|;Fpi'agit5*:1@
K$2{k;xL]vK'mzv{tQ,3T!=t6E6҇8jUeVKƨT@-6h`_6ʷ='ZTz^Fe,vʥ﷼	Z(YsVn4M6僧u[}K2FXL'!!r!*ÁP؂Cw9ιֶIRTS`yqQ&=WNk՝jI)<r+NAaU"͕ޯwԆ̂LNQn<oGjGZ#Q2DKͬTg7OcT9#Zܑ>uXv߉틮3<o^i{Hz6Hf   TX34a	=A6.NBAgdpC$LT6F2W HVT^6dVImjXwƟ/1J%
+UϏo<&ZeyR)teL4\qp}b  |ASSLܒ΅?c-uR$^dƼ VR_i6@M0s{׽8IXq (8Kd)0~Jg7]ϞD uwSɃgbFDDl\!S*rFї80;Si
3K&G!vp(iiѳǯ IH֤ƺ83.a*#qVWJPWε))Y2/)g0os59,ZIyWڢߴאw7cBHW7=UL"^2R//ҕQ܆*́f-=ީR(R[&~HVMzX-ä='AJ2t|G?>LNi7l%0HJ%=/%;Nc<SP%Ch?0)1@dFӃ9WI:si}`SM|#65-`JVx3Bv2_tr7%0amb|}@kv!v(1mS+%indD2Զ̠y5f ƃ(0kHa7;Ns`q 9C{>78(݃R
D%$ijNJ0]z.@̲MgK9A,,K-ʫ[!?o$#1
glvJp$7c_TEA{+97Iժ l.k1S{B:*f*m"zXף~y{OlY㢫'\ 7ݮ~Xf/<'d.En¬Zt<'c9+#0m{&BܭU`oڍѤR:m}S*ڮbtrb5GO1HgJzUG/̹sUP}Uo{TVs بm繬ۛ&
A8M%-B#PQo9d]ӟ@uJaZ''cS<-[wؗud<?w566p)L*<Wcjԟ͜=G&*}1' *Sc
x1߲Ъդipp>R`:.Kϊ
od,g	  	;z_A KzO~!A92
ߟΫRY7f[Aj.Sj}0Knx[M^%m3ey&ΆKԜi(>]`ϯZk"o/G\U,"'KV` e:$7LSFE|fXĎ:Kwr/=>Vҥ3A7is㚮&DTh0R8E><+S@5E]Ӊkk{S2bm2#ځr{EZ0),QZ0F=3g&@hާN6ob
2 DOTlc}lU4?JI-5Der\ƭz8ǌ)X/x}=.)uXF6E;;~b5cn12%!NĒf6	Huhln٪*C}b1w\u]LƬ>Ty;E+1N.iJL/촵M`R,<+&oQ'<{Ql(LTM8fO*
Gx-l i{pJ	a;:ТQP ]g~]l ^U0"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assignDefaults = void 0;
const codegen_1 = require("../codegen");
const util_1 = require("../util");
function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
        for (const key in properties) {
            assignDefault(it, key, properties[key].default);
        }
    }
    else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
}
exports.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
        return;
    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
    }
    let condition = (0, codegen_1._) `${childData} === undefined`;
    if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
    }
    // `${childData} === undefined` +
    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
}
//# sourceMappingURL=defaults.js.map                                                                                        +E|!Rϋ3:Y dp9g$78b5'~-Z5DF`kDClRFQI^f#I8s4>ͨ>
aL6])1"vn|+A[UTnPCԧ{lMwG;uGutˌJjC<фF&{+Q=^д!:rɑc̦9\Ig>NfKi@o?3O[YBζ6"#M`UCl_~w]aeNZ FK}A#Mvۺj7`(>g۰9pK#HdHyqSJ7r=?)+fѺ:tV/Y X
Ҩ:Cӕ|λwb'%uwOA!{ߕ 	7Ԛvn2
dM^$gM\SU{;XY$A K.(h2__nAa慉:M>vX:=#8|V87$t;^$aK.N8>%$ hj@6On&h%-I$)p\m	HZ)'1CCi~%̸֦d'j`|2(??ɪ磖n%|X'ڦ>see$p,2W"R3/jS.LƓ4!ݘzulI@<3sl]EG]"{T(>:N
c]GEdŕUό9A%zZ ĉPha#a&wV4:/<Dα	IlAq[sPB|0z+H*2WV<	,ױmM>ytb%nȪ>ӈFR_OK^*)93~z#8/o
i,_[EB\7Q-,VXP/X#ck8B&{M79=Rq r3@  eUY'<؜S@y%t4<vT'$ e-)ڳ]+-a7$kco\HKƾֺ+	)uFFJ5l7c<f
H
!
mi="9h,*d0vضTHpXqs/Z= ě(nȫmȐ9쭢DʹgMϊPuPў8E+I݈A [yZE(_;R;
F{`>(1k+
	G@lUd~Z͆+Y!!1
,Jj1SjQOoub0؃Z*X ҅ք*AN@Dݴ9,Yc8U胎:#<8֢:KU~4`NY<#HyП0OG%zpʨuE-h.øɒZ;t:p@ߧ`1*x}هPmxm*\x*h Bg,粇t\9/W%&׭o.!S?|^Xk4Ъ®< 63Ҹq{bܼ$䱲jf_Iq@>WL-}rQueD]\ #dW{P.Br 䅗pPg( hՁMEibiNgi?]/aj<ĸd#*Q39}#SG<Vi+ny Xh~}KΛ{koEDA8 81̮;IvurSJJag=HR]岾Ye zX0&]~4]1˾^[³N'H0?Nl4
{>,;/ciMgk<T=|Hs.HN5`͂"w;x$sDj7ْQU;ch
Ϧ?b	qطԺM`!,?ipJ7UvcfIN!:BpI0sj~\4|vp2lJ!b+#++YbS*C=6>B^Eb񂞵Yr
2QiLr:&#VdmfpE0DQI0`nxA6@3BMZ ;lV,ҷycfhݢb
>n$YlP41ua&^>ֆQmrC~b<wIy'Dy;ҍA z8pr-Pd;P{	70:QYY5P0nh@%
0
9XT8ew8rft!mϪvGsܱc~DlͲ.JF]*P3}6f>v{bg>1S<W|${
oka_us >0ZW}r)3HZXEX~ŌUxbؗ\2mO^bNLlfO:Pnf97B
@ K    !&ÁhP6ާ{ԕQWWPRTEE`KfVA/'+^
+
&m#jWe7 :.B:o
&²[ܫ+ASy?x߻룳<8ԀX,H;x#QqOOhZs)|۬J`tG	UMW[io.mL0tԑW(^) W!LEЅ1'H3@*,7(ñhް~--%V*߷Uc`E歎h_*>?PRT
E:$ !bAh@5ߍ{n1u*L
@*EڌyMNՠKB]{%jF<%
se -+g#Wɧ<NHZs*ݖM)+VYCS(K}qAT!GBy3invrQjq?uo𪋉ʕpȐԙ6xL;}*߅..%GUԪ^2E8 D*Tѓ\lhm3c34T.L5 ǳ*n"JLm=0ja:qFPV5,	@=}on|y37DvOps,J^  <AK|(MĪX6{&,>uYИ+}#ܴ?w[x":$B}OGɲ|_P7T｜'<^`CA]$.x5m$yi9^m^q.jNJ~?F띖*NV+3 < /),W\,[]=̂NǙi`,VERPE"BEV_i"nB@Gs`V!e+#:k1҂vq0S1E08姉K^i4d&іH=Ƭxcp`'#KshgXg$]mcf[l=$@3ꞀOӜx{i\؁:߂E67XD1ͤ U?~uVyVl0FA/fZ|?iDG#Tek}.d9Wq1wN001:h?K-)rɩV1sU_SET|Y#W^oGVmB6%H<MYVgPaz7駋3tZғd2eWI.Z*)r.c}QlE(.A'vWX|GamGg)ZYNG36bExκФKoר]:dY3&2gwn(#heYyPBww4# ; hf))֛&-n(2џ[W[ۃӯMOnwCbvȝkv=-OEdHiDv(FOC|W+Ib(8k2K}y`KLK
)'[_ӗ/81BRkzu. ԛ)6xrcxkMk(~2Cfÿ0qSy@0-A(lC\+M ]
"RU"QbO%Osm0Í&DWt
1s)e_"iI0bZm!U9рxHYJGyI,Z>!bOc͹&zJd4TZrdрrw
libG]KT2Z+@2$} w?T4dи8De ~zWlAxH90n̃MQ:oZ؋`kQ촞A/.#vin)}~Nk"tLŜ)9DX,U@_P٫zȄz.t)_H>3-sKn+N#8#@?D,s^T:e&96@(M	Y7J({N`moREgoo-|BFbhC]Jpj|Cw]op$oU98.Fֲby|\?E$x6`q)Gg4H:JPF"5vvd>6ÞzVk@P2/dL3qPpf&=ܕd!zgsa눆k.^(BjҺ$
F&Z7PS@V:-:Y%d3N&n#0mI~YKnWߕ,Psrr?"|yih򩒈εFWΙzȸ1RfOS[mhI5k85Moj9-@c,Ժ3_LeԷ.cީ g.@jbkc__˦X|Pk!BOG9dևz">aw_"ؘC۔ca0'!4kO/M:HQ	ԁ1ɢ7 nKuwx. eQli>#>ހNStH`۷q#pר<m->XV@7ُf V<h2)!ㆅS燗"% @ϕn\_Pc6։2x`pu$D4>C[Xɋieڃ]t1j୷O15]eíc8T6u NsQݞMI1cX|.`,rΦskUE(Yt]SGJx/Yr/уwTV@wl}aŏ: IһXD[V>у&1)O(xh`?Ld$oIp򸻷Df~u@9Ǫ`vT C.5{Vu@!٣,Rt*Oܕ=ktXlaB-mx8{|^O_ɳX114k~
Dj5Zh,:),_~jN"m4{b&9|/P5n]lW_\2j_ȑom5
EEXjPi2gh?3oȼŘ Cߍ1t|sG.bAQ4#ctm06Hr"̯v_y4o`b1	^?Ը[fN[ hY_5>Eh4KdBtXXrwF LR2G1L˽cϰ6y k?"$\"ǰ`jb#z$i"}^Pk\vr};K&v$BVڴ=r8Rj浸67?7QsC^
/-y^l(LLNk`kxpf|r-S۞mc~4=IR 0mQ{v~F&;:(ݡ9ˡ7ϤPc2WrTʻY[^	ۅͲA$2mB.ڔŔIn~
ްsXf͗yٙ#
&f`g.n-@4\~gY<tcl{W(x ,~>(+؉X"V鷶"A",3	`AzU#AopP)%Ɗj&Q1XI1fj`ɧCY&oN
S*kg[^N@fCbW
{&кeTL%g}H\H6Mi+%=[ioc\
vLEf-mݢs[-YBe;|JX;e	@ob}RiapĜ1ti=M22rƟCRtG)K*(Txk2i1.EcS` })xoLqQPC(ɵe/C螪q4|C0U;"]iT67XSxЋ? >fcK>;qL8 i"ۜz%ͦy _hZ_bg4dr#ֆ_H?md(f4P^@1z0o&@L͵ok_m4ǿBo>%ќ>
Z|+ސ}Bi7U-#6-3.Z ŕ:.Ef/0X*O>?8)îcLp?Lx$AKfX5pTѨ((Yh I?;/d7!!*mr\CjQWbNsDoK^oHacgɒ!ߌYH.9HxVѪt)`R;F+,~no[;MO2~mDvgbg^*[cX5Oa*sYCbkMm U(˿?O\7*zCOm PYO)n.Rkl"ToJgA[*v`Ɵ@޽TF/:Oі5ƧJ℘T`M\o'sCgYŔFs-n<P^(P`;\Ě80pS-0UG}qâ΢#E? c
Wq-Zd:*(]VYL%ӨI,MT";ꃇJ%G?^0AH+{3q}~괷E/ <.Ys_κ
[l
-B6
qlmГP0:zǶ?Lf
^[پ`"FYQ X1%E~7,Sw\[T8;QwL	@YPDZ+u;ds~%iK@D*юZ@9Mp,*h}y4(^"8YKmnP3ϬYGԦfTpJʍ|bVųFayq7bưK*#:<pnzjAM4˂2(܀[)M/KFtF*u$1yoU-1:1I[`v$4|IXU
/i%tNDN]}Sd,@HX#.%pEpei0#lw&Jm)}ۆ|k$ILff/G/KeI\$\mr,)X9Bz܋;*cal;-BUb?\Vܭ 5		)pw@w\UԙP8I__ƴ@hom3ތ5G-Ø0}βޖݧ
UTB{2Fi3}0$`	"Y":VAtؿTs~~c/
~{tI*ɭha'L/RJeIkBls׮#Ƽ0Z7:DE_,kb": R` $<ZO#@yuvFoܿ#4W`VڇHxBOSU>
yEbZcJeEg'@(>,<8(C{rBGKIFϬ"AKUdd
b;~E
(v׵hM3žBAܟ%<Kp(N(fQtL	[hK>pʄfCʰvI?T*Pﻣ7kHDHȼ\CCOȉaw*[\K{!zB/DL((3Vϧ/dη ;0{ù݀4 {lpX(|?r. o#]N@LKP3NQpԛ?Jξnq@<3yQ$mmP0
Er.nhU5ԕ
TmN`raS~9*njdQxm*b4߭rx-{F+eiI*$PcZyCw78:Y⒮f9دE[J8,UWhV)1_-_./D(OȯՓh}boQKK5SWTWo%"hVB`rV#U8YLnos|#jl7XeU̾{(W+F#,XoU-[7\0Tȯ^u1fjRVArb q>8x(älVVj"/XyVc[̅"GߝRCxaL!g6ai!*K1ȶou q1bs 41*G]"k=)Lφµ+#I+uH6a2N8+YHyHW%#Pi%+tKw~9C?"+Ԅ %ߞz<V,\׺y4G4zMݡt]"PIn粊:,)uvވex.(XLog9n36cH5$$JiѾA!wD/)kPY	npl
iO2ݦo
j56[ڕD3A`\fZX#l\~?i_Wv60.A-nJqP7@Yz!ԯ^~>t[ VgaY'o:'=>yC`տv"
K%;ta|ōu=)tK-ߋZ@ODw	J-:郎3!7;;cYz)|灙]vtI, +tSKqe],%y&`bNМVv>˟7ֶwW:;.0WiYa81R_02%Te@0@                <ASD+eߌ%A	M6(Tk@Ŋ~%43W^aӃǂƞIU`.vb_"pNhwh-?q-?<аv?;<;Biz*z,G,P^l*?pITlF/BK]S#	(~DZԕOӆO/Xs&@AGoWVX"FX	o3 Ygf%97cᬔ\U.Q󓡈(8>\̾RwuES	52^}E{h,Պlg&MS!j,,¡gQt1CMp}hDA
!ד
b $Eg\q ؊4ЌmQH.iW4ӑtbΖ}oh$?Epsu#`4xڴ{}8kN	ֺv' }f@>ߜ|7	B*EáqA-ܜ(x&B~`&//;qwzk|.ҋ+Ai>VZ|^N;3WO25&f<N
pHR+ GStp @E=J!q6(v:^?[RP^~#?+uO0{(A3Ͽ?[sgR|1Z~vA?@ab{5dt9o\0t{2Aj^~4z'm֙q|A`t9}6Fw8DY:aDBUD-%8w܃ZR{f ,?Q{S2U&6	j(; p	P|*RY/?X̄Di:V10R	N&g>o>-SWTs_Fnf ^aJD*h(Sy'۳QPl5F&|뢧\fW^%GmpI"e5(=L8l
ڍxWe Y,KdR1>&7Å.2~ڛJ3{k^3D#AGU[5ݿ eywCbM3pYY1үh`UZ	n%n]_Wn$XA0YVD>ey/?ָ,Qi/|yz?>sUʖFiAMV&g!e(g0KZ8vݯs=*uR0>9?a ܥ2;uD(ɺ&0=4ZE<]ʟv蘓0hH2p#&r˸	Ew@ɋir-Guu\:PHzCX-[x~xnﹷ7-hwb#X7u
yV6Y%w 턊##ށ(hgQ81md<{!~SS55D|-ʺDRWДJaO&oeAݓ? ~h]ú&ޛE|7ȏӆwOY:j^GmbCk	%+muzaB`^N1i,[jX G}}o`Ƨ <ۍr:wüd39lopu$s[>V~tRnt7Go4%\$WX!}$Յ9G=^[Oӛ%3}%2  <?5@O/6]Wg 1M;m:GnLqݮŘ}:%%P/JwtJ}CUS#\ي^^ e*zɸtۘ'{W܏Jd(_f#b`݆8JWU[r#*hKS6tHظs N;ů!TWsѼ~joS9$DBlT݊UXFV@+LakE}I#Cv!3hCLbtGHa;O	-/Y,TEù9	ن/phW?+Ý	mVxEL~[+o- \oqk98vק
!rvܵEOICZSi*%F.ɝJoL{A'f0>1aHxz*o<$/ؕS#@^+Il2i#]dlSv\''OFA?sf}(5y"|~Ŀs_Z.ɷ~8l>ֈW{;rW	QMφEcOZ2"ʘ40hĤZuV >ewbqļZj|̠ͭm/jscԥzQ;RU԰E~n<^#^Bۘ/YZQ򠳻-έ7;䉈˻fNMv:Հx̩j62W2?1KFyUj'A[6~א[?ڹ#z=MCzI-K.v@ #}7Fd3_3DJTE-L.ɑRͼF.h]B̓ue0(.D7LYj*d8'ssj̩x]1H^c[¤gcMq=e2\,VL}4M9'O 0#BֲAZTg IFMG{HwȞ:K;R X3 l˧9ruΑ#>,]3/6 8OC+Rt>ҧCe:[Mۉl#n Ifk}<0	V']]@ |*2ΣRc%ɀ'k}>jyl5@:OAoNjO`܋)	v3C ʍNdMл
hvxj/kHIQB0aO@ 7>ib^&Uq6Z+wq:g,Ͱ+Mt,yغUf)
R3öƾ[;j2@=* 0uS
ދ]Bdh2JБ;.9TakN`bEE`׆!hVGv`h]u,,!9Y)}؀aPdǪ%WtCbMɅꦾK})Z.b%@LXӗ>ia}h(l*nFbmYȡeyzeѩ|mYޥھߎp,	;3_G	31fЬZy)ǵGªPNNߩ\hgBM!*f]_|{o:spם]Bbk2O6NR<âb`LV-n['AgnSOѿ[WQ5K[KK1ש4VV͡f(cp[>
[cST|E%V$@QMJMbQ"])UH#X3/5Ǎ
3imB#R 05G0p[24-&f2T<Q2gbpIc殐Q߫=S招9Q.+ݕ1E(|F}vjեo27>}ۇ(O</<gsSFO>4(:r(j(_V y ߀ty!~+cPA(ng&F!v\Od{T샪jaF1:Dxh8Yttpfy^8/M8hUavA(L
4D{qq"Y(V*=ɿ[GiIQ}]{%ZrZJ~mwZĀߦþ' JCodѓ\&ǒ<g	~U蟎8pD"toѹEQOl%PhyrCKx֬R[!I6|>Xm{~)=#{<G7o$oD 7 xNq-Ev_ăAmpjC%	M<sӍMLOW3^/Ii6$W9f\BI=_Ìs}SN/[C'27 _g$<x"٠i|U CU5ٙnBM?#>=]L
~NzQ"ܡsVPBA2E5@0]7/vL/,e8[!.3ڮ1	(L<c)Ӂ^dX.y<bfR治iFbo
DpP.Cja~}SC9L:R2(^R{ŹEt#*8U<'uj+m"׌L:Du]\RIp		F.J5`"Va@N0:o$^<,eBtX$":Hc#.脢*XUUiʟ:lSoŨJNJ?|=nٗȾ1$4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAg