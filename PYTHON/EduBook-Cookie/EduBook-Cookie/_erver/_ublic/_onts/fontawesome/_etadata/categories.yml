   syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
      },
      "bg-size": {
        syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
      },
      "blur()": {
        syntax: "blur( <length> )"
      },
      "blend-mode": {
        syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
      },
      box: {
        syntax: "border-box | padding-box | content-box"
      },
      "brightness()": {
        syntax: "brightness( <number-percentage> )"
      },
      "calc()": {
        syntax: "calc( <calc-sum> )"
      },
      "calc-sum": {
        syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
      },
      "calc-product": {
        syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
      },
      "calc-value": {
        syntax: "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
      },
      "calc-constant": {
        syntax: "e | pi | infinity | -infinity | NaN"
      },
      "cf-final-image": {
        syntax: "<image> | <color>"
      },
      "cf-mixing-image": {
        syntax: "<percentage>? && <image>"
      },
      "circle()": {
        syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
      },
      "clamp()": {
        syntax: "clamp( <calc-sum>#{3} )"
      },
      "class-selector": {
        syntax: "'.' <ident-token>"
      },
      "clip-source": {
        syntax: "<url>"
      },
      color: {
        syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
      },
      "color-stop": {
        syntax: "<color-stop-length> | <color-stop-angle>"
      },
      "color-stop-angle": {
        syntax: "<angle-percentage>{1,2}"
      },
      "color-stop-length": {
        syntax: "<length-percentage>{1,2}"
      },
      "color-stop-list": {
        syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
      },
      combinator: {
        syntax: "'>' | '+' | '~' | [ '||' ]"
      },
      "common-lig-values": {
        syntax: "[ common-ligatures | no-common-ligatures ]"
      },
      "compat-auto": {
        syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
      },
      "composite-style": {
        syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
      },
      "compositing-operator": {
        syntax: "add | subtract | intersect | exclude"
      },
      "compound-selector": {
        syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
      },
      "compound-selector-list": {
        syntax: "<compound-selector>#"
      },
      "complex-selector": {
        syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
      },
      "complex-selector-list": {
        syntax: "<complex-selector>#"
      },
      "conic-gradient()": {
        syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "contextual-alt-values": {
        syntax: "[ contextual | no-contextual ]"
      },
      "content-distribution": {
        syntax: "space-between | space-around | space-evenly | stretch"
      },
      "content-list": {
        syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
      },
      "content-position": {
        syntax: "center | start | end | flex-start | flex-end"
      },
      "content-replacement": {
        syntax: "<image>"
      },
      "contrast()": {
        syntax: "contrast( [ <number-percentage> ] )"
      },
      "cos()": {
        syntax: "cos( <calc-sum> )"
      },
      counter: {
        syntax: "<counter()> | <counters()>"
      },
      "counter()": {
        syntax: "counter( <counter-name>, <counter-style>? )"
      },
      "counter-name": {
        syntax: "<custom-ident>"
      },
      "counter-style": {
        syntax: "<counter-style-name> | symbols()"
      },
      "counter-style-name": {
        syntax: "<custom-ident>"
      },
      "counters()": {
        syntax: "counters( <counter-name>, <string>, <counter-style>? )"
      },
      "cross-fade()": {
        syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
      },
      "cubic-bezier-timing-function": {
        syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
      },
      "deprecated-system-color": {
        syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
      },
      "discretionary-lig-values": {
        syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
      },
      "display-box": {
        syntax: "contents | none"
      },
      "display-inside": {
        syntax: "flow | flow-root | table | flex | grid | ruby"
      },
      "display-internal": {
        syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
      },
      "display-legacy": {
        syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
      },
      "display-listitem": {
        syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
      },
      "display-outside": {
        syntax: "block | inline | run-in"
      },
      "drop-shadow()": {
        syntax: "drop-shadow( <length>{2,3} <color>? )"
      },
      "east-asian-variant-values": {
        syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
      },
      "east-asian-width-values": {
        syntax: "[ full-width | proportional-width ]"
      },
      "element()": {
        syntax: "element( <id-selector> )"
      },
      "ellipse()": {
        syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
      },
      "ending-shape": {
        syntax: "circle | ellipse"
      },
      "env()": {
        syntax: "env( <custom-ident> , <declaration-value>? )"
      },
      "exp()": {
        syntax: "exp( <calc-sum> )"
      },
      "explicit-track-list": {
        syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
      },
      "family-name": {
        syntax: "<string> | <custom-ident>+"
      },
      "feature-tag-value": {
        syntax: "<string> [ <integer> | on | off ]?"
      },
      "feature-type": {
        syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
      },
      "feature-value-block": {
        syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
      },
      "feature-value-block-list": {
        syntax: "<feature-value-block>+"
      },
      "feature-value-declaration": {
        syntax: "<custom-ident>: <integer>+;"
      },
      "feature-value-declaration-list": {
        syntax: "<feature-value-declaration>"
      },
      "feature-value-name": {
        syntax: "<custom-ident>"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd"
      },
      "filter-function": {
        syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
      },
      "filter-function-list": {
        syntax: "[ <filter-function> | <url> ]+"
      },
      "final-bg-layer": {
        syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "fixed-breadth": {
        syntax: "<length-percentage>"
      },
      "fixed-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "fixed-size": {
        syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
      },
      "font-stretch-absolute": {
        syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
      },
      "font-variant-css21": {
        syntax: "[ normal | small-caps ]"
      },
      "font-weight-absolute": {
        syntax: "normal | bold | <number [1,1000]>"
      },
      "frequency-percentage": {
        syntax: "<frequency> | <percentage>"
      },
      "general-enclosed": {
        syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
      },
      "generic-family": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "generic-name": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "geometry-box": {
        syntax: "<shape-box> | fill-box | stroke-box | view-box"
      },
      gradient: {
        syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
      },
      "grayscale()": {
        syntax: "grayscale( <number-percentage> )"
      },
      "grid-line": {
        syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
      },
      "historical-lig-values": {
        syntax: "[ historical-ligatures | no-historical-ligatures ]"
      },
      "hsl()": {
        syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      "hsla()": {
        syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      hue: {
        syntax: "<number> | <angle>"
      },
      "hue-rotate()": {
        syntax: "hue-rotate( <angle> )"
      },
      "hwb()": {
        syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
      },
      "hypot()": {
        syntax: "hypot( <calc-sum># )"
      },
      "id-selector": {
        syntax: "<hash-token>"
      },
      image: {
        syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
      },
      "image()": {
        syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
      },
      "image-set()": {
        syntax: "image-set( <image-set-option># )"
      },
      "image-set-option": {
        syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
      },
      "image-src": {
        syntax: "<url> | <string>"
      },
      "image-tags": {
        syntax: "ltr | rtl"
      },
      "inflexible-breadth": {
        syntax: "<length-percentage> | min-content | max-content | auto"
      },
      "inset()": {
        syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
      },
      "invert()": {
        syntax: "invert( <number-percentage> )"
      },
      "keyframes-name": {
        syntax: "<custom-ident> | <string>"
      },
      "keyframe-block": {
        syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
      },
      "keyframe-block-list": {
        syntax: "<keyframe-block>+"
      },
      "keyframe-selector": {
        syntax: "from | to | <percentage>"
      },
      "lab()": {
        syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
      },
      "layer()": {
        syntax: "layer( <layer-name> )"
      },
      "layer-name": {
        syntax: "<ident> [ '.' <ident> ]*"
      },
      "lch()": {
        syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
      },
      "leader()": {
        syntax: "leader( <leader-type> )"
      },
      "leader-type": {
        syntax: "dotted | solid | space | <string>"
      },
      "length-percentage": {
        syntax: "<length> | <percentage>"
      },
      "line-names": {
        syntax: "'[' <custom-ident>* ']'"
      },
      "line-name-list": {
        syntax: "[ <line-names> | <name-repeat> ]+"
      },
      "line-style": {
        syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
      },
      "line-width": {
        syntax: "<length> | thin | medium | thick"
      },
      "linear-color-hint": {
        syntax: "<length-percentage>"
      },
      "linear-color-stop": {
        syntax: "<color> <color-stop-length>?"
      },
      "linear-gradient()": {
        syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "log()": {
        syntax: "log( <calc-sum>, <calc-sum>? )"
      },
      "mask-layer": {
        syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
      },
      "mask-position": {
        syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
      },
      "mask-reference": {
        syntax: "none | <image> | <mask-source>"
      },
      "mask-source": {
        syntax: "<url>"
      },
      "masking-mode": {
        syntax: "alpha | luminance | match-source"
      },
      "matrix()": {
        syntax: "matrix( <number>#{6} )"
      },
      "matrix3d()": {
        syntax: "matrix3d( <number>#{16} )"
      },
      "max()": {
        syntax: "max( <calc-sum># )"
      },
      "media-and": {
        syntax: "<media-in-parens> [ and <media-in-parens> ]+"
      },
      "media-condition": {
        syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
      },
      "media-condition-without-or": {
        syntax: "<media-not> | <media-and> | <media-in-parens>"
      },
      "media-feature": {
        syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
      },
      "media-in-parens": {
        syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
      },
      "media-not": {
        syntax: "not <media-in-parens>"
      },
      "media-or": {
        syntax: "<media-in-parens> [ or <media-in-parens> ]+"
      },
      "media-query": {
        syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
      },
      "media-query-list": {
        syntax: "<media-query>#"
      },
      "media-type": {
        syntax: "<ident>"
      },
      "mf-boolean": {
        syntax: "<mf-name>"
      },
      "mf-name": {
        syntax: "<ident>"
      },
      "mf-plain": {
        syntax: "<mf-name> : <mf-value>"
      },
      "mf-range": {
        syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
      },
      "mf-value": {
        syntax: "<number> | <dimension> | <ident> | <ratio>"
      },
      "min()": {
        syntax: "min( <calc-sum># )"
      },
      "minmax()": {
        syntax: "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"
      },
      "mod()": {
        syntax: "mod( <calc-sum>, <calc-sum> )"
      },
      "name-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> | auto-fill ], <line-names>+ )"
      },
      "named-color": {
        syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
      },
      "namespace-prefix": {
        syntax: "<ident>"
      },
      "ns-prefix": {
        syntax: "[ <ident-token> | '*' ]? '|'"
      },
      "number-percentage": {
        syntax: "<number> | <percentage>"
      },
      "numeric-figure-values": {
        syntax: "[ lining-nums | oldstyle-nums ]"
      },
      "numeric-fraction-values": {
        syntax: "[ diagonal-fractions | stacked-fractions ]"
      },
      "numeric-spacing-values": {
        syntax: "[ proportional-nums | tabular-nums ]"
      },
      nth: {
        syntax: "<an-plus-b> | even | odd"
      },
      "opacity()": {
        syntax: "opacity( [ <number-percentage> ] )"
      },
      "overflow-position": {
        syntax: "unsafe | safe"
      },
      "outline-radius": {
        syntax: "<length> | <percentage>"
      },
      "page-body": {
        syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
      },
      "page-margin-box": {
        syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
      },
      "page-margin-box-type": {
        syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
      },
      "page-selector-list": {
        syntax: "[ <page-selector># ]?"
      },
      "page-selector": {
        syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
      },
      "page-size": {
        syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
      },
      "path()": {
        syntax: "path( [ <fill-rule>, ]? <string> )"
      },
      "paint()": {
        syntax: "paint( <ident>, <declaration-value>? )"
      },
      "perspective()": {
        syntax: "perspective( [ <length [0,\u221E]> | none ] )"
      },
      "polygon()": {
        syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
      },
      position: {
        syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
      },
      "pow()": {
        syntax: "pow( <calc-sum>, <calc-sum> )"
      },
      "pseudo-class-selector": {
        syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
      },
      "pseudo-element-selector": {
        syntax: "':' <pseudo-class-selector>"
      },
      "pseudo-page": {
        syntax: ": [ left | right | first | blank ]"
      },
      quote: {
        syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
      },
      "radial-gradient()": {
        syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      ratio: {
        syntax: "<number [0,\u221E]> [ / <number [0,\u221E]> ]?"
      },
      "relative-selector": {
        syntax: "<combinator>? <complex-selector>"
      },
      "relative-selector-list": {
        syntax: "<relative-selector>#"
      },
      "relative-size": {
        syntax: "larger | smaller"
      },
      "rem()": {
        syntax: "rem( <calc-sum>, <calc-sum> )"
      },
      "repeat-style": {
        syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
      },
      "repeating-conic-gradient()": {
        syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "repeating-linear-gradient()": {
        syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "repeating-radial-gradient()": {
        syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "reversed-counter-name": {
        syntax: "reversed( <counter-name> )"
      },
      "rgb()": {
        syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
      },
      "rgba()": {
        syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
      },
      "rotate()": {
        syntax: "rotate( [ <angle> | <zero> ] )"
      },
      "rotate3d()": {
        syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
      },
      "rotateX()": {
        syntax: "rotateX( [ <angle> | <zero> ] )"
      },
      "rotateY()": {
        syntax: "rotateY( [ <angle> | <zero> ] )"
      },
      "rotateZ()": {
        syntax: "rotateZ( [ <angle> | <zero> ] )"
      },
      "round()": {
        syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"
      },
      "rounding-strategy": {
        syntax: "nearest | up | down | to-zero"
      },
      "saturate()": {
        syntax: "saturate( <number-percentage> )"
      },
      "scale()": {
        syntax: "scale( [ <number> | <percentage> ]#{1,2} )"
      },
      "scale3d()": {
        syntax: "scale3d( [ <number> | <percentage> ]#{3} )"
      },
      "scaleX()": {
        syntax: "scaleX( [ <number> | <percentage> ] )"
      },
      "scaleY()": {
        syntax: "scaleY( [ <number> | <percentage> ] )"
      },
      "scaleZ()": {
        syntax: "scaleZ( [ <number> | <percentage> ] )"
      },
      scroller: {
        syntax: "root | nearest"
      },
      "self-position": {
        syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
      },
      "shape-radius": {
        syntax: "<length-percentage> | closest-side | farthest-side"
      },
      "sign()": {
        syntax: "sign( <calc-sum> )"
      },
      "skew()": {
        syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
      },
      "skewX()": {
        syntax: "skewX( [ <angle> | <zero> ] )"
      },
      "skewY()": {
        syntax: "skewY( [ <angle> | <zero> ] )"
      },
      "sepia()": {
        syntax: "sepia( <number-percentage> )"
      },
      shadow: {
        syntax: "inset? && <length>{2,4} && <color>?"
      },
      "shadow-t": {
        syntax: "[ <length>{2,3} && <color>? ]"
      },
      shape: {
        syntax: "rect(<top>, <right>, <bottom>, <left>)"
      },
      "shape-box": {
        syntax: "<box> | margin-box"
      },
      "side-or-corner": {
        syntax: "[ left | right ] || [ top | bottom ]"
      },
      "sin()": {
        syntax: "sin( <calc-sum> )"
      },
      "single-animation": {
        syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
      },
      "single-animation-direction": {
        syntax: "normal | reverse | alternate | alternate-reverse"
      },
      "single-animation-fill-mode": {
        syntax: "none | forwards | backwards | both"
      },
      "single-animation-iteration-count": {
        syntax: "infinite | <number>"
      },
      "single-animation-play-state": {
        syntax: "running | paused"
      },
      "single-animation-timeline": {
        syntax: "auto | none | <timeline-name> | scroll(<axis>? <scroller>?)"
      },
      "single-transition": {
        syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
      },
      "single-transition-property": {
        syntax: "all | <custom-ident>"
      },
      size: {
        syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
      },
      "sqrt()": {
        syntax: "sqrt( <calc-sum> )"
      },
      "step-position": {
        syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
      },
      "step-timing-function": {
        syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
      },
      "subclass-selector": {
        syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
      },
      "supports-condition": {
        syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
      },
      "supports-in-parens": {
        syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
      },
      "supports-feature": {
        syntax: "<supports-decl> | <supports-selector-fn>"
      },
      "supports-decl": {
        syntax: "( <declaration> )"
      },
      "supports-selector-fn": {
        syntax: "selector( <complex-selector> )"
      },
      symbol: {
        syntax: "<string> | <image> | <custom-ident>"
      },
      "tan()": {
        syntax: "tan( <calc-sum> )"
      },
      target: {
        syntax: "<target-counter()> | <target-counters()> | <target-text()>"
      },
      "target-counter()": {
        syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
      },
      "target-counters()": {
        syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
      },
      "target-text()": {
        syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
      },
      "time-percentage": {
        syntax: "<time> | <percentage>"
      },
      "timeline-name": {
        syntax: "<custom-ident> | <string>"
      },
      "easing-function": {
        syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
      },
      "track-breadth": {
        syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
      },
      "track-list": {
        syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
      },
      "track-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
      },
      "track-size": {
        syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"
      },
      "transform-function": {
        syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
      },
      "transform-list": {
        syntax: "<transform-function>+"
      },
      "translate()": {
        syntax: "translate( <length-percentage> , <length-percentage>? )"
      },
      "translate3d()": {
        syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
      },
      "translateX()": {
        syntax: "translateX( <length-percentage> )"
      },
      "translateY()": {
        syntax: "translateY( <length-percentage> )"
      },
      "translateZ()": {
        syntax: "translateZ( <length> )"
      },
      "type-or-unit": {
        syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
      },
      "type-selector": {
        syntax: "<wq-name> | <ns-prefix>? '*'"
      },
      "var()": {
        syntax: "var( <custom-property-name> , <declaration-value>? )"
      },
      "viewport-length": {
        syntax: "auto | <length-percentage>"
      },
      "visual-box": {
        syntax: "content-box | padding-box | border-box"
      },
      "wq-name": {
        syntax: "<ns-prefix>? <ident-token>"
      }
    };
  }
});

// node_modules/css-tree/cjs/data.cjs
var require_data = __commonJS({
  "node_modules/css-tree/cjs/data.cjs"(exports2, module2) {
    "use strict";
    var dataPatch = require_data_patch();
    var mdnAtrules = require_at_rules();
    var mdnProperties = require_properties();
    var mdnSyntaxes = require_syntaxes();
    var extendSyntax = /^\s*\|\s*/;
    function preprocessAtrules(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;
        if (atrule.descriptors) {
          descriptors = /* @__PURE__ */ Object.create(null);
          for (const descriptor in atrule.descriptors) {
            descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
          }
        }
        result[atruleName.substr(1)] = {
          prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
          descriptors
        };
      }
      return result;
    }
    function patchDictionary(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
      }
      for (const key in patchDict) {
        if (key in dict) {
          if (patchDict[key].syntax) {
            result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
          } else {
            delete result[key];
          }
        } else {
          if (patchDict[key].syntax) {
            result[key] = patchDict[key].syntax.replace(extendSyntax, "");
          }
        }
      }
      return result;
    }
    function patchAtrules(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        const atrulePatch = patchDict[key] || {};
        result[key] = {
          prelude: key in patchDict && "prelude" in atrulePatch ? atrulePatch.prelude : dict[key].prelude || null,
          descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})
        };
      }
      for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
          const atrulePatch = patchDict[key] || {};
          result[key] = {
            prelude: atrulePatch.prelude || null,
            descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)
          };
        }
      }
      return result;
    }
    var definitions = {
      types: patchDictionary(mdnSyntaxes, dataPatch.types),
      atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
      properties: patchDictionary(mdnProperties, dataPatch.properties)
    };
    module2.exports = definitions;
  }
});

// node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs
var require_AnPlusB = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var charCodeDefinitions = require_char_code_definitions();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
      let pos = this.tokenStart + offset;
      const code = this.charCodeAt(pos);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          this.error("Number sign is not allowed");
        }
        pos++;
      }
      for (; pos < this.tokenEnd; pos++) {
        if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
          this.error("Integer is expected", pos);
        }
      }
    }
    function checkTokenIsInteger(disallowSign) {
      return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
      if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = "";
        switch (code) {
          case N:
            msg = "N is expected";
            break;
          case HYPHENMINUS:
            msg = "HyphenMinus is expected";
            break;
        }
        this.error(msg, this.tokenStart + offset);
      }
    }
    function consumeB() {
      let offset = 0;
      let sign = 0;
      let type = this.tokenType;
      while (type === types.WhiteSpace || type === types.Comment) {
        type = this.lookupType(++offset);
      }
      if (type !== types.Number) {
        if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {
          sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
          do {
            type = this.lookupType(++offset);
          } while (type === types.WhiteSpace || type === types.Comment);
          if (type !== types.Number) {
            this.skip(offset);
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
          }
        } else {
          return null;
        }
      }
      if (offset > 0) {
        this.skip(offset);
      }
      if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
          this.error("Number sign is expected");
        }
      }
      checkTokenIsInteger.call(this, sign !== 0);
      return sign === HYPHENMINUS ? "-" + this.consume(types.Number) : this.consume(types.Number);
    }
    var name = "AnPlusB";
    var structure = {
      a: [String, null],
      b: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let a = null;
      let b = null;
      if (this.tokenType === types.Number) {
        checkTokenIsInteger.call(this, ALLOW_SIGN);
        b = this.consume(types.Number);
      } else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {
        a = "-1";
        expectCharCode.call(this, 1, N);
        switch (this.tokenEnd - this.tokenStart) {
          case 2:
            this.next();
            b = consumeB.call(this);
            break;
          case 3:
            expectCharCode.call(this, 2, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          default:
            expectCharCode.call(this, 2, HYPHENMINUS);
            checkInteger.call(this, 3, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + 2);
        }
      } else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {
        let sign = 0;
        a = "1";
        if (this.isDelim(PLUSSIGN)) {
          sign = 1;
          this.next();
        }
        expectCharCode.call(this, 0, N);
        switch (this.tokenEnd - this.tokenStart) {
          case 1:
            this.next();
            b = consumeB.call(this);
            break;
          case 2:
            expectCharCode.call(this, 1, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          default:
            expectCharCode.call(this, 1, HYPHENMINUS);
            checkInteger.call(this, 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + sign + 1);
        }
      } else if (this.tokenType === types.Dimension) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === PLUSSIGN || code === HYPHENMINUS;
        let i = this.tokenStart + sign;
        for (; i < this.tokenEnd; i++) {
          if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
            break;
          }
        }
        if (i === this.tokenStart + sign) {
          this.error("Integer is expected", this.tokenStart + sign);
        }
        expectCharCode.call(this, i - this.tokenStart, N);
        a = this.substring(start, i);
        if (i + 1 === this.tokenEnd) {
          this.next();
          b = consumeB.call(this);
        } else {
          expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
          if (i + 2 === this.tokenEnd) {
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
          } else {
            checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(i + 1);
          }
        }
      } else {
        this.error();
      }
      if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
        a = a.substr(1);
      }
      if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
        b = b.substr(1);
      }
      return {
        type: "AnPlusB",
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
      };
    }
    function generate(node) {
      if (node.a) {
        const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
        if (node.b) {
          const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
          this.tokenize(a + b);
        } else {
          this.tokenize(a);
        }
      } else {
        this.tokenize(node.b);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Atrule.cjs
var require_Atrule = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Atrule.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
      for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === types.RightCurlyBracket) {
          return true;
        }
        if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
          return false;
        }
      }
      return false;
    }
    var name = "Atrule";
    var walkContext = "atrule";
    var structure = {
      name: String,
      prelude: ["AtrulePrelude", "Raw