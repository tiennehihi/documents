'use strict';

const Mixin = require('../../utils/mixin');
const Tokenizer = require('../../tokenizer');
const LocationInfoTokenizerMixin = require('./tokenizer-mixin');
const LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');
const HTML = require('../../common/html');

//Aliases
const $ = HTML.TAG_NAMES;

class LocationInfoParserMixin extends Mixin {
    constructor(parser) {
        super(parser);

        this.parser = parser;
        this.treeAdapter = this.parser.treeAdapter;
        this.posTracker = null;
        this.lastStartTagToken = null;
        this.lastFosterParentingLocation = null;
        this.currentToken = null;
    }

    _setStartLocation(element) {
        let loc = null;

        if (this.lastStartTagToken) {
            loc = Object.assign({}, this.lastStartTagToken.location);
            loc.startTag = this.lastStartTagToken.location;
        }

        this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }

    _setEndLocation(element, closingToken) {
        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);

        if (loc) {
            if (closingToken.location) {
                const ctLoc = closingToken.location;
                const tn = this.treeAdapter.getTagName(element);

                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;
                const endLoc = {};
                if (isClosingEndTag) {
                    endLoc.endTag = Object.assign({}, ctLoc);
                    endLoc.endLine = ctLoc.endLine;
                    endLoc.endCol = ctLoc.endCol;
                    endLoc.endOffset = ctLoc.endOffset;
                } else {
                    endLoc.endLine = ctLoc.startLine;
                    endLoc.endCol = ctLoc.startCol;
                    endLoc.endOffset = ctLoc.startOffset;
                }

                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
            }
        }
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            _bootstrap(document, fragmentContext) {
                orig._bootstrap.call(this, document, fragmentContext);

                mxn.lastStartTagToken = null;
                mxn.lastFosterParentingLocation = null;
                mxn.currentToken = null;

                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);

                mxn.posTracker = tokenizerMixin.posTracker;

                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
                    onItemPop: function(element) {
                        mxn._setEndLocation(element, mxn.currentToken);
                    }
                });
            },

            _runParsingLoop(scriptHandler) {
                orig._runParsingLoop.call(this, scriptHandler);

                // NOTE: generate location info for elements
                // that remains on open element stack
                for (let i = this.openElements.stackTop; i >= 0; i--) {
                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
                }
            },

            //Token processing
            _processTokenInForeignContent(token) {
                mxn.currentToken = token;
                orig._processTokenInForeignContent.call(this, token);
            },

            _processToken(token) {
                mxn.currentToken = token;
                orig._processToken.call(this, token);

                //NOTE: <body> and <html> are never popped from the stack, so we need to updated
                //their end location explicitly.
                const requireExplicitUpdate =
                    token.type === Tokenizer.END_TAG_TOKEN &&
                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));

                if (requireExplicitUpdate) {
                    for (let i = this.openElements.stackTop; i >= 0; i--) {
                        const element = this.openElements.items[i];

                        if (this.treeAdapter.getTagName(element) === token.tagName) {
                            mxn._setEndLocation(element, token);
                            break;
                        }
                    }
                }
            },

            //Doctype
            _setDocumentType(token) {
                orig._setDocumentType.call(this, token);

                const documentChildren = this.treeAdapter.getChildNodes(this.document);
                const cnLength = documentChildren.length;

                for (let i = 0; i < cnLength; i++) {
                    const node = documentChildren[i];

                    if (this.treeAdapter.isDocumentTypeNode(node)) {
                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
                        break;
                    }
                }
            },

            //Elements
            _attachElementToTree(element) {
                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
                //So we will use token location stored in this methods for the element.
                mxn._setStartLocation(element);
                mxn.lastStartTagToken = null;
                orig._attachElementToTree.call(this, element);
            },

            _appendElement(token, namespaceURI) {
                mxn.lastStartTagToken = token;
                orig._appendElement.call(this, token, namespaceURI);
            },

            _insertElement(token, namespaceURI) {
                mxn.lastStartTagToken = token;
                orig._insertElement.call(this, token, namespaceURI);
            },

            _insertTemplate(token) {
                mxn.lastStartTagToken = token;
                orig._insertTemplate.call(this, token);

                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);

                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
            },

            _insertFakeRootElement() {
                orig._insertFakeRootElement.call(this);
                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
            },

            //Comments
            _appendCommentNode(token, parent) {
                orig._appendCommentNode.call(this, token, parent);

                const children = this.treeAdapter.getChildNodes(parent);
                const commentNode = children[children.length - 1];

                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
            },

            //Text
            _findFosterParentingLocation() {
                //NOTE: store last foster parenting location, so we will be able to find inserted text
                //in case of foster parenting
                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);

                return mxn.lastFosterParentingLocation;
            },

            _insertCharacters(token) {
                orig._insertCharacters.call(this, token);

                const hasFosterParent = this._shouldFosterParentOnInsertion();

                const parent =
                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||
                    this.openElements.currentTmplContent ||
                    this.openElements.current;

                const siblings = this.treeAdapter.getChildNodes(parent);

                const textNodeIdx =
                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement
                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1
                        : siblings.length - 1;

                const textNode = siblings[textNodeIdx];

                //NOTE: if we have location assigned by another token, then just update end position
                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

                if (tnLoc) {
                    const { endLine, endCol, endOffset } = token.location;
                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
                } else {
                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
                }
            }
        };
    }
}

module.exports = LocationInfoParserMixin;
                            kMom¢˝’P•ÌüÛ1{û•≠®í0¯.Îe¶ l¬Sπˆ‡ı#zµ~4=sXﬁ±Ê·?c2ﬁπ€óÈlrûÖ-m∞å(a7;òæÓ ÉUπu∂ √˝J	9Jb÷™óFòû<udπG÷ﬁ{
uﬂ[jî‘.Nh9w©≈£π <ªçÿ∏∂wè÷a°ÿ€ÅÂ„ÚØ7w î∆û—„'À˜Õë√m∞å®Q:3òæπ8zKƒg∏:Ü„r^´∞/¶Áöœ]˚{î+≠,H`ù`m#8”ï–¥6ÌπΩπ‘/}ΩÙÂiLg]sÇ√ˆvÉè=Î…}∂≤Ô/È}%
gÜÍÆÁÚt^ uypZ.ál){{õ~≠pˆNúwÉ˛ÜºÉÌ∫GörÃ‚Õ~>–ÏGJ≥Wß√[”˜∑∂ü=én®‡7ÍCâªóÇXoå3Vhß÷{«‹Àîâ%Ûa∆]\Éî\˜Ö¡ó£ƒJúûP˙v1”zÅˇ˝f2»ëÁÓÉöy∏O˝=h›ùy´639ãSa˚2•4'ƒ<ºúãp“õ.+¸°∫Êa+1ŒÈÛ°Ù\U{¯È†ùêÚ”ˆ’ıóœø∫_-ˇxG?⁄N‡è7;o¸›ﬁè„g€˙éiõ≈>næ$ÕóáÊK“|5W⁄=»P◊p"Óz·VYﬁÂ≤gU¨!\ÓQµ9¥j˜¢útDM–Ö~¬Ë˙∫æ˝Â5˙√Î5˙=§◊ò¸BÎ› 5ΩçÄÀÙÜÅij¨=õÕsqÜ` æNö«ãŸ‚MﬂÃ·°Ã·∑ºIò‚áQ∞»bp‹¢å?~6ùL4;Oò,fÒ˘úXc +ràﬂívA~:1Œ»?FæºNΩç’É£»≈™∑1õD
Â;πxiLxÒ1Ê±ëYD8ˆ*1Q¸}%z	§/ +ŸVÓb±≥„uxx;+«Ç√ı‹ÕÄ‘Í˛:^∫ØŸIº3`[∞õ~kêº2ß$ˇçŸ0D◊R∫¸ƒ∏o¢è¶v∆‰ú4%€ˆA?≤Oæò«*˙—«SªâËbjC—@ú*˚Ó≈Y?zÆ„Ó}¥à¿SIyÌnΩÒÛ4≥Ö8\^>OU6q«©Íï‘2Î<≥W‡Ülõcw;ˆÒ…8'ø§î`.»ıÉà‰j|[Ë”ÿFâœ 7€≠PËkUü€g-–^°oCeF•¶√.§1√a#a„(ï˛ÀÕ/ˇ\‹æΩyı<˝ΩwÍ˝{◊{2!™)cLä‡´H^ÿ@Î0iQÅ÷·BÕ‰¸UP©‰÷ÿ“∫è(∞ökÑUÊçÉ◊Ìyç¸˝Ts¬Ï06çŒ∏†∫Ú…°*£a"ÜUr‘˝¯ØV£X¬⁄Dú}gQ<ÅGÒ”ŒÙ¨çªﬁ?YN∞s};∞]'Kga3%`{ÑN@â«⁄M˝ÈúuôÎyÓÏÈ\™◊í€3£ú)ô#7˚≤©®¬‹å3œEü8b:c7ïÁ÷^hÈË∆î∑òèdÁÃƒ·”?éÊ‡ﬁm!˛ÿaﬂÀŒÄ}ZËÍF;&hg˙&º9Æœ	‰q;i¯•’∞fsËÿF‹’C^á0ºa‚øÓ:æªµ∆$kZÎ‰Êí‹TÇyz‡@Ó/Èóı√ ÛN®•XÆ€4∫0‡>âÖª‹9—€“<êeòQ˜ﬂ7eÎ>õºπ»¢xbúèJÁÊè®“Ë•Z5sÇï“Ø_'c∞”—µî3€‰Ï„∞À4é√ãi á¬39Ï∏tπHBƒêkhÎ>êt'˜{gç¡Ï√q9∞ü,ñÒ= *„n‘°úÕ≠Ú∂-zu¥P¯M[±yÀ˘Ä‚QùU%7ßJØÅkÜß≤ìú>OÎ®ìÒ-˘ñ™IG˘,-VÜCb˝H¿g:ƒ^xÁl`∞àx(Ç4>ã*ºëõ^;B∏u49œ$†§?9äÀƒzY—}[‹ÓDkÕCÔËy˛÷`ƒáÀ¶P— äA…§…C(!w˚G«“WÊÎ‰;ÖìÈh∫îk\ªÿ¶Á‘ŸõaÚ≈E—Ò+Gâ‰Î<∂¶¬å˜Ñ¸ÃÉøœµtáﬂW`ÎXπ√°ŒÿÓ…R"∆}ÿB
¸ôë∂x≥”_;˚+êü3`Åh¬S ÷{¶Ì„gskoLÒ…v‘hô4R›⁄–ù∑/‹ &Võ]	ìÖ>ït‡?ÚÌBGÌ‘…Oö¨”Ã∑W–¨ò9´¢cÀ7=8Ígˇàås£d∂È\ßfµë#q≤Å`û+∫g`søºg—Dë/qÍŒél¡Lñ$Lmá„t„êí ªYêÁÑ…Û£ùñö»&¿ŒŸ($˝Üà¨SÛô"£A<œaüZ§á˘ú"R÷Ñ∞à˘ã~è˘6Ê÷·øçò´≠»jœﬁV€C∞=©€ÓÀÜì«Á≠…ıílN?â
0î∂ÓÙ1˙PÄs‘“¥Á‚2ú«·¸ZG2ﬁHC∑5vfxˆjX5‘Á§C˘÷zÔŸ¡ÀŒ›⁄Î	|”ç‘úÓZçOÃ=≠@rü”£s6Ä0 ©–‡çÅr(˜4Mzf∆òpJ
√õ|ù<;›5‰KgÍ˙≠úó∫ÆnˆtFZ6+´GåÍ‘@œåWS⁄ÃËHE–E!∫Yàn)\ß?NjÇªQäÓ4ﬁçßX1Ÿ’¬UJ˙~Ü'êß?Af›fñOa0/±¶§µ“÷6O