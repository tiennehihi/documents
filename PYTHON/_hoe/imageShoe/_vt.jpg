    if (!exports.is(esValue)) {
        throw new TypeError("'get onmousemove' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onmousemove"]);
    }

    set onmousemove(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onmousemove' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onmousemove' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onmousemove"] = V;
    }

    get onmouseout() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onmouseout' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseout"]);
    }

    set onmouseout(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onmouseout' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onmouseout' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onmouseout"] = V;
    }

    get onmouseover() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onmouseover' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseover"]);
    }

    set onmouseover(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onmouseover' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onmouseover' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onmouseover"] = V;
    }

    get onmouseup() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onmouseup' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onmouseup"]);
    }

    set onmouseup(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onmouseup' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onmouseup' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onmouseup"] = V;
    }

    get onwheel() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onwheel' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onwheel"]);
    }

    set onwheel(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onwheel' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onwheel' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onwheel"] = V;
    }

    get onpause() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onpause' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onpause"]);
    }

    set onpause(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onpause' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onpause' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onpause"] = V;
    }

    get onplay() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onplay' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onplay"]);
    }

    set onplay(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onplay' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onplay' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onplay"] = V;
    }

    get onplaying() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onplaying' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onplaying"]);
    }

    set onplaying(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onplaying' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onplaying' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onplaying"] = V;
    }

    get onprogress() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onprogress' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onprogress"]);
    }

    set onprogress(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onprogress' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onprogress' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onprogress"] = V;
    }

    get onratechange() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onratechange' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onratechange"]);
    }

    set onratechange(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onratechange' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onratechange' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onratechange"] = V;
    }

    get onreset() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onreset' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onreset"]);
    }

    set onreset(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onreset' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onreset' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onreset"] = V;
    }

    get onresize() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onresize' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onresize"]);
    }

    set onresize(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onresize' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onresize' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onresize"] = V;
    }

    get onscroll() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onscroll' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onscroll"]);
    }

    set onscroll(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onscroll' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onscroll' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onscroll"] = V;
    }

    get onsecuritypolicyviolation() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(
          "'get onsecuritypolicyviolation' called on an object that is not a valid instance of Document."
        );
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onsecuritypolicyviolation"]);
    }

    set onsecuritypolicyviolation(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError(
          "'set onsecuritypolicyviolation' called on an object that is not a valid instance of Document."
        );
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onsecuritypolicyviolation' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onsecuritypolicyviolation"] = V;
    }

    get onseeked() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onseeked' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onseeked"]);
    }

    set onseeked(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onseeked' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onseeked' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onseeked"] = V;
    }

    get onseeking() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onseeking' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onseeking"]);
    }

    set onseeking(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onseeking' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onseeking' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onseeking"] = V;
    }

    get onselect() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onselect' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onselect"]);
    }

    set onselect(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onselect' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onselect' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onselect"] = V;
    }

    get onstalled() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onstalled' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onstalled"]);
    }

    set onstalled(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onstalled' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed to set the 'onstalled' property on 'Document': The provided value"
        });
      }
      esValue[implSymbol]["onstalled"] = V;
    }

    get onsubmit() {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'get onsubmit' called on an object that is not a valid instance of Document.");
      }

      return utils.tryWrapperForImpl(esValue[implSymbol]["onsubmit"]);
    }

    set onsubmit(V) {
      const esValue = this !== null && this !== undefined ? this : globalObject;

      if (!exports.is(esValue)) {
        throw new TypeError("'set onsubmit' called on an object that is not a valid instance of Document.");
      }

      if (!utils.isObject(V)) {
        V = null;
      } else {
        V = EventHandlerNonNull.convert(V, {
          context: "Failed "use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginHiddenCallStack = beginHiddenCallStack;
exports.endHiddenCallStack = endHiddenCallStack;
exports.expectedError = expectedError;
exports.injectVirtualStackFrame = injectVirtualStackFrame;
var _Object$getOwnPropert;
const ErrorToString = Function.call.bind(Error.prototype.toString);
const SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : _Object$getOwnPropert.writable) === true;
const START_HIDING = "startHiding - secret - don't use this - v1";
const STOP_HIDING = "stopHiding - secret - don't use this - v1";
const expectedErrors = new WeakSet();
const virtualFrames = new WeakMap();
function CallSite(filename) {
  return Object.create({
    isNative: () => false,
    isConstructor: () => false,
    isToplevel: () => true,
    getFileName: () => filename,
    getLineNumber: () => undefined,
    getColumnNumber: () => undefined,
    getFunctionName: () => undefined,
    getMethodName: () => undefined,
    getTypeName: () => undefined,
    toString: () => filename
  });
}
function injectVirtualStackFrame(error, filename) {
  if (!SUPPORTED) return;
  let frames = virtualFrames.get(error);
  if (!frames) virtualFrames.set(error, frames = []);
  frames.push(CallSite(filename));
  return error;
}
function expectedError(error) {
  if (!SUPPORTED) return;
  expectedErrors.add(error);
  return error;
}
function beginHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function (...args) {
    setupPrepareStackTrace();
    return fn(...args);
  }, "name", {
    value: STOP_HIDING
  });
}
function endHiddenCallStack(fn) {
  if (!SUPPORTED) return fn;
  return Object.defineProperty(function (...args) {
    return fn(...args);
  }, "name", {
    value: START_HIDING
  });
}
function setupPrepareStackTrace() {
  setupPrepareStackTrace = () => {};
  const {
    prepareStackTrace = defaultPrepareStackTrace
  } = Error;
  const MIN_STACK_TRACE_LIMIT = 50;
  Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));
  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {
    let newTrace = [];
    const isExpected = expectedErrors.has(err);
    let status = isExpected ? "hiding" : "unknown";
    for (let i = 0; i < trace.length; i++) {
      const name = trace[i].getFunctionName();
      if (name === START_HIDING) {
        status = "hiding";
      } else if (name === STOP_HIDING) {
        if (status === "hiding") {
          status = "showing";
          if (virtualFrames.has(err)) {
            newTrace.unshift(...virtualFrames.get(err));
          }
        } else if (status === "unknown") {
          newTrace = trace;
          break;
        }
      } else if (status !== "hiding") {
        newTrace.push(trace[i]);
      }
    }
    return prepareStackTrace(err, newTrace);
  };
}
function defaultPrepareStackTrace(err, trace) {
  if (trace.length === 0) return ErrorToString(err);
  return `${ErrorToString(err)}\n    at ${trace.join("\n    at ")}`;
}
0 && 0;

//# sourceMappingURL=rewrite-stack-trace.js.map
                                                                                                                                                                                                                                                                                                                                                                           ¯ù	‰¿áa‚ß’Ô©y°ªÎÒE¢.~‘ŸÚš²MLnÈqÌãT¤×Á2ßSø'…1üËóÁ†íã'øÎ:d½Ì™»½ö×{ğäÉ’ËÎü®nzøtGÚtÇkƒ.»k.vÆÒÊñmÿcYÖÕÑş£ÙdF:.ô6³çõşº‡º}agdíe2„»FÅT³ûPNòş¾ıØ«:|®/L&“jA¾8w©UÂ½f\5/'Ûòj€ …bmÒ×eß¨=½¼ÔJ¶$DJ»¿Y‹”ò··CáA‰B™yå¥İ±½‡ÃBæ2¯Äp{´³ &GJ«–©pQîG“H?ò™PÖ,teÈ†Vü5ß—àVøƒ´1&àªÅTr­ôà/HÉû™é+Œ&È¡L'÷ÅS®Xİñe<@şóé3~¯/ûEO~>ırÉŞV›!9Ï‡PÔá|”<Wô:vtNöµèš#ÄÀ?ã~m„«51Àæk8ÓÌ@­d’*Bä|Ôññ§3Ì/a‚A}K_İ‚%÷ŸqeÆƒõïk.inEø'Ô˜€˜&Húdóæd=¸Vœ©Ù–/1ûS®ÖÂmõ1ÓÕ@`1–—Î#;åŠ+™SŒXÍg¤íŠZóŒš)ÓNü_çhWíãÆÑ³DßÄoë¨ÈÁ3õ1/{ò¼+töç\4âp³Ñâp“>‰LzAQ|&¸0æïFà½|³+ÿsÄÌÛfn„?¬Y}Y¢XÃf#_LPÙÍ{?dRnÍaŒ+‚=j=L´…ùu…OcÏXŞ˜(T*Ÿ…+§æË{©ÜV.©¢´Ó­sc–	Ã`e©|Ëu34zg¿Ú¦kåEgìóÏÇqb¯¶à‡unøm’–…èWsÆ¯°õ|N#l#?]Xø8}åÀ±À/çÆFLõß&_›’PP7q¬Ÿämd)8RL©	àüØWëŸ^=(Q[½CÂ¥9`´>we.³˜MrbßœËÓ3ûÌ’Ên”"{(o.ùË†qõñ*»B­œ	‡AÙÅGÔ,¦ßÄÜËÁ¿ÍøõÈ=¬Èüä÷=
 
$]ño=bK[»˜N¹åü°ÖÅÎ'ù{$í­JÃ³U*CÎî;d%i}…²¯4WÍŞC¬ÜMÃ
¥]Ár|¨ª@c¢u&…Õ&G&ÍeËíÌ1ÖÒ9°§4o+åZé¯õb;¯!+b«¾øPÔcÍã\•™İˆŠ‹ÍG”~BÛ‰^Ø±'1—›˜)%ş?k°æ½I±R:Vì]Ò™Ñ'“õw>ß™±áy½|ÍUÅUîH«æ¬}DqÁ‰1ãö¯övş™ıVdØ2,9ªuv:(êªwx”øYä{ûÓ¾"İì ë¶[¦ş¦(İ£^$&Şë[ÜıÍQ…ÕØŸ¼°q‹™]€¸¡’é˜¿½.8,¾_2}±˜Ôœë¡pËÆ·îMCÊaiì’ß)Jğjı}mÌ8óÉô½ckÃ}8şŒm˜~é–ñš ÜÜMl‡êƒó	.µtå)Ò²×˜éõ/æ»òÛò×'«61[ÙÄËR÷&uæç@áÙ1 W“G@!»39àã:©S“şY>!S'ÃÎ<6I
«Ñá<cHT§bÛÃÒÌÿ\·ZdeaM'¤}Ó^Åÿ3Ñ©|qj½.½¤8ÄîSwè™	Õk¨O³'06ÛÍB.Ü|ÕŞV´Ûre¬Ç²õ.CtÄá‰Í";«ÈtÂ=ËŠt~*~‘äW¶çoò­°3Ÿòrl%V/Nìi«¶…µĞÛú~œù»k`¶øëbœT±ÙY¥¬†¯7|÷ş³µ_œ\™×'SËƒ®gj‹½‚]¦-<|m^<d3|
›¸ßãÒoƒ<‡ªï±Y×£Ö›Œ-qü|kƒ—‹Ú›×+]3qš¸~I,0¯lëÄ"É¸A{l¦Wy™–k¬…ßëŞK¨ã©şàÁIs¡îagvõçH=(^¸P¯"Ùãù ÇQ€‰I(îC<*)ÙÚÒõ
óM[½óv(sí‘ƒUÑï
ÂÎÔ? >°].-4-P±Y"Ú¼ßÅdÍÖ«‹¿è¶Ï8 Õ ©†q7^sÍ®Åj0÷pI,9İ3¯½óòY¯“Ù*Ïn/Æ}L(­‰gÛ ç5nKš¤’ägèç´æ†ŠßÜÈR˜¢û¾ Œ'Õö1¯›ŒJ^¸w¨<V¾i´ªŞ_ôÒXù1>OØ.¾õ^¢øŠòÂ®ÍÉ«{ï~hğ³(é$ÿD~»Q)êqZ«qå[ºëœ¢èXas…·©¾Ÿ>Üç/°t5â8Ÿö;: 3H’<YB““´tƒİğÆÜtñM˜ëv¯Ùå=šÔ õ4ll8Áêá©°ÆÎ-}…Zªëòc„\+–Ä£bp–Âı2‰³Qõ¦OyP§Õ¨rÉ,Ñtúv·ò·†\’ô‚|“t´Çõ|ÿŸ;¾ËoúÍvÎ|-º ¤3í¤ŸkBuJXä|$Ÿm±¬sÌR™±tõŞ™_”NÕ”[­ğmsÔöz„”ü\õ¾}âsÌvŸµÕ’óIÜ"uµ‚W˜?^’}ílde},©áDq]»¦ò¾Å“ğ‰ú”§ÄÜŒšB^°p¼3W¯íkz>ˆ;{B@‰5ØfƒEáÖ;¼a±^7¼Ç¯>êâı±t3.4O«ç¾ç¼ˆÚyÀ$šæ¯ÚËi%û\•¼ç‘1‚ôìdI—¢tó¥"ÓşO¯]±rõå¸xÔú¼Ò¾Ü¨«‰ÅGŒj|ş.õX½­—›Ûv=K-®—éÄé`å˜uÆ£u>+İãÄ¼!˜‰-3VğœV¹Óªå¦ú­zŸşşBÚ0¤‘“S˜t~×‰é©
üç%³Â2Yü±wn¤‡pğÃ[>L³]gÇ&~>ì]ÉÈ?ÿ¢ñæoÚÃ`Õ7ÿ¶¶˜_çn7ìÒ¾ŞÚ=S«°™—ûâ4·$òXæ7[!¯ë©'g|=#Õê¶x¶o6dÔ“údÑ¬‚·2±´7éWè¡ñîÄÊ,WçlëéÛ¸Î'øˆ!“gçöX?1İ¯oÒóşğ]û>Å±,¸Û½W³·RòÌ Ã%Ïç?×|ÚöK¬ƒŸ¨+]çŒÖÈÙ_G¹İÓcŸ×>ŒŠ(¦\û2yUóx~¹ú~²¾ëám=3©ƒ/n"\.Z†´†P.L1Ub;Ş®†ÅL¶?¨°6È­}îò*¸û™•;ê#ñcëğ+çW¦Á»ãA—Î_ÿ§7êÖ7Ÿ´]F}-Ï›Ì:lÜ*nøT¾³;³4]ùm¢Êõ¦yô¨ïsí,…	Â×¨h•u·³'BO}è?vè‰_£bÂJ”Û~PaÍràuşÑ|ıcP˜túù…N×Â_“8ÉO×v§ã¦2Â¦•¿WJÀıxU&yÚuà-‰òĞqİßŸIÌ%1iŞüã|-…k´­¦ïæêJ\¦ò¾ZeZÅùœ¹>£±¶ş1åÂ¿/ÙR›EaĞ*eË³==&ÖOu‚Ş(_ˆp3b‚0MŸnÊ™®ÂöÂJ6¯\»€1›şåkÍÈmå–ÔyS‚'6†¦SŠ½\S*çâ6U.Ì¾úÈ·äÏ	Õ·•—ızÊıNìó.“Î\»n¸÷SÕ»Ê[ı÷öÿİ•yú”øƒ‘’Ì/±;ÿ®{ğû­ø?Oo­_ğ÷KÉ?>şçÏ—ÿü#NéĞ!îtX·áÿàk,åk¢ìû€©fšÿéÊafšáfÒ±fRaæÊaæº±æJ±æZ»,ôNY*û[éúÙ(úÙhÿ#A9ØF3ÜF:ÜF%ÎF:ÑF!ÉF7ÓFÃÏÖä^BŒ­n¬­r°q˜^ØdB"Y3ÌA%ÆA+ÎAÅ×Qé€£^°£r˜£ÖRÂ¿Ç8ÅQ)ÇQÿ€“I°“V¸“I¸‹Mœ«u»í%w“L­0ÏmG=Iá»ô#vÙÜeqÔËíe™³[÷ˆ/1Æ×-Å×<Ï× Ë—œäï»Ï|~¿Çÿ¼„‡ÎéA‚ÿç%$ğ(6K:èü uÓá 
ªyFÈ¾¬÷¢×ô0×‡a>¬ğ}ãî³Gv_ˆ¶oˆŞÃˆ*ˆ=À<êu,¢ˆæUœÖ˜èX˜ä?D)N‰kIİ]{â;cÙ©è²SI·OÅÏœ
¬ÍŒëÌôùyøÖéƒÉ½Ì£eYXTNvFc~J}Á‘ºÂÓ‚ÂÅ¢ğ¶’Œ¥aWËXõå…õñÃáW+Ûª
VÅ}¯Jœc.+ÿ™ĞUSøô<­ıBÅ§KçÛ¹™õU÷ê«^Ôg¼ªOZmH^lŒ_hJ_lJº×Ì\oIÿv9õn+÷cküRBÒ@w¶-i¶-s±-ı?,!}ñ:SÀ+~tƒı?&aéFÊòŒåÌ¥öÂ¾Ëc³ì—7OÜéx|÷ÊÃ*aOõ›û…Ÿï—<|p÷9¿sº·æMoóóş/ıµsÕSCÿ	Ï¯<<ÿbl`vìÜÛ±ÆÏcÍu/ŒÌ>{=uinê¦pz`qš»:İøîé£ùçmŸfø_^t,¾š^ıÏHøşêÁâë[+¯Ÿ~šŸ^YxığàëbÇ÷Eş÷ÅÇßŞ½şöéõO·¿­,~[í_ÿòpıËÊÑìÑâïµ©?kc¿¾İûı­ï÷·•??¾ıÜxû÷?&áFÂÏ­Ÿÿ1	?ş™úHxõÿ	ÿ€KŸã<JÖ÷ï}â¬ÏYãÙòMã,Éxí›qå…ºµ´Dw5	ÃêåmóŸ6Lá2Ô˜šóº¹İs9
áëî9
ñKŞu†Óôr\®Šı{¡y¹´£«ŒÇøí‹ŞBdğdÂ‘¿
mğ•ÛÕ-»-aâ²^ ,®kDäçCw”9Ğm4BúÈ²R‘4G––³Xb¬=Ô˜l'
µJgÔ©hdPEĞQ"ÜkÍËfÓrãuuëº7«ëN4ä[·.·ÊSÈ@åI Ãlã&‡Hóëõ{›3~,çzy;Ô;…½7
I`ä“¯SÿÈõÊ
RvbÂIñ,eª¸ùå÷)œYv¡§—¨U£ÓPœ)Òiñã4¨)ãéĞ@efóÅSŒ¸¸^…Öşù7§Ó9ÄFäö`>CÜEÂ˜)Û0  uR®áÇ•­”¿ª6<^Î”ÇcMH çš-ÿ!©/®1eîu&éN»ªû”Ü}ã &^ê3O:Û;©ßC7jÎ
åŒÍ©úù®©„ºƒ (x!Ù±_¯n<.[í=b¹I›-1«št„m¯'Z`%‘¼^ŒsŞWø–rúÆÜÏ·™µêÙâ*=ÁôGºš5M€¿tÙXWâ»°‰êr?oFİ ªRB5UÎ+Z|¨•*±ki/±ı–´Û°¤Ğ…Teıü*FĞ:áúáŠnd§H0i0AMŸ1É›ÚŞœTl½<\o½¼Ö²ğÈ¨—Ôr:@õõŠ£$OÅõéøÕ°—}«Ï/dùf7%aø›×à³5KvşùùåŸ¶:6ÃêhK|L"À¡]Úr§cº‡§/è†~¤	ĞÁ<°x[!ò{ÀlÄ—¬$©¾£ÃÕûÉ,„<ÒûA¤0´”5öšíÚœ¶P?eÛ‡İ2­®
ÍÀg ‘×o4Ò«Æ§ü)2µ÷†kŒq€|G¿ñ(aNxíËé	'4˜ŠpXIwv5©Ür˜Tû@‡o{C†Ö¡“šG™†ıs•*k}*!H¡$’!“ÌøÍôıx>èÚzíôZ| – —ø5¾tP»häğ¶åzX­ó.ë8	²A.-ŒÓRRÙ™îŞ†“€G9?»ÄªAr9n Öó’ğõ]¬N2Tƒœí™¦y¶ÕK¸-qFv9Ş­,“óuà¨L1~Fğ ˜
º
Á¸ÆCwË £-E –åæ„Â€ä$Ÿ¼X›»’Ú6€nÑıĞP ±!PZÄè ×ò´Ü9ø7ˆ“ü3XT³Z7i	õäû=…ÙÅai«ë¨ÕËŞnIÍºæZ{ol,ãQ2Ê^È;!ÄNM´xıEYLVÊèªüÉ‘Wî{”O!_8«m3W6¹m¡Â ¨<˜¯ƒz±Öív@¦EF¹’²yùî­_Œ0ÛÇ<sÔZÈ24ï§¯×#-¨ÙÆ0!7/}Åu5¡äÈ®€Í¸ÎŞEO v )óçOÊè-w' Ä¥…ÁEŠàíiå%şQêTZÌ–§:›_n	"ÖÒàwÔ•ÃA[njÁìF0›õc»ì½ò<­íL•.Óš Ì’ò¤lù€Ø!ü-g¦JËêruiv|S>Œ…İµs‚›[‘ò-=  ,y¯M‘Eša·>ŒÆ1Š_uCn'?U–ˆ3:4âY¢pDX[·§	‘¼Ş©+™8¤î“
 §99æÔŞ+8Ï1* ·Á÷„°sNçÜıäuLıA7hßÊRíÙ`!º¡÷×j±ı©•åâ÷¾Ò³0œ6	ìzõ&û,ÖrÒVÏƒ•§–·»AååSû6¿‚8@%++77#è€;¨`¹•y„Pú|ˆî¯w8¾ëİ½3Õ$Ëª-Q'ÿ×FµùG qŞs{¬ì&Â”G3u'ÃÂ9ƒ±“¹†GâÁq÷İ–E…A© ûkàªOpFwèG/…«Ï_§.à$Z*G´(Ùá¢ú«-D‰µMQxT¾Å×ôœ•>%½v›Ë€ÎVW–ä”H5(è[—²¹¾Ú€2ĞTÃÙÙô3ïNô³¿×éûÆ%ƒ¼gÎ_g¤@+„©ÉwC¦"`ò$È^ï©b{?ò5· ‚Í½À+éµ?–`âQï™¨¸å§É;-ú$2a·~z­z;~X½;navFEøj:ãxcë·şWúš¾6ÉAœ^+jtÇ©<ık€7?˜8ò&LEåxÅ°úö‰´F_¢”“YÕ½šòòë34Ç]şÙGôuË|a6v$ˆ³üßNpO·â*Ó~İÚ´uÉa4æØˆ¼ ºÿù';{#HR ¯ï–¿(ÉCût'½,_.²`aãƒ.²¢6¹ùı4xkåÍ÷Vœ’|Úâø˜ãøØ¿VnS¥«ı¹—vî$§GeŒ§¯‡Éç\Ú×tTğkí'{¦—|7c.²¡[¨¾ˆóæ6‡ß¼<HØØ%mêÊ£³`<±áùæ½åhŠ*Êyc·m|«fKIzk5ãFjz•y^,‡œ>NÏÂ—lèÚk¿^ïo´óKhMıN/§H¸F©½cè1Úo³ëbC%ÈšSŒâq…¿ Ü	Ñ“™ˆP[¼£ ’¶EÆÈŠtûÓÔ­ri@q"p€íg/Š÷¡³˜£‡ªçp§& šRædäİï§µuNoQp{8º’T8…‹ª€L>n[uVQ2Ú Ÿy¸	1éªğÅÌXKÊœÅö´laeY3„†c•Pæ t™Î_¤³´“A±?I¨=3`Ì #wR½oì§
åPoå¬ÀÑ•æƒ?$ş¡côé ­mt°-3œë6„ûñÌàğ=‰Qò…h;:Å ò¡a—òD‰/P ÖnÁ»%RòZ\&°EÈüÑpñ×øãdS"6M9ÃRÇ €†æc,É‡¯E1VDGû4AÙ´ü?|”®?Á†MÈ‚R°x`w_P8[¯âƒ›õ¤Q4õ¸¼4È(œ@Ò‘€*mP4>Ûs¡›BĞà³Å#,ëÕúC¬däá#RXÉãˆNÛR¤âótÔ„´RB	pDœ…†şÛ§Öî9øj (ItşÂù'G¼cB•óKôo”Ê··Û;¤é@üÕHÀq¾³Ìå¬
{Úgf7$íÔí¦!<fÊâµÈ™GlLÙĞ£9ê ²OpæØ¦›¾2Q±çWÅ}f„‡uÕĞT·’úËÃÂŸ‚CL@¡|¬õe¯
h¥jr[]~Œ]òbç
\JXîÁ÷ø%™‚ÆÆtsÄÊ'Ñ<˜İÄƒúIËbŞÉ)õÖ>0r<‰'v‹¹ıd‡¢&Şñ²„r|GÙ™“vô…û%!(âD¥'¨4ß8&:72ña“Cœ Ñ|ß°$†YÕJCFSáGÊöùJí¡ Åäh‘1ûkùr»n) ˆÀ;9°£|D­ı’¿ãÂ<AõŒÄ›yøêSG‰n©)ÒB×;yâœ­Ë¤¡,u—jkJA¦|”ÀÌã„"tíÂ—Q§ƒPt:¬'cˆäè 8µckàÉ2Îø£¨¿ ÙÛÔDàh<²U„òwt|”(Ù›Jƒ*øeÂ×yˆ‰ßÅİ¥p(ûĞ²Uİ•éœ¡09ğ‚’€àzS+„×­ë¢ñ`LX	 §˜9Á@@rà®z*€Ô¸ôG“¦BIì:K;ìı˜z¶ó:¹ã˜Çö6#‡¡üÍœk<¸ôIàÃw.¶F‹"º|m=H˜D‰ogş½ÜEnÖ`W'™Nƒ·ÌH€‚_‚øPà±<xÄ’}qœ?H†Ú!e@íıVĞ\âÅË›óğVÂù÷—ñ#$(â¬ñ¡ØøÍs?xàO¤×y% E&ÀN®ëvò=Òå;ÙG“a	(’á˜éKüÎ½—$T ¬ÆĞäÚQ&1dF‡äÁãQ·È˜)ö`7¡)>æví}Ìµeî5;`Î’Çyğ=Tˆ*ï²Ÿœ‘A¶MşØaÛ§¦‹‹ÄÚY¶­Æâ4DÒ‰»œ„hˆˆç»;¤5ødá¹»AX[¼
-~Å»‹1‚tØáÏ­ğXæn„†İ@S9“½ V
dN‡Å’‘í f–Îú!¾HÂv‘Q,Š‹åÈ„8*©r
çˆ=ãé7ÒÓåøàãšŒ4s´-¡Á–†Ş_e½B‚Ÿéû4ÒFø~+H?ïø>Ä#‰	Úä
Z»_Çï^†7¿ƒ½B†«ß†¤ 
‰Är¿Aò<çaºğ¨˜9¨`»lz“tıiÈ^zÓ°'F¨Ó@2$P&¡Î¯4_Jhš­´¥CÏ<ëòQw¤Q ıV@)éßøˆ!stT'@ûÓnYìGÊˆÀÛş}Ñ1§m¬6· \+Ïpu­#µK€Á£:øØk±ÉË4ìÙW02Õã-$~B‰«O…×r°z6êÙPÂ’¤~Ç3¢”6¤P%Hba±â·NÛ“
ö0pálMzDsüWÂ!ü¾p<Vüş¾šr.ş4ö¦ÛJ†Ïj]•µ´DVí4ÌßWéË$laI$H;?HrÑdÀ…ƒèîg|Â%IN–åPÄ®ğ ÚÏ~3üs¬„!I¾²{.'p:Kï/•ÙÇ§AĞ4{rR¡9v«Z’†Töñ¿S†3< ªsPZ¤]p‚£¢9ÿDŠ¿‡"x¦å’W·]]ãEèé¬í©yÆ iâÍ}QøAe‰°èä$¸äØ–Aé‘9Ä
>¸8‡O‚;à»"zè°Ğ`ôºyP}‰&[T_Ååv„’QuJfE¨clèù‡:éé šâ£Ş'Ù¦b}„ó‰é€È’‰İÒ=œãËplï/¤ğzÚ PîFŠgqnG†CÎŠ]ÂƒŠ™àíØŸ0MCÖû€ÖÁH@ƒ ×p_ˆN‹%ƒ:9ãeûl'¬•Éğ7)æÃiƒØ=$p¿­S&m´Ö%©xâÙÄ]ÛIñæì·¾qÿ˜oaÍE$ø÷¬xµD~¿}9Êjß32† s¼KÔo}ÇÇ£öLLA&|ùäVD_½o!KhœtÑã£šKmñÏ	ğ3í ˆ~ÌÓœH” QÍñË<¸LñÖÓ§ï2p¡<°¬mmHô0y*A€e’°ic¹‹Tô	2T…ÖG¢uÂœ–ÈØzÇ¬İÖÒSB„££É.Ü8†såè0¾s¸×Ã»u·w½Ã1„4Ú_ ‚†ËºÀÛšÀ ¦Á„#Ç«šˆæDø%ÂtØèÎGd¤¹ĞîâIS
t°÷œ~KL9‚U	°Ğ­±(^7L[7=PÈôæŠŸ/4•BßQãÖğH8àAZÊÚÙIvI†dàï+ˆ?*€<;Ì45 ŠåƒßĞ¡ª@£8Ö66EÈ ·ÓÁ=»dV9–o‚¥ØñPU”ÿöh/ ¡#¿>:ZOÓÇH$bŒ?¹vĞqV„ôy]\ö)ÏH9Ë#RZ\c½$y8’^ä;¹+´jÖ7ëg.fN3n×¤Ò6‘¡™¦z2Àæ`&$$«<]NüÕäÖXˆ„òAÊ"Ö‡ZÒuOLC_:— rÏ:n$ój›³ÍZŒLÚE|2'½FClu›‹O\«Y"ú¤A-g™a’â!¾·¨
Kÿ”[ ©ÿ`SÍsÊ2KØ SGF¡‰Ç>:‘"ştk²®?À¾¶ÍÖ ô\E¾[0Åş»`BØ¹÷ª˜¦¾67³SŸ.;»áPuP°¨oûd–Ğ.”£Å> "Ì×¼”"L GwŞTNX)}úÌ§z|¹#£µİ;‚Şu—§xˆ®Pqa$½Ğ0ÛÔ;2µ¹K:"ôB#®ƒòNW2M2y¸YÕÀ¯|ìï$QÈñE4=‹oeQ>lBF*+¾¦¬ÜÌÒ±›(ı~EºL“*eæ­Û‚–ŠŞS0¦^EËöÉrµÆ«ãC¢ùûWŒíV%ØkĞİÓ®và&T›<I¤ß™‰‡¢ôl!aÀAa¦T@òHòı
v§«]†fğqu‡^˜½ıŞYi]O×~bÁ6'Å5Şœ»2í9 „å”_ï¿ÃílçµaHØúG¼îÍÏbgL•ÒºÄ :eÃ–‚B?ş~èÁÆôQ¾¡ğR¶GbŒı]¸ÿµó
€Iç-é°Á;ğyÌí²«|”ı1Ô×Y€!Rp_	ßJ¯á&È.–”%=ºÍãöKWHŒ/C÷/Õİûı¡^O<Q³-| ¼Ê¿$ªßš€UN›IBz#?ÑŞï¹!v€M„ö¯Å!­§WDè©	ìû·ØkN˜z!"š5%ê]LFÛ}Xjà0Z«aãÁƒĞƒ¸pÀÉÁ«apÊÕä¹\"Ãõ{ÍàîùÎ¼¡ÈÕÀ¬ì~d±&¹‡Ge`2ÿn\p>çóÎ³Rÿà}–‚¯öXrnš<Ô»Îy#lˆ˜C”:¢r…;ËPÃi¡œi1½şáü/Ú>xïÿ	.ºœß·ÔuôõıltªŞşÔ®Á ‡ç%‰åĞ¹ÿÆ0ÏÒ×y	TYGä˜ˆ’V#j«o9wÁîô\e3üAêô¬Öeúœü½…ój­¹ì'¸|Xz.IÎ–ÒÏ¸GYÀñÒ“Tİ¶*c×oçªlKHÌÌ€Zò­¡‡ôÓ:İG™0ØÚb‡aZÌ½fÄáã9ÙÃ77_ ı“¹uñ÷í¾¬*òÛG3È?­tæë´‰¹ØÌÀŒ¬V®¸/@-A—g)_-,7p~_)å}õƒ§³Ä«ã¿ 2Q<*æèÀL,Ûoê0á2~xCwy}Êuw@Y—‡ïü³™eì¹cÌ‡s­ÕlR¯–°ı¡Ê7¿Ğ©%!·#sÅC ‚¹õà;KÛ®Hù6l%Ó‡A‘ªó®­İiVŠÊû«KrÿcâmÃëƒˆg8µ0%Ç½~{Õ½ÇçT‹ÜöúsÔ/O³1¦Êp5«¦lí|»ÿş_w÷^ÒMØ¡U¤ŸCì¢äúŠi/š¼ö}³B©~C™cİ68€üg*ÜÙåcç‡j›L:tÔmcßô=æÊ¡÷ì^´­ËÃÃ,¼S¤Ø>Êá–ìÑ€J¥—ç¥Ã¸„¬B-ÛÆ„bÏ•ŞB'úÑ÷÷«å¤íü³>¹]…ÖÅ¬
1UÍ©9:İ¬õ{ßhóbùAE~Ì’èL™—åRªâL§rèÅÖÆôüÈ¦­wùÊ–ÈËLvñ5P]÷×Şô¸\…Eõi±Ö “LÇ7U¡“ ÜšÁÔÅ’I#şû4#ï®+Ç£>—Ez)ÓÒ&¬EÀ1:ÔÂCİ¡·>v7YÕkÊ»Ê˜ äkê`Ì=Óªñoã°¬âÏÃY 6=˜&qûEXŒ³ø8*g)ìüm‡¤ÄÎ›¯sìR_x¿t—ÃÓø |§>'×ø½öêÕ¦0OC4î°ëànéÕdLÊò¬îE#1aTÎ´?Š.kWë}HoøÁg¢´¦ŠB"swfş
YÍ­6Êt¤3¾­NïT¼$jšc—Xšzò,‹­é„âÈZÄ @ Õq°;=;OSN`Ôw=7şN(F!©I®“Ù`e!Ä Šëöƒù7Í4d…`öİpénÇÌx dùYäz½¤zĞüø‰U­¬LQùş¦¹,Ì/’Ë†1´nPYÌ¹š9ã×2wÆÁ´ÔnP"OmqÌx4¨\õâWk…®É¢ö¤'†O&ÚÄ—e	½Û§ªøŒzg[nÅ·Ô#7úöşM´i½H/öY€‰p‚ˆ@–òÌKZy€h$Ä~¼˜Th) ïİqAlDt×½É³×+.ØÏróµ*F‹w’År§•!(3šà+{Ë—á¬gÉ…²%`ò-P-eø—“˜ußšB£ÛÈ=µ{ö!å"A¥t1wª[ù…õ¡ïsG‘}5’º~ñËèäáeÎ@Jk-††2—d+MòÄ­å4®õBÌZ´ìVl d[èh8-'‰nBü‘7¤Ó)|W˜“N¿ùæä¸ÿÀT£a‘dt\‘Jİ1"ÍW¨~?»N-`*3ohuW1½x´4+{bXSuïÑÖÀ?~g@äNÉ•P79([ X;'JÅ —'¯³5ñ· Œtv;,x	İt,[¯b³§zõåñ¶üh™¡€ËKJ£èªÖ
&ïîs4A6q]C2İ2KJëU¶ÙŠºä½¥©€–“I[æÁ"'ü™¶ÚX(o c+¸­¤‰	ËÏRëÏOù}.S+ì8wÛY±Ë‘ì<°²Õ¹?Kaƒ]ëªö”¨>OcIÉÓérK4PÆdãVnl^£¤ÀDş F¯;÷z‡mÈî—ÔÊ˜,yX
“ˆÆNÑ@Ş`<Ì–úxÂ%ÿcídÎ9˜·JÄLèQå›ÌÏ\é»EEÈD÷?¤AÅiU6ˆ8~ÿvsÆgª¤EÇ;faÙ¤¢-Ssp0ØËU°”,üÑ=d÷Ì(ïòÑ/0Àú…;UÛâ¶Ö+RŸOüI ]ÈtXÏ‘'NT©npåú	ÆoÄ(-ò‹0Ój… ®Ø*îE¿1²WªtÄz§:ÒØò¢ñ¹2‘@”DpØVø±ÄÁò!¸„šk×Zš-uRˆ»r4ˆ=4™Ã&}‚ésºû?„ïIº£¶Ä;GLvÌ€ŸLÍÃe˜ó¢›Ê‘OéËZl<·'DÁäDÈÚ.dH²yÙ?YF@$£àc±A0q0­îÒ°_ó¹Ë 9RØÍ¾;ß,(„áé'3œ œú©®;sJaR[­ÍºÅ¶)|N9ªŸÓ»4ÁŞ›:tß‹ƒYù.fÑ~¬0Ã(&§õÊ¨®¸ü!Üc¶ğº"›=^si<Q¥ò"µ«r˜&“3~°aø¼ä©‡^`å]{-¼Oèä{ıâoş¡µ¤5+‘¨ù»gİX,DR@¿‚©Ö9ŒØ;XÁEe7UtXovYé,HÈ0öú¢7…ÔrÃ ,“1.Òy” Q°“-t47¨ø…¹\ŒÊ¹C’î}&:ÚI÷¥Ôn8À¦¥ÊPµ‚û¦¾CŠ–>ôÀäÕwKL˜˜07mfA™Ay–CXÔü*$tokÿ~e×V/ dz>ËœX ¶z/}à¢œØ´0iÆÊC´»¨¿ï 'ïmÉMîlÿ2ôø¨ÍúDüÃ†	0„Í¬9ïŠ„ĞPPš«U« ÒM…ïz7j–x‹#­‰_«!K—€¸'åö3©ôµÔÍ³öîkŞ÷àŠ§ÆÜÃıXí…ãåÒ@ß9 ÿnéj§û°Œú7wÎ<¼A÷A¡@æ¯úsŞ-ö„ }y<Fd/şi›Z5Ä£“{ÒİwJ¥=¢ü0±{H±»‘…p¿|Å¢iÌÄ¶ûÚ†ı´Ò¥$,äcu‡$j†YÆßV¸½Æ$K öê æÊİ[7›¬àJdÀÆ›ÑË<Ä/7iaàD û’èT:6`§lœ ;6«ö“õv®MZ‹‡§Úw$+! ÷0åö¢ÂU`®Ë®YıÈTëVF-A®…ôºÄñ(²n
ô+ù¹|¦B]^ºVGÀ·hJ-¦³jB¢±Wí,Ê#¤±¨±}¬‚lRŞÛ ;0G]$Á®Ê¢æ	AJ*İí_G —K™ò¹nìkÒËŒp
Ù5Ùuæÿ!ëÍÿ¡|¼ÿÿëšİ,f0ûŒ­±5¤ÌØ“4v!)BRQÒ53–±¤Idik’¤R©T3–’$•-©çˆJ¢¤Mªy}zışçv;?œÛãÜï¿œó4ë,O+Hø%s…\ÒáTí„ÒçRıW<vÑx‘v½ÿLàè8àÂé-Cxñ—“ì¯T¢Ìg!J>ˆhº¦Fc0”cié2d´Ìåğb¥³ØÛ“J™Ì¸ŸŸ£s`Hàİâf‹7Ú\Y}×xjC¢C V¤óÑxLR7§[ Gá©&t^YD9J@¥q¡¾ôå´MG×ï¥üèÅ«DÎ1ç7]#?§¯.«<›«o!Ç£Wò#E|Œ¨8.‚né‡¶|fª©³­;Gë:#Rğá§8â
ÚBà`Ì­Xqhı}g\SÎŒrTÉ`øÖ#ünºå[´AÇŠ S‰W*öŞZ*L;ÕOÊ·æp<Šv0e ¤á—g8Ep[ïÃú¢mœÎ}NÉ~­—szr|÷Rà¯; ,C°¿}?094‹íûKfMÊéoåˆy.¨İM.SH-É AúÑo½P Gˆ•àæpÜÁÊ<ßE]°‚G·çª:òTÄW/v§×«¸''†Ğ©M0…!l64kMÆe
s4g"Ğ_#„¯iƒ[Œ¤T¦iÓ¦3ÓOÚØù«IĞR`ÃÌ?vòÇğPÅl¾»hÅ§:%‹ın6×€©3ylHu#„
‡ÔNÙ'´))Ù9¾vÿi)~ËÂö'Ùâ<Cè˜©dm]À¬#ú< IªT½ÔVƒírzÈ8øß8ÏtUø­÷öYøS@UVr0)/IæØˆ`ç«@íEĞ´Í´ÙXb¾·Ç«±[g¹ğ¬Ü7ïsjÈD8y*ì@E‹r7µåns$³T•6KšT8<Ãñ¼LJUWyíUOƒ/­‡=t2by©†xÉ_-‚pá»]uco°ñpğª§ù™ÿ÷èÑ"P0w3àmc.W•oäïç˜”¥„m—„Ÿ®Ì¬D`A²¸^ûãÈÎ†€okB°" U0ÊE‡şiÊ3z¤Ö7²¥atß÷SÑb¤	²c{ŒİNY{w·Ñæ?î@JLşi¹ÇXö÷:®£ ã7¯Ú]6ó;ôf¬‘Äc~Ë'4¼¼ ˆ|ø©ì“ÛÖ†ß-yÊFâÿïö´Avîø±ï§ö¥òAŠ“&µ |b¼xdœû½Ç³!R´–úâAìC.Cëd·§¿¨x‹?>•#¡m†_4¨jóêÔqXâb5bşiÍ+‹b{8lÚuuSã÷ˆ9Dİâ1·Ê	DûDZĞ¿~òMyË*¼€å‰rÂ?šNÕ(üŒÅ«gWÓm¶÷æ¾î£ö”½ìj8Îí€°SE~Ùüıå‰áBkx–#DtD‘òÎÇ€ª\ø¥˜Í}G&åÃÙL¹-J›ò|ßÛº'[¨EùûÄ[ö.¢
$¯&Ë…)TôşÅ-h‹¦®µèü`jh±Å–M‘&‡wğ<˜„ßº0r1\¼o•LÍÛLÉõfæ¬…ö‚E%u«9fØê±ÿûş¤¦n¥²×,é®Ü¬x7åDyÛ9¨ñ«µ6a,B¤O/²#fíºCáùæ	…0n@9:ıß*rÌ‹lÊñ^ØÎò-|`º©g¾ıêë=ˆ•œ=7îfù¦¶Wë*rhõY
¨Ìtx‹à[b¶ºRr¼)ÈØ¼}ÜfÀØ,…Éwî]sœ¡ğ¿‘)Ê%bÀ‘&Şè!9û GŒÍÎYãW|Ö%Ä¼»mûæqÃ³z]´0^d­;­İ¡W^~c¯æ‚hó£pÇâ× lE`İ÷!¨h™QP&Ş°é²Oß³‹õïD…¬ÖAÖ˜MÑ…ù;gs}ÇÖák®OSÇ?L­"2Kœm% c»	FcğCÔ`AşoÃ²·k0xø!@G† |ä füêæaeETl)ÖOå[rù *˜ù­$§ó     leftType,
            Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type,
            /*isAwaitValid*/
            true
          );
          const rightOk = checkArithmeticOperandType(
            right,
            rightType,
            Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type,
            /*isAwaitValid*/
            true
          );
          let resultType2;
          if (isTypeAssignableToKind(leftType, 3 /* AnyOrUnknown */) && isTypeAssignableToKind(rightType, 3 /* AnyOrUnknown */) || // Or, if neither could be bigint, implicit coercion results in a number result
          !(maybeTypeOfKind(leftType, 2112 /* BigIntLike */) || maybeTypeOfKind(rightType, 2112 /* BigIntLike */))) {
            resultType2 = numberType;
          } else if (bothAreBigIntLike(leftType, rightType)) {
            switch (operator) {
              case 50 /* GreaterThanGreaterThanGreaterThanToken */:
              case 73 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                reportOperatorError();
                break;
              case 43 /* AsteriskAsteriskToken */:
              case 68 /* AsteriskAsteriskEqualsToken */:
                if (languageVersion < 3 /* ES2016 */) {
                  error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);
                }
            }
            resultType2 = bigintType;
          } else {
            reportOperatorError(bothAreBigIntLike);
            resultType2 = errorType;
          }
          if (leftOk && rightOk) {
            checkAssignmentOperator(resultType2);
          }
          return resultType2;
        }
      case 40 /* PlusToken */:
      case 65 /* PlusEqualsToken */:
        if (leftType === silentNeverType || rightType === silentNeverType) {
          return silentNeverType;
        }
        if (!isTypeAssignableToKind(leftType, 402653316 /* StringLike */) && !isTypeAssignableToKind(rightType, 402653316 /* StringLike */)) {
          leftType = checkNonNullType(leftType, left);
          rightType = checkNonNullType(rightType, right);
        }
        let resultType;
        if (isTypeAssignableToKind(
          leftType,
          296 /* NumberLike */,
          /*strict*/
          true
        ) && isTypeAssignableToKind(
          rightType,
          296 /* NumberLike */,
          /*strict*/
          true
        )) {
          resultType = numberType;
        } else if (isTypeAssignableToKind(
          leftType,
          2112 /* BigIntLike */,
          /*strict*/
          true
        ) && isTypeAssignableToKind(
          rightType,
          2112 /* BigIntLike */,
          /*strict*/
          true
        )) {
          resultType = bigintType;
        } else if (isTypeAssignableToKind(
          leftType,
          402653316 /* StringLike */,
          /*strict*/
          true
        ) || isTypeAssignableToKind(
          rightType,
          402653316 /* StringLike */,
          /*strict*/
          true
        )) {
          resultType = stringType;
        } else if (isTypeAny(leftType) || isTypeAny(rightType)) {
          resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;
        }
        if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
          return resultType;
        }
        if (!resultType) {
          const closeEnoughKind = 296 /* NumberLike */ | 2112 /* BigIntLike */ | 402653316 /* StringLike */ | 3 /* AnyOrUnknown */;
          reportOperatorError(
            (left2, right2) => isTypeAssignableToKind(left2, closeEnoughKind) && isTypeAssignableToKind(right2, closeEnoughKind)
          );
          return anyType;
        }
        if (operator === 65 /* PlusEqualsToken */) {
          checkAssignmentOperator(resultType);
        }
        return resultType;
      case 30 /* LessThanToken */:
      case 32 /* GreaterThanToken */:
      case 33 /* LessThanEqualsToken */:
      case 34 /* GreaterThanEqualsToken */:
        if (checkForDisallowedESSymbolOperand(operator)) {
          leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));
          rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));
          reportOperatorErrorUnless((left2, right2) => {
            if (isTypeAny(left2) || isTypeAny(right2)) {
              return true;
            }
            const leftAssignableToNumber = isTypeAssignableTo(left2, numberOrBigIntType);
            const rightAssignableToNumber = isTypeAssignableTo(right2, numberOrBigIntType);
            return leftAssignableToNumber && rightAssignableToNumber || !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left2, right2);
          });
        }
        return booleanType;
      case 35 /* EqualsEqualsToken */:
      case 36 /* ExclamationEqualsToken */:
      case 37 /* EqualsEqualsEqualsToken */:
      case 38 /* ExclamationEqualsEqualsToken */:
        if (!(checkMode && checkMode & 64 /* TypeOnly */)) {
          if ((isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) && // only report for === and !== in JS, not == or !=
          (!isInJSFile(left) || (operator === 37 /* EqualsEqualsEqualsToken */ || operator === 38 /* ExclamationEqualsEqualsToken */))) {
            const eqType = operator === 35 /* EqualsEqualsToken */ || operator === 37 /* EqualsEqualsEqualsToken */;
            error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");
          }
          checkNaNEquality(errorNode, operator, left, right);
          reportOperatorErrorUnless((left2, right2) => isTypeEqualityComparableTo(left2, right2) || isTypeEqualityComparableTo(right2, left2));
        }
        return booleanType;
      case 104 /* InstanceOfKeyword */:
        return checkInstanceOfExpression(left, right, leftType, rightType, checkMode);
      case 103 /* InKeyword */:
        return checkInExpression(left, right, leftType, rightType);
      case 56 /* AmpersandAmpersandToken */:
      case 77 /* AmpersandAmpersandEqualsToken */: {
        const resultType2 = hasTypeFacts(leftType, 4194304 /* Truthy */) ? getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) : leftType;
        if (operator === 77 /* AmpersandAmpersandEqualsToken */) {
          checkAssignmentOperator(rightType);
        }
        return resultType2;
      }
      case 57 /* BarBarToken */:
      case 76 /* BarBarEqualsToken */: {
        const resultType2 = hasTypeFacts(leftType, 8388608 /* Falsy */) ? getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], 2 /* Subtype */) : leftType;
        if (operator === 76 /* BarBarEqualsToken */) {
          checkAssignmentOperator(rightType);
        }
        return resultType2;
      }
      case 61 /* QuestionQuestionToken */:
      case 78 /* QuestionQuestionEqualsToken */: {
        const resultType2 = hasTypeFacts(leftType, 262144 /* EQUndefinedOrNull */) ? getUnionType([getNonNullableType(leftType), rightType], 2 /* Subtype */) : leftType;
        if (operator === 78 /* QuestionQuestionEqualsToken */) {
          checkAssignmentOperator(rightType);
        }
        return resultType2;
      }
      case 64 /* EqualsToken */:
        const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : 0 /* None */;
        checkAssignmentDeclaration(declKind, rightType);
        if (isAssignmentDeclaration2(declKind)) {
          if (!(rightType.flags & 524288 /* Object */) || declKind !== 2 /* ModuleExports */ && declKind !== 6 /* Prototype */ && !isEmptyObjectType(rightType) && !isFunctionObjectType(rightType) && !(getObjectFlags(rightType) & 1 /* Class */)) {
            checkAssignmentOperator(rightType);
          }
          return leftType;
        } else {
          checkAssignmentOperator(rightType);
          return rightType;
        }
      case 28 /* CommaToken */:
        if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent)) {
          const sf = getSourceFileOfNode(left);
          const sourceText = sf.text;
          const start = skipTrivia(sourceText, left.pos);
          const isInDiag2657 = sf.parseDiagnostics.some((diag2) => {
            if (diag2.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code)
              return false;
            return textSpanContainsPosition(diag2, start);
          });
          if (!isInDiag2657)
            error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
        }
        return rightType;
      default:
        return Debug.fail();
    }
    function bothAreBigIntLike(left2, right2) {
      return isTypeAssignableToKind(left2, 2112 /* BigIntLike */) && isTypeAssignableToKind(right2, 2112 /* BigIntLike */);
    }
    function checkAssignmentDeclaration(kind, rightType2) {
      if (kind === 2 /* ModuleExports */) {
        for (const prop of getPropertiesOfObjectType(rightType2)) {
          const propType = getTypeOfSymbol(prop);
          if (propType.symbol && propType.symbol.flags & 32 /* Class */) {
            const name = prop.escapedName;
            const symbol = resolveName(
              prop.valueDeclaration,
              name,
              788968 /* Type */,
              /*nameNotFoundMessage*/
              void 0,
              name,
              /*isUse*/
              false
            );
            if ((symbol == null ? void 0 : symbol.declarations) && symbol.declarations.some(isJSDocTypedefTag)) {
              addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop);
              addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol);
            }
          }
        }
      }
    }
    function isIndirectCall(node) {
      return node.parent.kind === 217 /* ParenthesizedExpression */ && isNumericLiteral(node.left) && node.left.text === "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression === node.parent || node.parent.parent.kind === 215 /* TaggedTemplateExpression */) && // special-case for "eval" because it's the only non-access case where an indirect call actually affects behavior.
      (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText === "eval");
    }
    function checkForDisallowedESSymbolOperand(operator2) {
      const offendingSymbolOperand = maybeTypeOfKindConsideringBaseConstraint(leftType, 12288 /* ESSymbolLike */) ? left : maybeTypeOfKindConsideringBaseConstraint(rightType, 12288 /* ESSymbolLike */) ? right : void 0;
      if (offendingSymbolOperand) {
        error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator2));
        return false;
      }
      return true;
    }
    function getSuggestedBooleanOperator(operator2) {
      switch (operator2) {
        case 52 /* BarToken */:
        case 75 /* BarEqualsToken */:
          return 57 /* BarBarToken */;
        case 53 /* CaretToken */:
        case 79 /* CaretEqualsToken */:
          return 38 /* ExclamationEqualsEqualsToken */;
        case 51 /* AmpersandToken */:
        case 74 /* AmpersandEqualsToken */:
          return 56 /* AmpersandAmpersandToken */;
        default:
          return void 0;
      }
    }
    function checkAssignmentOperator(valueType) {
      if (isAssignmentOperator(operator)) {
        addLazyDiagnostic(checkAssignmentOperatorWorker);
      }
      function checkAssignmentOperatorWorker() {
        let assigneeType = leftType;
        if (isCompoundAssignment(operatorToken.kind) && left.kind === 211 /* PropertyAccessExpression */) {
          assigneeType = checkPropertyAccessExpression(
            left,
            /*checkMode*/
            void 0,
            /*writeOnly*/
            true
          );
        }
        if (checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access)) {
          let headMessage;
          if (exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, 32768 /* Undefined */)) {
            const target = getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText);
            if (isExactOptionalPropertyMismatch(valueType, target)) {
              headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target;
            }
          }
          checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage);
        }
      }
    }
    function isAssignmentDeclaration2(kind) {
      var _a;
      switch (kind) {
        case 2 /* ModuleExports */:
          return true;
        case 1 /* ExportsProperty */:
        case 5 /* Property */:
        case 6 /* Prototype */:
        case 3 /* PrototypeProperty */:
        case 4 /* ThisProperty */:
          const symbol = getSymbolOfNode(left);
          const init = getAssignedExpandoInitializer(right);
          return !!init && isObjectLiteralExpression(init) && !!((_a = symbol == null ? void 0 : symbol.exports) == null ? void 0 : _a.size);
        default:
          return false;
      }
    }
    function reportOperatorErrorUnless(typesAreCompatible) {
      if (!typesAreCompatible(leftType, rightType)) {
        reportOperatorError(typesAreCompatible);
        return true;
      }
      return false;
    }
    function reportOperatorError(isRelated) {
      let wouldWorkWithAwait = false;
      const errNode = errorNode || operatorToken;
      if (isRelated) {
        const awaitedLeftType = getAwaitedTypeNoAlias(leftType);
        const awaitedRightType = getAwaitedTypeNoAlias(rightType);
        wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType);
      }
      let effectiveLeft = leftType;
      let effectiveRight = rightType;
      if (!wouldWorkWithAwait && isRelated) {
        [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated);
      }
      const [leftStr, rightStr] = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight);
      if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr)) {
        errorAndMaybeSuggestAwait(
          errNode,
          wouldWorkWithAwait,
          Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2,
          tokenToString(operatorToken.kind),
          leftStr,
          rightStr
        );
      }
    }
    function tryGiveBetterPrimaryError(errNode, maybeMissingAwait, leftStr, rightStr) {
      switch (operatorToken.kind) {
        case 37 /* EqualsEqualsEqualsToken */:
        case 35 /* EqualsEqualsToken */:
        case 38 /* ExclamationEqualsEqualsToken */:
        case 36 /* ExclamationEqualsToken */:
          return errorAndMaybeSuggestAwait(
            errNode,
            maybeMissingAwait,
            Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap,
            leftStr,
            rightStr
          );
        default:
          return void 0;
      }
    }
    function checkNaNEquality(errorNode2, operator2, left2, right2) {
      const isLeftNaN = isGlobalNaN(skipParentheses(left2));
      const isRightNaN = isGlobalNaN(skipParentheses(right2));
      if (isLeftNaN || isRightNaN) {
        const err = error(errorNode2, Diagnostics.This_condition_will_always_return_0, tokenToString(operator2 === 37 /* EqualsEqualsEqualsToken */ || operator2 === 35 /* EqualsEqualsToken */ ? 97 /* FalseKeyword */ : 112 /* TrueKeyword */));
        if (isLeftNaN && isRightNaN)
          return;
        const operatorString = operator2 === 38 /* ExclamationEqualsEqualsToken */ || operator2 === 36 /* ExclamationEqualsToken */ ? tokenToString(54 /* ExclamationToken */) : "";
        const location = isLeftNaN ? right2 : left2;
        const expression = skipParentheses(location);
        addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})`));
      }
    }
    function isGlobalNaN(expr) {
      if (isIdentifier(expr) && expr.escapedText === "NaN") {
        const globalNaNSymbol = getGlobalNaNSymbol();
        return !!globalNaNSymbol && globalNaNSymbol === getResolvedSymbol(expr);
      }
      return false;
    }
  }
  function getBaseTypesIfUnrelated(leftType, rightType, isRelated) {
    let effectiveLeft = leftType;
    let effectiveRight = rightType;
    const leftBase = getBaseTypeOfLiteralType(leftType);
    const rightBase = getBaseTypeOfLiteralType(rightType);
    if (!isRelated(leftBase, rightBase)) {
      effectiveLeft = leftBase;
      effectiveRight = rightBase;
    }
    return [effectiveLeft, effectiveRight];
  }
  function checkYieldExpression(node) {
    addLazyDiagnostic(checkYieldExpressionGrammar);
    const func = getContainingFunction(node);
    if (!func)
      return anyType;
    const functionFlags = getFunctionFlags(func);
    if (!(functionFlags & 1 /* Generator */)) {
      return anyType;
    }
    const isAsync = (functionFlags & 2 /* Async */) !== 0;
    if (node.asteriskToken) {
      if (isAsync && languageVersion < 99 /* ESNext */) {
        checkExternalEmitHelpers(node, 26624 /* AsyncDelegatorIncludes */);
      }
      if (!isAsync && languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
        checkExternalEmitHelpers(node, 256 /* Values */);
      }
    }
    let returnType = getReturnTypeFromAnnotation(func);
    if (returnType && returnType.flags & 1048576 /* Union */) {
      returnType = filterType(returnType, (t) => checkGeneratorInstantiationAssignabilityToReturnType(
        t,
        functionFlags,
        /*errorNode*/
        void 0
      ));
    }
    const iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync);
    const signatureYieldType = iterationTypes && iterationTypes.yieldType || anyType;
    const signatureNextType = iterationTypes && iterationTypes.nextType || anyType;
    const resolvedSignatureNextType = isAsync ? getAwaitedType(signatureNextType) || anyType : signatureNextType;
    const yieldExpressionType = node.expression ? checkExpression(node.expression) : undefinedWideningType;
    const yieldedType = getYieldedTypeOfYieldExpression(node, yieldExpressionType, resolvedSignatureNextType, isAsync);
    if (returnType && yieldedType) {
      checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression);
    }
    if (node.asteriskToken) {
      const use = isAsync ? 19 /* AsyncYieldStar */ : 17 /* YieldStar */;
      return getIterationTypeOfIterable(use, 1 /* Return */, yieldExpressionType, node.expression) || anyType;
    } else if (returnType) {
      return getIterationTypeOfGeneratorFunctionReturnType(2 /* Next */, returnType, isAsync) || anyType;
    }
    let type = getContextualIterationType(2 /* Next */, func);
    if (!type) {
      type = anyType;
      addLazyDiagnostic(() => {
        if (noImplicitAny && !expressionResultIsUnused(node)) {
          const contextualType = getContextualType(
            node,
            /*contextFlags*/
            void 0
          );
          if (!contextualType || isTypeAny(contextualType)) {
            error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation);
          }
        }
      });
    }
    return type;
    function checkYieldExpressionGrammar() {
      if (!(node.flags & 16384 /* YieldContext */)) {
        grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
      }
      if (isInParameterInitializerBeforeContainingFunction(node)) {
        error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
      }
    }
  }
  function checkConditionalExpression(node, checkMode) {
    const type = checkTruthinessExpression(node.condition, checkMode);
    checkTestingKnownTruthyCallableOrAwaitableType(node.condition, type, node.whenTrue);
    const type1 = checkExpression(node.whenTrue, checkMode);
    const type2 = checkExpression(node.whenFalse, checkMode);
    return getUnionType([type1, type2], 2 /* Subtype */);
  }
  function isTemplateLiteralContext(node) {
    const parent = node.parent;
    return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && parent.argumentExpression === node;
  }
  function checkTemplateExpression(node) {
    const texts = [node.head.text];
    const types = [];
    for (const span of node.templateSpans) {
      const type = checkExpression(span.expression);
      if (maybeTypeOfKindConsideringBaseConstraint(type, 12288 /* ESSymbolLike */)) {
        error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);
      }
      texts.push(span.literal.text);
      types.push(isTypeAssignableTo(type, templateConstraintType) ? type : stringType);
    }
    if (isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(
      node,
      /*contextFlags*/
      void 0
    ) || unknownType, isTemplateLiteralContextualType)) {
      return getTemplateLiteralType(texts, types);
    }
    const evaluated = node.parent.kind !== 215 /* TaggedTemplateExpression */ && evaluateTemplateExpression(node);
    return evaluated ? getFreshTypeOfLiteralType(getStringLiteralType(evaluated)) : stringType;
  }
  function isTemplateLiteralContextualType(type) {
    return !!(type.flags & (128 /* StringLiteral */ | 134217728 /* TemplateLiteral */) || type.flags & 58982400 /* InstantiableNonPrimitive */ && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, 402653316 /* StringLike */));
  }
  function getContextNode(node) {
    if (isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent)) {
      return node.parent.parent;
    }
    return node;
  }
  function checkExpressionWithContextualType(node, contextualType, inferenceContext, checkMode) {
    const contextNode = getContextNode(node);
    pushContextualType(
      contextNode,
      contextualType,
      /*isCache*/
      false
    );
    pushInferenceContext(contextNode, inferenceContext);
    const type = checkExpression(node, checkMode | 1 /* Contextual */ | (inferenceContext ? 2 /* Inferential */ : 0));
    if (inferenceContext && inferenceContext.intraExpressionInferenceSites) {
      inferenceContext.intraExpressionInferenceSites = void 0;
    }
    const result = maybeTypeOfKind(type, 2944 /* Literal */) && isLiteralOfContextualType(type, instantiateContextualType(
      contextualType,
      node,
      /*contextFlags*/
      void 0
    )) ? getRegularTypeOfLiteralType(type) : type;
    popInferenceContext();
    popContextualType();
    return result;
  }
  function checkExpressionCached(node, checkMode) {
    if (checkMode) {
      return checkExpression(node, checkMode);
    }
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const saveFlowLoopStart = flowLoopStart;
      const saveFlowTypeCache = flowTypeCache;
      flowLoopStart = flowLoopCount;
      flowTypeCache = void 0;
      links.resolvedType = checkExpression(node, checkMode);
      flowTypeCache = saveFlowTypeCache;
      flowLoopStart = saveFlowLoopStart;
    }
    return links.resolvedType;
  }
  function isTypeAssertion(node) {
    node = skipParentheses(
      node,
      /*excludeJSDocTypeAssertions*/
      true
    );
    return node.kind === 216 /* TypeAssertionExpression */ || node.kind === 234 /* AsExpression */ || isJSDocTypeAssertion(node);
  }
  function checkDeclarationInitializer(declaration, checkMode, contextualType) {
    const initializer = getEffectiveInitializer(declaration);
    if (isInJSFile(declaration)) {
      const typeNode = tryGetJSDocSatisfiesTypeNode(declaration);
      if (typeNode) {
        return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode);
      }
    }
    const type = getQuickTypeOfExpression(initializer) || (contextualType ? checkExpressionWithContextualType(
      initializer,
      contextualType,
      /*inferenceContext*/
      void 0,
      checkMode || 0 /* Normal */
    ) : checkExpressionCached(initializer, checkMode));
    return isParameter(declaration) && declaration.name.kind === 207 /* ArrayBindingPattern */ && isTupleType(type) && !type.target.hasRestElement && getTypeReferenceArity(type) < declaration.name.elements.length ? padTupleType(type, declaration.name) : type;
  }
  function padTupleType(type, pattern) {
    const patternElements = pattern.elements;
    const elementTypes = getElementTypes(type).slice();
    const elementFlags = type.target.elementFlags.slice();
    for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {
      const e = patternElements[i];
      if (i < patternElements.length - 1 || !(e.kind === 208 /* BindingElement */ && e.dotDotDotToken)) {
        elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(
          e,
          /*includePatternInType*/
          false,
          /*reportErrors*/
          false
        ) : anyType);
        elementFlags.push(2 /* Optional */);
        if (!isOmittedExpression(e) && !hasDefaultValue(e)) {
          reportImplicitAny(e, anyType);
        }
      }
    }
    return createTupleType(elementTypes, elementFlags, type.target.readonly);
  }
  function widenTypeInferredFromInitializer(declaration, type) {
    const widened = getCombinedNodeFlagsCached(declaration) & 6 /* Constant */ || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type);
    if (isInJSFile(declaration)) {
      if (isEmptyLiteralType(widened)) {
        reportImplicitAny(declaration, anyType);
        return anyType;
      } else if (isEmptyArrayLiteralType(widened)) {
        reportImplicitAny(declaration, anyArrayType);
        return anyArrayType;
      }
    }
    return widened;
  }
  function isLiteralOfContextualType(candidateType, contextualType) {
    if (contextualType) {
      if (contextualType.flags & 3145728 /* UnionOrIntersection */) {
        const types = contextualType.types;
        return some(types, (t) => isLiteralOfContextualType(candidateType, t));
      }
      if (contextualType.flags & 58982400 /* InstantiableNonPrimitive */) {
        const constraint = getBaseConstraintOfType(contextualType) || unknownType;
        return maybeTypeOfKind(constraint, 4 /* String */) && maybeTypeOfKind(candidateType, 128 /* StringLiteral */) || maybeTypeOfKind(constraint, 8 /* Number */) && maybeTypeOfKind(candidateType, 256 /* NumberLiteral */) || maybeTypeOfKind(constraint, 64 /* BigInt */) && maybeTypeOfKind(candidateType, 2048 /* BigIntLiteral */) || maybeTypeOfKind(constraint, 4096 /* ESSymbol */) && maybeTypeOfKind(candidateType, 8192 /* UniqueESSymbol */) || isLiteralOfContextualType(candidateType, constraint);
      }
      return !!(contextualType.flags & (128 /* StringLiteral */ | 4194304 /* Index */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */) && maybeTypeOfKind(candidateType, 128 /* StringLiteral */) || contextualType.flags & 256 /* NumberLiteral */ && maybeTypeOfKind(candidateType, 256 /* NumberLiteral */) || contextualType.flags & 2048 /* BigIntLiteral */ && maybeTypeOfKind(candidateType, 2048 /* BigIntLiteral */) || contextualType.flags & 512 /* BooleanLiteral */ && maybeTypeOfKind(candidateType, 512 /* BooleanLiteral */) || contextualType.flags & 8192 /* UniqueESSymbol */ && maybeTypeOfKind(candidateType, 8192 /* UniqueESSymbol */));
    }
    return false;
  }
  function isConstContext(node) {
    const parent = node.parent;
    return isAssertionExpression(parent) && isConstTypeReference(parent.type) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, 0 /* None */)) || (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent);
  }
  function checkExpressionForMutableLocation(node, checkMode, forceTuple) {
    const type = checkExpression(node, checkMode, forceTuple);
    return isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) : isTypeAssertion(node) ? type : getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(
      getContextualType(
        node,
        /*contextFlags*/
        void 0
      ),
      node,
      /*contextFlags*/
      void 0
    ));
  }
  function checkPropertyAssignment(node, checkMode) {
    if (node.name.kind === 167 /* ComputedPropertyName */) {
      checkComputedPropertyName(node.name);
    }
    return checkExpressionForMutableLocation(node.initializer, checkMode);
  }
  function checkObjectLiteralMethod(node, checkMode) {
    checkGrammarMethod(node);
    if (node.name.kind === 167 /* ComputedPropertyName */) {
      checkComputedPropertyName(node.name);
    }
    const uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
    return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
  }
  function instantiateTypeWithSingleGenericCallSignature(node, type, checkMode) {
    if (checkMode && checkMode & (2 /* Inferential */ | 8 /* SkipGenericFunctions */)) {
      const callSignature = getSingleSignature(
        type,
        0 /* Call */,
        /*allowMembers*/
        true
      );
      const constructSignature = getSingleSignature(
        type,
        1 /* Construct */,
        /*allowMembers*/
        true
      );
      const signature = callSignature || constructSignature;
      if (signature && signature.typeParameters) {
        const contextualType = getApparentTypeOfContextualType(node, 2 /* NoConstraints */);
        if (contextualType) {
          const contextualSignature = getSingleSignature(
            getNonNullableType(contextualType),
            callSignature ? 0 /* Call */ : 1 /* Construct */,
            /*allowMembers*/
            false
          );
          if (contextualSignature && !contextualSignature.typeParameters) {
            if (checkMode & 8 /* SkipGenericFunctions */) {
              skippedGenericFunction(node, checkMode);
              return anyFunctionType;
            }
            const context = getInferenceContext(node);
            const returnType = context.signature && getReturnTypeOfSignature(context.signature);
            const returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
            if (returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates)) {
              const uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
              const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
              const inferences = map(context.inferences, (info) => createInferenceInfo(info.typeParameter));
              applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {
                inferTypes(
                  inferences,
                  source,
                  target,
                  /*priority*/
                  0,
                  /*contravariant*/
                  true
                );
              });
              if (some(inferences, hasInferenceCandidates)) {
                applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {
                  inferTypes(inferences, source, target);
                });
                if (!hasOverlappingInferences(context.inferences, inferences)) {
                  mergeInferences(context.inferences, inferences);
                  context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                  return getOrCreateTypeFromSignature(instantiatedSignature);
                }
              }
            }
            return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
          }
        }
      }
    }
    return type;
  }
  function skippedGenericFunction(node, checkMode) {
    if (checkMode & 2 /* Inferential */) {
      const context = getInferenceContext(node);
      context.flags |= 4 /* SkippedGenericFunction */;
    }
  }
  function hasInferenceCandidates(info) {
    return !!(info.candidates || info.contraCandidates);
  }
  function hasInferenceCandidatesOrDefault(info) {
    return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter));
  }
  function hasOverlappingInferences(a, b) {
    for (let i = 0; i < a.length; i++) {
      if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
        return true;
      }
    }
    return false;
  }
  function mergeInferences(target, source) {
    for (let i = 0; i < target.length; i++) {
      if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {
        target[i] = source[i];
      }
    }
  }
  function getUniqueTypeParameters(context, typeParameters) {
    const result = [];
    let oldTypeParameters;
    let newTypeParameters;
    for (const tp of typeParameters) {
      const name = tp.symbol.escapedName;
      if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
        const newName = getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name);
        const symbol = createSymbol(262144 /* TypeParameter */, newName);
        const newTypeParameter = createTypeParameter(symbol);
        newTypeParameter.target = tp;
        oldTypeParameters = append(oldTypeParameters, tp);
        newTypeParameters = append(newTypeParameters, newTypeParameter);
        result.push(newTypeParameter);
      } else {
        result.push(tp);
      }
    }
    if (newTypeParameters) {
      const mapper = createTypeMapper(oldTypeParameters, newTypeParameters);
      for (const tp of newTypeParameters) {
        tp.mapper = mapper;
      }
    }
    return result;
  }
  function hasTypeParameterByName(typeParameters, name) {
    return some(typeParameters, (tp) => tp.symbol.escapedName === name);
  }
  function getUniqueTypeParameterName(typeParameters, baseName) {
    let len = baseName.length;
    while (len > 1 && baseName.charCodeAt(len - 1) >= 48 /* _0 */ && baseName.charCodeAt(len - 1) <= 57 /* _9 */)
      len--;
    const s = baseName.slice(0, len);
    for (let index = 1; true; index++) {
      const augmentedName = s + index;
      if (!hasTypeParameterByName(typeParameters, augmentedName)) {
        return augmentedName;
      }
    }
  }
  function getReturnTypeOfSingleNonGenericCallSignature(funcType) {
    const signature = getSingleCallSignature(funcType);
    if (signature && !signature.typeParameters) {
      return getReturnTypeOfSignature(signature);
    }
  }
  function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) {
    const funcType = checkExpression(expr.expression);
    const nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
    const returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
    return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
  }
  function getTypeOfExpression(node) {
    const quickType = getQuickTypeOfExpression(node);
    if (quickType) {
      return quickType;
    }
    if (node.flags & 268435456 /* TypeCached */ && flowTypeCache) {
      const cachedType = flowTypeCache[getNodeId(node)];
      if (cachedType) {
        return cachedType;
      }
    }
    const startInvocationCount = flowInvocationCount;
    const type = checkExpression(node, 64 /* TypeOnly */);
    if (flowInvocationCount !== startInvocationCount) {
      const cache = flowTypeCache || (flowTypeCache = []);
      cache[getNodeId(node)] = type;
      setNodeFlags(node, node.flags | 268435456 /* TypeCached */);
    }
    return type;
  }
  function getQuickTypeOfExpression(node) {
    let expr = skipParentheses(
      node,
      /*excludeJSDocTypeAssertions*/
      true
    );
    if (isJSDocTypeAssertion(expr)) {
      const type = getJSDocTypeAssertionType(expr);
      if (!isConstTypeReference(type)) {
        return getTypeFromTypeNode(type);
      }
    }
    expr = skipParentheses(node);
    if (isAwaitExpression(expr)) {
      const type = getQuickTypeOfExpression(expr.expression);
      return type ? getAwaitedType(type) : void 0;
    }
    if (isCallExpression(expr) && expr.expression.kind !== 108 /* SuperKeyword */ && !isRequireCall(
      expr,
      /*requireStringLiteralLikeArgument*/
      true
    ) && !isSymbolOrSymbolForCall(expr)) {
      return isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) : getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
    } else if (isAssertionExpression(expr) && !isConstTypeReference(expr.type)) {
      return getTypeFromTypeNode(expr.type);
    } else if (isLiteralExpression(node) || isBooleanLiteral(node)) {
      return checkExpression(node);
    }
    return void 0;
  }
  function getContextFreeTypeOfExpression(node) {
    const links = getNodeLinks(node);
    if (links.contextFreeType) {
      return links.contextFreeType;
    }
    pushContextualType(
      node,
      anyType,
      /*isCache*/
      false
    );
    const type = links.contextFreeType = checkExpression(node, 4 /* SkipContextSensitive */);
    popContextualType();
    return type;
  }
  function checkExpression(node, checkMode, forceTuple) {
    var _a, _b;
    (_a = tracing) == null ? void 0 : _a.push(tracing.Phase.Check, "checkExpression", { kind: node.kind, pos: node.pos, end: node.end, path: node.tracingPath });
    const saveCurrentNode = currentNode;
    currentNode = node;
    instantiationCount = 0;
    const uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple);
    const type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
    if (isConstEnumObjectType(type)) {
      checkConstEnumAccess(node, type);
    }
    currentNode = saveCurrentNode;
    (_b = tracing) == null ? void 0 : _b.pop();
    return type;
  }
  function checkConstEnumAccess(node, type) {
    const ok = node.parent.kind === 211 /* PropertyAccessExpression */ && node.parent.expression === node || node.parent.kind === 212 /* ElementAccessExpression */ && node.parent.expression === node || ((node.kind === 80 /* Identifier */ || node.kind === 166 /* QualifiedName */) && isInRightSideOfImportOrExportAssignment(node) || node.parent.kind === 186 /* TypeQuery */ && node.parent.exprName === node) || node.parent.kind === 281 /* ExportSpecifier */;
    if (!ok) {
      error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query);
    }
    if (getIsolatedModules(compilerOptions)) {
      Debug.assert(!!(type.symbol.flags & 128 /* ConstEnum */));
      const constEnumDeclaration = type.symbol.valueDeclaration;
      if (constEnumDeclaration.flags & 33554432 /* Ambient */ && !isValidTypeOnlyAliasUseSite(node)) {
        error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName);
      }
    }
  }
  function checkParenthesizedExpression(node, checkMode) {
    if (hasJSDocNodes(node)) {
      if (isJSDocSatisfiesExpression(node)) {
        return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode);
      }
      if (isJSDocTypeAssertion(node)) {
        return checkAssertionWorker(node, checkMode);
      }
    }
    return checkExpression(node.expression, checkMode);
  }
  function checkExpressionWorker(node, checkMode, forceTuple) {
    const kind = node.kind;
    if (cancellationToken) {
      switch (kind) {
        case 231 /* ClassExpression */:
        case 218 /* FunctionExpression */:
        case 219 /* ArrowFunction */:
          cancellationToken.throwIfCancellationRequested();
      }
    }
    switch (kind) {
      case 80 /* Identifier */:
        return checkIdentifier(node, checkMode);
      case 81 /* PrivateIdentifier */:
        return checkPrivateIdentifierExpression(node);
      case 110 /* ThisKeyword */:
        return checkThisExpression(node);
      case 108 /* SuperKeyword */:
        return checkSuperExpression(node);
      case 106 /* NullKeyword */:
        return nullWideningType;
      case 15 /* NoSubstitutionTemplateLiteral */:
      case 11 /* StringLiteral */:
        return hasSkipDirectInferenceFlag(node) ? blockedStringType : getFreshTypeOfLiteralType(getStringLiteralType(node.text));
      case 9 /* NumericLiteral */:
        checkGrammarNumericLiteral(node);
        return getFreshTypeOfLiteralType(getNumberLiteralType(+node.text));
      case 10 /* BigIntLiteral */:
        checkGrammarBigIntLiteral(node);
        return getFreshTypeOfLiteralType(getBigIntLiteralType({
          negative: false,
          base10Value: parsePseudoBigInt(node.text)
        }));
      case 112 /* TrueKeyword */:
        return trueType;
      case 97 /* FalseKeyword */:
        return falseType;
      case 228 /* TemplateExpression */:
        return checkTemplateExpression(node);
      case 14 /* RegularExpressionLiteral */:
        return globalRegExpType;
      case 209 /* ArrayLiteralExpression */:
        return checkArrayLiteral(node, checkMode, forceTuple);
      case 210 /* ObjectLiteralExpression */:
        return checkObjectLiteral(node, checkMode);
      case 211 /* PropertyAccessExpression */:
        return checkPropertyAccessExpression(node, checkMode);
      case 166 /* QualifiedName */:
        return checkQualifiedName(node, checkMode);
      case 212 /* ElementAccessExpression */:
        return checkIndexedAccess(node, checkMode);
      case 213 /* CallExpression */:
        if (node.expression.kind === 102 /* ImportKeyword */) {
          return checkImportCallExpression(node);
        }
      case 214 /* NewExpression */:
        return checkCallExpression(node, checkMode);
      case 215 /* TaggedTemplateExpression */:
        return checkTaggedTemplateExpression(node);
      case 217 /* ParenthesizedExpression */:
        return checkParenthesizedExpression(node, checkMode);
      case 231 /* ClassExpression */:
        return checkClassExpression(node);
      case 218 /* FunctionExpression */:
      case 219 /* ArrowFunction */:
        return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
      case 221 /* TypeOfExpression */:
        return checkTypeOfExpression(node);
      case 216 /* TypeAssertionExpression */:
      case 234 /* AsExpression */:
        return checkAssertion(node, checkMode);
      case 235 /* NonNullExpression */:
        return checkNonNullAssertion(node);
      case 233 /* ExpressionWithTypeArguments */:
        return checkExpressionWithTypeArguments(node);
      case 238 /* SatisfiesExpression */:
        return checkSatisfiesExpression(node);
      case 236 /* MetaProperty */:
        return checkMetaProperty(node);
      case 220 /* DeleteExpression */:
        return checkDeleteExpression(node);
      case 222 /* VoidExpression */:
        return checkVoidExpression(node);
      case 223 /* AwaitExpression */:
        return checkAwaitExpression(node);
      case 224 /* PrefixUnaryExpression */:
        return checkPrefixUnaryExpression(node);
      case 225 /* PostfixUnaryExpression */:
        return checkPostfixUnaryExpression(node);
      case 226 /* BinaryExpression */:
        return checkBinaryExpression(node, checkMode);
      case 227 /* ConditionalExpression */:
        return checkConditionalExpression(node, checkMode);
      case 230 /* SpreadElement */:
        return checkSpreadExpression(node, checkMode);
      case 232 /* OmittedExpression */:
        return undefinedWideningType;
      case 229 /* YieldExpression */:
        return checkYieldExpression(node);
      case 237 /* SyntheticExpression */:
        return checkSyntheticExpression(node);
      case 294 /* JsxExpression */:
        return checkJsxExpression(node, checkMode);
      case 284 /* JsxElement */:
        return checkJsxElement(node, checkMode);
      case 285 /* JsxSelfClosingElement */:
        return checkJsxSelfClosingElement(node, checkMode);
      case 288 /* JsxFragment */:
        return checkJsxFragment(node);
      case 292 /* JsxAttributes */:
        return checkJsxAttributes(node, checkMode);
      case 286 /* JsxOpeningElement */:
        Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
    }
    return errorType;
  }
  function checkTypeParameter(node) {
    checkGrammarModifiers(node);
    if (node.expression) {
      grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected);
    }
    checkSourceElement(node.constraint);
    checkSourceElement(node.default);
    const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
    getBaseConstraintOfType(typeParameter);
    if (!hasNonCircularTypeParameterDefault(typeParameter)) {
      error(node.default, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
    }
    const constraintType = getConstraintOfTypeParameter(typeParameter);
    const defaultType = getDefaultFromTypeParameter(typeParameter);
    if (constraintType && defaultType) {
      checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
    }
    checkNodeDeferred(node);
    addLazyDiagnostic(() => checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0));
  }
  function checkTypeParameterDeferred(node) {
    var _a, _b;
    if (isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent)) {
      const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
      const modifiers = getTypeParameterModifiers(typeParameter) & (8192 /* In */ | 16384 /* Out */);
      if (modifiers) {
        const symbol = getSymbolOfDeclaration(node.parent);
        if (isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (4 /* Reference */ | 16 /* Anonymous */ | 32 /* Mapped */))) {
          error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types);
        } else if (modifiers === 8192 /* In */ || modifiers === 16384 /* Out */) {
          (_a = tracing) == null ? void 0 : _a.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) });
          const source = createMarkerType(symbol, typeParameter, modifiers === 16384 /* Out */ ? markerSubTypeForCheck : markerSuperTypeForCheck);
          const target = createMarkerType(symbol, typeParameter, modifiers === 16384 /* Out */ ? markerSuperTypeForCheck : markerSubTypeForCheck);
          const saveVarianceTypeParameter = typeParameter;
          varianceTypeParameter = typeParameter;
          checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation);
          varianceTypeParameter = saveVarianceTypeParameter;
          (_b = tracing) == null ? void 0 : _b.pop();
        }
      }
    }
  }
  function checkParameter(node) {
    checkGrammarModifiers(node);
    checkVariableLikeDeclaration(node);
    const func = getContainingFunction(node);
    if (hasSyntacticModifier(node, 31 /* ParameterPropertyModifier */)) {
      if (!(func.kind === 176 /* Constructor */ && nodeIsPresent(func.body))) {
        error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
      }
      if (func.kind === 176 /* Constructor */ && isIdentifier(node.name) && node.name.escapedText === "constructor") {
        error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name);
      }
    }
    if (!node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && func.body) {
      error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
    }
    if (node.name && isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")) {
      if (func.parameters.indexOf(node) !== 0) {
        error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText);
      }
      if (func.kind === 176 /* Constructor */ || func.kind === 180 /* ConstructSignature */ || func.kind === 185 /* ConstructorType */) {
        error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter);
      }
      if (func.kind === 219 /* ArrowFunction */) {
        error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
      }
      if (func.kind === 177 /* GetAccessor */ || func.kind === 178 /* SetAccessor */) {
        error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters);
      }
    }
    if (node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType)) {
      error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type);
    }
  }
  function checkTypePredicate(node) {
    const parent = getTypePredicateParent(node);
    if (!parent) {
      error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
      return;
    }
    const signature = getSignatureFromDeclaration(parent);
    const typePredicate = getTypePredicateOfSignature(signature);
    if (!typePredicate) {
      return;
    }
    checkSourceElement(node.type);
    const { parameterName } = node;
    if (typePredicate.kind === 0 /* This */ || typePredicate.kind === 2 /* AssertsThis */) {
      getTypeFromThisTypeNode(parameterName);
    } else {
      if (typePredicate.parameterIndex >= 0) {
        if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) {
          error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
        } else {
          if (typePredicate.type) {
            const leadingError = () => chainDiagnosticMessages(
              /*details*/
              void 0,
              Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type
            );
            checkTypeAssignableTo(
              typePredicate.type,
              getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]),
              node.type,
              /*headMessage*/
              void 0,
              leadingError
            );
          }
        }
      } else if (parameterName) {
        let hasReportedError = false;
        for (const { name } of parent.parameters) {
          if (isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
            hasReportedError = true;
            break;
          }
        }
        if (!hasReportedError) {
          error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
        }
      }
    }
  }
  function getTypePredicateParent(node) {
    switch (node.parent.kind) {
      case 219 /* ArrowFunction */:
      case 179 /* CallSignature */:
      case 262 /* FunctionDeclaration */:
      case 218 /* FunctionExpression */:
      case 184 /* FunctionType */:
      case 174 /* MethodDeclaration */:
      case 173 /* MethodSignature */:
        const parent = node.parent;
        if (node === parent.type) {
          return parent;
        }
    }
  }
  function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern, predicateVariableNode, predicateVariableName) {
    for (const element of pattern.elements) {
      if (isOmittedExpression(element)) {
        continue;
      }
      const name = element.name;
      if (name.kind === 80 /* Identifier */ && name.escapedText === predicateVariableName) {
        error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
        return true;
      } else if (name.kind === 207 /* ArrayBindingPattern */ || name.kind === 206 /* ObjectBindingPattern */) {
        if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(
          name,
          predicateVariableNode,
          predicateVariableName
        )) {
          return true;
        }
      }
    }
  }
  function checkSignatureDeclaration(node) {
    if (node.kind === 181 /* IndexSignature */) {
      checkGrammarIndexSignature(node);
    } else if (node.kind === 184 /* FunctionType */ || node.kind === 262 /* FunctionDeclaration */ || node.kind === 185 /* ConstructorType */ || node.kind === 179 /* CallSignature */ || node.kind === 176 /* Constructor */ || node.kind === 180 /* ConstructSignature */) {
      checkGrammarFunctionLikeDeclaration(node);
    }
    const functionFlags = getFunctionFlags(node);
    if (!(functionFlags & 4 /* Invalid */)) {
      if ((functionFlags & 3 /* AsyncGenerator */) === 3 /* AsyncGenerator */ && languageVersion < 99 /* ESNext */) {
        checkExternalEmitHelpers(node, 6144 /* AsyncGeneratorIncludes */);
      }
      if ((functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */ && languageVersion < 4 /* ES2017 */) {
        checkExternalEmitHelpers(node, 64 /* Awaiter */);
      }
      if ((functionFlags & 3 /* AsyncGenerator */) !== 0 /* Normal */ && languageVersion < 2 /* ES2015 */) {
        checkExternalEmitHelpers(node, 128 /* Generator */);
      }
    }
    checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
    checkUnmatchedJSDocParameters(node);
    forEach(node.parameters, checkParameter);
    if (node.type) {
      checkSourceElement(node.type);
    }
    addLazyDiagnostic(checkSignatureDeclarationDiagnostics);
    function checkSignatureDeclarationDiagnostics() {
      checkCollisionWithArgumentsInGeneratedCode(node);
      let returnTypeNode = getEffectiveReturnTypeNode(node);
      let returnTypeErrorLocation = returnTypeNode;
      if (isInJSFile(node)) {
        const typeTag = getJSDocTypeTag(node);
        if (typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type)) {
          const signature = getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
          if (signature && signature.declaration) {
            returnTypeNode = getEffectiveReturnTypeNode(signature.declaration);
            returnTypeErrorLocation = typeTag.typeExpression.type;
          }
        }
      }
      if (noImplicitAny && !returnTypeNode) {
        switch (node.kind) {
          case 180 /* ConstructSignature */:
            error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
            break;
          case 179 /* CallSignature */:
            error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
            break;
        }
      }
      if (returnTypeNode && returnTypeErrorLocation) {
        const functionFlags2 = getFunctionFlags(node);
        if ((functionFlags2 & (4 /* Invalid */ | 1 /* Generator */)) === 1 /* Generator */) {
          const returnType = getTypeFromTypeNode(returnTypeNode);
          if (returnType === voidType) {
            error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation);
          } else {
            checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags2, returnTypeErrorLocation);
          }
        } else if ((functionFlags2 & 3 /* AsyncGenerator */) === 2 /* Async */) {
          checkAsyncFunctionReturnType(node, returnTypeNode, returnTypeErrorLocation);
        }
      }
      if (node.kind !== 181 /* IndexSignature */ && node.kind !== 324 /* JSDocFunctionType */) {
        registerForUnusedIdentifiersCheck(node);
      }
    }
  }
  function checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, errorNode) {
    const generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(0 /* Yield */, returnType, (functionFlags & 2 /* Async */) !== 0) || anyType;
    const generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(1 /* Return */, returnType, (functionFlags & 2 /* Async */) !== 0) || generatorYieldType;
    const generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(2 /* Next */, returnType, (functionFlags & 2 /* Async */) !== 0) || unknownType;
    const generatorInstantiation = createGeneratorReturnType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & 2 /* Async */));
    return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode);
  }
  function checkClassForDuplicateDeclarations(node) {
    const instanceNames = /* @__PURE__ */ new Map();
    const staticNames = /* @__PURE__ */ new Map();
    const privateIdentifiers = /* @__PURE__ */ new Map();
    for (const member of node.members) {
      if (member.kind === 176 /* Constructor */) {
        for (const param of member.parameters) {
          if (isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name)) {
            addName(instanceNames, param.name, param.name.escapedText, 3 /* GetOrSetAccessor */);
          }
        }
      } else {
        const isStaticMember = isStatic(member);
        const name = member.name;
        if (!name) {
          continue;
        }
        const isPrivate = isPrivateIdentifier(name);
        const privateStaticFlags = isPrivate && isStaticMember ? 16 /* PrivateStatic */ : 0;
        const names = isPrivate ? privateIdentifiers : isStaticMember ? staticNames : instanceNames;
        const memberName = name && getEffectivePropertyNameForPropertyNameNode(name);
        if (memberName) {
          switch (member.kind) {
            case 177 /* GetAccessor */:
              addName(names, name, memberName, 1 /* GetAccessor */ | privateStaticFlags);
              break;
            case 178 /* SetAccessor */:
              addName(names, name, memberName, 2 /* SetAccessor */ | privateStaticFlags);
              break;
            case 172 /* PropertyDeclaration */:
              addName(names, name, memberName, 3 /* GetOrSetAccessor */ | privateStaticFlags);
              break;
            case 174 /* MethodDeclaration */:
              addName(names, name, memberName, 8 /* Method */ | privateStaticFlags);
              break;
          }
        }
      }
    }
    function addName(names, location, name, meaning) {
      const prev = names.get(name);
      if (prev) {
        if ((prev & 16 /* PrivateStatic */) !== (meaning & 16 /* PrivateStatic */)) {
          error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location));
        } else {
          const prevIsMethod = !!(prev & 8 /* Method */);
          const isMethod = !!(meaning & 8 /* Method */);
          if (prevIsMethod || isMethod) {
            if (prevIsMethod !== isMethod) {
              error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
            }
          } else if (prev & meaning & ~16 /* PrivateStatic */) {
            error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
          } else {
            names.set(name, prev | meaning);
          }
        }
      } else {
        names.set(name, meaning);
      }
    }
  }
  function checkClassForStaticPropertyNameConflicts(node) {
    for (const member of node.members) {
      const memberNameNode = member.name;
      const isStaticMember = isStatic(member);
      if (isStaticMember && memberNameNode) {
        const memberName = getEffectivePropertyNameForPropertyNameNode(memberNameNode);
        switch (memberName) {
          case "name":
          case "length":
          case "caller":
          case "arguments":
            if (useDefineForClassFields) {
              break;
            }
          case "prototype":
            const message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
            const className = getNameOfSymbolAsWritten(getSymbolOfDeclaration(node));
            error(memberNameNode, message, memberName, className);
            break;
        }
      }
    }
  }
  function checkObjectTypeForDuplicateDeclarations(node) {
    const names = /* @__PURE__ */ new Map();
    for (const member of node.members) {
      if (member.kind === 171 /* PropertySignature */) {
        let memberName;
        const name = member.name;
        switch (name.kind) {
          case 11 /* StringLiteral */:
          case 9 /* NumericLiteral */:
            memberName = name.text;
            break;
          case 80 /* Identifier */:
            memberName = idText(name);
            break;
          default:
            continue;
        }
        if (names.get(memberName)) {
          error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName);
          error(member.name, Diagnostics.Duplicate_identifier_0, memberName);
        } else {
          names.set(memberName, true);
        }
      }
    }
  }
  function checkTypeForDuplicateIndexSignatures(node) {
    if (node.kind === 264 /* InterfaceDeclaration */) {
      const nodeSymbol = getSymbolOfDeclaration(node);
      if (nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
        return;
      }
    }
    const indexSymbol = getIndexSymbol(getSymbolOfDeclaration(node));
    if (indexSymbol == null ? void 0 : indexSymbol.declarations) {
      const indexSignatureMap = /* @__PURE__ */ new Map();
      for (const declaration of indexSymbol.declarations) {
        if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
          forEachType(getTypeFromTypeNode(declaration.parameters[0].type), (type) => {
            const entry = indexSignatureMap.get(getTypeId(type));
            if (entry) {
              entry.declarations.push(declaration);
            } else {
              indexSignatureMap.set(getTypeId(type), { type, declarations: [declaration] });
            }
          });
        }
      }
      indexSignatureMap.forEach((entry) => {
        if (entry.declarations.length > 1) {
          for (const declaration of entry.declarations) {
            error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));
          }
        }
      });
    }
  }
  function checkPropertyDeclaration(node) {
    if (!checkGrammarModifiers(node) && !checkGrammarProperty(node))
      checkGrammarComputedPropertyName(node.name);
    checkVariableLikeDeclaration(node);
    setNodeLinksForPrivateIdentifierScope(node);
    if (hasSyntacticModifier(node, 64 /* Abstract */) && node.kind === 172 /* PropertyDeclaration */ && node.initializer) {
      error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name));
    }
  }
  function checkPropertySignature(node) {
    if (isPrivateIdentifier(node.name)) {
      error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
    }
    return checkPropertyDeclaration(node);
  }
  function checkMethodDeclaration(node) {
    if (!checkGrammarMethod(node))
      checkGrammarComputedPropertyName(node.name);
    if (isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) === "constructor") {
      error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator);
    }
    checkFunctionOrMethodDeclaration(node);
    if (hasSyntacticModifier(node, 64 /* Abstract */) && node.kind === 174 /* MethodDeclaration */ && node.body) {
      error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name));
    }
    if (isPrivateIdentifier(node.name) && !getContainingClass(node)) {
      error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
    }
    setNodeLinksForPrivateIdentifierScope(node);
  }
  function setNodeLinksForPrivateIdentifierScope(node) {
    if (isPrivateIdentifier(node.name) && languageVersion < 99 /* ESNext */) {
      for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {
        getNodeLinks(lexicalScope).flags |= 1048576 /* ContainsClassWithPrivateIdentifiers */;
      }
      if (isClassExpression(node.parent)) {
        const enclosingIterationStatement = getEnclosingIterationStatement(node.parent);
        if (enclosingIterationStatement) {
          getNodeLinks(node.name).flags |= 32768 /* BlockScopedBindingInLoop */;
          getNodeLinks(enclosingIterationStatement).flags |= 4096 /* LoopWithCapturedBlockScopedBinding */;
        }
      }
    }
  }
  function checkClassStaticBlockDeclaration(node) {
    checkGrammarModifiers(node);
    forEachChild(node, checkSourceElement);
  }
  function checkConstructorDeclaration(node) {
    checkSignatureDeclaration(node);
    if (!checkGrammarConstructorTypeParameters(node))
      checkGrammarConstructorTypeAnnotation(node);
    checkSourceElement(node.body);
    const symbol = getSymbolOfDeclaration(node);
    const firstDeclaration = getDeclarationOfKind(symbol, node.kind);
    if (node === firstDeclaration) {
      checkFunctionOrConstructorSymbol(symbol);
    }
    if (nodeIsMissing(node.body)) {
      return;
    }
    addLazyDiagnostic(checkConstructorDeclarationDiagnostics);
    return;
    function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n) {
      if (isPrivateIdentifierClassElementDeclaration(n)) {
        return true;
      }
      return n.kind === 172 /* PropertyDeclaration */ && !isStatic(n) && !!n.initializer;
    }
    function checkConstructorDeclarationDiagnostics() {
      const containingClassDecl = node.parent;
      if (getClassExtendsHeritageElement(containingClassDecl)) {
        captureLexicalThis(node.parent, containingClassDecl);
        const classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
        const superCall = findFirstSuperCall(node.body);
        if (superCall) {
          if (classExtendsNull) {
            error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
          }
          const superCallShouldBeRootLevel = !emitStandardClassFields && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, (p) => hasSyntacticModifier(p, 31 /* ParameterPropertyModifier */)));
          if (superCallShouldBeRootLevel) {
            if (!superCallIsRootLevelInConstructor(superCall, node.body)) {
              error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers);
            } else {
              let superCallStatement;
              for (const statement of node.body.statements) {
                if (isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression))) {
                  superCallStatement = statement;
                  break;
                }
                if (nodeImmediatelyReferencesSuperOrThis(statement)) {
                  break;
                }
              }
              if (superCallStatement === void 0) {
                error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers);
              }
            }
          }
        } else if (!classExtendsNull) {
          error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
        }
      }
    }
  }
  function superCallIsRootLevelInConstructor(superCall, body) {
    const superCallParent = walkUpParenthesizedExpressions(superCall.parent);
    return isExpressionStatement(superCallParent) && superCallParent.parent === body;
  }
  function nodeImmediatelyReferencesSuperOrThis(node) {
    if (node.kind === 108 /* SuperKeyword */ || node.kind === 110 /* ThisKeyword */) {
      return true;
    }
    if (isThisContainerOrFunctionBlock(node)) {
      return false;
    }
    return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis);
  }
  function checkAccessorDeclaration(node) {
    if (isIdentifier(node.name) && idText(node.name) === "constructor" && isClassLike(node.parent)) {
      error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor);
    }
    addLazyDiagnostic(checkAccessorDeclarationDiagnostics);
    checkSourceElement(node.body);
    setNodeLinksForPrivateIdentifierScope(node);
    function checkAccessorDeclarationDiagnostics() {
      if (!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node))
        checkGrammarComputedPropertyName(node.name);
      checkDecorators(node);
      checkSignatureDeclaration(node);
      if (node.kind === 177 /* GetAccessor */) {
        if (!(node.flags & 33554432 /* Ambient */) && nodeIsPresent(node.body) && node.flags & 512 /* HasImplicitReturn */) {
          if (!(node.flags & 1024 /* HasExplicitReturn */)) {
            error(node.name, Diagnostics.A_get_accessor_must_return_a_value);
          }
        }
      }
      if (node.name.kind === 167 /* ComputedPropertyName */) {
        checkComputedPropertyName(node.name);
      }
      if (hasBindableName(node)) {
        const symbol = getSymbolOfDeclaration(node);
        const getter = getDeclarationOfKind(symbol, 177 /* GetAccessor */);
        const setter = getDeclarationOfKind(symbol, 178 /* SetAccessor */);
        if (getter && setter && !(getNodeCheckFlags(getter) & 1 /* TypeChecked */)) {
          getNodeLinks(getter).flags |= 1 /* TypeChecked */;
          const getterFlags = getEffectiveModifierFlags(getter);
          const setterFlags = getEffectiveModifierFlags(setter);
          if ((getterFlags & 64 /* Abstract */) !== (setterFlags & 64 /* Abstract */)) {
            error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
            error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
          }
          if (getterFlags & 4 /* Protected */ && !(setterFlags & (4 /* Protected */ | 2 /* Private */)) || getterFlags & 2 /* Private */ && !(setterFlags & 2 /* Private */)) {
            error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
            error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
          }
        }
      }
      const returnType = getTypeOfAccessors(getSymbolOfDeclaration(node));
      if (node.kind === 177 /* GetAccessor */) {
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
      }
    }
  }
  function checkMissingDeclaration(node) {
    checkDecorators(node);
  }
  function getEffectiveTypeArgumentAtIndex(node, typeParameters, index) {
    if (node.typeArguments && index < node.typeArguments.length) {
      return getTypeFromTypeNode(node.typeArguments[index]);
    }
    return getEffectiveTypeArguments(node, typeParameters)[index];
  }
  function getEffectiveTypeArguments(node, typeParameters) {
    return fillMissingTypeArguments(map(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node));
  }
  function checkTypeArgumentConstraints(node, typeParameters) {
    let typeArguments;
    let mapper;
    let result = true;
    for (let i = 0; i < typeParameters.length; i++) {
      const constraint = getConstraintOfTypeParameter(typeParameters[i]);
      if (constraint) {
        if (!typeArguments) {
          typeArguments = getEffectiveTypeArguments(node, typeParameters);
          mapper = createTypeMapper(typeParameters, typeArguments);
        }
        result = result && checkTypeAssignableTo(
          typeArguments[i],
          instantiateType(constraint, mapper),
          node.typeArguments[i],
          Diagnostics.Type_0_does_not_satisfy_the_constraint_1
        );
      }
    }
    return result;
  }
  function getTypeParametersForTypeAndSymbol(type, symbol) {
    if (!isErrorType(type)) {
      return symbol.flags & 524288 /* TypeAlias */ && getSymbolLinks(symbol).typeParameters || (getObjectFlags(type) & 4 /* Reference */ ? type.target.localTypeParameters : void 0);
    }
    return void 0;
  }
  function getTypeParametersForTypeReferenceOrImport(node) {
    const type = getTypeFromTypeNode(node);
    if (!isErrorType(type)) {
      const symbol = getNodeLinks(node).resolvedSymbol;
      if (symbol) {
        return getTypeParametersForTypeAndSymbol(type, symbol);
      }
    }
    return void 0;
  }
  function checkTypeReferenceNode(node) {
    checkGrammarTypeArguments(node, node.typeArguments);
    if (node.kind === 183 /* TypeReference */ && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end !== node.typeArguments.pos) {
      const sourceFile = getSourceFileOfNode(node);
      if (scanTokenAtPosition(sourceFile, node.typeName.end) === 25 /* DotToken */) {
        grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
      }
    }
    forEach(node.typeArguments, checkSourceElement);
    checkTypeReferenceOrImport(node);
  }
  function checkTypeReferenceOrImport(node) {
    const type = getTypeFromTypeNode(node);
    if (!isErrorType(type)) {
      if (node.typeArguments) {
        addLazyDiagnostic(() => {
          const typeParameters = getTypeParametersForTypeReferenceOrImport(node);
          if (typeParameters) {
            checkTypeArgumentConstraints(node, typeParameters);
          }
        });
      }
      const symbol = getNodeLinks(node).resolvedSymbol;
      if (symbol) {
        if (some(symbol.declarations, (d) => isTypeDeclaration(d) && !!(d.flags & 536870912 /* Deprecated */))) {
          addDeprecatedSuggestion(
            getDeprecatedSuggestionNode(node),
            symbol.declarations,
            symbol.escapedName
          );
        }
      }
    }
  }
  function getTypeArgumentConstraint(node) {
    const typeReferenceNode = tryCast(node.parent, isTypeReferenceType);
    if (!typeReferenceNode)
      return void 0;
    const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReferenceNode);
    if (!typeParameters)
      return void 0;
    const constraint = getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)]);
    return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)));
  }
  function checkTypeQuery(node) {
    getTypeFromTypeQueryNode(node);
  }
  function checkTypeLiteral(node) {
    forEach(node.members, checkSourceElement);
    addLazyDiagnostic(checkTypeLiteralDiagnostics);
    function checkTypeLiteralDiagnostics() {
      const type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
      checkIndexConstraints(type, type.symbol);
      checkTypeForDuplicateIndexSignatures(node);
      checkObjectTypeForDuplicateDeclarations(node);
    }
  }
  function checkArrayType(node) {
    checkSourceElement(node.elementType);
  }
  function checkTupleType(node) {
    let seenOptionalElement = false;
    let seenRestElement = false;
    for (const e of node.elements) {
      let flags = getTupleElementFlags(e);
      if (flags & 8 /* Variadic */) {
        const type = getTypeFromTypeNode(e.type);
        if (!isArrayLikeType(type)) {
          error(e, Diagnostics.A_rest_element_type_must_be_an_array_type);
          break;
        }
        if (isArrayType(type) || isTupleType(type) && type.target.combinedFlags & 4 /* Rest */) {
          flags |= 4 /* Rest */;
        }
      }
      if (flags & 4 /* Rest */) {
        if (seenRestElement) {
          grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element);
          break;
        }
        seenRestElement = true;
      } else if (flags & 2 /* Optional */) {
        if (seenRestElement) {
          grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element);
          break;
        }
        seenOptionalElement = true;
      } else if (flags & 1 /* Required */ && seenOptionalElement) {
        grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element);
        break;
      }
    }
    forEach(node.elements, checkSourceElement);
    getTypeFromTypeNode(node);
  }
  function checkUnionOrIntersectionType(node) {
    forEach(node.types, checkSourceElement);
    getTypeFromTypeNode(node);
  }
  function checkIndexedAccessIndexType(type, accessNode) {
    if (!(type.flags & 8388608 /* IndexedAccess */)) {
      return type;
    }
    const objectType = type.objectType;
    const indexType = type.indexType;
    const objectIndexType = isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === 2 /* Remapping */ ? getIndexTypeForMappedType(objectType, 0 /* None */) : getIndexType(objectType, 0 /* None */);
    const hasNumberIndexInfo = !!getIndexInfoOfType(objectType, numberType);
    if (everyType(indexType, (t) => isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType))) {
      if (accessNode.kind === 212 /* ElementAccessExpression */ && isAssignmentTarget(accessNode) && getObjectFlags(objectType) & 32 /* Mapped */ && getMappedTypeModifiers(objectType) & 1 /* IncludeReadonly */) {
        error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
      }
      return type;
    }
    if (isGenericObjectType(objectType)) {
      const propertyName = getPropertyNameFromIndex(indexType, accessNode);
      if (propertyName) {
        const propertySymbol = forEachType(getApparentType(objectType), (t) => getPropertyOfType(t, propertyName));
        if (propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & 6 /* NonPublicAccessibilityModifier */) {
          error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName));
          return errorType;
        }
      }
    }
    error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
    return errorType;
  }
  function checkIndexedAccessType(node) {
    checkSourceElement(node.objectType);
    checkSourceElement(node.indexType);
    checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
  }
  function checkMappedType(node) {
    checkGrammarMappedType(node);
    checkSourceElement(node.typeParameter);
    checkSourceElement(node.nameType);
    checkSourceElement(node.type);
    if (!node.type) {
      reportImplicitAny(node, anyType);
    }
    const type = getTypeFromMappedTypeNode(node);
    const nameType = getNameTypeFromMappedType(type);
    if (nameType) {
      checkTypeAssignableTo(nameType, keyofConstraintType, node.nameType);
    } else {
      const constraintType = getConstraintTypeFromMappedType(type);
      checkTypeAssignableTo(constraintType, keyofConstraintType, getEffectiveConstraintOfTypeParameter(node.typeParameter));
    }
  }
  function checkGrammarMappedType(node) {
    var _a;
    if ((_a = node.members) == null ? void 0 : _a.length) {
      return grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
    }
  }
  function checkThisType(node) {
    getTypeFromThisTypeNode(node);
  }
  function checkTypeOperator(node) {
    checkGrammarTypeOperatorNode(node);
    checkSourceElement(node.type);
  }
  function checkConditionalType(node) {
    forEachChild(node, checkSourceElement);
  }
  function checkInferType(node) {
    if (!findAncestor(node, (n) => n.parent && n.parent.kind === 194 /* ConditionalType */ && n.parent.extendsType === n)) {
      grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type);
    }
    checkSourceElement(node.typeParameter);
    const symbol = getSymbolOfDeclaration(node.typeParameter);
    if (symbol.declarations && symbol.declarations.length > 1) {
      const links = getSymbolLinks(symbol);
      if (!links.typeParametersChecked) {
        links.typeParametersChecked = true;
        const typeParameter = getDeclaredTypeOfTypeParameter(symbol);
        const declarations = getDeclarationsOfKind(symbol, 168 /* TypeParameter */);
        if (!areTypeParametersIdentical(declarations, [typeParameter], (decl) => [decl])) {
          const name = symbolToString(symbol);
          for (const declaration of declarations) {
            error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name);
          }
        }
      }
    }
    registerForUnusedIdentifiersCheck(node);
  }
  function checkTemplateLiteralType(node) {
    for (const span of node.templateSpans) {
      checkSourceElement(span.type);
      const type = getTypeFromTypeNode(span.type);
      checkTypeAssignableTo(type, templateConstraintType, span.type);
    }
    getTypeFromTypeNode(node);
  }
  function checkImportType(node) {
    checkSourceElement(node.argument);
    if (node.attributes) {
      getResolutionModeOverride(node.attributes, grammarErrorOnNode);
    }
    checkTypeReferenceOrImport(node);
  }
  function checkNamedTupleMember(node) {
    if (node.dotDotDotToken && node.questionToken) {
      grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest);
    }
    if (node.type.kind === 190 /* OptionalType */) {
      grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type);
    }
    if (node.type.kind === 191 /* RestType */) {
      grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type);
    }
    checkSourceElement(node.type);
    getTypeFromTypeNode(node);
  }
  function isPrivateWithinAmbient(node) {
    return (hasEffectiveModifier(node, 2 /* Private */) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & 33554432 /* Ambient */);
  }
  function getEffectiveDeclarationFlags(n, flagsToCheck) {
    let flags = getCombinedModifierFlagsCached(n);
    if (n.parent.kind !== 264 /* InterfaceDeclaration */ && n.parent.kind !== 263 /* ClassDeclaration */ && n.parent.kind !== 231 /* ClassExpression */ && n.flags & 33554432 /* Ambient */) {
      const container = getEnclosingContainer(n);
      if (container && container.flags & 128 /* ExportContext */ && !(flags & 128 /* Ambient */) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent))) {
        flags |= 32 /* Export */;
      }
      flags |= 128 /* Ambient */;
    }
    return flags & flagsToCheck;
  }
  function checkFunctionOrConstructorSymbol(symbol) {
    addLazyDiagnostic(() => checkFunctionOrConstructorSymbolWorker(symbol));
  }
  function checkFunctionOrConstructorSymbolWorker(symbol) {
    function getCanonicalOverload(overloads, implementation) {
      const implementationSharesContainerWithFirstOverload = implementation !== void 0 && implementation.parent === overloads[0].parent;
      return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
    }
    function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck2, someOverloadFlags, allOverloadFlags) {
      const someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
      if (someButNotAllOverloadFlags !== 0) {
        const canonicalFlags = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck2);
        forEach(overloads, (o) => {
          const deviation = getEffectiveDeclarationFlags(o, flagsToCheck2) ^ canonicalFlags;
          if (deviation & 32 /* Export */) {
            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
          } else if (deviation & 128 /* Ambient */) {
            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
          } else if (deviation & (2 /* Private */ | 4 /* Protected */)) {
            error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
          } else if (deviation & 64 /* Abstract */) {
            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
          }
        });
      }
    }
    function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken2, allHaveQuestionToken2) {
      if (someHaveQuestionToken2 !== allHaveQuestionToken2) {
        const canonicalHasQuestionToken = hasQuestionToken(getCanonicalOverload(overloads, implementation));
        forEach(overloads, (o) => {
          const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;
          if (deviation) {
            error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required);
          }
        });
      }
    }
    const flagsToCheck = 32 /* Export */ | 128 /* Ambient */ | 2 /* Private */ | 4 /* Protected */ | 64 /* Abstract */;
    let someNodeFlags = 0 /* None */;
    let allNodeFlags = flagsToCheck;
    let someHaveQuestionToken = false;
    let allHaveQuestionToken = true;
    let hasOverloads = false;
    let bodyDeclaration;
    let lastSeenNonAmbientDeclaration;
    let previousDeclaration;
    const declarations = symbol.declarations;
    const isConstructor = (symbol.flags & 16384 /* Constructor */) !== 0;
    function reportImplementationExpectedError(node) {
      if (node.name && nodeIsMissing(node.name)) {
        return;
      }
      let seen = false;
      const subsequentNode = forEachChild(node.parent, (c) => {
        if (seen) {
          return c;
        } else {
          seen = c === node;
        }
      });
      if (subsequentNode && subsequentNode.pos === node.end) {
        if (subsequentNode.kind === node.kind) {
          const errorNode2 = subsequentNode.name || subsequentNode;
          const subsequentName = subsequentNode.name;
          if (node.name && subsequentName && // both are private identifiers
          (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText || // Both are computed property names
          isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) || // Both are literal property names that are the same.
          isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(subsequentName))) {
            const reportError = (node.kind === 174 /* MethodDeclaration */ || node.kind === 173 /* MethodSignature */) && isStatic(node) !== isStatic(subsequentNode);
            if (reportError) {
              const diagnostic = isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static;
              error(errorNode2, diagnostic);
            }
            return;
          }
          if (nodeIsPresent(subsequentNode.body)) {
            error(errorNode2, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name));
            return;
          }
        }
      }
      const errorNode = node.name || node;
      if (isConstructor) {
        error(errorNode, Diagnostics.Constructor_implementation_is_missing);
      } else {
        if (hasSyntacticModifier(node, 64 /* Abstract */)) {
          error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
        } else {
          error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
        }
      }
    }
    let duplicateFunctionDeclaration = false;
    let multipleConstructorImplementation = false;
    let hasNonAmbientClass = false;
    const functionDeclarations = [];
    if (declarations) {
      for (const current of declarations) {
        const node = current;
        const inAmbientContext = node.flags & 33554432 /* Ambient */;
        const inAmbientContextOrInterface = node.parent && (node.parent.kind === 264 /* InterfaceDeclaration */ || node.parent.kind === 187 /* TypeLiteral */) || inAmbientContext;
        if (inAmbientContextOrInterface) {
          previousDeclaration = void 0;
        }
        if ((node.kind === 263 /* ClassDeclaration */ || node.kind === 231 /* ClassExpression */) && !inAmbientContext) {
          hasNonAmbientClass = true;
        }
        if (node.kind === 262 /* FunctionDeclaration */ || node.kind === 174 /* MethodDeclaration */ || node.kind === 173 /* MethodSignature */ || node.kind === 176 /* Constructor */) {
          functionDeclarations.push(node);
          const currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
          someNodeFlags |= currentNodeFlags;
          allNodeFlags &= currentNodeFlags;
          someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node);
          allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node);
          const bodyIsPresent = nodeIsPresent(node.body);
          if (bodyIsPresent && bodyDeclaration) {
            if (isConstructor) {
              multipleConstructorImplementation = true;
            } else {
              duplicateFunctionDeclaration = true;
            }
          } else if ((previousDeclaration == null ? void 0 : previousDeclaration.parent) === node.parent && previousDeclaration.end !== node.pos) {
            reportImplementationExpectedError(previousDeclaration);
          }
          if (bodyIsPresent) {
            if (!bodyDeclaration) {
              bodyDeclaration = node;
            }
          } else {
            hasOverloads = true;
          }
          previousDeclaration = node;
          if (!inAmbientContextOrInterface) {
            lastSeenNonAmbientDeclaration = node;
          }
        }
        if (isInJSFile(current) && isFunctionLike(current) && current.jsDoc) {
          hasOverloads = length(getJSDocOverloadTags(current)) > 0;
        }
      }
    }
    if (multipleConstructorImplementation) {
      forEach(functionDeclarations, (declaration) => {
        error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed);
      });
    }
    if (duplicateFunctionDeclaration) {
      forEach(functionDeclarations, (declaration) => {
        error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation);
      });
    }
    if (hasNonAmbientClass && !isConstructor && symbol.flags & 16 /* Function */ && declarations) {
      const relatedDiagnostics = filter(declarations, (d) => d.kind === 263 /* ClassDeclaration */).map((d) => createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class));
      forEach(declarations, (declaration) => {
        const diagnostic = declaration.kind === 263 /* ClassDeclaration */ ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0 : declaration.kind === 262 /* FunctionDeclaration */ ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient : void 0;
        if (diagnostic) {
          addRelatedInfo(
            error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)),
            ...relatedDiagnostics
          );
        }
      });
    }
    if (lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, 64 /* Abstract */) && !lastSeenNonAmbientDeclaration.questionToken) {
      reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
    }
    if (hasOverloads) {
      if (declarations) {
        checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
        checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
      }
      if (bodyDeclaration) {
        const signatures = getSignaturesOfSymbol(symbol);
        const bodySignature = getSignatureFromDeclaration(bodyDeclaration);
        for (const signature of signatures) {
          if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
            const errorNode = signature.declaration && isJSDocSignature(signature.declaration) ? signature.declaration.parent.tagName : signature.declaration;
            addRelatedInfo(
              error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature),
              createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here)
            );
            break;
          }
        }
      }
    }
  }
  function checkExportsOnMergedDeclarations(node) {
    addLazyDiagnostic(() => checkExportsOnMergedDeclarationsWorker(node));
  }
  function checkExportsOnMergedDeclarationsWorker(node) {
    let symbol = node.localSymbol;
    if (!symbol) {
      symbol = getSymbolOfDeclaration(node);
      if (!symbol.exportSymbol) {
        return;
      }
    }
    if (getDeclarationOfKind(symbol, node.kind) !== node) {
      return;
    }
    let exportedDeclarationSpaces = 0 /* None */;
    let nonExportedDeclarationSpaces = 0 /* None */;
    let defaultExportedDeclarationSpaces = 0 /* None */;
    for (const d of symbol.declarations) {
      const declarationSpaces = getDeclarationSpaces(d);
      const effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, 32 /* Export */ | 2048 /* Default */);
      if (effectiveDeclarationFlags & 32 /* Export */) {
        if (effectiveDeclarationFlags & 2048 /* Default */) {
          defaultExportedDeclarationSpaces |= declarationSpaces;
        } else {
          exportedDeclarationSpaces |= declarationSpaces;
        }
      } else {
        nonExportedDeclarationSpaces |= declarationSpaces;
      }
    }
    const nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
    const commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
    const commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
    if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
      for (const d of symbol.declarations) {
        const declarationSpaces = getDeclarationSpaces(d);
        const name = getNameOfDeclaration(d);
        if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {
          error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name));
        } else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
          error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name));
        }
      }
    }
    function getDeclarationSpaces(decl) {
      let d = decl;
      switch (d.kind) {
        case 264 /* InterfaceDeclaration */:
        case 265 /* TypeAliasDeclaration */:
        case 353 /* JSDocTypedefTag */:
        case 345 /* JSDocCallbackTag */:
        case 347 /* JSDocEnumTag */:
          return 2 /* ExportType */;
        case 267 /* ModuleDeclaration */:
          return isAmbientModule(d) || getModuleInstanceState(d) !== 0 /* NonInstantiated */ ? 4 /* ExportNamespace */ | 1 /* ExportValue */ : 4 /* ExportNamespace */;
        case 263 /* ClassDeclaration */:
        case 266 /* EnumDeclaration */:
        case 306 /* EnumMember */:
          return 2 /* ExportType */ | 1 /* ExportValue */;
        case 312 /* SourceFile */:
          return 2 /* ExportType */ | 1 /* ExportValue */ | 4 /* ExportNamespace */;
        case 277 /* ExportAssignment */:
        case 226 /* BinaryExpression */:
          const node2 = d;
          const expression = isExportAssignment(node2) ? node2.expression : node2.right;
          if (!isEntityNameExpression(expression)) {
            return 1 /* ExportValue */;
          }
          d = expression;
        case 271 /* ImportEqualsDeclaration */:
        case 274 /* NamespaceImport */:
        case 273 /* ImportClause */:
          let result = 0 /* None */;
          const target = resolveAlias(getSymbolOfDeclaration(d));
          forEach(target.declarations, (d2) => {
            result |= getDeclarationSpaces(d2);
          });
          return result;
        case 260 /* VariableDeclaration */:
        case 208 /* BindingElement */:
        case 262 /* FunctionDeclaration */:
        case 276 /* ImportSpecifier */:
        case 80 /* Identifier */:
          return 1 /* ExportValue */;
        case 173 /* MethodSignature */:
        case 171 /* PropertySignature */:
          return 2 /* ExportType */;
        default:
          return Debug.failBadSyntaxKind(d);
      }
    }
  }
  function getAwaitedTypeOfPromise(type, errorNode, diagnosticMessage, ...args) {
    const promisedType = getPromisedTypeOfPromise(type, errorNode);
    return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, ...args);
  }
  function getPromisedTypeOfPromise(type, errorNode, thisTypeForErrorOut) {
    if (isTypeAny(type)) {
      return void 0;
    }
    const typeAsPromise = type;
    if (typeAsPromise.promisedTypeOfPromise) {
      return typeAsPromise.promisedTypeOfPromise;
    }
    if (isReferenceToType(type, getGlobalPromiseType(
      /*reportErrors*/
      false
    ))) {
      return typeAsPromise.promisedTypeOfPromise = getTypeArguments(type)[0];
    }
    if (allTypesAssignableToKind(getBaseConstraintOrType(type), 402784252 /* Primitive */ | 131072 /* Never */)) {
      return void 0;
    }
    const thenFunction = getTypeOfPropertyOfType(type, "then");
    if (isTypeAny(thenFunction)) {
      return void 0;
    }
    const thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, 0 /* Call */) : emptyArray;
    if (thenSignatures.length === 0) {
      if (errorNode) {
        error(errorNode, Diagnostics.A_promise_must_have_a_then_method);
      }
      return void 0;
    }
    let thisTypeForError;
    let candidates;
    for (const thenSignature of thenSignatures) {
      const thisType = getThisTypeOfSignature(thenSignature);
      if (thisType && thisType !== voidType && !isTypeRelatedTo(type, thisType, subtypeRelation)) {
        thisTypeForError = thisType;
      } else {
        candidates = append(candidates, thenSignature);
      }
    }
    if (!candidates) {
      Debug.assertIsDefined(thisTypeForError);
      if (thisTypeForErrorOut) {
        thisTypeForErrorOut.value = thisTypeForError;
      }
      if (errorNode) {
        error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForError));
      }
      return void 0;
    }
    const onfulfilledParameterType = getTypeWithFacts(getUnionType(map(candidates, getTypeOfFirstParameterOfSignature)), 2097152 /* NEUndefinedOrNull */);
    if (isTypeAny(onfulfilledParameterType)) {
      return void 0;
    }
    const onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, 0 /* Call */);
    if (onfulfilledParameterSignatures.length === 0) {
      if (errorNode) {
        error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
      }
      return void 0;
    }
    return typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), 2 /* Subtype */);
  }
  function checkAwaitedType(type, withAlias, errorNode, diagnosticMessage, ...args) {
    const awaitedType = withAlias ? getAwaitedType(type, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args);
    return awaitedType || errorType;
  }
  function isThenableType(type) {
    if (allTypesAssignableToKind(getBaseConstraintOrType(type), 402784252 /* Primitive */ | 131072 /* Never */)) {
      return false;
    }
    const thenFunction = getTypeOfPropertyOfType(type, "then");
    return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, 2097152 /* NEUndefinedOrNull */), 0 /* Call */).length > 0;
  }
  function isAwaitedTypeInstantiation(type) {
    var _a;
    if (type.flags & 16777216 /* Conditional */) {
      const awaitedSymbol = getGlobalAwaitedSymbol(
        /*reportErrors*/
        false
      );
      return !!awaitedSymbol && type.aliasSymbol === awaitedSymbol && ((_a = type.aliasTypeArguments) == null ? void 0 : _a.length) === 1;
    }
    return false;
  }
  function unwrapAwaitedType(type) {
    return type.flags & 1048576 /* Union */ ? mapType(type, unwrapAwaitedType) : isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] : type;
  }
  function isAwaitedTypeNeeded(type) {
    if (isTypeAny(type) || isAwaitedTypeInstantiation(type)) {
      return false;
    }
    if (isGenericObjectType(type)) {
      const baseConstraint = getBaseConstraintOfType(type);
      if (baseConstraint ? baseConstraint.flags & 3 /* AnyOrUnknown */ || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) : maybeTypeOfKind(type, 8650752 /* TypeVariable */)) {
        return true;
      }
    }
    return false;
  }
  function tryCreateAwaitedType(type) {
    const awaitedSymbol = getGlobalAwaitedSymbol(
      /*reportErrors*/
      true
    );
    if (awaitedSymbol) {
      return getTypeAliasInstantiation(awaitedSymbol, [unwrapAwaitedType(type)]);
    }
    return void 0;
  }
  function createAwaitedTypeIfNeeded(type) {
    if (isAwaitedTypeNeeded(type)) {
      const awaitedType = tryCreateAwaitedType(type);
      if (awaitedType) {
        return awaitedType;
      }
    }
    Debug.assert(isAwaitedTypeInstantiation(type) || getPromisedTypeOfPromise(type) === void 0, "type provided should not be a non-generic 'promise'-like.");
    return type;
  }
  function getAwaitedType(type, errorNode, diagnosticMessage, ...args) {
    const awaitedType = getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args);
    return awaitedType && createAwaitedTypeIfNeeded(awaitedType);
  }
  function getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args) {
    if (isTypeAny(type)) {
      return type;
    }
    if (isAwaitedTypeInstantiation(type)) {
      return type;
    }
    const typeAsAwaitable = type;
    if (typeAsAwaitable.awaitedTypeOfType) {
      return typeAsAwaitable.awaitedTypeOfType;
    }
    if (type.flags & 1048576 /* Union */) {
      if (awaitedTypeStack.lastIndexOf(type.id) >= 0) {
        if (errorNode) {
          error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
        }
        return void 0;
      }
      const mapper = errorNode ? (constituentType) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias;
      awaitedTypeStack.push(type.id);
      const mapped = mapType(type, mapper);
      awaitedTypeStack.pop();
      return typeAsAwaitable.awaitedTypeOfType = mapped;
    }
    if (isAwaitedTypeNeeded(type)) {
      return typeAsAwaitable.awaitedTypeOfType = type;
    }
    const thisTypeForErrorOut = { value: void 0 };
    const promisedType = getPromisedTypeOfPromise(
      type,
      /*errorNode*/
      void 0,
      thisTypeForErrorOut
    );
    if (promisedType) {
      if (type.id === promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0) {
        if (errorNode) {
          error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
        }
        return void 0;
      }
      awaitedTypeStack.push(type.id);
      const awaitedType = getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, ...args);
      awaitedTypeStack.pop();
      if (!awaitedType) {
        return void 0;
      }
      return typeAsAwaitable.awaitedTypeOfType = awaitedType;
    }
    if (isThenableType(type)) {
      if (errorNode) {
        Debug.assertIsDefined(diagnosticMessage);
        let chain;
        if (thisTypeForErrorOut.value) {
          chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForErrorOut.value));
        }
        chain = chainDiagnosticMessages(chain, diagnosticMessage, ...args);
        diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain));
      }
      return void 0;
    }
    return typeAsAwaitable.awaitedTypeOfType = type;
  }
  function checkAsyncFunctionReturnType(node, returnTypeNode, returnTypeErrorLocation) {
    const returnType = getTypeFromTypeNode(returnTypeNode);
    if (languageVersion >= 2 /* ES2015 */) {
      if (isErrorType(returnType)) {
        return;
      }
      const globalPromiseType = getGlobalPromiseType(
        /*reportErrors*/
        true
      );
      if (globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType)) {
        reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType));
        return;
      }
    } else {
      markTypeNodeAsReferenced(returnTypeNode);
      if (isErrorType(returnType)) {
        return;
      }
      const promiseConstructorName = getEntityNameFromTypeNode(returnTypeNode);
      if (promiseConstructorName === void 0) {
        reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType));
        return;
      }
      const promiseConstructorSymbol = resolveEntityName(
        promiseConstructorName,
        111551 /* Value */,
        /*ignoreErrors*/
        true
      );
      const promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType;
      if (isErrorType(promiseConstructorType)) {
        if (promiseConstructorName.kind === 80 /* Identifier */ && promiseConstructorName.escapedText === "Promise" && getTargetType(returnType) === getGlobalPromiseType(
          /*reportErrors*/
          false
        )) {
          error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
        } else {
          reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName));
        }
        return;
      }
      const globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(
        /*reportErrors*/
        true
      );
      if (globalPromiseConstructorLikeType === emptyObjectType) {
        reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName));
        return;
      }
      const headMessage = Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value;
      const errorInfo = () => returnTypeNode === returnTypeErrorLocation ? void 0 : chainDiagnosticMessages(
        /*details*/
        void 0,
        Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type
      );
      if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo)) {
        return;
      }
      const rootName = promiseConstructorName && getFirstIdentifier(promiseConstructorName);
      const collidingSymbol = getSymbol(node.locals, rootName.escapedText, 111551 /* Value */);
      if (collidingSymbol) {
        error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName));
        return;
      }
    }
    checkAwaitedType(
      returnType,
      /*withAlias*/
      false,
      node,
      Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
    );
    function reportErrorForInvalidReturnType(message, returnTypeNode2, returnTypeErrorLocation2, typeName) {
      if (returnTypeNode2 === returnTypeErrorLocation2) {
        error(returnTypeErrorLocation2, message, typeName);
      } else {
        const diag2 = error(returnTypeErrorLocation2, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type);
        addRelatedInfo(diag2, createDiagnosticForNode(returnTypeNode2, message, typeName));
      }
    }
  }
  function checkDecorator(node) {
    const signature = getResolvedSignature(node);
    checkDeprecatedSignature(signature, node);
    const returnType = getReturnTypeOfSignature(signature);
    if (returnType.flags & 1 /* Any */) {
      return;
    }
    const decoratorSignature = getDecoratorCallSignature(node);
    if (!(decoratorSignature == null ? void 0 : decoratorSignature.resolvedReturnType))
      return;
    let headMessage;
    const expectedReturnType = decoratorSignature.resolvedReturnType;
    switch (node.parent.kind) {
      case 263 /* ClassDeclaration */:
      case 231 /* ClassExpression */:
        headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
        break;
      case 172 /* PropertyDeclaration */:
        if (!legacyDecorators) {
          headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
          break;
        }
      case 169 /* Parameter */:
        headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any;
        break;
      case 174 /* MethodDeclaration */:
      case 177 /* GetAccessor */:
      case 178 /* SetAccessor */:
        headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
        break;
      default:
        return Debug.failBadSyntaxKind(node.parent);
    }
    checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage);
  }
  function createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount = parameters.length, flags = 0 /* None */) {
    const decl = factory.createFunctionTypeNode(
      /*typeParameters*/
      void 0,
      emptyArray,
      factory.createKeywordTypeNode(133 /* AnyKeyword */)
    );
    return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags);
  }
  function createFunctionType(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags) {
    const signature = createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags);
    return getOrCreateTypeFromSignature(signature);
  }
  function createGetterFunctionType(type) {
    return createFunctionType(
      /*typeParameters*/
      void 0,
      /*thisParameter*/
      void 0,
      emptyArray,
      type
    );
  }
  function createSetterFunctionType(type) {
    const valueParam = createParameter("value", type);
    return createFunctionType(
      /*typeParameters*/
      void 0,
      /*thisParameter*/
      void 0,
      [valueParam],
      voidType
    );
  }
  function markTypeNodeAsReferenced(node) {
    markEntityNameOrEntityExpressionAsReference(
      node && getEntityNameFromTypeNode(node),
      /*forDecoratorMetadata*/
      false
    );
  }
  function markEntityNameOrEntityExpressionAsReference(typeName, forDecoratorMetadata) {
    if (!typeName)
      return;
    const rootName = getFirstIdentifier(typeName);
    const meaning = (typeName.kind === 80 /* Identifier */ ? 788968 /* Type */ : 1920 /* Namespace */) | 2097152 /* Alias */;
    const rootSymbol = resolveName(
      rootName,
      rootName.escapedText,
      meaning,
      /*nameNotFoundMessage*/
      void 0,
      /*nameArg*/
      void 0,
      /*isUse*/
      true
    );
    if (rootSymbol && rootSymbol.flags & 2097152 /* Alias */) {
      if (canCollectSymbolAliasAccessabilityData && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol)) {
        markAliasSymbolAsReferenced(rootSymbol);
      } else if (forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= 5 /* ES2015 */ && !symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration)) {
        const diag2 = error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled);
        const aliasDeclaration = find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration);
        if (aliasDeclaration) {
          addRelatedInfo(diag2, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)));
        }
      }
    }
  }
  function markDecoratorMedataDataTypeNodeAsReferenced(node) {
    const entityName = getEntityNameForDecoratorMetadata(node);
    if (entityName && isEntityName(entityName)) {
      markEntityNameOrEntityExpressionAsReference(
        entityName,
        /*forDecoratorMetadata*/
        true
      );
    }
  }
  function getEntityNameForDecoratorMetadata(node) {
    if (node) {
      switch (node.kind) {
        case 193 /* IntersectionType */:
        case 192 /* UnionType */:
          return getEntityNameForDecoratorMetadataFromTypeList(node.types);
        case 194 /* ConditionalType */:
          return getEntityNameForDecoratorMetadataFromTypeList([node.trueType, node.falseType]);
        case 196 /* ParenthesizedType */:
        case 202 /* NamedTupleMember */:
          return getEntityNameForDecoratorMetadata(node.type);
        case 183 /* TypeReference */:
          return node.typeName;
      }
    }
  }
  function getEntityNameForDecoratorMetadataFromTypeList(types) {
    let commonEntityName;
    for (let typeNode of types) {
      while (typeNode.kind === 196 /* ParenthesizedType */ || typeNode.kind === 202 /* NamedTupleMember */) {
        typeNode = typeNode.type;
      }
      if (typeNode.kind === 146 /* NeverKeyword */) {
        continue;
      }
      if (!strictNullChecks && (typeNode.kind === 201 /* LiteralType */ && typeNode.literal.kind === 106 /* NullKeyword */ || typeNode.kind === 157 /* UndefinedKeyword */)) {
        continue;
      }
      const individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
      if (!individualEntityName) {
        return void 0;
      }
      if (commonEntityName) {
        if (!isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || commonEntityName.escapedText !== individualEntityName.escapedText) {
          return void 0;
        }
      } else {
        commonEntityName = individualEntityName;
      }
    }
    return commonEntityName;
  }
  function getParameterTypeNodeForDecoratorCheck(node) {
    const typeNode = getEffectiveTypeAnnotationNode(node);
    return isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode;
  }
  function checkDecorators(node) {
    if (!canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent)) {
      return;
    }
    const firstDecorator = find(node.modifiers, isDecorator);
    if (!firstDecorator) {
      return;
    }
    if (legacyDecorators) {
      checkExternalEmitHelpers(firstDecorator, 8 /* Decorate */);
      if (node.kind === 169 /* Parameter */) {
        checkExternalEmitHelpers(firstDecorator, 32 /* Param */);
      }
    } else if (languageVersion < 99 /* ESNext */) {
      checkExternalEmitHelpers(firstDecorator, 8 /* ESDecorateAndRunInitializers */);
      if (isClassDeclaration(node)) {
        if (!node.name) {
          checkExternalEmitHelpers(firstDecorator, 8388608 /* SetFunctionName */);
        } else {
          const member = getFirstTransformableStaticClassElement(node);
          if (member) {
            checkExternalEmitHelpers(firstDecorator, 8388608 /* SetFunctionName */);
          }
        }
      } else if (!isClassExpression(node)) {
        if (isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node))) {
          checkExternalEmitHelpers(firstDecorator, 8388608 /* SetFunctionName */);
        }
        if (isComputedPropertyName(node.name)) {
          checkExternalEmitHelpers(firstDecorator, 16777216 /* PropKey */);
        }
      }
    }
    if (compilerOptions.emitDecoratorMetadata) {
      checkExternalEmitHelpers(firstDecorator, 16 /* Metadata */);
      switch (node.kind) {
        case 263 /* ClassDeclaration */:
          const constructor = getFirstConstructorWithBody(node);
          if (constructor) {
            for (const parameter of constructor.parameters) {
              markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
            }
          }
          break;
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
          const otherKind = node.kind === 177 /* GetAccessor */ ? 178 /* SetAccessor */ : 177 /* GetAccessor */;
          const otherAccessor = getDeclarationOfKind(getSymbolOfDeclaration(node), otherKind);
          markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));
          break;
        case 174 /* MethodDeclaration */:
          for (const parameter of node.parameters) {
            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
          }
          markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node));
          break;
        case 172 /* PropertyDeclaration */:
          markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node));
          break;
        case 169 /* Parameter */:
          markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));
          const containingSignature = node.parent;
          for (const parameter of containingSignature.parameters) {
            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
          }
          markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature));
          break;
      }
    }
    for (const modifier of node.modifiers) {
      if (isDecorator(modifier)) {
        checkDecorator(modifier);
      }
    }
  }
  function checkFunctionDeclaration(node) {
    addLazyDiagnostic(checkFunctionDeclarationDiagnostics);
    function checkFunctionDeclarationDiagnostics() {
      checkFunctionOrMethodDeclaration(node);
      checkGrammarForGenerator(node);
      checkCollisionsForDeclarationName(node, node.name);
    }
  }
  function checkJSDocTypeAliasTag(node) {
    if (!node.typeExpression) {
      error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
    }
    if (node.name) {
      checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
    }
    checkSourceElement(node.typeExpression);
    checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
  }
  function checkJSDocTemplateTag(node) {
    checkSourceElement(node.constraint);
    for (const tp of node.typeParameters) {
      checkSourceElement(tp);
    }
  }
  function checkJSDocTypeTag(node) {
    checkSourceElement(node.typeExpression);
  }
  function checkJSDocSatisfiesTag(node) {
    checkSourceElement(node.typeExpression);
    const host2 = getEffectiveJSDocHost(node);
    if (host2) {
      const tags = getAllJSDocTags(host2, isJSDocSatisfiesTag);
      if (length(tags) > 1) {
        for (let i = 1; i < length(tags); i++) {
          const tagName = tags[i].tagName;
          error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));
        }
      }
    }
  }
  function checkJSDocLinkLikeTag(node) {
    if (node.name) {
      resolveJSDocMemberName(
        node.name,
        /*ignoreErrors*/
        true
      );
    }
  }
  function checkJSDocParameterTag(node) {
    checkSourceElement(node.typeExpression);
  }
  function checkJSDocPropertyTag(node) {
    checkSourceElement(node.typeExpression);
  }
  function checkJSDocFunctionType(node) {
    addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny);
    checkSignatureDeclaration(node);
    function checkJSDocFunctionTypeImplicitAny() {
      if (!node.type && !isJSDocConstructSignature(node)) {
        reportImplicitAny(node, anyType);
      }
    }
  }
  function checkJSDocThisTag(node) {
    const host2 = getEffectiveJSDocHost(node);
    if (host2 && isArrowFunction(host2)) {
      error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
    }
  }
  function checkJSDocImplementsTag(node) {
    const classLike = getEffectiveJSDocHost(node);
    if (!classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike)) {
      error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
    }
  }
  function checkJSDocAugmentsTag(node) {
    const classLike = getEffectiveJSDocHost(node);
    if (!classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike)) {
      error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
      return;
    }
    const augmentsTags = getJSDocTags(classLike).filter(isJSDocAugmentsTag);
    Debug.assert(augmentsTags.length > 0);
    if (augmentsTags.length > 1) {
      error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag);
    }
    const name = getIdentifierFromEntityNameExpression(node.class.expression);
    const extend2 = getClassExtendsHeritageElement(classLike);
    if (extend2) {
      const className = getIdentifierFromEntityNameExpression(extend2.expression);
      if (className && name.escapedText !== className.escapedText) {
        error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className));
      }
    }
  }
  function checkJSDocAccessibilityModifiers(node) {
    const host2 = getJSDocHost(node);
    if (host2 && isPrivateIdentifierClassElementDeclaration(host2)) {
      error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
    }
  }
  function getIdentifierFromEntityNameExpression(node) {
    switch (node.kind) {
      case 80 /* Identifier */:
        return node;
      case 211 /* PropertyAccessExpression */:
        return node.name;
      default:
        return void 0;
    }
  }
  function checkFunctionOrMethodDeclaration(node) {
    var _a;
    checkDecorators(node);
    checkSignatureDeclaration(node);
    const functionFlags = getFunctionFlags(node);
    if (node.name && node.name.kind === 167 /* ComputedPropertyName */) {
      checkComputedPropertyName(node.name);
    }
    if (hasBindableName(node)) {
      const symbol = getSymbolOfDeclaration(node);
      const localSymbol = node.localSymbol || symbol;
      const firstDeclaration = (_a = localSymbol.declarations) == null ? void 0 : _a.find(
        // Get first non javascript function declaration
        (declaration) => declaration.kind === node.kind && !(declaration.flags & 524288 /* JavaScriptFile */)
      );
      if (node === firstDeclaration) {
        checkFunctionOrConstructorSymbol(localSymbol);
      }
      if (symbol.parent) {
        checkFunctionOrConstructorSymbol(symbol);
      }
    }
    const body = node.kind === 173 /* MethodSignature */ ? void 0 : node.body;
    checkSourceElement(body);
    checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));
    addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics);
    if (isInJSFile(node)) {
      const typeTag = getJSDocTypeTag(node);
      if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node)) {
        error(typeTag.typeExpression.type, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature);
      }
    }
    function checkFunctionOrMethodDeclarationDiagnostics() {
      if (!getEffectiveReturnTypeNode(node)) {
        if (nodeIsMissing(body) && !isPrivateWithinAmbient(node)) {
          reportImplicitAny(node, anyType);
        }
        if (functionFlags & 1 /* Generator */ && nodeIsPresent(body)) {
          getReturnTypeOfSignature(getSignatureFromDeclaration(node));
        }
      }
    }
  }
  function registerForUnusedIdentifiersCheck(node) {
    addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics);
    function registerForUnusedIdentifiersCheckDiagnostics() {
      const sourceFile = getSourceFileOfNode(node);
      let potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
      if (!potentiallyUnusedIdentifiers) {
        potentiallyUnusedIdentifiers = [];
        allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
      }
      potentiallyUnusedIdentifiers.push(node);
    }
  }
  function checkUnusedIdentifiers(potentiallyUnusedIdentifiers, addDiagnostic) {
    for (const node of potentiallyUnusedIdentifiers) {
      switch (node.kind) {
        case 263 /* ClassDeclaration */:
        case 231 /* ClassExpression */:
          checkUnusedClassMembers(node, addDiagnostic);
          checkUnusedTypeParameters(node, addDiagnostic);
          break;
        case 312 /* SourceFile */:
        case 267 /* ModuleDeclaration */:
        case 241 /* Block */:
        case 269 /* CaseBlock */:
        case 248 /* ForStatement */:
        case 249 /* ForInStatement */:
        case 250 /* ForOfStatement */:
          checkUnusedLocalsAndParameters(node, addDiagnostic);
          break;
        case 176 /* Constructor */:
        case 218 /* FunctionExpression */:
        case 262 /* FunctionDeclaration */:
        case 219 /* ArrowFunction */:
        case 174 /* MethodDeclaration */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
          if (node.body) {
            checkUnusedLocalsAndParameters(node, addDiagnostic);
          }
          checkUnusedTypeParameters(node, addDiagnostic);
          break;
        case 173 /* MethodSignature */:
        case 179 /* CallSignature */:
        case 180 /* ConstructSignature */:
        case 184 /* FunctionType */:
        case 185 /* ConstructorType */:
        case 265 /* TypeAliasDeclaration */:
        case 264 /* InterfaceDeclaration */:
          checkUnusedTypeParameters(node, addDiagnostic);
          break;
        case 195 /* InferType */:
          checkUnusedInferTypeParameter(node, addDiagnostic);
          break;
        default:
          Debug.assertNever(node, "Node should not have been registered for unused identifiers check");
      }
    }
  }
  function errorUnusedLocal(declaration, name, addDiagnostic) {
    const node = getNameOfDeclaration(declaration) || declaration;
    const message = isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read;
    addDiagnostic(declaration, 0 /* Local */, createDiagnosticForNode(node, message, name));
  }
  function isIdentifierThatStartsWithUnderscore(node) {
    return isIdentifier(node) && idText(node).charCodeAt(0) === 95 /* _ */;
  }
  function checkUnusedClassMembers(node, addDiagnostic) {
    for (const member of node.members) {
      switch (member.kind) {
        case 174 /* MethodDeclaration */:
        case 172 /* PropertyDeclaration */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
          if (member.kind === 178 /* SetAccessor */ && member.symbol.flags & 32768 /* GetAccessor */) {
            break;
          }
          const symbol = getSymbolOfDeclaration(member);
          if (!symbol.isReferenced && (hasEffectiveModifier(member, 2 /* Private */) || isNamedDeclaration(member) && isPrivateIdentifier(member.name)) && !(member.flags & 33554432 /* Ambient */)) {
            addDiagnostic(member, 0 /* Local */, createDiagnosticForNode(member.name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));
          }
          break;
        case 176 /* Constructor */:
          for (const parameter of member.parameters) {
            if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, 2 /* Private */)) {
              addDiagnostic(parameter, 0 /* Local */, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));
            }
          }
          break;
        case 181 /* IndexSignature */:
        case 240 /* SemicolonClassElement */:
        case 175 /* ClassStaticBlockDeclaration */:
          break;
        default:
          Debug.fail("Unexpected class member");
      }
    }
  }
  function checkUnusedInferTypeParameter(node, addDiagnostic) {
    const { typeParameter } = node;
    if (isTypeParameterUnused(typeParameter)) {
      addDiagnostic(node, 1 /* Parameter */, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)));
    }
  }
  function checkUnusedTypeParameters(node, addDiagnostic) {
    const declarations = getSymbolOfDeclaration(node).declarations;
    if (!declarations || last(declarations) !== node)
      return;
    const typeParameters = getEffectiveTypeParameterDeclarations(node);
    const seenParentsWithEveryUnused = /* @__PURE__ */ new Set();
    for (const typeParameter of typeParameters) {
      if (!isTypeParameterUnused(typeParameter))
        continue;
      const name = idText(typeParameter.name);
      const { parent } = typeParameter;
      if (parent.kind !== 195 /* InferType */ && parent.typeParameters.every(isTypeParameterUnused)) {
        if (tryAddToSet(seenParentsWithEveryUnused, parent)) {
          const sourceFile = getSourceFileOfNode(parent);
          const range = isJSDocTemplateTag(parent) ? rangeOfNode(parent) : rangeOfTypeParameters(sourceFile, parent.typeParameters);
          const only = parent.typeParameters.length === 1;
          const messageAndArg = only ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name] : [Diagnostics.All_type_parameters_are_unused];
          addDiagnostic(typeParameter, 1 /* Parameter */, createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, ...messageAndArg));
        }
      } else {
        addDiagnostic(typeParameter, 1 /* Parameter */, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name));
      }
    }
  }
  function isTypeParameterUnused(typeParameter) {
    return !(getMergedSymbol(typeParameter.symbol).isReferenced & 262144 /* TypeParameter */) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
  }
  function addToGroup(map2, key, value, getKey) {
    const keyString = String(getKey(key));
    const group2 = map2.get(keyString);
    if (group2) {
      group2[1].push(value);
    } else {
      map2.set(keyString, [key, [value]]);
    }
  }
  function tryGetRootParameterDeclaration(node) {
    return tryCast(getRootDeclaration(node), isParameter);
  }
  function isValidUnusedLocalDeclaration(declaration) {
    if (isBindingElement(declaration)) {
      if (isObjectBindingPattern(declaration.parent)) {
        return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name));
      }
      return isIdentifierThatStartsWithUnderscore(declaration.name);
    }
    return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name);
  }
  function checkUnusedLocalsAndParameters(nodeWithLocals, addDiagnostic) {
    const unusedImports = /* @__PURE__ */ new Map();
    const unusedDestructures = /* @__PURE__ */ new Map();
    const unusedVariables = /* @__PURE__ */ new Map();
    nodeWithLocals.locals.forEach((local) => {
      if (local.flags & 262144 /* TypeParameter */ ? !(local.flags & 3 /* Variable */ && !(local.isReferenced & 3 /* Variable */)) : local.isReferenced || local.exportSymbol) {
        return;
      }
      if (local.declarations) {
        for (const declaration of local.declarations) {
          if (isValidUnusedLocalDeclaration(declaration)) {
            continue;
          }
          if (isImportedDeclaration(declaration)) {
            addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
          } else if (isBindingElement(declaration) && isObjectBindingPattern(declaration.parent)) {
            const lastElement = last(declaration.parent.elements);
            if (declaration === lastElement || !last(declaration.parent.elements).dotDotDotToken) {
              addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
            }
          } else if (isVariableDeclaration(declaration)) {
            const blockScopeKind = getCombinedNodeFlagsCached(declaration) & 7 /* BlockScoped */;
            const name = getNameOfDeclaration(declaration);
            if (blockScopeKind !== 4 /* Using */ && blockScopeKind !== 6 /* AwaitUsing */ || !name || !isIdentifierThatStartsWithUnderscore(name)) {
              addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
            }
          } else {
            const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
            const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);
            if (parameter && name) {
              if (!isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {
                if (isBindingElement(declaration) && isArrayBindingPattern(declaration.parent)) {
                  addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                } else {
                  addDiagnostic(parameter, 1 /* Parameter */, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)));
                }
              }
            } else {
              errorUnusedLocal(declaration, symbolName(local), addDiagnostic);
            }
          }
        }
      }
    });
    unusedImports.forEach(([importClause, unuseds]) => {
      const importDecl = importClause.parent;
      const nDeclarations = (importClause.name ? 1 : 0) + (importClause.namedBindings ? importClause.namedBindings.kind === 274 /* NamespaceImport */ ? 1 : importClause.namedBindings.elements.length : 0);
      if (nDeclarations === unuseds.length) {
        addDiagnostic(
          importDecl,
          0 /* Local */,
          unuseds.length === 1 ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name)) : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused)
        );
      } else {
        for (const unused of unuseds)
          errorUnusedLocal(unused, idText(unused.name), addDiagnostic);
      }
    });
    unusedDestructures.forEach(([bindingPattern, bindingElements]) => {
      const kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? 1 /* Parameter */ : 0 /* Local */;
      if (bindingPattern.elements.length === bindingElements.length) {
        if (bindingElements.length === 1 && bindingPattern.parent.kind === 260 /* VariableDeclaration */ && bindingPattern.parent.parent.kind === 261 /* VariableDeclarationList */) {
          addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);
        } else {
          addDiagnostic(
            bindingPattern,
            kind,
            bindingElements.length === 1 ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name)) : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused)
          );
        }
      } else {
        for (const e of bindingElements) {
          addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));
        }
      }
    });
    unusedVariables.forEach(([declarationList, declarations]) => {
      if (declarationList.declarations.length === declarations.length) {
        addDiagnostic(
          declarationList,
          0 /* Local */,
          declarations.length === 1 ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name)) : createDiagnosticForNode(declarationList.parent.kind === 243 /* VariableStatement */ ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused)
        );
      } else {
        for (const decl of declarations) {
          addDiagnostic(decl, 0 /* Local */, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
        }
      }
    });
  }
  function checkPotentialUncheckedRenamedBindingElementsInTypes() {
    var _a;
    for (const node of potentialUnusedRenamedBindingElementsInTypes) {
      if (!((_a = getSymbolOfDeclaration(node)) == null ? void 0 : _a.isReferenced)) {
        const wrappingDeclaration = walkUpBindingElementsAndPatterns(node);
        Debug.assert(isParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here");
        const diagnostic = createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName));
        if (!wrappingDeclaration.type) {
          addRelatedInfo(
            diagnostic,
            createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 1, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName))
          );
        }
        diagnostics.add(diagnostic);
      }
    }
  }
  function bindingNameText(name) {
    switch (name.kind) {
      case 80 /* Identifier */:
        return idText(name);
      case 207 /* ArrayBindingPattern */:
      case 206 /* ObjectBindingPattern */:
        return bindingNameText(cast(first(name.elements), isBindingElement).name);
      default:
        return Debug.assertNever(name);
    }
  }
  function isImportedDeclaration(node) {
    return node.kind === 273 /* ImportClause */ || node.kind === 276 /* ImportSpecifier */ || node.kind === 274 /* NamespaceImport */;
  }
  function importClauseFromImported(decl) {
    return decl.kind === 273 /* ImportClause */ ? decl : decl.kind === 274 /* NamespaceImport */ ? decl.parent : decl.parent.parent;
  }
  function checkBlock(node) {
    if (node.kind === 241 /* Block */) {
      checkGrammarStatementInAmbientContext(node);
    }
    if (isFunctionOrModuleBlock(node)) {
      const saveFlowAnalysisDisabled = flowAnalysisDisabled;
      forEach(node.statements, checkSourceElement);
      flowAnalysisDisabled = saveFlowAnalysisDisabled;
    } else {
      forEach(node.statements, checkSourceElement);
    }
    if (node.locals) {
      registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkCollisionWithArgumentsInGeneratedCode(node) {
    if (languageVersion >= 2 /* ES2015 */ || !hasRestParameter(node) || node.flags & 33554432 /* Ambient */ || nodeIsMissing(node.body)) {
      return;
    }
    forEach(node.parameters, (p) => {
      if (p.name && !isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {
        errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
      }
    });
  }
  function needCollisionCheckForIdentifier(node, identifier, name) {
    if ((identifier == null ? void 0 : identifier.escapedText) !== name) {
      return false;
    }
    if (node.kind === 172 /* PropertyDeclaration */ || node.kind === 171 /* PropertySignature */ || node.kind === 174 /* MethodDeclaration */ || node.kind === 173 /* MethodSignature */ || node.kind === 177 /* GetAccessor */ || node.kind === 178 /* SetAccessor */ || node.kind === 303 /* PropertyAssignment */) {
      return false;
    }
    if (node.flags & 33554432 /* Ambient */) {
      return false;
    }
    if (isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node)) {
      if (isTypeOnlyImportOrExportDeclaration(node)) {
        return false;
      }
    }
    const root = getRootDeclaration(node);
    if (isParameter(root) && nodeIsMissing(root.parent.body)) {
      return false;
    }
    return true;
  }
  function checkIfThisIsCapturedInEnclosingScope(node) {
    findAncestor(node, (current) => {
      if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {
        const isDeclaration2 = node.kind !== 80 /* Identifier */;
        if (isDeclaration2) {
          error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
        } else {
          error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
        }
        return true;
      }
      return false;
    });
  }
  function checkIfNewTargetIsCapturedInEnclosingScope(node) {
    findAncestor(node, (current) => {
      if (getNodeCheckFlags(current) & 8 /* CaptureNewTarget */) {
        const isDeclaration2 = node.kind !== 80 /* Identifier */;
        if (isDeclaration2) {
          error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
        } else {
          error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
        }
        return true;
      }
      return false;
    });
  }
  function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
    if (moduleKind >= 5 /* ES2015 */ && !(moduleKind >= 100 /* Node16 */ && getSourceFileOfNode(node).impliedNodeFormat === 1 /* CommonJS */)) {
      return;
    }
    if (!name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
      return;
    }
    if (isModuleDeclaration(node) && getModuleInstanceState(node) !== 1 /* Instantiated */) {
      return;
    }
    const parent = getDeclarationContainer(node);
    if (parent.kind === 312 /* SourceFile */ && isExternalOrCommonJsModule(parent)) {
      errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name));
    }
  }
  function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
    if (!name || languageVersion >= 4 /* ES2017 */ || !needCollisionCheckForIdentifier(node, name, "Promise")) {
      return;
    }
    if (isModuleDeclaration(node) && getModuleInstanceState(node) !== 1 /* Instantiated */) {
      return;
    }
    const parent = getDeclarationContainer(node);
    if (parent.kind === 312 /* SourceFile */ && isExternalOrCommonJsModule(parent) && parent.flags & 4096 /* HasAsyncFunctions */) {
      errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name));
    }
  }
  function recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name) {
    if (languageVersion <= 8 /* ES2021 */ && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet"))) {
      potentialWeakMapSetCollisions.push(node);
    }
  }
  function checkWeakMapSetCollision(node) {
    const enclosingBlockScope = getEnclosingBlockScopeContainer(node);
    if (getNodeCheckFlags(enclosingBlockScope) & 1048576 /* ContainsClassWithPrivateIdentifiers */) {
      Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && typeof node.name.escapedText === "string", "The target of a WeakMap/WeakSet collision check should be an identifier");
      errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText);
    }
  }
  function recordPotentialCollisionWithReflectInGeneratedCode(node, name) {
    if (name && languageVersion >= 2 /* ES2015 */ && languageVersion <= 8 /* ES2021 */ && needCollisionCheckForIdentifier(node, name, "Reflect")) {
      potentialReflectCollisions.push(node);
    }
  }
  function checkReflectCollision(node) {
    let hasCollision = false;
    if (isClassExpression(node)) {
      for (const member of node.members) {
        if (getNodeCheckFlags(member) & 2097152 /* ContainsSuperPropertyInStaticInitializer */) {
          hasCollision = true;
          break;
        }
      }
    } else if (isFunctionExpression(node)) {
      if (getNodeCheckFlags(node) & 2097152 /* ContainsSuperPropertyInStaticInitializer */) {
        hasCollision = true;
      }
    } else {
      const container = getEnclosingBlockScopeContainer(node);
      if (container && getNodeCheckFlags(container) & 2097152 /* ContainsSuperPropertyInStaticInitializer */) {
        hasCollision = true;
      }
    }
    if (hasCollision) {
      Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier");
      errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect");
    }
  }
  function checkCollisionsForDeclarationName(node, name) {
    if (!name)
      return;
    checkCollisionWithRequireExportsInGeneratedCode(node, name);
    checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
    recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
    recordPotentialCollisionWithReflectInGeneratedCode(node, name);
    if (isClassLike(node)) {
      checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0);
      if (!(node.flags & 33554432 /* Ambient */)) {
        checkClassNameCollisionWithObject(name);
      }
    } else if (isEnumDeclaration(node)) {
      checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0);
    }
  }
  function checkVarDeclaredNamesNotShadowed(node) {
    if ((getCombinedNodeFlagsCached(node) & 7 /* BlockScoped */) !== 0 || isParameterDeclaration(node)) {
      return;
    }
    const symbol = getSymbolOfDeclaration(node);
    if (symbol.flags & 1 /* FunctionScopedVariable */) {
      if (!isIdentifier(node.name))
        return Debug.fail();
      const localDeclarationSymbol = resolveName(
        node,
        node.name.escapedText,
        3 /* Variable */,
        /*nameNotFoundMessage*/
        void 0,
        /*nameArg*/
        void 0,
        /*isUse*/
        false
      );
      if (localDeclarationSymbol && localDeclarationSymbol !== symbol && localDeclarationSymbol.flags & 2 /* BlockScopedVariable */) {
        if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & 7 /* BlockScoped */) {
          const varDeclList = getAncestor(localDeclarationSymbol.valueDeclaration, 261 /* VariableDeclarationList */);
          const container = varDeclList.parent.kind === 243 /* VariableStatement */ && varDeclList.parent.parent ? varDeclList.parent.parent : void 0;
          const namesShareScope = container && (container.kind === 241 /* Block */ && isFunctionLike(container.parent) || container.kind === 268 /* ModuleBlock */ || container.kind === 267 /* ModuleDeclaration */ || container.kind === 312 /* SourceFile */);
          if (!namesShareScope) {
            const name = symbolToString(localDeclarationSymbol);
            error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
          }
        }
      }
    }
  }
  function convertAutoToAny(type) {
    return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
  }
  function checkVariableLikeDeclaration(node) {
    var _a;
    checkDecorators(node);
    if (!isBindingElement(node)) {
      checkSourceElement(node.type);
    }
    if (!node.name) {
      return;
    }
    if (node.name.kind === 167 /* ComputedPropertyName */) {
      checkComputedPropertyName(node.name);
      if (hasOnlyExpressionInitializer(node) && node.initializer) {
        checkExpressionCached(node.initializer);
      }
    }
    if (isBindingElement(node)) {
      if (node.propertyName && isIdentifier(node.name) && isParameterDeclaration(node) && nodeIsMissing(getContainingFunction(node).body)) {
        potentialUnusedRenamedBindingElementsInTypes.push(node);
        return;
      }
      if (isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < 5 /* ES2018 */) {
        checkExternalEmitHelpers(node, 4 /* Rest */);
      }
      if (node.propertyName && node.propertyName.kind === 167 /* ComputedPropertyName */) {
        checkComputedPropertyName(node.propertyName);
      }
      const parent = node.parent.parent;
      const parentCheckMode = node.dotDotDotToken ? 32 /* RestBindingElement */ : 0 /* Normal */;
      const parentType = getTypeForBindingElementParent(parent, parentCheckMode);
      const name = node.propertyName || node.name;
      if (parentType && !isBindingPattern(name)) {
        const exprType = getLiteralTypeFromPropertyName(name);
        if (isTypeUsableAsPropertyName(exprType)) {
          const nameText = getPropertyNameFromType(exprType);
          const property = getPropertyOfType(parentType, nameText);
          if (property) {
            markPropertyAsReferenced(
              property,
              /*nodeForCheckWriteOnly*/
              void 0,
              /*isSelfTypeAccess*/
              false
            );
            checkPropertyAccessibility(
              node,
              !!parent.initializer && parent.initializer.kind === 108 /* SuperKeyword */,
              /*writing*/
              false,
              parentType,
              property
            );
          }
        }
      }
    }
    if (isBindingPattern(node.name)) {
      if (node.name.kind === 207 /* ArrayBindingPattern */ && languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
        checkExternalEmitHelpers(node, 512 /* Read */);
      }
      forEach(node.name.elements, checkSourceElement);
    }
    if (node.initializer && isParameterDeclaration(node) && nodeIsMissing(getContainingFunction(node).body)) {
      error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
      return;
    }
    if (isBindingPattern(node.name)) {
      if (isInAmbientOrTypeNode(node)) {
        return;
      }
      const needCheckInitializer = hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind !== 249 /* ForInStatement */;
      const needCheckWidenedType = !some(node.name.elements, not(isOmittedExpression));
      if (needCheckInitializer || needCheckWidenedType) {
        const widenedType = getWidenedTypeForVariableLikeDeclaration(node);
        if (needCheckInitializer) {
          const initializerType = checkExpressionCached(node.initializer);
          if (strictNullChecks && needCheckWidenedType) {
            checkNonNullNonVoidType(initializerType, node);
          } else {
            checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
          }
        }
        if (needCheckWidenedType) {
          if (isArrayBindingPattern(node.name)) {
            checkIteratedTypeOrElementType(65 /* Destructuring */, widenedType, undefinedType, node);
          } else if (strictNullChecks) {
            checkNonNullNonVoidType(widenedType, node);
          }
        }
      }
      return;
    }
    const symbol = getSymbolOfDeclaration(node);
    if (symbol.flags & 2097152 /* Alias */ && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node))) {
      checkAliasSymbol(node);
      return;
    }
    const type = convertAutoToAny(getTypeOfSymbol(symbol));
    if (node === symbol.valueDeclaration) {
      const initializer = hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node);
      if (initializer) {
        const isJSObjectLiteralInitializer = isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length === 0 || isPrototypeAccess(node.name)) && !!((_a = symbol.exports) == null ? void 0 : _a.size);
        if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== 249 /* ForInStatement */) {
          const initializerType = checkExpressionCached(initializer);
          checkTypeAssignableToAndOptionallyElaborate(
            initializerType,
            type,
            node,
            initializer,
            /*headMessage*/
            void 0
          );
          const blockScopeKind = getCombinedNodeFlagsCached(node) & 7 /* BlockScoped */;
          if (blockScopeKind === 6 /* AwaitUsing */) {
            const globalAsyncDisposableType = getGlobalAsyncDisposableType(
              /*reportErrors*/
              true
            );
            const globalDisposableType = getGlobalDisposableType(
              /*reportErrors*/
              true
            );
            if (globalAsyncDisposableType !== emptyObjectType && globalDisposableType !== emptyObjectType) {
              const optionalDisposableType = getUnionType([globalAsyncDisposableType, globalDisposableType, nullType, undefinedType]);
              checkTypeAssignableTo(initializerType, optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined);
            }
          } else if (blockScopeKind === 4 /* Using */) {
            const globalDisposableType = getGlobalDisposableType(
              /*reportErrors*/
              true
            );
            if (globalDisposableType !== emptyObjectType) {
              const optionalDisposableType = getUnionType([globalDisposableType, nullType, undefinedType]);
              checkTypeAssignableTo(initializerType, optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined);
            }
          }
        }
      }
      if (symbol.declarations && symbol.declarations.length > 1) {
        if (some(symbol.declarations, (d) => d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node))) {
          error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
        }
      }
    } else {
      const declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
      if (!isErrorType(type) && !isErrorType(declarationType) && !isTypeIdenticalTo(type, declarationType) && !(symbol.flags & 67108864 /* Assignment */)) {
        errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
      }
      if (hasOnlyExpressionInitializer(node) && node.initializer) {
        checkTypeAssignableToAndOptionallyElaborate(
          checkExpressionCached(node.initializer),
          declarationType,
          node,
          node.initializer,
          /*headMessage*/
          void 0
        );
      }
      if (symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
        error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
      }
    }
    if (node.kind !== 172 /* PropertyDeclaration */ && node.kind !== 171 /* PropertySignature */) {
      checkExportsOnMergedDeclarations(node);
      if (node.kind === 260 /* VariableDeclaration */ || node.kind === 208 /* BindingElement */) {
        checkVarDeclaredNamesNotShadowed(node);
      }
      checkCollisionsForDeclarationName(node, node.name);
    }
  }
  function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration, firstType, nextDeclaration, nextType) {
    const nextDeclarationName = getNameOfDeclaration(nextDeclaration);
    const message = nextDeclaration.kind === 172 /* PropertyDeclaration */ || nextDeclaration.kind === 171 /* PropertySignature */ ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2 : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
    const declName = declarationNameToString(nextDeclarationName);
    const err = error(
      nextDeclarationName,
      message,
      declName,
      typeToString(firstType),
      typeToString(nextType)
    );
    if (firstDeclaration) {
      addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName));
    }
  }
  function areDeclarationFlagsIdentical(left, right) {
    if (left.kind === 169 /* Parameter */ && right.kind === 260 /* VariableDeclaration */ || left.kind === 260 /* VariableDeclaration */ && right.kind === 169 /* Parameter */) {
      return true;
    }
    if (hasQuestionToken(left) !== hasQuestionToken(right)) {
      return false;
    }
    const interestingFlags = 2 /* Private */ | 4 /* Protected */ | 1024 /* Async */ | 64 /* Abstract */ | 8 /* Readonly */ | 256 /* Static */;
    return getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(right, interestingFlags);
  }
  function checkVariableDeclaration(node) {
    var _a, _b;
    (_a = tracing) == null ? void 0 : _a.push(tracing.Phase.Check, "checkVariableDeclaration", { kind: node.kind, pos: node.pos, end: node.end, path: node.tracingPath });
    checkGrammarVariableDeclaration(node);
    checkVariableLikeDeclaration(node);
    (_b = tracing) == null ? void 0 : _b.pop();
  }
  function checkBindingElement(node) {
    checkGrammarBindingElement(node);
    return checkVariableLikeDeclaration(node);
  }
  function checkVariableDeclarationList(node) {
    const blockScopeKind = getCombinedNodeFlags(node) & 7 /* BlockScoped */;
    if (blockScopeKind === 4 /* Using */ || blockScopeKind === 6 /* AwaitUsing */) {
      checkExternalEmitHelpers(node, 33554432 /* AddDisposableResourceAndDisposeResources */);
    }
    forEach(node.declarations, checkSourceElement);
  }
  function checkVariableStatement(node) {
    if (!checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList))
      checkGrammarForDisallowedBlockScopedVariableStatement(node);
    checkVariableDeclarationList(node.declarationList);
  }
  function checkExpressionStatement(node) {
    checkGrammarStatementInAmbientContext(node);
    checkExpression(node.expression);
  }
  function checkIfStatement(node) {
    checkGrammarStatementInAmbientContext(node);
    const type = checkTruthinessExpression(node.expression);
    checkTestingKnownTruthyCallableOrAwaitableType(node.expression, type, node.thenStatement);
    checkSourceElement(node.thenStatement);
    if (node.thenStatement.kind === 242 /* EmptyStatement */) {
      error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
    }
    checkSourceElement(node.elseStatement);
  }
  function checkTestingKnownTruthyCallableOrAwaitableType(condExpr, condType, body) {
    if (!strictNullChecks)
      return;
    bothHelper(condExpr, body);
    function bothHelper(condExpr2, body2) {
      condExpr2 = skipParentheses(condExpr2);
      helper(condExpr2, body2);
      while (isBinaryExpression(condExpr2) && (condExpr2.operatorToken.kind === 57 /* BarBarToken */ || condExpr2.operatorToken.kind === 61 /* QuestionQuestionToken */)) {
        condExpr2 = skipParentheses(condExpr2.left);
        helper(condExpr2, body2);
      }
    }
    function helper(condExpr2, body2) {
      const location = isLogicalOrCoalescingBinaryExpression(condExpr2) ? skipParentheses(condExpr2.right) : condExpr2;
      if (isModuleExportsAccessExpression(location)) {
        return;
      }
      if (isLogicalOrCoalescingBinaryExpression(location)) {
        bothHelper(location, body2);
        return;
      }
      const type = location === condExpr2 ? condType : checkTruthinessExpression(location);
      const isPropertyExpressionCast = isPropertyAccessExpression(location) && isTypeAssertion(location.expression);
      if (!hasTypeFacts(type, 4194304 /* Truthy */) || isPropertyExpressionCast)
        return;
      const callSignatures = getSignaturesOfType(type, 0 /* Call */);
      const isPromise = !!getAwaitedTypeOfPromise(type);
      if (callSignatures.length === 0 && !isPromise) {
        return;
      }
      const testedNode = isIdentifier(location) ? location : isPropertyAccessExpression(location) ? location.name : void 0;
      const testedSymbol = testedNode && getSymbolAtLocation(testedNode);
      if (!testedSymbol && !isPromise) {
        return;
      }
      const isUsed = testedSymbol && isBinaryExpression(condExpr2.parent) && isSymbolUsedInBinaryExpressionChain(condExpr2.parent, testedSymbol) || testedSymbol && body2 && isSymbolUsedInConditionBody(condExpr2, body2, testedNode, testedSymbol);
      if (!isUsed) {
        if (isPromise) {
          errorAndMaybeSuggestAwait(
            location,
            /*maybeMissingAwait*/
            true,
            Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined,
            getTypeNameForErrorDisplay(type)
          );
        } else {
          error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead);
        }
      }
    }
  }
  function isSymbolUsedInConditionBody(expr, body, testedNode, testedSymbol) {
    return !!forEachChild(body, function check(childNode) {
      if (isIdentifier(childNode)) {
        const childSymbol = getSymbolAtLocation(childNode);
        if (childSymbol && childSymbol === testedSymbol) {
          if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {
            return true;
          }
          let testedExpression = testedNode.parent;
          let childExpression = childNode.parent;
          while (testedExpression && childExpression) {
            if (isIdentifier(testedExpression) && isIdentifier(childExpression) || testedExpression.kind === 110 /* ThisKeyword */ && childExpression.kind === 110 /* ThisKeyword */) {
              return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
            } else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {
              if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {
                return false;
              }
              childExpression = childExpression.expression;
              testedExpression = testedExpression.expression;
            } else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {
              childExpression = childExpression.expression;
              testedExpression = testedExpression.expression;
            } else {
              return false;
            }
          }
        }
      }
      return forEachChild(childNode, check);
    });
  }
  function isSymbolUsedInBinaryExpressionChain(node, testedSymbol) {
    while (isBinaryExpression(node) && node.operatorToken.kind === 56 /* AmpersandAmpersandToken */) {
      const isUsed = forEachChild(node.right, function visit(child) {
        if (isIdentifier(child)) {
          const symbol = getSymbolAtLocation(child);
          if (symbol && symbol === testedSymbol) {
            return true;
          }
        }
        return forEachChild(child, visit);
      });
      if (isUsed) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }
  function checkDoStatement(node) {
    checkGrammarStatementInAmbientContext(node);
    checkSourceElement(node.statement);
    checkTruthinessExpression(node.expression);
  }
  function checkWhileStatement(node) {
    checkGrammarStatementInAmbientContext(node);
    checkTruthinessExpression(node.expression);
    checkSourceElement(node.statement);
  }
  function checkTruthinessOfType(type, node) {
    if (type.flags & 16384 /* Void */) {
      error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness);
    }
    return type;
  }
  function checkTruthinessExpression(node, checkMode) {
    return checkTruthinessOfType(checkExpression(node, checkMode), node);
  }
  function checkForStatement(node) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      if (node.initializer && node.initializer.kind === 261 /* VariableDeclarationList */) {
        checkGrammarVariableDeclarationList(node.initializer);
      }
    }
    if (node.initializer) {
      if (node.initializer.kind === 261 /* VariableDeclarationList */) {
        checkVariableDeclarationList(node.initializer);
      } else {
        checkExpression(node.initializer);
      }
    }
    if (node.condition)
      checkTruthinessExpression(node.condition);
    if (node.incrementor)
      checkExpression(node.incrementor);
    checkSourceElement(node.statement);
    if (node.locals) {
      registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkForOfStatement(node) {
    checkGrammarForInOrForOfStatement(node);
    const container = getContainingFunctionOrClassStaticBlock(node);
    if (node.awaitModifier) {
      if (container && isClassStaticBlockDeclaration(container)) {
        grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block);
      } else {
        const functionFlags = getFunctionFlags(container);
        if ((functionFlags & (4 /* Invalid */ | 2 /* Async */)) === 2 /* Async */ && languageVersion < 99 /* ESNext */) {
          checkExternalEmitHelpers(node, 16384 /* ForAwaitOfIncludes */);
        }
      }
    } else if (compilerOptions.downlevelIteration && languageVersion < 2 /* ES2015 */) {
      checkExternalEmitHelpers(node, 256 /* ForOfIncludes */);
    }
    if (node.initializer.kind === 261 /* VariableDeclarationList */) {
      checkVariableDeclarationList(node.initializer);
    } else {
      const varExpr = node.initializer;
      const iteratedType = checkRightHandSideOfForOf(node);
      if (varExpr.kind === 209 /* ArrayLiteralExpression */ || varExpr.kind === 210 /* ObjectLiteralExpression */) {
        checkDestructuringAssignment(varExpr, iteratedType || errorType);
      } else {
        const leftType = checkExpression(varExpr);
        checkReferenceExpression(
          varExpr,
          Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access,
          Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access
        );
        if (iteratedType) {
          checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
        }
      }
    }
    checkSourceElement(node.statement);
    if (node.locals) {
      registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkForInStatement(node) {
    checkGrammarForInOrForOfStatement(node);
    const rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));
    if (node.initializer.kind === 261 /* VariableDeclarationList */) {
      const variable = node.initializer.declarations[0];
      if (variable && isBindingPattern(variable.name)) {
        error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
      }
      checkVariableDeclarationList(node.initializer);
    } else {
      const varExpr = node.initializer;
      const leftType = checkExpression(varExpr);
      if (varExpr.kind === 209 /* ArrayLiteralExpression */ || varExpr.kind === 210 /* ObjectLiteralExpression */) {
        error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
      } else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
        error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
      } else {
        checkReferenceExpression(
          varExpr,
          Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access,
          Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access
        );
      }
    }
    if (rightType === neverType || !isTypeAssignableToKind(rightType, 67108864 /* NonPrimitive */ | 58982400 /* InstantiableNonPrimitive */)) {
      error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
    }
    checkSourceElement(node.statement);
    if (node.locals) {
      registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkRightHandSideOfForOf(statement) {
    const use = statement.awaitModifier ? 15 /* ForAwaitOf */ : 13 /* ForOf */;
    return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
  }
  function checkIteratedTypeOrElementType(use, inputType, sentType, errorNode) {
    if (isTypeAny(inputType)) {
      return inputType;
    }
    return getIteratedTypeOrElementType(
      use,
      inputType,
      sentType,
      errorNode,
      /*checkAssignability*/
      true
    ) || anyType;
  }
  function getIteratedTypeOrElementType(use, inputType, sentType, errorNode, checkAssignability) {
    const allowAsyncIterables = (use & 2 /* AllowsAsyncIterablesFlag */) !== 0;
    if (inputType === neverType) {
      reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables);
      return void 0;
    }
    const uplevelIteration = languageVersion >= 2 /* ES2015 */;
    const downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
    const possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & 128 /* PossiblyOutOfBounds */);
    if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
      const iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : void 0);
      if (checkAssignability) {
        if (iterationTypes) {
          const diagnostic = use & 8 /* ForOfFlag */ ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 : use & 32 /* SpreadFlag */ ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 : use & 64 /* DestructuringFlag */ ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 : use & 16 /* YieldStarFlag */ ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 : void 0;
          if (diagnostic) {
            checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
          }
        }
      }
      if (iterationTypes || uplevelIteration) {
        return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : iterationTypes && iterationTypes.yieldType;
      }
    }
    let arrayType = inputType;
    let reportedError = false;
    let hasStringConstituent = false;
    if (use & 4 /* AllowsStringInputFlag */) {
      if (arrayType.flags & 1048576 /* Union */) {
        const arrayTypes = inputType.types;
        const filteredTypes = filter(arrayTypes, (t) => !(t.flags & 402653316 /* StringLike */));
        if (filteredTypes !== arrayTypes) {
          arrayType = getUnionType(filteredTypes, 2 /* Subtype */);
        }
      } else if (arrayType.flags & 402653316 /* StringLike */) {
        arrayType = neverType;
      }
      hasStringConstituent = arrayType !== inputType;
      if (hasStringConstituent) {
        if (languageVersion < 1 /* ES5 */) {
          if (errorNode) {
            error(errorNode, Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
            reportedError = true;
          }
        }
        if (arrayType.flags & 131072 /* Never */) {
          return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
        }
      }
    }
    if (!isArrayLikeType(arrayType)) {
      if (errorNode && !reportedError) {
        const allowsStrings = !!(use & 4 /* AllowsStringInputFlag */) && !hasStringConstituent;
        const [defaultDiagnostic, maybeMissingAwait] = getIterationDiagnosticDetails(allowsStrings, downlevelIteration);
        errorAndMaybeSuggestAwait(
          errorNode,
          maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType),
          defaultDiagnostic,
          typeToString(arrayType)
        );
      }
      return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : void 0;
    }
    const arrayElementType = getIndexTypeOfType(arrayType, numberType);
    if (hasStringConstituent && arrayElementType) {
      if (arrayElementType.flags & 402653316 /* StringLike */ && !compilerOptions.noUncheckedIndexedAccess) {
        return stringType;
      }
      return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], 2 /* Subtype */);
    }
    return use & 128 /* PossiblyOutOfBounds */ ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType;
    function getIterationDiagnosticDetails(allowsStrings, downlevelIteration2) {
      var _a;
      if (downlevelIteration2) {
        return allowsStrings ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true] : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
      }
      const yieldType = getIterationTypeOfIterable(
        use,
        0 /* Yield */,
        inputType,
        /*errorNode*/
        void 0
      );
      if (yieldType) {
        return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false];
      }
      if (isES2015OrLaterIterable((_a = inputType.symbol) == null ? void 0 : _a.escapedName)) {
        return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true];
      }
      return allowsStrings ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true] : [Diagnostics.Type_0_is_not_an_array_type, true];
    }
  }
  function isES2015OrLaterIterable(n) {
    switch (n) {
      case "Float32Array":
      case "Float64Array":
      case "Int16Array":
      case "Int32Array":
      case "Int8Array":
      case "NodeList":
      case "Uint16Array":
      case "Uint32Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
        return true;
    }
    return false;
  }
  function getIterationTypeOfIterable(use, typeKind, inputType, errorNode) {
    if (isTypeAny(inputType)) {
      return void 0;
    }
    const iterationTypes = getIterationTypesOfIterable(inputType, use, errorNode);
    return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)];
  }
  function createIterationTypes(yieldType = neverType, returnType = neverType, nextType = unknownType) {
    if (yieldType.flags & 67359327 /* Intrinsic */ && returnType.flags & (1 /* Any */ | 131072 /* Never */ | 2 /* Unknown */ | 16384 /* Void */ | 32768 /* Undefined */) && nextType.flags & (1 /* Any */ | 131072 /* Never */ | 2 /* Unknown */ | 16384 /* Void */ | 32768 /* Undefined */)) {
      const id = getTypeListId([yieldType, returnType, nextType]);
      let iterationTypes = iterationTypesCache.get(id);
      if (!iterationTypes) {
        iterationTypes = { yieldType, returnType, nextType };
        iterationTypesCache.set(id, iterationTypes);
      }
      return iterationTypes;
    }
    return { yieldType, returnType, nextType };
  }
  function combineIterationTypes(array) {
    let yieldTypes;
    let returnTypes;
    let nextTypes;
    for (const iterationTypes of array) {
      if (iterationTypes === void 0 || iterationTypes === noIterationTypes) {
        continue;
      }
      if (iterationTypes === anyIterationTypes) {
        return anyIterationTypes;
      }
      yieldTypes = append(yieldTypes, iterationTypes.yieldType);
      returnTypes = append(returnTypes, iterationTypes.returnType);
      nextTypes = append(nextTypes, iterationTypes.nextType);
    }
    if (yieldTypes || returnTypes || nextTypes) {
      return createIterationTypes(
        yieldTypes && getUnionType(yieldTypes),
        returnTypes && getUnionType(returnTypes),
        nextTypes && getIntersectionType(nextTypes)
      );
    }
    return noIterationTypes;
  }
  function getCachedIterationTypes(type, cacheKey) {
    return type[cacheKey];
  }
  function setCachedIterationTypes(type, cacheKey, cachedTypes2) {
    return type[cacheKey] = cachedTypes2;
  }
  function getIterationTypesOfIterable(type, use, errorNode) {
    var _a, _b;
    if (isTypeAny(type)) {
      return anyIterationTypes;
    }
    if (!(type.flags & 1048576 /* Union */)) {
      const errorOutputContainer = errorNode ? { errors: void 0 } : void 0;
      const iterationTypes2 = getIterationTypesOfIterableWorker(type, use, errorNode, errorOutputContainer);
      if (iterationTypes2 === noIterationTypes) {
        if (errorNode) {
          const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & 2 /* AllowsAsyncIterablesFlag */));
          if (errorOutputContainer == null ? void 0 : errorOutputContainer.errors) {
            addRelatedInfo(rootDiag, ...errorOutputContainer.errors);
          }
        }
        return void 0;
      } else if ((_a = errorOutputContainer == null ? void 0 : errorOutputContainer.errors) == null ? void 0 : _a.length) {
        for (const diag2 of errorOutputContainer.errors) {
          diagnostics.add(diag2);
        }
      }
      return iterationTypes2;
    }
    const cacheKey = use & 2 /* AllowsAsyncIterablesFlag */ ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable";
    const cachedTypes2 = getCachedIterationTypes(type, cacheKey);
    if (cachedTypes2)
      return cachedTypes2 === noIterationTypes ? void 0 : cachedTypes2;
    let allIterationTypes;
    for (const constituent of type.types) {
      const errorOutputContainer = errorNode ? { errors: void 0 } : void 0;
      const iterationTypes2 = getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer);
      if (iterationTypes2 === noIterationTypes) {
        if (errorNode) {
          const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & 2 /* AllowsAsyncIterablesFlag */));
          if (errorOutputContainer == null ? void 0 : errorOutputContainer.errors) {
            addRelatedInfo(rootDiag, ...errorOutputContainer.errors);
          }
        }
        setCachedIterationTypes(type, cacheKey, noIterationTypes);
        return void 0;
      } else if ((_b = errorOutputContainer == null ? void 0 : errorOutputContainer.errors) == null ? void 0 : _b.length) {
        for (const diag2 of errorOutputContainer.errors) {
          diagnostics.add(diag2);
        }
      }
      allIterationTypes = append(allIterationTypes, iterationTypes2);
    }
    const iterationTypes = allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes;
    setCachedIterationTypes(type, cacheKey, iterationTypes);
    return iterationTypes === noIterationTypes ? void 0 : iterationTypes;
  }
  function getAsyncFromSyncIterationTypes(iterationTypes, errorNode) {
    if (iterationTypes === noIterationTypes)
      return noIterationTypes;
    if (iterationTypes === anyIterationTypes)
      return anyIterationTypes;
    const { yieldType, returnType, nextType } = iterationTypes;
    if (errorNode) {
      getGlobalAwaitedSymbol(
        /*reportErrors*/
        true
      );
    }
    return createIterationTypes(
      getAwaitedType(yieldType, errorNode) || anyType,
      getAwaitedType(returnType, errorNode) || anyType,
      nextType
    );
  }
  function getIterationTypesOfIterableWorker(type, use, errorNode, errorOutputContainer) {
    if (isTypeAny(type)) {
      return anyIterationTypes;
    }
    let noCache = false;
    if (use & 2 /* AllowsAsyncIterablesFlag */) {
      const iterationTypes = getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
      if (iterationTypes) {
        if (iterationTypes === noIterationTypes && errorNode) {
          noCache = true;
        } else {
          return use & 8 /* ForOfFlag */ ? getAsyncFromSyncIterationTypes(iterationTypes, errorNode) : iterationTypes;
        }
      }
    }
    if (use & 1 /* AllowsSyncIterablesFlag */) {
      let iterationTypes = getIterationTypesOfIterableCached(type, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
      if (iterationTypes) {
        if (iterationTypes === noIterationTypes && errorNode) {
          noCache = true;
        } else {
          if (use & 2 /* AllowsAsyncIterablesFlag */) {
            if (iterationTypes !== noIterationTypes) {
              iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode);
              return noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes);
            }
          } else {
            return iterationTypes;
          }
        }
      }
    }
    if (use & 2 /* AllowsAsyncIterablesFlag */) {
      const iterationTypes = getIterationTypesOfIterableSlow(type, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache);
      if (iterationTypes !== noIterationTypes) {
        return iterationTypes;
      }
    }
    if (use & 1 /* AllowsSyncIterablesFlag */) {
      let iterationTypes = getIterationTypesOfIterableSlow(type, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache);
      if (iterationTypes !== noIterationTypes) {
        if (use & 2 /* AllowsAsyncIterablesFlag */) {
          iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode);
          return noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes);
        } else {
          return iterationTypes;
        }
      }
    }
    return noIterationTypes;
  }
  function getIterationTypesOfIterableCached(type, resolver) {
    return getCachedIterationTypes(type, resolver.iterableCacheKey);
  }
  function getIterationTypesOfGlobalIterableType(globalType, resolver) {
    const globalIterationTypes = getIterationTypesOfIterableCached(globalType, resolver) || getIterationTypesOfIterableSlow(
      globalType,
      resolver,
      /*errorNode*/
      void 0,
      /*errorOutputContainer*/
      void 0,
      /*noCache*/
      false
    );
    return globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
  }
  function getIterationTypesOfIterableFast(type, resolver) {
    let globalType;
    if (isReferenceToType(type, globalType = resolver.getGlobalIterableType(
      /*reportErrors*/
      false
    )) || isReferenceToType(type, globalType = resolver.getGlobalIterableIteratorType(
      /*reportErrors*/
      false
    ))) {
      const [yieldType] = getTypeArguments(type);
      const { returnType, nextType } = getIterationTypesOfGlobalIterableType(globalType, resolver);
      return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(
        yieldType,
        /*errorNode*/
        void 0
      ) || yieldType, resolver.resolveIterationType(
        returnType,
        /*errorNode*/
        void 0
      ) || returnType, nextType));
    }
    if (isReferenceToType(type, resolver.getGlobalGeneratorType(
      /*reportErrors*/
      false
    ))) {
      const [yieldType, returnType, nextType] = getTypeArguments(type);
      return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(
        yieldType,
        /*errorNode*/
        void 0
      ) || yieldType, resolver.resolveIterationType(
        returnType,
        /*errorNode*/
        void 0
      ) || returnType, nextType));
    }
  }
  function getPropertyNameForKnownSymbolName(symbolName2) {
    const ctorType = getGlobalESSymbolConstructorSymbol(
      /*reportErrors*/
      false
    );
    const uniqueType = ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName2));
    return uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName2}`;
  }
  function getIterationTypesOfIterableSlow(type, resolver, errorNode, errorOutputContainer, noCache) {
    const method = getPropertyOfType(type, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName));
    const methodType = method && !(method.flags & 16777216 /* Optional */) ? getTypeOfSymbol(method) : void 0;
    if (isTypeAny(methodType)) {
      return noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes);
    }
    const signatures = methodType ? getSignaturesOfType(methodType, 0 /* Call */) : void 0;
    if (!some(signatures)) {
      return noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes);
    }
    const iteratorType = getIntersectionType(map(signatures, getReturnTypeOfSignature));
    const iterationTypes = getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes;
    return noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes);
  }
  function reportTypeNotIterableError(errorNode, type, allowAsyncIterables) {
    const message = allowAsyncIterables ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
    const suggestAwait = (
      // for (const x of Promise<...>) or [...Promise<...>]
      !!getAwaitedTypeOfPromise(type) || !allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression === errorNode && getGlobalAsyncIterableType(
        /*reportErrors*/
        false
      ) !== emptyGenericType && isTypeAssignableTo(type, getGlobalAsyncIterableType(
        /*reportErrors*/
        false
      ))
    );
    return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type));
  }
  function getIterationTypesOfIterator(type, resolver, errorNode, errorOutputContainer) {
    return getIterationTypesOfIteratorWorker(
      type,
      resolver,
      errorNode,
      errorOutputContainer,
      /*noCache*/
      false
    );
  }
  function getIterationTypesOfIteratorWorker(type, resolver, errorNode, errorOutputContainer, noCache) {
    if (isTypeAny(type)) {
      return anyIterationTypes;
    }
    let iterationTypes = getIterationTypesOfIteratorCached(type, resolver) || getIterationTypesOfIteratorFast(type, resolver);
    if (iterationTypes === noIterationTypes && errorNode) {
      iterationTypes = void 0;
      noCache = true;
    }
    iterationTypes ?? (iterationTypes = getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache));
    return iterationTypes === noIterationTypes ? void 0 : iterationTypes;
  }
  function getIterationTypesOfIteratorCached(type, resolver) {
    return getCachedIterationTypes(type, resolver.iteratorCacheKey);
  }
  function getIterationTypesOfIteratorFast(type, resolver) {
    const globalType = resolver.getGlobalIterableIteratorType(
      /*reportErrors*/
      false
    );
    if (isReferenceToType(type, globalType)) {
      const [yieldType] = getTypeArguments(type);
      const globalIterationTypes = getIterationTypesOfIteratorCached(globalType, resolver) || getIterationTypesOfIteratorSlow(
        globalType,
        resolver,
        /*errorNode*/
        void 0,
        /*errorOutputContainer*/
        void 0,
        /*noCache*/
        false
      );
      const { returnType, nextType } = globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
      return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
    }
    if (isReferenceToType(type, resolver.getGlobalIteratorType(
      /*reportErrors*/
      false
    )) || isReferenceToType(type, resolver.getGlobalGeneratorType(
      /*reportErrors*/
      false
    ))) {
      const [yieldType, returnType, nextType] = getTypeArguments(type);
      return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
    }
  }
  function isIteratorResult(type, kind) {
    const doneType = getTypeOfPropertyOfType(type, "done") || falseType;
    return isTypeAssignableTo(kind === 0 /* Yield */ ? falseType : trueType, doneType);
  }
  function isYieldIteratorResult(type) {
    return isIteratorResult(type, 0 /* Yield */);
  }
  function isReturnIteratorResult(type) {
    return isIteratorResult(type, 1 /* Return */);
  }
  function getIterationTypesOfIteratorResult(type) {
    if (isTypeAny(type)) {
      return anyIterationTypes;
    }
    const cachedTypes2 = getCachedIterationTypes(type, "iterationTypesOfIteratorResult");
    if (cachedTypes2) {
      return cachedTypes2;
    }
    if (isReferenceToType(type, getGlobalIteratorYieldResultType(
      /*reportErrors*/
      false
    ))) {
      const yieldType2 = getTypeArguments(type)[0];
      return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(
        yieldType2,
        /*returnType*/
        void 0,
        /*nextType*/
        void 0
      ));
    }
    if (isReferenceToType(type, getGlobalIteratorReturnResultType(
      /*reportErrors*/
      false
    ))) {
      const returnType2 = getTypeArguments(type)[0];
      return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(
        /*yieldType*/
        void 0,
        returnType2,
        /*nextType*/
        void 0
      ));
    }
    const yieldIteratorResult = filterType(type, isYieldIteratorResult);
    const yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value") : void 0;
    const returnIteratorResult = filterType(type, isReturnIteratorResult);
    const returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value") : void 0;
    if (!yieldType && !returnType) {
      return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", noIterationTypes);
    }
    return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(
      yieldType,
      returnType || voidType,
      /*nextType*/
      void 0
    ));
  }
  function getIterationTypesOfMethod(type, resolver, methodName, errorNode, errorOutputContainer) {
    var _a, _b, _c, _d;
    const method = getPropertyOfType(type, methodName);
    if (!method && methodName !== "next") {
      return void 0;
    }
    const methodType = method && !(methodName === "next" && method.flags & 16777216 /* Optional */) ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), 2097152 /* NEUndefinedOrNull */) : void 0;
    if (isTypeAny(methodType)) {
      return methodName === "next" ? anyIterationTypes : anyIterationTypesExceptNext;
    }
    const methodSignatures = methodType ? getSignaturesOfType(methodType, 0 /* Call */) : emptyArray;
    if (methodSignatures.length === 0) {
      if (errorNode) {
        const diagnostic = methodName === "next" ? resolver.mustHaveANextMethodDiagnostic : resolver.mustBeAMethodDiagnostic;
        if (errorOutputContainer) {
          errorOutputContainer.errors ?? (errorOutputContainer.errors = []);
          errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName));
        } else {
          error(errorNode, diagnostic, methodName);
        }
      }
      return methodName === "next" ? noIterationTypes : void 0;
    }
    if ((methodType == null ? void 0 : methodType.symbol) && methodSignatures.length === 1) {
      const globalGeneratorType = resolver.getGlobalGeneratorType(
        /*reportErrors*/
        false
      );
      const globalIteratorType = resolver.getGlobalIteratorType(
        /*reportErrors*/
        false
      );
      const isGeneratorMethod = ((_b = (_a = globalGeneratorType.symbol) == null ? void 0 : _a.members) == null ? void 0 : _b.get(methodName)) === methodType.symbol;
      const isIteratorMethod = !isGeneratorMethod && ((_d = (_c = globalIteratorType.symbol) == null ? void 0 : _c.members) == null ? void 0 : _d.get(methodName)) === methodType.symbol;
      if (isGeneratorMethod || isIteratorMethod) {
        const globalType = isGeneratorMethod ? globalGeneratorType : globalIteratorType;
        const { mapper } = methodType;
        return createIterationTypes(
          getMappedType(globalType.typeParameters[0], mapper),
          getMappedType(globalType.typeParameters[1], mapper),
          methodName === "next" ? getMappedType(globalType.typeParameters[2], mapper) : void 0
        );
      }
    }
    let methodParameterTypes;
    let methodReturnTypes;
    for (const signature of methodSignatures) {
      if (methodName !== "throw" && some(signature.parameters)) {
        methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0));
      }
      methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature));
    }
    let returnTypes;
    let nextType;
    if (methodName !== "throw") {
      const methodParameterType = methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType;
      if (methodName === "next") {
        nextType = methodParameterType;
      } else if (methodName === "return") {
        const resolvedMethodParameterType = resolver.resolveIterationType(methodParameterType, errorNode) || anyType;
        returnTypes = append(returnTypes, resolvedMethodParameterType);
      }
    }
    let yieldType;
    const methodReturnType = methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType;
    const resolvedMethodReturnType = resolver.resolveIterationType(methodReturnType, errorNode) || anyType;
    const iterationTypes = getIterationTypesOfIteratorResult(resolvedMethodReturnType);
    if (iterationTypes === noIterationTypes) {
      if (errorNode) {
        if (errorOutputContainer) {
          errorOutputContainer.errors ?? (errorOutputContainer.errors = []);
          errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName));
        } else {
          error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
        }
      }
      yieldType = anyType;
      returnTypes = append(returnTypes, anyType);
    } else {
      yieldType = iterationTypes.yieldType;
      returnTypes = append(returnTypes, iterationTypes.returnType);
    }
    return createIterationTypes(yieldType, getUnionType(returnTypes), nextType);
  }
  function getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache) {
    const iterationTypes = combineIterationTypes([
      getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer),
      getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer),
      getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer)
    ]);
    return noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes);
  }
  function getIterationTypeOfGeneratorFunctionReturnType(kind, returnType, isAsyncGenerator) {
    if (isTypeAny(returnType)) {
      return void 0;
    }
    const iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator);
    return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)];
  }
  function getIterationTypesOfGeneratorFunctionReturnType(type, isAsyncGenerator) {
    if (isTypeAny(type)) {
      return anyIterationTypes;
    }
    const use = isAsyncGenerator ? 2 /* AsyncGeneratorReturnType */ : 1 /* GeneratorReturnType */;
    const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
    return getIterationTypesOfIterable(
      type,
      use,
      /*errorNode*/
      void 0
    ) || getIterationTypesOfIterator(
      type,
      resolver,
      /*errorNode*/
      void 0,
      /*errorOutputContainer*/
      void 0
    );
  }
  function checkBreakOrContinueStatement(node) {
    if (!checkGrammarStatementInAmbientContext(node))
      checkGrammarBreakOrContinueStatement(node);
  }
  function unwrapReturnType(returnType, functionFlags) {
    const isGenerator = !!(functionFlags & 1 /* Generator */);
    const isAsync = !!(functionFlags & 2 /* Async */);
    if (isGenerator) {
      const returnIterationType = getIterationTypeOfGeneratorFunctionReturnType(1 /* Return */, returnType, isAsync);
      if (!returnIterationType) {
        return errorType;
      }
      return isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType;
    }
    return isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType;
  }
  function isUnwrappedReturnTypeUndefinedVoidOrAny(func, returnType) {
    const type = unwrapReturnType(returnType, getFunctionFlags(func));
    return !!(type && (maybeTypeOfKind(type, 16384 /* Void */) || type.flags & (1 /* Any */ | 32768 /* Undefined */)));
  }
  function checkReturnStatement(node) {
    if (checkGrammarStatementInAmbientContext(node)) {
      return;
    }
    const container = getContainingFunctionOrClassStaticBlock(node);
    if (container && isClassStaticBlockDeclaration(container)) {
      grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block);
      return;
    }
    if (!container) {
      grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
      return;
    }
    const signature = getSignatureFromDeclaration(container);
    const returnType = getReturnTypeOfSignature(signature);
    const functionFlags = getFunctionFlags(container);
    if (strictNullChecks || node.expression || returnType.flags & 131072 /* Never */) {
      const exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
      if (container.kind === 178 /* SetAccessor */) {
        if (node.expression) {
          error(node, Diagnostics.Setters_cannot_return_a_value);
        }
      } else if (container.kind === 176 /* Constructor */) {
        if (node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression)) {
          error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
        }
      } else if (getReturnTypeFromAnnotation(container)) {
        const unwrappedReturnType = unwrapReturnType(returnType, functionFlags) ?? returnType;
        const unwrappedExprType = functionFlags & 2 /* Async */ ? checkAwaitedType(
          exprType,
          /*withAlias*/
          false,
          node,
          Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
        ) : exprType;
        if (unwrappedReturnType) {
          checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression);
        }
      }
    } else if (container.kind !== 176 /* Constructor */ && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType)) {
      error(node, Diagnostics.Not_all_code_paths_return_a_value);
    }
  }
  function checkWithStatement(node) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      if (node.flags & 65536 /* AwaitContext */) {
        grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
      }
    }
    checkExpression(node.expression);
    const sourceFile = getSourceFileOfNode(node);
    if (!hasParseDiagnostics(sourceFile)) {
      const start = getSpanOfTokenAtPosition(sourceFile, node.pos).start;
      const end = node.statement.pos;
      grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
    }
  }
  function checkSwitchStatement(node) {
    checkGrammarStatementInAmbientContext(node);
    let firstDefaultClause;
    let hasDuplicateDefaultClause = false;
    const expressionType = checkExpression(node.expression);
    forEach(node.caseBlock.clauses, (clause) => {
      if (clause.kind === 297 /* DefaultClause */ && !hasDuplicateDefaultClause) {
        if (firstDefaultClause === void 0) {
          firstDefaultClause = clause;
        } else {
          grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
          hasDuplicateDefaultClause = true;
        }
      }
      if (clause.kind === 296 /* CaseClause */) {
        addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));
      }
      forEach(clause.statements, checkSourceElement);
      if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {
        error(clause, Diagnostics.Fallthrough_case_in_switch);
      }
      function createLazyCaseClauseDiagnostics(clause2) {
        return () => {
          const caseType = checkExpression(clause2.expression);
          if (!isTypeEqualityComparableTo(expressionType, caseType)) {
            checkTypeComparableTo(
              caseType,
              expressionType,
              clause2.expression,
              /*headMessage*/
              void 0
            );
          }
        };
      }
    });
    if (node.caseBlock.locals) {
      registerForUnusedIdentifiersCheck(node.caseBlock);
    }
  }
  function checkLabeledStatement(node) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      findAncestor(node.parent, (current) => {
        if (isFunctionLike(current)) {
          return "quit";
        }
        if (current.kind === 256 /* LabeledStatement */ && current.label.escapedText === node.label.escapedText) {
          grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label));
          return true;
        }
        return false;
      });
    }
    checkSourceElement(node.statement);
  }
  function checkThrowStatement(node) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      if (isIdentifier(node.expression) && !node.expression.escapedText) {
        grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here);
      }
    }
    if (node.expression) {
      checkExpression(node.expression);
    }
  }
  function checkTryStatement(node) {
    checkGrammarStatementInAmbientContext(node);
    checkBlock(node.tryBlock);
    const catchClause = node.catchClause;
    if (catchClause) {
      if (catchClause.variableDeclaration) {
        const declaration = catchClause.variableDeclaration;
        checkVariableLikeDeclaration(declaration);
        const typeNode = getEffectiveTypeAnnotationNode(declaration);
        if (typeNode) {
          const type = getTypeFromTypeNode(typeNode);
          if (type && !(type.flags & 3 /* AnyOrUnknown */)) {
            grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified);
          }
        } else if (declaration.initializer) {
          grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
        } else {
          const blockLocals = catchClause.block.locals;
          if (blockLocals) {
            forEachKey(catchClause.locals, (caughtName) => {
              const blockLocal = blockLocals.get(caughtName);
              if ((blockLocal == null ? void 0 : blockLocal.valueDeclaration) && (blockLocal.flags & 2 /* BlockScopedVariable */) !== 0) {
                grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName));
              }
            });
          }
        }
      }
      checkBlock(catchClause.block);
    }
    if (node.finallyBlock) {
      checkBlock(node.finallyBlock);
    }
  }
  function checkIndexConstraints(type, symbol, isStaticIndex) {
    const indexInfos = getIndexInfosOfType(type);
    if (indexInfos.length === 0) {
      return;
    }
    for (const prop of getPropertiesOfObjectType(type)) {
      if (!(isStaticIndex && prop.flags & 4194304 /* Prototype */)) {
        checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(
          prop,
          8576 /* StringOrNumberLiteralOrUnique */,
          /*includeNonPublic*/
          true
        ), getNonMissingTypeOfSymbol(prop));
      }
    }
    const typeDeclaration = symbol.valueDeclaration;
    if (typeDeclaration && isClassLike(typeDeclaration)) {
      for (const member of typeDeclaration.members) {
        if (!isStatic(member) && !hasBindableName(member)) {
          const symbol2 = getSymbolOfDeclaration(member);
          checkIndexConstraintForProperty(type, symbol2, getTypeOfExpression(member.name.expression), getNonMissingTypeOfSymbol(symbol2));
        }
      }
    }
    if (indexInfos.length > 1) {
      for (const info of indexInfos) {
        checkIndexConstraintForIndexSignature(type, info);
      }
    }
  }
  function checkIndexConstraintForProperty(type, prop, propNameType, propType) {
    const declaration = prop.valueDeclaration;
    const name = getNameOfDeclaration(declaration);
    if (name && isPrivateIdentifier(name)) {
      return;
    }
    const indexInfos = getApplicableIndexInfos(type, propNameType);
    const interfaceDeclaration = getObjectFlags(type) & 2 /* Interface */ ? getDeclarationOfKind(type.symbol, 264 /* InterfaceDeclaration */) : void 0;
    const propDeclaration = declaration && declaration.kind === 226 /* BinaryExpression */ || name && name.kind === 167 /* ComputedPropertyName */ ? declaration : void 0;
    const localPropDeclaration = getParentOfSymbol(prop) === type.symbol ? declaration : void 0;
    for (const info of indexInfos) {
      const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : void 0;
      const errorNode = localPropDeclaration || localIndexDeclaration || (interfaceDeclaration && !some(getBaseTypes(type), (base) => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : void 0);
      if (errorNode && !isTypeAssignableTo(propType, info.type)) {
        const diagnostic = createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));
        if (propDeclaration && errorNode !== propDeclaration) {
          addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)));
        }
        diagnostics.add(diagnostic);
      }
    }
  }
  function checkIndexConstraintForIndexSignature(type, checkInfo) {
    const declaration = checkInfo.declaration;
    const indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
    const interfaceDeclaration = getObjectFlags(type) & 2 /* Interface */ ? getDeclarationOfKind(type.symbol, 264 /* InterfaceDeclaration */) : void 0;
    const localCheckDeclaration = declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : void 0;
    for (const info of indexInfos) {
      if (info === checkInfo)
        continue;
      const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : void 0;
      const errorNode = localCheckDeclaration || localIndexDeclaration || (interfaceDeclaration && !some(getBaseTypes(type), (base) => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : void 0);
      if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
        error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));
      }
    }
  }
  function checkTypeNameIsReserved(name, message) {
    switch (name.escapedText) {
      case "any":
      case "unknown":
      case "never":
      case "number":
      case "bigint":
      case "boolean":
      case "string":
      case "symbol":
      case "void":
      case "object":
        error(name, message, name.escapedText);
    }
  }
  function checkClassNameCollisionWithObject(name) {
    if (languageVersion >= 1 /* ES5 */ && name.escapedText === "Object" && (moduleKind < 5 /* ES2015 */ || getSourceFileOfNode(name).impliedNodeFormat === 1 /* CommonJS */)) {
      error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[moduleKind]);
    }
  }
  function checkUnmatchedJSDocParameters(node) {
    const jsdocParameters = filter(getJSDocTags(node), isJSDocParameterTag);
    if (!length(jsdocParameters))
      return;
    const isJs = isInJSFile(node);
    const parameters = /* @__PURE__ */ new Set();
    const excludedParameters = /* @__PURE__ */ new Set();
    forEach(node.parameters, ({ name }, index) => {
      if (isIdentifier(name)) {
        parameters.add(name.escapedText);
      }
      if (isBindingPattern(name)) {
        excludedParameters.add(index);
      }
    });
    const containsArguments = containsArgumentsReference(node);
    if (containsArguments) {
      const lastJSDocParamIndex = jsdocParameters.length - 1;
      const lastJSDocParam = jsdocParameters[lastJSDocParamIndex];
      if (isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type))) {
        error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name));
      }
    } else {
      forEach(jsdocParameters, ({ name, isNameFirst }, index) => {
        if (excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText)) {
          return;
        }
        if (isQualifiedName(name)) {
          if (isJs) {
            error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left));
          }
        } else {
          if (!isNameFirst) {
            errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name));
          }
        }
      });
    }
  }
  function checkTypeParameters(typeParameterDeclarations) {
    let seenDefault = false;
    if (typeParameterDeclarations) {
      for (let i = 0; i < typeParameterDeclarations.length; i++) {
        const node = typeParameterDeclarations[i];
        checkTypeParameter(node);
        addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));
      }
    }
    function createCheckTypeParameterDiagnostic(node, i) {
      return () => {
        if (node.default) {
          seenDefault = true;
          checkTypeParametersNotReferenced(node.default, typeParameterDeclarations, i);
        } else if (seenDefault) {
          error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
        }
        for (let j = 0; j < i; j++) {
          if (typeParameterDeclarations[j].symbol === node.symbol) {
            error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));
          }
        }
      };
    }
  }
  function checkTypeParametersNotReferenced(root, typeParameters, index) {
    visit(root);
    function visit(node) {
      if (node.kind === 183 /* TypeReference */) {
        const type = getTypeFromTypeReference(node);
        if (type.flags & 262144 /* TypeParameter */) {
          for (let i = index; i < typeParameters.length; i++) {
            if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {
              error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
            }
          }
        }
      }
      forEachChild(node, visit);
    }
  }
  function checkTypeParameterListsIdentical(symbol) {
    if (symbol.declarations && symbol.declarations.length === 1) {
      return;
    }
    const links = getSymbolLinks(symbol);
    if (!links.typeParametersChecked) {
      links.typeParametersChecked = true;
      const declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
      if (!declarations || declarations.length <= 1) {
        return;
      }
      const type = getDeclaredTypeOfSymbol(symbol);
      if (!areTypeParametersIdentical(declarations, type.localTypeParameters, getEffectiveTypeParameterDeclarations)) {
        const name = symbolToString(symbol);
        for (const declaration of declarations) {
          error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
        }
      }
    }
  }
  function areTypeParametersIdentical(declarations, targetParameters, getTypeParameterDeclarations) {
    const maxTypeArgumentCount = length(targetParameters);
    const minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);
    for (const declaration of declarations) {
      const sourceParameters = getTypeParameterDeclarations(declaration);
      const numTypeParameters = sourceParameters.length;
      if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
        return false;
      }
      for (let i = 0; i < numTypeParameters; i++) {
        const source = sourceParameters[i];
        const target = targetParameters[i];
        if (source.name.escapedText !== target.symbol.escapedName) {
          return false;
        }
        const constraint = getEffectiveConstraintOfTypeParameter(source);
        const sourceConstraint = constraint && getTypeFromTypeNode(constraint);
        const targetConstraint = getConstraintOfTypeParameter(target);
        if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {
          return false;
        }
        const sourceDefault = source.default && getTypeFromTypeNode(source.default);
        const targetDefault = getDefaultFromTypeParameter(target);
        if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
          return false;
        }
      }
    }
    return true;
  }
  function getFirstTransformableStaticClassElement(node) {
    const willTransformStaticElementsOfDecoratedClass = !legacyDecorators && languageVersion < 99 /* ESNext */ && classOrConstructorParameterIsDecorated(
      /*useLegacyDecorators*/
      false,
      node
    );
    const willTransformPrivateElementsOrClassStaticBlocks = languageVersion <= 9 /* ES2022 */;
    const willTransformInitializers = !emitStandardClassFields;
    if (willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks) {
      for (const member of node.members) {
        if (willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(
          /*useLegacyDecorators*/
          false,
          member,
          node
        )) {
          return firstOrUndefined(getDecorators(node)) ?? node;
        } else if (willTransformPrivateElementsOrClassStaticBlocks) {
          if (isClassStaticBlockDeclaration(member)) {
            return member;
          } else if (isStatic(member)) {
            if (isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member)) {
              return member;
            }
          }
        }
      }
    }
  }
  function checkClassExpressionExternalHelpers(node) {
    if (node.name)
      return;
    const parent = walkUpOuterExpressions(node);
    if (!isNamedEvaluationSource(parent))
      return;
    const willTransformESDecorators = !legacyDecorators && languageVersion < 99 /* ESNext */;
    let location;
    if (willTransformESDecorators && classOrConstructorParameterIsDecorated(
      /*useLegacyDecorators*/
      false,
      node
    )) {
      location = firstOrUndefined(getDecorators(node)) ?? node;
    } else {
      location = getFirstTransformableStaticClassElement(node);
    }
    if (location) {
      checkExternalEmitHelpers(location, 8388608 /* SetFunctionName */);
      if ((isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name)) {
        checkExternalEmitHelpers(location, 16777216 /* PropKey */);
      }
    }
  }
  function checkClassExpression(node) {
    checkClassLikeDeclaration(node);
    checkNodeDeferred(node);
    checkClassExpressionExternalHelpers(node);
    return getTypeOfSymbol(getSymbolOfDeclaration(node));
  }
  function checkClassExpressionDeferred(node) {
    forEach(node.members, checkSourceElement);
    registerForUnusedIdentifiersCheck(node);
  }
  function checkClassDeclaration(node) {
    const firstDecorator = find(node.modifiers, isDecorator);
    if (legacyDecorators && firstDecorator && some(node.members, (p) => hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p))) {
      grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator);
    }
    if (!node.name && !hasSyntacticModifier(node, 2048 /* Default */)) {
      grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
    }
    checkClassLikeDeclaration(node);
    forEach(node.members, checkSourceElement);
    registerForUnusedIdentifiersCheck(node);
  }
  function checkClassLikeDeclaration(node) {
    checkGrammarClassLikeDeclaration(node);
    checkDecorators(node);
    checkCollisionsForDeclarationName(node, node.name);
    checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
    checkExportsOnMergedDeclarations(node);
    const symbol = getSymbolOfDeclaration(node);
    const type = getDeclaredTypeOfSymbol(symbol);
    const typeWithThis = getTypeWithThisArgument(type);
    const staticType = getTypeOfSymbol(symbol);
    checkTypeParameterListsIdentical(symbol);
    checkFunctionOrConstructorSymbol(symbol);
    checkClassForDuplicateDeclarations(node);
    const nodeInAmbientContext = !!(node.flags & 33554432 /* Ambient */);
    if (!nodeInAmbientContext) {
      checkClassForStaticPropertyNameConflicts(node);
    }
    const baseTypeNode = getEffectiveBaseTypeNode(node);
    if (baseTypeNode) {
      forEach(baseTypeNode.typeArguments, checkSourceElement);
      if (languageVersion < 2 /* ES2015 */) {
        checkExternalEmitHelpers(baseTypeNode.parent, 1 /* Extends */);
      }
      const extendsNode = getClassExtendsHeritageElement(node);
      if (extendsNode && extendsNode !== baseTypeNode) {
        checkExpression(extendsNode.expression);
      }
      const baseTypes = getBaseTypes(type);
      if (baseTypes.length) {
        addLazyDiagnostic(() => {
          const baseType = baseTypes[0];
          const baseConstructorType = getBaseConstructorTypeOfClass(type);
          const staticBaseType = getApparentType(baseConstructorType);
          checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
          checkSourceElement(baseTypeNode.expression);
          if (some(baseTypeNode.typeArguments)) {
            forEach(baseTypeNode.typeArguments, checkSourceElement);
            for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {
              if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters)) {
                break;
              }
            }
          }
          const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);
          if (!checkTypeAssignableTo(
            typeWithThis,
            baseWithThis,
            /*errorNode*/
            void 0
          )) {
            issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1);
          } else {
            checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
          }
          if (baseConstructorType.flags & 8650752 /* TypeVariable */) {
            if (!isMixinConstructorType(staticType)) {
              error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
            } else {
              const constructSignatures = getSignaturesOfType(baseConstructorType, 1 /* Construct */);
              if (constructSignatures.some((signature) => signature.flags & 4 /* Abstract */) && !hasSyntacticModifier(node, 64 /* Abstract */)) {
                error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);
              }
            }
          }
          if (!(staticBaseType.symbol && staticBaseType.symbol.flags & 32 /* Class */) && !(baseConstructorType.flags & 8650752 /* TypeVariable */)) {
            const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
            if (forEach(constructors, (sig) => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType))) {
              error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);
            }
          }
          checkKindsOfPropertyMemberOverrides(type, baseType);
        });
      }
    }
    checkMembersForOverrideModifier(node, type, typeWithThis, staticType);
    const implementedTypeNodes = getEffectiveImplementsTypeNodes(node);
    if (implementedTypeNodes) {
      for (const typeRefNode of implementedTypeNodes) {
        if (!isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression)) {
          error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
        }
        checkTypeReferenceNode(typeRefNode);
        addLazyDiagnostic(createImplementsDiagnostics(typeRefNode));
      }
    }
    addLazyDiagnostic(() => {
      checkIndexConstraints(type, symbol);
      checkIndexConstraints(
        staticType,
        symbol,
        /*isStaticIndex*/
        true
      );
      checkTypeForDuplicateIndexSignatures(node);
      checkPropertyInitialization(node);
    });
    function createImplementsDiagnostics(typeRefNode) {
      return () => {
        const t = getReducedType(getTypeFromTypeNode(typeRefNode));
        if (!isErrorType(t)) {
          if (isValidBaseType(t)) {
            const genericDiag = t.symbol && t.symbol.flags & 32 /* Class */ ? Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass : Diagnostics.Class_0_incorrectly_implements_interface_1;
            const baseWithThis = getTypeWithThisArgument(t, type.thisType);
            if (!checkTypeAssignableTo(
              typeWithThis,
              baseWithThis,
              /*errorNode*/
              void 0
            )) {
              issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
            }
          } else {
            error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
          }
        }
      };
    }
  }
  function checkMembersForOverrideModifier(node, type, typeWithThis, staticType) {
    const baseTypeNode = getEffectiveBaseTypeNode(node);
    const baseTypes = baseTypeNode && getBaseTypes(type);
    const baseWithThis = (baseTypes == null ? void 0 : baseTypes.length) ? getTypeWithThisArgument(first(baseTypes), type.thisType) : void 0;
    const baseStaticType = getBaseConstructorTypeOfClass(type);
    for (const member of node.members) {
      if (hasAmbientModifier(member)) {
        continue;
      }
      if (isConstructorDeclaration(member)) {
        forEach(member.parameters, (param) => {
          if (isParameterPropertyDeclaration(param, member)) {
            checkExistingMemberForOverrideModifier(
              node,
              staticType,
              baseStaticType,
              baseWithThis,
              type,
              typeWithThis,
              param,
              /*memberIsParameterProperty*/
              true
            );
          }
        });
      }
      checkExistingMemberForOverrideModifier(
        node,
        staticType,
        baseStaticType,
        baseWithThis,
        type,
        typeWithThis,
        member,
        /*memberIsParameterProperty*/
        false
      );
    }
  }
  function checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, member, memberIsParameterProperty, reportErrors2 = true) {
    const declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
    if (!declaredProp) {
      return 0 /* Ok */;
    }
    return checkMemberForOverrideModifier(
      node,
      staticType,
      baseStaticType,
      baseWithThis,
      type,
      typeWithThis,
      hasOverrideModifier(member),
      hasAbstractModifier(member),
      isStatic(member),
      memberIsParameterProperty,
      symbolName(declaredProp),
      reportErrors2 ? member : void 0
    );
  }
  function checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, memberHasOverrideModifier, memberHasAbstractModifier, memberIsStatic, memberIsParameterProperty, memberName, errorNode) {
    const isJs = isInJSFile(node);
    const nodeInAmbientContext = !!(node.flags & 33554432 /* Ambient */);
    if (baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride)) {
      const memberEscapedName = escapeLeadingUnderscores(memberName);
      const thisType = memberIsStatic ? staticType : typeWithThis;
      const baseType = memberIsStatic ? baseStaticType : baseWithThis;
      const prop = getPropertyOfType(thisType, memberEscapedName);
      const baseProp = getPropertyOfType(baseType, memberEscapedName);
      const baseClassName = typeToString(baseWithThis);
      if (prop && !baseProp && memberHasOverrideModifier) {
        if (errorNode) {
          const suggestion = getSuggestedSymbolForNonexistentClassMember(memberName, baseType);
          suggestion ? error(
            errorNode,
            isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,
            baseClassName,
            symbolToString(suggestion)
          ) : error(
            errorNode,
            isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,
            baseClassName
          );
        }
        return 2 /* HasInvalidOverride */;
      } else if (prop && (baseProp == null ? void 0 : baseProp.declarations) && compilerOptions.noImplicitOverride && !nodeInAmbientContext) {
        const baseHasAbstract = some(baseProp.declarations, hasAbstractModifier);
        if (memberHasOverrideModifier) {
          return 0 /* Ok */;
        }
        if (!baseHasAbstract) {
          if (errorNode) {
            const diag2 = memberIsParameterProperty ? isJs ? Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 : isJs ? Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0;
            error(errorNode, diag2, baseClassName);
          }
          return 1 /* NeedsOverride */;
        } else if (memberHasAbstractModifier && baseHasAbstract) {
          if (errorNode) {
            error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName);
          }
          return 1 /* NeedsOverride */;
        }
      }
    } else if (memberHasOverrideModifier) {
      if (errorNode) {
        const className = typeToString(type);
        error(
          errorNode,
          isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class : Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class,
          className
        );
      }
      return 2 /* HasInvalidOverride */;
    }
    return 0 /* Ok */;
  }
  function issueMemberSpecificError(node, typeWithThis, baseWithThis, broadDiag) {
    let issuedMemberError = false;
    for (const member of node.members) {
      if (isStatic(member)) {
        continue;
      }
      const declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
      if (declaredProp) {
        const prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);
        const baseProp = getPropertyOfType(baseWithThis, declaredProp.escapedName);
        if (prop && baseProp) {
          const rootChain = () => chainDiagnosticMessages(
            /*details*/
            void 0,
            Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,
            symbolToString(declaredProp),
            typeToString(typeWithThis),
            typeToString(baseWithThis)
          );
          if (!checkTypeAssignableTo(
            getTypeOfSymbol(prop),
            getTypeOfSymbol(baseProp),
            member.name || member,
            /*headMessage*/
            void 0,
            rootChain
          )) {
            issuedMemberError = true;
          }
        }
      }
    }
    if (!issuedMemberError) {
      checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag);
    }
  }
  function checkBaseTypeAccessibility(type, node) {
    const signatures = getSignaturesOfType(type, 1 /* Construct */);
    if (signatures.length) {
      const declaration = signatures[0].declaration;
      if (declaration && hasEffectiveModifier(declaration, 2 /* Private */)) {
        const typeClassDeclaration = getClassLikeDeclarationOfSymbol(type.symbol);
        if (!isNodeWithinClass(node, typeClassDeclaration)) {
          error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
        }
      }
    }
  }
  function getMemberOverrideModifierStatus(node, member, memberSymbol) {
    if (!member.name) {
      return 0 /* Ok */;
    }
    const classSymbol = getSymbolOfDeclaration(node);
    const type = getDeclaredTypeOfSymbol(classSymbol);
    const typeWithThis = getTypeWithThisArgument(type);
    const staticType = getTypeOfSymbol(classSymbol);
    const baseTypeNode = getEffectiveBaseTypeNode(node);
    const baseTypes = baseTypeNode && getBaseTypes(type);
    const baseWithThis = (baseTypes == null ? void 0 : baseTypes.length) ? getTypeWithThisArgument(first(baseTypes), type.thisType) : void 0;
    const baseStaticType = getBaseConstructorTypeOfClass(type);
    const memberHasOverrideModifier = member.parent ? hasOverrideModifier(member) : hasSyntacticModifier(member, 16 /* Override */);
    return checkMemberForOverrideModifier(
      node,
      staticType,
      baseStaticType,
      baseWithThis,
      type,
      typeWithThis,
      memberHasOverrideModifier,
      hasAbstractModifier(member),
      isStatic(member),
      /*memberIsParameterProperty*/
      false,
      symbolName(memberSymbol)
    );
  }
  function getTargetSymbol(s) {
    return getCheckFlags(s) & 1 /* Instantiated */ ? s.links.target : s;
  }
  function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
    return filter(symbol.declarations, (d) => d.kind === 263 /* ClassDeclaration */ || d.kind === 264 /* InterfaceDeclaration */);
  }
  function checkKindsOfPropertyMemberOverrides(type, baseType) {
    var _a, _b, _c, _d;
    const baseProperties = getPropertiesOfType(baseType);
    let inheritedAbstractMemberNotImplementedError;
    basePropertyCheck:
      for (const baseProperty of baseProperties) {
        const base = getTargetSymbol(baseProperty);
        if (base.flags & 4194304 /* Prototype */) {
          continue;
        }
        const baseSymbol = getPropertyOfObjectType(type, base.escapedName);
        if (!baseSymbol) {
          continue;
        }
        const derived = getTargetSymbol(baseSymbol);
        const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);
        Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
        if (derived === base) {
          const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol);
          if (baseDeclarationFlags & 64 /* Abstract */ && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, 64 /* Abstract */))) {
            for (const otherBaseType of getBaseTypes(type)) {
              if (otherBaseType === baseType)
                continue;
              const baseSymbol2 = getPropertyOfObjectType(otherBaseType, base.escapedName);
              const derivedElsewhere = baseSymbol2 && getTargetSymbol(baseSymbol2);
              if (derivedElsewhere && derivedElsewhere !== base) {
                continue basePropertyCheck;
              }
            }
            if (!inheritedAbstractMemberNotImplementedError) {
              inheritedAbstractMemberNotImplementedError = error(
                derivedClassDecl,
                Diagnostics.Non_abstract_class_0_does_not_implement_all_abstract_members_of_1,
                typeToString(type),
                typeToString(baseType)
              );
            }
            if (derivedClassDecl.kind === 231 /* ClassExpression */) {
              addRelatedInfo(
                inheritedAbstractMemberNotImplementedError,
                createDiagnosticForNode(
                  baseProperty.valueDeclaration ?? (baseProperty.declarations && first(baseProperty.declarations)) ?? derivedClassDecl,
                  Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1,
                  symbolToString(baseProperty),
                  typeToString(baseType)
                )
              );
            } else {
              addRelatedInfo(
                inheritedAbstractMemberNotImplementedError,
                createDiagnosticForNode(
                  baseProperty.valueDeclaration ?? (baseProperty.declarations && first(baseProperty.declarations)) ?? derivedClassDecl,
                  Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2,
                  typeToString(type),
                  symbolToString(baseProperty),
                  typeToString(baseType)
                )
              );
            }
          }
        } else {
          const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);
          if (baseDeclarationFlags & 2 /* Private */ || derivedDeclarationFlags & 2 /* Private */) {
            continue;
          }
          let errorMessage;
          const basePropertyFlags = base.flags & 98308 /* PropertyOrAccessor */;
          const derivedPropertyFlags = derived.flags & 98308 /* PropertyOrAccessor */;
          if (basePropertyFlags && derivedPropertyFlags) {
            if ((getCheckFlags(base) & 6 /* Synthetic */ ? (_a = base.declarations) == null ? void 0 : _a.some((d) => isPropertyAbstractOrInterface(d, baseDeclarationFlags)) : (_b = base.declarations) == null ? void 0 : _b.every((d) => isPropertyAbstractOrInterface(d, baseDeclarationFlags))) || getCheckFlags(base) & 262144 /* Mapped */ || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)) {
              continue;
            }
            const overriddenInstanceProperty = basePropertyFlags !== 4 /* Property */ && derivedPropertyFlags === 4 /* Property */;
            const overriddenInstanceAccessor = basePropertyFlags === 4 /* Property */ && derivedPropertyFlags !== 4 /* Property */;
            if (overriddenInstanceProperty || overriddenInstanceAccessor) {
              const errorMessage2 = overriddenInstanceProperty ? Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property : Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;
              error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage2, symbolToString(base), typeToString(baseType), typeToString(type));
            } else if (useDefineForClassFields) {
              const uninitialized = (_c = derived.declarations) == null ? void 0 : _c.find((d) => d.kind === 172 /* PropertyDeclaration */ && !d.initializer);
              if (uninitialized && !(derived.flags & 33554432 /* Transient */) && !(baseDeclarationFlags & 64 /* Abstract */) && !(derivedDeclarationFlags & 64 /* Abstract */) && !((_d = derived.declarations) == null ? void 0 : _d.some((d) => !!(d.flags & 33554432 /* Ambient */)))) {
                const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol));
                const propName = uninitialized.name;
                if (uninitialized.exclamationToken || !constructor || !isIdentifier(propName) || !strictNullChecks || !isPropertyInitializedInConstructor(propName, type, constructor)) {
                  const errorMessage2 = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;
                  error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage2, symbolToString(base), typeToString(baseType));
                }
              }
            }
            continue;
          } else if (isPrototypeProperty(base)) {
            if (isPrototypeProperty(derived) || derived.flags & 4 /* Property */) {
              continue;
            } else {
              Debug.assert(!!(derived.flags & 98304 /* Accessor */));
              errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
            }
          } else if (base.flags & 98304 /* Accessor */) {
            errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
          } else {
            errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
          }
          error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
        }
      }
  }
  function isPropertyAbstractOrInterface(declaration, baseDeclarationFlags) {
    return baseDeclarationFlags & 64 /* Abstract */ && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent);
  }
  function getNonInheritedProperties(type, baseTypes, properties) {
    if (!length(baseTypes)) {
      return properties;
    }
    const seen = /* @__PURE__ */ new Map();
    forEach(properties, (p) => {
      seen.set(p.escapedName, p);
    });
    for (const base of baseTypes) {
      const properties2 = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
      for (const prop of properties2) {
        const existing = seen.get(prop.escapedName);
        if (existing && prop.parent === existing.parent) {
          seen.delete(prop.escapedName);
        }
      }
    }
    return arrayFrom(seen.values());
  }
  function checkInheritedPropertiesAreIdentical(type, typeNode) {
    const baseTypes = getBaseTypes(type);
    if (baseTypes.length < 2) {
      return true;
    }
    const seen = /* @__PURE__ */ new Map();
    forEach(resolveDeclaredMembers(type).declaredProperties, (p) => {
      seen.set(p.escapedName, { prop: p, containingType: type });
    });
    let ok = true;
    for (const base of baseTypes) {
      const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
      for (const prop of properties) {
        const existing = seen.get(prop.escapedName);
        if (!existing) {
          seen.set(prop.escapedName, { prop, containingType: base });
        } else {
          const isInheritedProperty = existing.containingType !== type;
          if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
            ok = false;
            const typeName1 = typeToString(existing.containingType);
            const typeName2 = typeToString(base);
            let errorInfo = chainDiagnosticMessages(
              /*details*/
              void 0,
              Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical,
              symbolToString(prop),
              typeName1,
              typeName2
            );
            errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
            diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo));
          }
        }
      }
    }
    return ok;
  }
  function checkPropertyInitialization(node) {
    if (!strictNullChecks || !strictPropertyInitialization || node.flags & 33554432 /* Ambient */) {
      return;
    }
    const constructor = findConstructorDeclaration(node);
    for (const member of node.members) {
      if (getEffectiveModifierFlags(member) & 128 /* Ambient */) {
        continue;
      }
      if (!isStatic(member) && isPropertyWithoutInitializer(member)) {
        const propName = member.name;
        if (isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName)) {
          const type = getTypeOfSymbol(getSymbolOfDeclaration(member));
          if (!(type.flags & 3 /* AnyOrUnknown */ || containsUndefinedType(type))) {
            if (!constructor || !isPropertyInitializedInConstructor(propName, type, constructor)) {
              error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName));
            }
          }
        }
      }
    }
  }
  function isPropertyWithoutInitializer(node) {
    return node.kind === 172 /* PropertyDeclaration */ && !hasAbstractModifier(node) && !node.exclamationToken && !node.initializer;
  }
  function isPropertyInitializedInStaticBlocks(propName, propType, staticBlocks, startPos, endPos) {
    for (const staticBlock of staticBlocks) {
      if (staticBlock.pos >= startPos && staticBlock.pos <= endPos) {
        const reference = factory.createPropertyAccessExpression(factory.createThis(), propName);
        setParent(reference.expression, reference);
        setParent(reference, staticBlock);
        reference.flowNode = staticBlock.returnFlowNode;
        const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
        if (!containsUndefinedType(flowType)) {
          return true;
        }
      }
    }
    return false;
  }
  function isPropertyInitializedInConstructor(propName, propType, constructor) {
    const reference = isComputedPropertyName(propName) ? factory.createElementAccessExpression(factory.createThis(), propName.expression) : factory.createPropertyAccessExpression(factory.createThis(), propName);
    setParent(reference.expression, reference);
    setParent(reference, constructor);
    reference.flowNode = constructor.returnFlowNode;
    const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
    return !containsUndefinedType(flowType);
  }
  function checkInterfaceDeclaration(node) {
    if (!checkGrammarModifiers(node))
      checkGrammarInterfaceDeclaration(node);
    checkTypeParameters(node.typeParameters);
    addLazyDiagnostic(() => {
      checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0);
      checkExportsOnMergedDeclarations(node);
      const symbol = getSymbolOfDeclaration(node);
      checkTypeParameterListsIdentical(symbol);
      const firstInterfaceDecl = getDeclarationOfKind(symbol, 264 /* InterfaceDeclaration */);
      if (node === firstInterfaceDecl) {
        const type = getDeclaredTypeOfSymbol(symbol);
        const typeWithThis = getTypeWithThisArgument(type);
        if (checkInheritedPropertiesAreIdentical(type, node.name)) {
          for (const baseType of getBaseTypes(type)) {
            checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1);
          }
          checkIndexConstraints(type, symbol);
        }
      }
      checkObjectTypeForDuplicateDeclarations(node);
    });
    forEach(getInterfaceBaseTypeNodes(node), (heritageElement) => {
      if (!isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression)) {
        error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
      }
      checkTypeReferenceNode(heritageElement);
    });
    forEach(node.members, checkSourceElement);
    addLazyDiagnostic(() => {
      checkTypeForDuplicateIndexSignatures(node);
      registerForUnusedIdentifiersCheck(node);
    });
  }
  function checkTypeAliasDeclaration(node) {
    checkGrammarModifiers(node);
    checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
    checkExportsOnMergedDeclarations(node);
    checkTypeParameters(node.typeParameters);
    if (node.type.kind === 141 /* IntrinsicKeyword */) {
      if (!intrinsicTypeKinds.has(node.name.escapedText) || length(node.typeParameters) !== 1) {
        error(node.type, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types);
      }
    } else {
      checkSourceElement(node.type);
      registerForUnusedIdentifiersCheck(node);
    }
  }
  function computeEnumMemberValues(node) {
    const nodeLinks2 = getNodeLinks(node);
    if (!(nodeLinks2.flags & 1024 /* EnumValuesComputed */)) {
      nodeLinks2.flags |= 1024 /* EnumValuesComputed */;
      let autoValue = 0;
      for (const member of node.members) {
        const value = computeMemberValue(member, autoValue);
        getNodeLinks(member).enumMemberValue = value;
        autoValue = typeof value === "number" ? value + 1 : void 0;
      }
    }
  }
  function computeMemberValue(member, autoValue) {
    if (isComputedNonLiteralName(member.name)) {
      error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums);
    } else {
      const text = getTextOfPropertyName(member.name);
      if (isNumericLiteralName(text)) {
        error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name);
      }
    }
    if (member.initializer) {
      return computeConstantValue(member);
    }
    if (member.parent.flags & 33554432 /* Ambient */ && !isEnumConst(member.parent)) {
      return void 0;
    }
    if (autoValue !== void 0) {
      return autoValue;
    }
    error(member.name, Diagnostics.Enum_member_must_have_initializer);
    return void 0;
  }
  function computeConstantValue(member) {
    const isConstEnum = isEnumConst(member.parent);
    const initializer = member.initializer;
    const value = evaluate(initializer, member);
    if (value !== void 0) {
      if (isConstEnum && typeof value === "number" && !isFinite(value)) {
        error(
          initializer,
          isNaN(value) ? Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN : Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value
        );
      }
    } else if (isConstEnum) {
      error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions);
    } else if (member.parent.flags & 33554432 /* Ambient */) {
      error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
    } else {
      checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values);
    }
    return value;
  }
  function evaluate(expr, location) {
    switch (expr.kind) {
      case 224 /* PrefixUnaryExpression */:
        const value = evaluate(expr.operand, location);
        if (typeof value === "number") {
          switch (expr.operator) {
            case 40 /* PlusToken */:
              return value;
            case 41 /* MinusToken */:
              return -value;
            case 55 /* TildeToken */:
              return ~value;
          }
        }
        break;
      case 226 /* BinaryExpression */:
        const left = evaluate(expr.left, location);
        const right = evaluate(expr.right, location);
        if (typeof left === "number" && typeof right === "number") {
          switch (expr.operatorToken.kind) {
            case 52 /* BarToken */:
              return left | right;
            case 51 /* AmpersandToken */:
              return left & right;
            case 49 /* GreaterThanGreaterThanToken */:
              return left >> right;
            case 50 /* GreaterThanGreaterThanGreaterThanToken */:
              return left >>> right;
            case 48 /* LessThanLessThanToken */:
              return left << right;
            case 53 /* CaretToken */:
              return left ^ right;
            case 42 /* AsteriskToken */:
              return left * right;
            case 44 /* SlashToken */:
              return left / right;
            case 40 /* PlusToken */:
              return left + right;
            case 41 /* MinusToken */:
              return left - right;
            case 45 /* PercentToken */:
              return left % right;
            case 43 /* AsteriskAsteriskToken */:
              return left ** right;
          }
        } else if ((typeof left === "string" || typeof left === "number") && (typeof right === "string" || typeof right === "number") && expr.operatorToken.kind === 40 /* PlusToken */) {
          return "" + left + right;
        }
        break;
      case 11 /* StringLiteral */:
      case 15 /* NoSubstitutionTemplateLiteral */:
        return expr.text;
      case 228 /* TemplateExpression */:
        return evaluateTemplateExpression(expr, location);
      case 9 /* NumericLiteral */:
        checkGrammarNumericLiteral(expr);
        return +expr.text;
      case 217 /* ParenthesizedExpression */:
        return evaluate(expr.expression, location);
      case 80 /* Identifier */: {
        const identifier = expr;
        if (isInfinityOrNaNString(identifier.escapedText) && resolveEntityName(
          identifier,
          111551 /* Value */,
          /*ignoreErrors*/
          true
        ) === getGlobalSymbol(
          identifier.escapedText,
          111551 /* Value */,
          /*diagnostic*/
          void 0
        )) {
          return +identifier.escapedText;
        }
      }
      case 211 /* PropertyAccessExpression */:
        if (isEntityNameExpression(expr)) {
          const symbol = resolveEntityName(
            expr,
            111551 /* Value */,
            /*ignoreErrors*/
            true
          );
          if (symbol) {
            if (symbol.flags & 8 /* EnumMember */) {
              return location ? evaluateEnumMember(expr, symbol, location) : getEnumMemberValue(symbol.valueDeclaration);
            }
            if (isConstantVariable(symbol)) {
              const declaration = symbol.valueDeclaration;
              if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && (!location || declaration !== location && isBlockScopedNameDeclaredBeforeUse(declaration, location))) {
                return evaluate(declaration.initializer, declaration);
              }
            }
          }
        }
        break;
      case 212 /* ElementAccessExpression */:
        const root = expr.expression;
        if (isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression)) {
          const rootSymbol = resolveEntityName(
            root,
            111551 /* Value */,
            /*ignoreErrors*/
            true
          );
          if (rootSymbol && rootSymbol.flags & 384 /* Enum */) {
            const name = escapeLeadingUnderscores(expr.argumentExpression.text);
            const member = rootSymbol.exports.get(name);
            if (member) {
              return location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration);
            }
          }
        }
        break;
    }
    return void 0;
  }
  function evaluateEnumMember(expr, symbol, location) {
    const declaration = symbol.valueDeclaration;
    if (!declaration || declaration === location) {
      error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol));
      return void 0;
    }
    if (!isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
      error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
      return 0;
    }
    return getEnumMemberValue(declaration);
  }
  function evaluateTemplateExpression(expr, location) {
    let result = expr.head.text;
    for (const span of expr.templateSpans) {
      const value = evaluate(span.expression, location);
      if (value === void 0) {
        return void 0;
      }
      result += value;
      result += span.literal.text;
    }
    return result;
  }
  function checkEnumDeclaration(node) {
    addLazyDiagnostic(() => checkEnumDeclarationWorker(node));
  }
  function checkEnumDeclarationWorker(node) {
    checkGrammarModifiers(node);
    checkCollisionsForDeclarationName(node, node.name);
    checkExportsOnMergedDeclarations(node);
    node.members.forEach(checkEnumMember);
    computeEnumMemberValues(node);
    const enumSymbol = getSymbolOfDeclaration(node);
    const firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
    if (node === firstDeclaration) {
      if (enumSymbol.declarations && enumSymbol.declarations.length > 1) {
        const enumIsConst = isEnumConst(node);
        forEach(enumSymbol.declarations, (decl) => {
          if (isEnumDeclaration(decl) && isEnumConst(decl) !== enumIsConst) {
            error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
          }
        });
      }
      let seenEnumMissingInitialInitializer = false;
      forEach(enumSymbol.declarations, (declaration) => {
        if (declaration.kind !== 266 /* EnumDeclaration */) {
          return false;
        }
        const enumDeclaration = declaration;
        if (!enumDeclaration.members.length) {
          return false;
        }
        const firstEnumMember = enumDeclaration.members[0];
        if (!firstEnumMember.initializer) {
          if (seenEnumMissingInitialInitializer) {
            error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
          } else {
            seenEnumMissingInitialInitializer = true;
          }
        }
      });
    }
  }
  function checkEnumMember(node) {
    if (isPrivateIdentifier(node.name)) {
      error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier);
    }
    if (node.initializer) {
      checkExpression(node.initializer);
    }
  }
  function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
    const declarations = symbol.declarations;
    if (declarations) {
      for (const declaration of declarations) {
        if ((declaration.kind === 263 /* ClassDeclaration */ || declaration.kind === 262 /* FunctionDeclaration */ && nodeIsPresent(declaration.body)) && !(declaration.flags & 33554432 /* Ambient */)) {
          return declaration;
        }
      }
    }
    return void 0;
  }
  function inSameLexicalScope(node1, node2) {
    const container1 = getEnclosingBlockScopeContainer(node1);
    const container2 = getEnclosingBlockScopeContainer(node2);
    if (isGlobalSourceFile(container1)) {
      return isGlobalSourceFile(container2);
    } else if (isGlobalSourceFile(container2)) {
      return false;
    } else {
      return container1 === container2;
    }
  }
  function checkModuleDeclaration(node) {
    if (node.body) {
      checkSourceElement(node.body);
      if (!isGlobalScopeAugmentation(node)) {
        registerForUnusedIdentifiersCheck(node);
      }
    }
    addLazyDiagnostic(checkModuleDeclarationDiagnostics);
    function checkModuleDeclarationDiagnostics() {
      var _a, _b;
      const isGlobalAugmentation = isGlobalScopeAugmentation(node);
      const inAmbientContext = node.flags & 33554432 /* Ambient */;
      if (isGlobalAugmentation && !inAmbientContext) {
        error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
      }
      const isAmbientExternalModule = isAmbientModule(node);
      const contextErrorMessage = isAmbientExternalModule ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module;
      if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
        return;
      }
      if (!checkGrammarModifiers(node)) {
        if (!inAmbientContext && node.name.kind === 11 /* StringLiteral */) {
          grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names);
        }
      }
      if (isIdentifier(node.name)) {
        checkCollisionsForDeclarationName(node, node.name);
      }
      checkExportsOnMergedDeclarations(node);
      const symbol = getSymbolOfDeclaration(node);
      if (symbol.flags & 512 /* ValueModule */ && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions))) {
        if (getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator) {
          error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName);
        }
        if (((_a = symbol.declarations) == null ? void 0 : _a.length) > 1) {
          const firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
          if (firstNonAmbientClassOrFunc) {
            if (getSourceFileOfNode(node) !== getSourceFileOfNode(firstNonAmbientClassOrFunc)) {
              error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
            } else if (node.pos < firstNonAmbientClassOrFunc.pos) {
              error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
            }
          }
          const mergedClass = getDeclarationOfKind(symbol, 263 /* ClassDeclaration */);
          if (mergedClass && inSameLexicalScope(node, mergedClass)) {
            getNodeLinks(node).flags |= 2048 /* LexicalModuleMergesWithClass */;
          }
        }
        if (compilerOptions.verbatimModuleSyntax && node.parent.kind === 312 /* SourceFile */ && (moduleKind === 1 /* CommonJS */ || node.parent.impliedNodeFormat === 1 /* CommonJS */)) {
          const exportModifier = (_b = node.modifiers) == null ? void 0 : _b.find((m) => m.kind === 95 /* ExportKeyword */);
          if (exportModifier) {
            error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
          }
        }
      }
      if (isAmbientExternalModule) {
        if (isExternalModuleAugmentation(node)) {
          const checkBody = isGlobalAugmentation || getSymbolOfDeclaration(node).flags & 33554432 /* Transient */;
          if (checkBody && node.body) {
            for (const statement of node.body.statements) {
              checkModuleAugmentationElement(statement, isGlobalAugmentation);
            }
          }
        } else if (isGlobalSourceFile(node.parent)) {
          if (isGlobalAugmentation) {
            error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
          } else if (isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name))) {
            error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name);
          }
        } else {
          if (isGlobalAugmentation) {
            error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
          } else {
            error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
          }
        }
      }
    }
  }
  function checkModuleAugmentationElement(node, isGlobalAugmentation) {
    switch (node.kind) {
      case 243 /* VariableStatement */:
        for (const decl of node.declarationList.declarations) {
          checkModuleAugmentationElement(decl, isGlobalAugmentation);
        }
        break;
      case 277 /* ExportAssignment */:
      case 278 /* ExportDeclaration */:
        grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
        break;
      case 271 /* ImportEqualsDeclaration */:
      case 272 /* ImportDeclaration */:
        grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
        break;
      case 208 /* BindingElement */:
      case 260 /* VariableDeclaration */:
        const name = node.name;
        if (isBindingPattern(name)) {
          for (const el of name.elements) {
            checkModuleAugmentationElement(el, isGlobalAugmentation);
          }
          break;
        }
      case 263 /* ClassDeclaration */:
      case 266 /* EnumDeclaration */:
      case 262 /* FunctionDeclaration */:
      case 264 /* InterfaceDeclaration */:
      case 267 /* ModuleDeclaration */:
      case 265 /* TypeAliasDeclaration */:
        if (isGlobalAugmentation) {
          return;
        }
        break;
    }
  }
  function getFirstNonModuleExportsIdentifier(node) {
    switch (node.kind) {
      case 80 /* Identifier */:
        return node;
      case 166 /* QualifiedName */:
        do {
          node = node.left;
        } while (node.kind !== 80 /* Identifier */);
        return node;
      case 211 /* PropertyAccessExpression */:
        do {
          if (isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name)) {
            return node.name;
          }
          node = node.expression;
        } while (node.kind !== 80 /* Identifier */);
        return node;
    }
  }
  function checkExternalImportOrExportDeclaration(node) {
    const moduleName = getExternalModuleName(node);
    if (!moduleName || nodeIsMissing(moduleName)) {
      return false;
    }
    if (!isStringLiteral(moduleName)) {
      error(moduleName, Diagnostics.String_literal_expected);
      return false;
    }
    const inAmbientExternalModule = node.parent.kind === 268 /* ModuleBlock */ && isAmbientModule(node.parent.parent);
    if (node.parent.kind !== 312 /* SourceFile */ && !inAmbientExternalModule) {
      error(
        moduleName,
        node.kind === 278 /* ExportDeclaration */ ? Diagnostics.Export_declarations_are_not_permitted_in_a_namespace : Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module
      );
      return false;
    }
    if (inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text)) {
      if (!isTopLevelInExternalModuleAugmentation(node)) {
        error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
        return false;
      }
    }
    if (!isImportEqualsDeclaration(node) && node.attributes) {
      const diagnostic = node.attributes.token === 118 /* WithKeyword */ ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions;
      let hasError = false;
      for (const attr of node.attributes.elements) {
        if (!isStringLiteral(attr.value)) {
          hasError = true;
          error(attr.value, diagnostic);
        }
      }
      return !hasError;
    }
    return true;
  }
  function checkAliasSymbol(node) {
    var _a, _b, _c, _d;
    let symbol = getSymbolOfDeclaration(node);
    const target = resolveAlias(symbol);
    if (target !== unknownSymbol) {
      symbol = getMergedSymbol(symbol.exportSymbol || symbol);
      if (isInJSFile(node) && !(target.flags & 111551 /* Value */) && !isTypeOnlyImportOrExportDeclaration(node)) {
        const errorNode = isImportOrExportSpecifier(node) ? node.propertyName || node.name : isNamedDeclaration(node) ? node.name : node;
        Debug.assert(node.kind !== 280 /* NamespaceExport */);
        if (node.kind === 281 /* ExportSpecifier */) {
          const diag2 = error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files);
          const alreadyExportedSymbol = (_b = (_a = getSourceFileOfNode(node).symbol) == null ? void 0 : _a.exports) == null ? void 0 : _b.get((node.propertyName || node.name).escapedText);
          if (alreadyExportedSymbol === target) {
            const exportingDeclaration = (_c = alreadyExportedSymbol.declarations) == null ? void 0 : _c.find(isJSDocNode);
            if (exportingDeclaration) {
              addRelatedInfo(
                diag2,
                createDiagnosticForNode(
                  exportingDeclaration,
                  Diagnostics._0_is_automatically_exported_here,
                  unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)
                )
              );
            }
          }
        } else {
          Debug.assert(node.kind !== 260 /* VariableDeclaration */);
          const importDeclaration = findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration));
          const moduleSpecifier = (importDeclaration && ((_d = tryGetModuleSpecifierFromDeclaration(importDeclaration)) == null ? void 0 : _d.text)) ?? "...";
          const importedIdentifier = unescapeLeadingUnderscores(isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName);
          error(
            errorNode,
            Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation,
            importedIdentifier,
            `import("${moduleSpecifier}").${importedIdentifier}`
          );
        }
        return;
      }
      const targetFlags = getSymbolFlags(target);
      const excludedMeanings = (symbol.flags & (111551 /* Value */ | 1048576 /* ExportValue */) ? 111551 /* Value */ : 0) | (symbol.flags & 788968 /* Type */ ? 788968 /* Type */ : 0) | (symbol.flags & 1920 /* Namespace */ ? 1920 /* Namespace */ : 0);
      if (targetFlags & excludedMeanings) {
        const message = node.kind === 281 /* ExportSpecifier */ ? Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 : Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
        error(node, message, symbolToString(symbol));
      } else if (node.kind !== 281 /* ExportSpecifier */) {
        const appearsValueyToTranspiler = compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration);
        if (appearsValueyToTranspiler && symbol.flags & (111551 /* Value */ | 1048576 /* ExportValue */)) {
          error(
            node,
            Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled,
            symbolToString(symbol),
            isolatedModulesLikeFlagName
          );
        }
      }
      if (getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & 33554432 /* Ambient */)) {
        const typeOnlyAlias = getTypeOnlyAliasDeclaration(symbol);
        const isType = !(targetFlags & 111551 /* Value */);
        if (isType || typeOnlyAlias) {
          switch (node.kind) {
            case 273 /* ImportClause */:
            case 276 /* ImportSpecifier */:
            case 271 /* ImportEqualsDeclaration */: {
              if (compilerOptions.preserveValueImports || compilerOptions.verbatimModuleSyntax) {
                Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");
                const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node) ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled : isType ? compilerOptions.verbatimModuleSyntax ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled : Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled : compilerOptions.verbatimModuleSyntax ? Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled;
                const name = idText(node.kind === 276 /* ImportSpecifier */ ? node.propertyName || node.name : node.name);
                addTypeOnlyDeclarationRelatedInfo(
                  error(node, message, name),
                  isType ? void 0 : typeOnlyAlias,
                  name
                );
              }
              if (isType && node.kind === 271 /* ImportEqualsDeclaration */ && hasEffectiveModifier(node, 32 /* Export */)) {
                error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);
              }
              break;
            }
            case 281 /* ExportSpecifier */: {
              if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {
                const name = idText(node.propertyName || node.name);
                const diagnostic = isType ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName) : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);
                addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? void 0 : typeOnlyAlias, name);
                break;
              }
            }
          }
        }
        if (compilerOptions.verbatimModuleSyntax && node.kind !== 271 /* ImportEqualsDeclaration */ && !isInJSFile(node) && (moduleKind === 1 /* CommonJS */ || getSourceFileOfNode(node).impliedNodeFormat === 1 /* CommonJS */)) {
          error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
        }
      }
      if (isImportSpecifier(node)) {
        const targetSymbol = resolveAliasWithDeprecationCheck(symbol, node);
        if (isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations) {
          addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName);
        }
      }
    }
  }
  function resolveAliasWithDeprecationCheck(symbol, location) {
    if (!(symbol.flags & 2097152 /* Alias */) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol)) {
      return symbol;
    }
    const targetSymbol = resolveAlias(symbol);
    if (targetSymbol === unknownSymbol)
      return targetSymbol;
    while (symbol.flags & 2097152 /* Alias */) {
      const target = getImmediateAliasedSymbol(symbol);
      if (target) {
        if (target === targetSymbol)
          break;
        if (target.declarations && length(target.declarations)) {
          if (isDeprecatedSymbol(target)) {
            addDeprecatedSuggestion(location, target.declarations, target.escapedName);
            break;
          } else {
            if (symbol === targetSymbol)
              break;
            symbol = target;
          }
        }
      } else {
        break;
      }
    }
    return targetSymbol;
  }
  function checkImportBinding(node) {
    checkCollisionsForDeclarationName(node, node.name);
    checkAliasSymbol(node);
    if (node.kind === 276 /* ImportSpecifier */ && idText(node.propertyName || node.name) === "default" && getESModuleInterop(compilerOptions) && moduleKind !== 4 /* System */ && (moduleKind < 5 /* ES2015 */ || getSourceFileOfNode(node).impliedNodeFormat === 1 /* CommonJS */)) {
      checkExternalEmitHelpers(node, 131072 /* ImportDefault */);
    }
  }
  function checkImportAttributes(declaration) {
    var _a;
    const node = declaration.attributes;
    if (node) {
      const importAttributesType = getGlobalImportAttributesType(
        /*reportErrors*/
        true
      );
      if (importAttributesType !== emptyObjectType) {
        checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, 32768 /* Undefined */), node);
      }
      const validForTypeAttributes = isExclusivelyTypeOnlyImportOrExport(declaration);
      const override = getResolutionModeOverride(node, validForTypeAttributes ? grammarErrorOnNode : void 0);
      const isImportAttributes2 = declaration.attributes.token === 118 /* WithKeyword */;
      if (validForTypeAttributes && override) {
        return;
      }
      const mode = moduleKind === 199 /* NodeNext */ && declaration.moduleSpecifier && getUsageModeForExpression(declaration.moduleSpecifier);
      if (mode !== 99 /* ESNext */ && moduleKind !== 99 /* ESNext */ && moduleKind !== 200 /* Preserve */) {
        const message = isImportAttributes2 ? moduleKind === 199 /* NodeNext */ ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls : Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve : moduleKind === 199 /* NodeNext */ ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve;
        return grammarErrorOnNode(node, message);
      }
      if (isImportDeclaration(declaration) ? (_a = declaration.importClause) == null ? void 0 : _a.isTypeOnly : declaration.isTypeOnly) {
        return grammarErrorOnNode(node, isImportAttributes2 ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports);
      }
      if (override) {
        return grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports);
      }
    }
  }
  function checkImportAttribute(node) {
    return getRegularTypeOfLiteralType(checkExpressionCached(node.value));
  }
  function checkImportDeclaration(node) {
    if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
      return;
    }
    if (!checkGrammarModifiers(node) && hasEffectiveModifiers(node)) {
      grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers);
    }
    if (checkExternalImportOrExportDeclaration(node)) {
      const importClause = node.importClause;
      if (importClause && !checkGrammarImportClause(importClause)) {
        if (importClause.name) {
          checkImportBinding(importClause);
        }
        if (importClause.namedBindings) {
          if (importClause.namedBindings.kind === 274 /* NamespaceImport */) {
            checkImportBinding(importClause.namedBindings);
            if (moduleKind !== 4 /* System */ && (moduleKind < 5 /* ES2015 */ || getSourceFileOfNode(node).impliedNodeFormat === 1 /* CommonJS */) && getESModuleInterop(compilerOptions)) {
              checkExternalEmitHelpers(node, 65536 /* ImportStar */);
            }
          } else {
            const moduleExisted = resolveExternalModuleName(node, node.moduleSpecifier);
            if (moduleExisted) {
              forEach(importClause.namedBindings.elements, checkImportBinding);
            }
          }
        }
      }
    }
    checkImportAttributes(node);
  }
  function checkImportEqualsDeclaration(node) {
    if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
      return;
    }
    checkGrammarModifiers(node);
    if (isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
      check