import type CJSImportProcessor from "../CJSImportProcessor";
import type { HelperManager } from "../HelperManager";
import type NameManager from "../NameManager";
import type TokenProcessor from "../TokenProcessor";
import type ReactHotLoaderTransformer from "./ReactHotLoaderTransformer";
import type RootTransformer from "./RootTransformer";
import Transformer from "./Transformer";
/**
 * Class for editing import statements when we are transforming to commonjs.
 */
export default class CJSImportTransformer extends Transformer {
    readonly rootTransformer: RootTransformer;
    readonly tokens: TokenProcessor;
    readonly importProcessor: CJSImportProcessor;
    readonly nameManager: NameManager;
    readonly helperManager: HelperManager;
    readonly reactHotLoaderTransformer: ReactHotLoaderTransformer | null;
    readonly enableLegacyBabel5ModuleInterop: boolean;
    readonly enableLegacyTypeScriptModuleInterop: boolean;
    readonly isTypeScriptTransformEnabled: boolean;
    readonly isFlowTransformEnabled: boolean;
    readonly preserveDynamicImport: boolean;
    readonly keepUnusedImports: boolean;
    private hadExport;
    private hadNamedExport;
    private hadDefaultExport;
    private declarationInfo;
    constructor(rootTransformer: RootTransformer, tokens: TokenProcessor, importProcessor: CJSImportProcessor, nameManager: NameManager, helperManager: HelperManager, reactHotLoaderTransformer: ReactHotLoaderTransformer | null, enableLegacyBabel5ModuleInterop: boolean, enableLegacyTypeScriptModuleInterop: boolean, isTypeScriptTransformEnabled: boolean, isFlowTransformEnabled: boolean, preserveDynamicImport: boolean, keepUnusedImports: boolean);
    getPrefixCode(): string;
    getSuffixCode(): string;
    process(): boolean;
    private processImportEquals;
    /**
     * Transform this:
     * import foo, {bar} from 'baz';
     * into
     * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
     *
     * The import code was already generated in the import preprocessing step, so
     * we just need to look it up.
     */
    private processImport;
    /**
     * Erase this import (since any CJS output would be completely different), and
     * return true if this import is should be elided due to being a type-only
     * import. Such imports will not be emitted at all to avoid side effects.
     *
     * Import elision only happens with the TypeScript or Flow transforms enabled.
     *
     * TODO: This function has some awkward overlap with
     *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
     *  That function handles TypeScript implicit import name elision, and removes
     *  an import if all typical imported names (without `type`) are removed due
     *  to being type-only imports. This function handles Flow import removal and
     *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
     *  purposes.
     *
     * The position should end at the import string.
     */
    private removeImportAndDetectIfShouldElide;
    private removeRemainingImport;
    private processIdentifier;
    processObjectShorthand(): boolean;
    processExport(): boolean;
    private processAssignment;
    /**
     * Process something like `a += 3`, where `a` might be an exported value.
     */
    private processComplexAssignment;
    /**
     * Process something like `++a`, where `a` might be an exported value.
     */
    private processPreIncDec;
    /**
     * Process something like `a++`, where `a` might be an exported value.
     * This starts at the `a`, not at the `++`.
     */
    private processPostIncDec;
    private processExportDefault;
    priv