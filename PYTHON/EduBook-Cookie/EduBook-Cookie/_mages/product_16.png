ation */ || kind === 271 /* ImportEqualsDeclaration */ || kind === 272 /* ImportDeclaration */ || kind === 270 /* NamespaceExportDeclaration */ || kind === 278 /* ExportDeclaration */ || kind === 277 /* ExportAssignment */;
}
function canHaveIllegalModifiers(node) {
  const kind = node.kind;
  return kind === 175 /* ClassStaticBlockDeclaration */ || kind === 303 /* PropertyAssignment */ || kind === 304 /* ShorthandPropertyAssignment */ || kind === 282 /* MissingDeclaration */ || kind === 270 /* NamespaceExportDeclaration */;
}
function isQuestionOrExclamationToken(node) {
  return isQuestionToken(node) || isExclamationToken(node);
}
function isIdentifierOrThisTypeNode(node) {
  return isIdentifier(node) || isThisTypeNode(node);
}
function isReadonlyKeywordOrPlusOrMinusToken(node) {
  return isReadonlyKeyword(node) || isPlusToken(node) || isMinusToken(node);
}
function isQuestionOrPlusOrMinusToken(node) {
  return isQuestionToken(node) || isPlusToken(node) || isMinusToken(node);
}
function isModuleName(node) {
  return isIdentifier(node) || isStringLiteral(node);
}
function isLiteralTypeLikeExpression(node) {
  const kind = node.kind;
  return kind === 106 /* NullKeyword */ || kind === 112 /* TrueKeyword */ || kind === 97 /* FalseKeyword */ || isLiteralExpression(node) || isPrefixUnaryExpression(node);
}
function isExponentiationOperator(kind) {
  return kind === 43 /* AsteriskAsteriskToken */;
}
function isMultiplicativeOperator(kind) {
  return kind === 42 /* AsteriskToken */ || kind === 44 /* SlashToken */ || kind === 45 /* PercentToken */;
}
function isMultiplicativeOperatorOrHigher(kind) {
  return isExponentiationOperator(kind) || isMultiplicativeOperator(kind);
}
function isAdditiveOperator(kind) {
  return kind === 40 /* PlusToken */ || kind === 41 /* MinusToken */;
}
function isAdditiveOperatorOrHigher(kind) {
  return isAdditiveOperator(kind) || isMultiplicativeOperatorOrHigher(kind);
}
function isShiftOperator(kind) {
  return kind === 48 /* LessThanLessThanToken */ || kind === 49 /* GreaterThanGreaterThanToken */ || kind === 50 /* GreaterThanGreaterThanGreaterThanToken */;
}
function isShiftOperatorOrHigher(kind) {
  return isShiftOperator(kind) || isAdditiveOperatorOrHigher(kind);
}
function isRelationalOperator(kind) {
  return kind === 30 /* LessThanToken */ || kind === 33 /* LessThanEqualsToken */ || kind === 32 /* GreaterThanToken */ || kind === 34 /* GreaterThanEqualsToken */ || kind === 104 /* InstanceOfKeyword */ || kind === 103 /* InKeyword */;
}
function isRelationalOperatorOrHigher(kind) {
  return isRelationalOperator(kind) || isShiftOperatorOrHigher(kind);
}
function isEqualityOperator(kind) {
  return kind === 35 /* EqualsEqualsToken */ || kind === 37 /* EqualsEqualsEqualsToken */ || kind === 36 /* ExclamationEqualsToken */ || kind === 38 /* ExclamationEqualsEqualsToken */;
}
function isEqualityOperatorOrHigher(kind) {
  return isEqualityOperator(kind) || isRelationalOperatorOrHigher(kind);
}
function isBitwiseOperator(kind) {
  return kind === 51 /* AmpersandToken */ || kind === 52 /* BarToken */ || kind === 53 /* CaretToken */;
}
function isBitwiseOperatorOrHigher(kind) {
  return isBitwiseOperator(kind) || isEqualityOperatorOrHigher(kind);
}
function isLogicalOperator2(kind) {
  return kind === 56 /* AmpersandAmpersandToken */ || kind === 57 /* BarBarToken */;
}
function isLogicalOperatorOrHigher(kind) {
  return isLogicalOperator2(kind) || isBitwiseOperatorOrHigher(kind);
}
function isAssignmentOperatorOrHigher(kind) {
  return kind === 61 /* QuestionQuestionToken */ || isLogicalOperatorOrHigher(kind) || isAssignmentOperator(kind);
}
function isBinaryOperator(kind) {
  return isAssignmentOperatorOrHigher(kind) || kind === 28 /* CommaToken */;
}
function isBinaryOperatorToken(node) {
  return isBinaryOperator(node.kind);
}
var BinaryExpressionState;
((BinaryExpressionState2) => {
  function enter(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, outerState) {
    const prevUserState = stackIndex > 0 ? userStateStack[stackIndex - 1] : void 0;
    Debug.assertEqual(stateStack[stackIndex], enter);
    userStateStack[stackIndex] = machine.onEnter(nodeStack[stackIndex], prevUserState, outerState);
    stateStack[stackIndex] = nextState(machine, enter);
    return stackIndex;
  }
  BinaryExpressionState2.enter = enter;
  function left(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
    Debug.assertEqual(stateStack[stackIndex], left);
    Debug.assertIsDefined(machine.onLeft);
    stateStack[stackIndex] = nextState(machine, left);
    const nextNode = machine.onLeft(nodeStack[stackIndex].left, userStateStack[stackIndex], nodeStack[stackIndex]);
    if (nextNode) {
      checkCircularity(stackIndex, nodeStack, nextNode);
      return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
    }
    return stackIndex;
  }
  BinaryExpressionState2.left = left;
  function operator(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
    Debug.assertEqual(stateStack[stackIndex], operator);
    Debug.assertIsDefined(machine.onOperator);
    stateStack[stackIndex] = nextState(machine, operator);
    machine.onOperator(nodeStack[stackIndex].operatorToken, userStateStack[stackIndex], nodeStack[stackIndex]);
    return stackIndex;
  }
  BinaryExpressionState2.operator = operator;
  function right(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
    Debug.assertEqual(stateStack[stackIndex], right);
    Debug.assertIsDefined(machine.onRight);
    stateStack[stackIndex] = nextState(machine, right);
    const nextNode = machine.onRight(nodeStack[stackIndex].right, userStateStack[stackIndex], nodeStack[stackIndex]);
    if (nextNode) {
      checkCircularity(stackIndex, nodeStack, nextNode);
      return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
    }
    return stackIndex;
  }
  BinaryExpressionState2.right = right;
  function exit(machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, _outerState) {
    Debug.assertEqual(stateStack[stackIndex], exit);
    stateStack[stackIndex] = nextState(machine, exit);
    const result = machine.onExit(nodeStack[stackIndex], userStateStack[stackIndex]);
    if (stackIndex > 0) {
      stackIndex--;
      if (machine.foldState) {
        const side = stateStack[stackIndex] === exit ? "right" : "left";
        userStateStack[stackIndex] = machine.foldState(userStateStack[stackIndex], result, side);
      }
    } else {
      resultHolder.value = result;
    }
    return stackIndex;
  }
  BinaryExpressionState2.exit = exit;
  function done(_machine, stackIndex, stateStack, _nodeStack, _userStateStack, _resultHolder, _outerState) {
    Debug.assertEqual(stateStack[stackIndex], done);
    return stackIndex;
  }
  BinaryExpressionState2.done = done;
  function nextState(machine, currentState) {
    switch (currentState) {
      case enter:
        if (machine.onLeft)
          return left;
      case left:
        if (machine.onOperator)
          return operator;
      case operator:
        if (machine.onRight)
          return right;
      case right:
        return exit;
      case exit:
        return done;
      case done:
        return done;
      default:
        Debug.fail("Invalid state");
    }
  }
  BinaryExpressionState2.nextState = nextState;
  function pushStack(stackIndex, stateStack, nodeStack, userStateStack, node) {
    stackIndex++;
    stateStack[stackIndex] = enter;
    nodeStack[stackIndex] = node;
    userStateStack[stackIndex] = void 0;
    return stackIndex;
  }
  function checkCircularity(stackIndex, nodeStack, node) {
    if (Debug.shouldAssert(2 /* Aggressive */)) {
      while (stackIndex >= 0) {
        Debug.assert(nodeStack[stackIndex] !== node, "Circular traversal detected.");
        stackIndex--;
      }
    }
  }
})(BinaryExpressionState || (BinaryExpressionState = {}));
var BinaryExpressionStateMachine = class {
  constructor(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
    this.onEnter = onEnter;
    this.onLeft = onLeft;
    this.onOperator = onOperator;
    this.onRight = onRight;
    this.onExit = onExit;
    this.foldState = foldState;
  }
};
function createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
  const machine = new BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState);
  return trampoline;
  function trampoline(node, outerState) {
    const resultHolder = { value: void 0 };
    const stateStack = [BinaryExpressionState.enter];
    const nodeStack = [node];
    const userStateStack = [void 0];
    let stackIndex = 0;
    while (stateStack[stackIndex] !== BinaryExpressionState.done) {
      stackIndex = stateStack[stackIndex](machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, outerState);
    }
    Debug.assertEqual(stackIndex, 0);
    return resultHolder.value;
  }
}
function isExportOrDefaultKeywordKind(kind) {
  return kind === 95 /* ExportKeyword */ || kind === 90 /* DefaultKeyword */;
}
function isExportOrDefaultModifier(node) {
  const kind = node.kind;
  return isExportOrDefaultKeywordKind(kind);
}
function isNonExportDefaultModifier(node) {
  const kind = node.kind;
  return isModifierKind(kind) && !isExportOrDefaultKeywordKind(kind);
}
function elideNodes(factory2, nodes) {
  if (nodes === void 0)
    return void 0;
  if (nodes.length === 0)
    return nodes;
  return setTextRange(factory2.createNodeArray([], nodes.hasTrailingComma), nodes);
}
function getNodeForGeneratedName(name) {
  var _a;
  const autoGenerate = name.emitNode.autoGenerate;
  if (autoGenerate.flags & 4 /* Node */) {
    const autoGenerateId = autoGenerate.id;
    let node = name;
    let original = node.original;
    while (original) {
      node = original;
      const autoGenerate2 = (_a = node.emitNode) == null ? void 0 : _a.autoGenerate;
      if (isMemberName(node) && (autoGenerate2 === void 0 || !!(autoGenerate2.flags & 4 /* Node */) && autoGenerate2.id !== autoGenerateId)) {
        break;
      }
      original = node.original;
    }
    return node;
  }
  return name;
}
function formatGeneratedNamePart(part, generateName) {
  return typeof part === "object" ? formatGeneratedName(
    /*privateName*/
    false,
    part.prefix,
    part.node,
    part.suffix,
    generateName
  ) : typeof part === "string" ? part.length > 0 && part.charCodeAt(0) === 35 /* hash */ ? part.slice(1) : part : "";
}
function formatIdentifier(name, generateName) {
  return typeof name === "string" ? name : formatIdentifierWorker(name, Debug.checkDefined(generateName));
}
function formatIdentifierWorker(node, generateName) {
  return isGeneratedPrivateIdentifier(node) ? generateName(node).slice(1) : isGeneratedIdentifier(node) ? generateName(node) : isPrivateIdentifier(node) ? node.escapedText.slice(1) : idText(node);
}
function formatGeneratedName(privateName, prefix, baseName, suffix, generateName) {
  prefix = formatGeneratedNamePart(prefix, generateName);
  suffix = formatGeneratedNamePart(suffix, generateName);
  baseName = formatIdentifier(baseName, generateName);
  return `${privateName ? "#" : ""}${prefix}${baseName}${suffix}`;
}
function createAccessorPropertyBackingField(factory2, node, modifiers, initializer) {
  return factory2.updatePropertyDeclaration(
    node,
    modifiers,
    factory2.getGeneratedPrivateNameForNode(
      node.name,
      /*prefix*/
      void 0,
      "_accessor_storage"
    ),
    /*questionOrExclamationToken*/
    void 0,
    /*type*/
    void 0,
    initializer
  );
}
function createAccessorPropertyGetRedirector(factory2, node, modifiers, name, receiver = factory2.createThis()) {
  return factory2.createGetAccessorDeclaration(
    modifiers,
    name,
    [],
    /*type*/
    void 0,
    factory2.createBlock([
      factory2.createReturnStatement(
        factory2.createPropertyAccessExpression(
          receiver,
          factory2.getGeneratedPrivateNameForNode(
            node.name,
            /*prefix*/
            void 0,
            "_accessor_storage"
          )
        )
      )
    ])
  );
}
function createAccessorPropertySetRedirector(factory2, node, modifiers, name, receiver = factory2.createThis()) {
  return factory2.createSetAccessorDeclaration(
    modifiers,
    name,
    [factory2.createParameterDeclaration(
      /*modifiers*/
      void 0,
      /*dotDotDotToken*/
      void 0,
      "value"
    )],
    factory2.createBlock([
      factory2.createExpressionStatement(
        factory2.createAssignment(
          factory2.createPropertyAccessExpression(
            receiver,
            factory2.getGeneratedPrivateNameForNode(
              node.name,
              /*prefix*/
              void 0,
              "_accessor_storage"
            )
          ),
          factory2.createIdentifier("value")
        )
      )
    ])
  );
}
function findComputedPropertyNameCacheAssignment(name) {
  let node = name.expression;
  while (true) {
    node = skipOuterExpressions(node);
    if (isCommaListExpression(node)) {
      node = last(node.elements);
      continue;
    }
    if (isCommaExpression(node)) {
      node = node.right;
      continue;
    }
    if (isAssignmentExpression(
      node,
      /*excludeCompoundAssignment*/
      true
    ) && isGeneratedIdentifier(node.left)) {
      return node;
    }
    break;
  }
}
function isSyntheticParenthesizedExpression(node) {
  return isParenthesizedExpression(node) && nodeIsSynthesized(node) && !node.emitNode;
}
function flattenCommaListWorker(node, expressions) {
  if (isSyntheticParenthesizedExpression(node)) {
    flattenCommaListWorker(node.expression, expressions);
  } else if (isCommaExpression(node)) {
    flattenCommaListWorker(node.left, expressions);
    flattenCommaListWorker(node.right, expressions);
  } else if (isCommaListExpression(node)) {
    for (const child of node.elements) {
      flattenCommaListWorker(child, expressions);
    }
  } else {
    expressions.push(node);
  }
}
function flattenCommaList(node) {
  const expressions = [];
  flattenCommaListWorker(node, expressions);
  return expressions;
}
function containsObjectRestOrSpread(node) {
  if (node.transformFlags & 65536 /* ContainsObjectRestOrSpread */)
    return true;
  if (node.transformFlags & 128 /* ContainsES2018 */) {
    for (const element of getElementsOfBindingOrAssignmentPattern(node)) {
      const target = getTargetOfBindingOrAssignmentElement(element);
      if (target && isAssignmentPattern(target)) {
        if (target.transformFlags & 65536 /* ContainsObjectRestOrSpread */) {
          return true;
        }
        if (target.transformFlags & 128 /* ContainsES2018 */) {
          if (containsObjectRestOrSpread(target))
            return true;
        }
      }
    }
  }
  return false;
}

// src/compiler/factory/utilitiesPublic.ts
function setTextRange(range, location) {
  return location ? setTextRangePosEnd(range, location.pos, location.end) : range;
}
function canHaveModifiers(node) {
  const kind = node.kind;
  return kind === 168 /* TypeParameter */ || kind === 169 /* Parameter */ || kind === 171 /* PropertySignature */ || kind === 172 /* PropertyDeclaration */ || kind === 173 /* MethodSignature */ || kind === 174 /* MethodDeclaration */ || kind === 176 /* Constructor */ || kind === 177 /* GetAccessor */ || kind === 178 /* SetAccessor */ || kind === 181 /* IndexSignature */ || kind === 185 /* ConstructorType */ || kind === 218 /* FunctionExpression */ || kind === 219 /* ArrowFunction */ || kind === 231 /* ClassExpression */ || kind === 243 /* VariableStatement */ || kind === 262 /* FunctionDeclaration */ || kind === 263 /* ClassDeclaration */ || kind === 264 /* InterfaceDeclaration */ || kind === 265 /* TypeAliasDeclaration */ || kind === 266 /* EnumDeclaration */ || kind === 267 /* ModuleDeclaration */ || kind === 271 /* ImportEqualsDeclaration */ || kind === 272 /* ImportDeclaration */ || kind === 277 /* ExportAssignment */ || kind === 278 /* ExportDeclaration */;
}
function canHaveDecorators(node) {
  const kind = node.kind;
  return kind === 169 /* Parameter */ || kind === 172 /* PropertyDeclaration */ || kind === 174 /* MethodDeclaration */ || kind === 177 /* GetAccessor */ || kind === 178 /* SetAccessor */ || kind === 231 /* ClassExpression */ || kind === 263 /* ClassDeclaration */;
}

// src/compiler/parser.ts
var NodeConstructor;
var TokenConstructor;
var IdentifierConstructor;
var PrivateIdentifierConstructor;
var SourceFileConstructor;
var parseBaseNodeFactory = {
  createBaseSourceFileNode: (kind) => new (SourceFileConstructor || (SourceFileConstructor = objectAllocator.getSourceFileConstructor()))(kind, -1, -1),
  createBaseIdentifierNode: (kind) => new (IdentifierConstructor || (IdentifierConstructor = objectAllocator.getIdentifierConstructor()))(kind, -1, -1),
  createBasePrivateIdentifierNode: (kind) => new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1),
  createBaseTokenNode: (kind) => new (TokenConstructor || (TokenConstructor = objectAllocator.getTokenConstructor()))(kind, -1, -1),
  createBaseNode: (kind) => new (NodeConstructor || (NodeConstructor = objectAllocator.getNodeConstructor()))(kind, -1, -1)
};
var parseNodeFactory = createNodeFactory(1 /* NoParenthesizerRules */, parseBaseNodeFactory);
function visitNode2(cbNode, node) {
  return node && cbNode(node);
}
function visitNodes(cbNode, cbNodes, nodes) {
  if (nodes) {
    if (cbNodes) {
      return cbNodes(nodes);
    }
    for (const node of nodes) {
      const result = cbNode(node);
      if (result) {
        return result;
      }
    }
  }
}
function isJSDocLikeText(text, start2) {
  return text.charCodeAt(start2 + 1) === 42 /* asterisk */ && text.charCodeAt(start2 + 2) === 42 /* asterisk */ && text.charCodeAt(start2 + 3) !== 47 /* slash */;
}
function isFileProbablyExternalModule(sourceFile) {
  return forEach(sourceFile.statements, isAnExternalModuleIndicatorNode) || getImportMetaIfNecessary(sourceFile);
}
function isAnExternalModuleIndicatorNode(node) {
  return canHaveModifiers(node) && hasModifierOfKind(node, 95 /* ExportKeyword */) || isImportEqualsDeclaration(node) && isExternalModuleReference(node.moduleReference) || isImportDeclaration(node) || isExportAssignment(node) || isExportDeclaration(node) ? node : void 0;
}
function getImportMetaIfNecessary(sourceFile) {
  return sourceFile.flags & 8388608 /* PossiblyContainsImportMeta */ ? walkTreeForImportMeta(sourceFile) : void 0;
}
function walkTreeForImportMeta(node) {
  return isImportMeta2(node) ? node : forEachChild(node, walkTreeForImportMeta);
}
function hasModifierOfKind(node, kind) {
  return some(node.modifiers, (m) => m.kind === kind);
}
function isImportMeta2(node) {
  return isMetaProperty(node) && node.keywordToken === 102 /* ImportKeyword */ && node.name.escapedText === "meta";
}
var forEachChildTable = {
  [166 /* QualifiedName */]: function forEachChildInQualifiedName(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.left) || visitNode2(cbNode, node.right);
  },
  [168 /* TypeParameter */]: function forEachChildInTypeParameter(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.constraint) || visitNode2(cbNode, node.default) || visitNode2(cbNode, node.expression);
  },
  [304 /* ShorthandPropertyAssignment */]: function forEachChildInShorthandPropertyAssignment(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.exclamationToken) || visitNode2(cbNode, node.equalsToken) || visitNode2(cbNode, node.objectAssignmentInitializer);
  },
  [305 /* SpreadAssignment */]: function forEachChildInSpreadAssignment(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [169 /* Parameter */]: function forEachChildInParameter(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.dotDotDotToken) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.initializer);
  },
  [172 /* PropertyDeclaration */]: function forEachChildInPropertyDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.exclamationToken) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.initializer);
  },
  [171 /* PropertySignature */]: function forEachChildInPropertySignature(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.initializer);
  },
  [303 /* PropertyAssignment */]: function forEachChildInPropertyAssignment(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.exclamationToken) || visitNode2(cbNode, node.initializer);
  },
  [260 /* VariableDeclaration */]: function forEachChildInVariableDeclaration(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name) || visitNode2(cbNode, node.exclamationToken) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.initializer);
  },
  [208 /* BindingElement */]: function forEachChildInBindingElement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.dotDotDotToken) || visitNode2(cbNode, node.propertyName) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.initializer);
  },
  [181 /* IndexSignature */]: function forEachChildInIndexSignature(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type);
  },
  [185 /* ConstructorType */]: function forEachChildInConstructorType(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type);
  },
  [184 /* FunctionType */]: function forEachChildInFunctionType(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type);
  },
  [179 /* CallSignature */]: forEachChildInCallOrConstructSignature,
  [180 /* ConstructSignature */]: forEachChildInCallOrConstructSignature,
  [174 /* MethodDeclaration */]: function forEachChildInMethodDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.asteriskToken) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.exclamationToken) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.body);
  },
  [173 /* MethodSignature */]: function forEachChildInMethodSignature(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type);
  },
  [176 /* Constructor */]: function forEachChildInConstructor(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.body);
  },
  [177 /* GetAccessor */]: function forEachChildInGetAccessor(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.body);
  },
  [178 /* SetAccessor */]: function forEachChildInSetAccessor(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.body);
  },
  [262 /* FunctionDeclaration */]: function forEachChildInFunctionDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.asteriskToken) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.body);
  },
  [218 /* FunctionExpression */]: function forEachChildInFunctionExpression(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.asteriskToken) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.body);
  },
  [219 /* ArrowFunction */]: function forEachChildInArrowFunction(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type) || visitNode2(cbNode, node.equalsGreaterThanToken) || visitNode2(cbNode, node.body);
  },
  [175 /* ClassStaticBlockDeclaration */]: function forEachChildInClassStaticBlockDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.body);
  },
  [183 /* TypeReference */]: function forEachChildInTypeReference(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.typeName) || visitNodes(cbNode, cbNodes, node.typeArguments);
  },
  [182 /* TypePredicate */]: function forEachChildInTypePredicate(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.assertsModifier) || visitNode2(cbNode, node.parameterName) || visitNode2(cbNode, node.type);
  },
  [186 /* TypeQuery */]: function forEachChildInTypeQuery(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.exprName) || visitNodes(cbNode, cbNodes, node.typeArguments);
  },
  [187 /* TypeLiteral */]: function forEachChildInTypeLiteral(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.members);
  },
  [188 /* ArrayType */]: function forEachChildInArrayType(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.elementType);
  },
  [189 /* TupleType */]: function forEachChildInTupleType(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.elements);
  },
  [192 /* UnionType */]: forEachChildInUnionOrIntersectionType,
  [193 /* IntersectionType */]: forEachChildInUnionOrIntersectionType,
  [194 /* ConditionalType */]: function forEachChildInConditionalType(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.checkType) || visitNode2(cbNode, node.extendsType) || visitNode2(cbNode, node.trueType) || visitNode2(cbNode, node.falseType);
  },
  [195 /* InferType */]: function forEachChildInInferType(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.typeParameter);
  },
  [205 /* ImportType */]: function forEachChildInImportType(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.argument) || visitNode2(cbNode, node.attributes) || visitNode2(cbNode, node.qualifier) || visitNodes(cbNode, cbNodes, node.typeArguments);
  },
  [302 /* ImportTypeAssertionContainer */]: function forEachChildInImportTypeAssertionContainer(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.assertClause);
  },
  [196 /* ParenthesizedType */]: forEachChildInParenthesizedTypeOrTypeOperator,
  [198 /* TypeOperator */]: forEachChildInParenthesizedTypeOrTypeOperator,
  [199 /* IndexedAccessType */]: function forEachChildInIndexedAccessType(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.objectType) || visitNode2(cbNode, node.indexType);
  },
  [200 /* MappedType */]: function forEachChildInMappedType(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.readonlyToken) || visitNode2(cbNode, node.typeParameter) || visitNode2(cbNode, node.nameType) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.type) || visitNodes(cbNode, cbNodes, node.members);
  },
  [201 /* LiteralType */]: function forEachChildInLiteralType(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.literal);
  },
  [202 /* NamedTupleMember */]: function forEachChildInNamedTupleMember(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.dotDotDotToken) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.type);
  },
  [206 /* ObjectBindingPattern */]: forEachChildInObjectOrArrayBindingPattern,
  [207 /* ArrayBindingPattern */]: forEachChildInObjectOrArrayBindingPattern,
  [209 /* ArrayLiteralExpression */]: function forEachChildInArrayLiteralExpression(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.elements);
  },
  [210 /* ObjectLiteralExpression */]: function forEachChildInObjectLiteralExpression(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.properties);
  },
  [211 /* PropertyAccessExpression */]: function forEachChildInPropertyAccessExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.questionDotToken) || visitNode2(cbNode, node.name);
  },
  [212 /* ElementAccessExpression */]: function forEachChildInElementAccessExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.questionDotToken) || visitNode2(cbNode, node.argumentExpression);
  },
  [213 /* CallExpression */]: forEachChildInCallOrNewExpression,
  [214 /* NewExpression */]: forEachChildInCallOrNewExpression,
  [215 /* TaggedTemplateExpression */]: function forEachChildInTaggedTemplateExpression(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tag) || visitNode2(cbNode, node.questionDotToken) || visitNodes(cbNode, cbNodes, node.typeArguments) || visitNode2(cbNode, node.template);
  },
  [216 /* TypeAssertionExpression */]: function forEachChildInTypeAssertionExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.type) || visitNode2(cbNode, node.expression);
  },
  [217 /* ParenthesizedExpression */]: function forEachChildInParenthesizedExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [220 /* DeleteExpression */]: function forEachChildInDeleteExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [221 /* TypeOfExpression */]: function forEachChildInTypeOfExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [222 /* VoidExpression */]: function forEachChildInVoidExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [224 /* PrefixUnaryExpression */]: function forEachChildInPrefixUnaryExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.operand);
  },
  [229 /* YieldExpression */]: function forEachChildInYieldExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.asteriskToken) || visitNode2(cbNode, node.expression);
  },
  [223 /* AwaitExpression */]: function forEachChildInAwaitExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [225 /* PostfixUnaryExpression */]: function forEachChildInPostfixUnaryExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.operand);
  },
  [226 /* BinaryExpression */]: function forEachChildInBinaryExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.left) || visitNode2(cbNode, node.operatorToken) || visitNode2(cbNode, node.right);
  },
  [234 /* AsExpression */]: function forEachChildInAsExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.type);
  },
  [235 /* NonNullExpression */]: function forEachChildInNonNullExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [238 /* SatisfiesExpression */]: function forEachChildInSatisfiesExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.type);
  },
  [236 /* MetaProperty */]: function forEachChildInMetaProperty(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name);
  },
  [227 /* ConditionalExpression */]: function forEachChildInConditionalExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.condition) || visitNode2(cbNode, node.questionToken) || visitNode2(cbNode, node.whenTrue) || visitNode2(cbNode, node.colonToken) || visitNode2(cbNode, node.whenFalse);
  },
  [230 /* SpreadElement */]: function forEachChildInSpreadElement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [241 /* Block */]: forEachChildInBlock,
  [268 /* ModuleBlock */]: forEachChildInBlock,
  [312 /* SourceFile */]: function forEachChildInSourceFile(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.statements) || visitNode2(cbNode, node.endOfFileToken);
  },
  [243 /* VariableStatement */]: function forEachChildInVariableStatement(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.declarationList);
  },
  [261 /* VariableDeclarationList */]: function forEachChildInVariableDeclarationList(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.declarations);
  },
  [244 /* ExpressionStatement */]: function forEachChildInExpressionStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [245 /* IfStatement */]: function forEachChildInIfStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.thenStatement) || visitNode2(cbNode, node.elseStatement);
  },
  [246 /* DoStatement */]: function forEachChildInDoStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.statement) || visitNode2(cbNode, node.expression);
  },
  [247 /* WhileStatement */]: function forEachChildInWhileStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.statement);
  },
  [248 /* ForStatement */]: function forEachChildInForStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.initializer) || visitNode2(cbNode, node.condition) || visitNode2(cbNode, node.incrementor) || visitNode2(cbNode, node.statement);
  },
  [249 /* ForInStatement */]: function forEachChildInForInStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.initializer) || visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.statement);
  },
  [250 /* ForOfStatement */]: function forEachChildInForOfStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.awaitModifier) || visitNode2(cbNode, node.initializer) || visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.statement);
  },
  [251 /* ContinueStatement */]: forEachChildInContinueOrBreakStatement,
  [252 /* BreakStatement */]: forEachChildInContinueOrBreakStatement,
  [253 /* ReturnStatement */]: function forEachChildInReturnStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [254 /* WithStatement */]: function forEachChildInWithStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.statement);
  },
  [255 /* SwitchStatement */]: function forEachChildInSwitchStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.caseBlock);
  },
  [269 /* CaseBlock */]: function forEachChildInCaseBlock(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.clauses);
  },
  [296 /* CaseClause */]: function forEachChildInCaseClause(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNodes(cbNode, cbNodes, node.statements);
  },
  [297 /* DefaultClause */]: function forEachChildInDefaultClause(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.statements);
  },
  [256 /* LabeledStatement */]: function forEachChildInLabeledStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.label) || visitNode2(cbNode, node.statement);
  },
  [257 /* ThrowStatement */]: function forEachChildInThrowStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [258 /* TryStatement */]: function forEachChildInTryStatement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.tryBlock) || visitNode2(cbNode, node.catchClause) || visitNode2(cbNode, node.finallyBlock);
  },
  [299 /* CatchClause */]: function forEachChildInCatchClause(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.variableDeclaration) || visitNode2(cbNode, node.block);
  },
  [170 /* Decorator */]: function forEachChildInDecorator(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [263 /* ClassDeclaration */]: forEachChildInClassDeclarationOrExpression,
  [231 /* ClassExpression */]: forEachChildInClassDeclarationOrExpression,
  [264 /* InterfaceDeclaration */]: function forEachChildInInterfaceDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.heritageClauses) || visitNodes(cbNode, cbNodes, node.members);
  },
  [265 /* TypeAliasDeclaration */]: function forEachChildInTypeAliasDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNode2(cbNode, node.type);
  },
  [266 /* EnumDeclaration */]: function forEachChildInEnumDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.members);
  },
  [306 /* EnumMember */]: function forEachChildInEnumMember(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name) || visitNode2(cbNode, node.initializer);
  },
  [267 /* ModuleDeclaration */]: function forEachChildInModuleDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.body);
  },
  [271 /* ImportEqualsDeclaration */]: function forEachChildInImportEqualsDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNode2(cbNode, node.moduleReference);
  },
  [272 /* ImportDeclaration */]: function forEachChildInImportDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.importClause) || visitNode2(cbNode, node.moduleSpecifier) || visitNode2(cbNode, node.attributes);
  },
  [273 /* ImportClause */]: function forEachChildInImportClause(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name) || visitNode2(cbNode, node.namedBindings);
  },
  [300 /* ImportAttributes */]: function forEachChildInImportAttributes(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.elements);
  },
  [301 /* ImportAttribute */]: function forEachChildInImportAttribute(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name) || visitNode2(cbNode, node.value);
  },
  [270 /* NamespaceExportDeclaration */]: function forEachChildInNamespaceExportDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name);
  },
  [274 /* NamespaceImport */]: function forEachChildInNamespaceImport(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name);
  },
  [280 /* NamespaceExport */]: function forEachChildInNamespaceExport(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name);
  },
  [275 /* NamedImports */]: forEachChildInNamedImportsOrExports,
  [279 /* NamedExports */]: forEachChildInNamedImportsOrExports,
  [278 /* ExportDeclaration */]: function forEachChildInExportDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.exportClause) || visitNode2(cbNode, node.moduleSpecifier) || visitNode2(cbNode, node.attributes);
  },
  [276 /* ImportSpecifier */]: forEachChildInImportOrExportSpecifier,
  [281 /* ExportSpecifier */]: forEachChildInImportOrExportSpecifier,
  [277 /* ExportAssignment */]: function forEachChildInExportAssignment(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.expression);
  },
  [228 /* TemplateExpression */]: function forEachChildInTemplateExpression(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans);
  },
  [239 /* TemplateSpan */]: function forEachChildInTemplateSpan(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNode2(cbNode, node.literal);
  },
  [203 /* TemplateLiteralType */]: function forEachChildInTemplateLiteralType(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans);
  },
  [204 /* TemplateLiteralTypeSpan */]: function forEachChildInTemplateLiteralTypeSpan(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.type) || visitNode2(cbNode, node.literal);
  },
  [167 /* ComputedPropertyName */]: function forEachChildInComputedPropertyName(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [298 /* HeritageClause */]: function forEachChildInHeritageClause(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.types);
  },
  [233 /* ExpressionWithTypeArguments */]: function forEachChildInExpressionWithTypeArguments(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.expression) || visitNodes(cbNode, cbNodes, node.typeArguments);
  },
  [283 /* ExternalModuleReference */]: function forEachChildInExternalModuleReference(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [282 /* MissingDeclaration */]: function forEachChildInMissingDeclaration(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.modifiers);
  },
  [361 /* CommaListExpression */]: function forEachChildInCommaListExpression(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.elements);
  },
  [284 /* JsxElement */]: function forEachChildInJsxElement(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.openingElement) || visitNodes(cbNode, cbNodes, node.children) || visitNode2(cbNode, node.closingElement);
  },
  [288 /* JsxFragment */]: function forEachChildInJsxFragment(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.openingFragment) || visitNodes(cbNode, cbNodes, node.children) || visitNode2(cbNode, node.closingFragment);
  },
  [285 /* JsxSelfClosingElement */]: forEachChildInJsxOpeningOrSelfClosingElement,
  [286 /* JsxOpeningElement */]: forEachChildInJsxOpeningOrSelfClosingElement,
  [292 /* JsxAttributes */]: function forEachChildInJsxAttributes(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.properties);
  },
  [291 /* JsxAttribute */]: function forEachChildInJsxAttribute(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name) || visitNode2(cbNode, node.initializer);
  },
  [293 /* JsxSpreadAttribute */]: function forEachChildInJsxSpreadAttribute(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.expression);
  },
  [294 /* JsxExpression */]: function forEachChildInJsxExpression(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.dotDotDotToken) || visitNode2(cbNode, node.expression);
  },
  [287 /* JsxClosingElement */]: function forEachChildInJsxClosingElement(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.tagName);
  },
  [295 /* JsxNamespacedName */]: function forEachChildInJsxNamespacedName(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.namespace) || visitNode2(cbNode, node.name);
  },
  [190 /* OptionalType */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [191 /* RestType */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [316 /* JSDocTypeExpression */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [322 /* JSDocNonNullableType */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [321 /* JSDocNullableType */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [323 /* JSDocOptionalType */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [325 /* JSDocVariadicType */]: forEachChildInOptionalRestOrJSDocParameterModifier,
  [324 /* JSDocFunctionType */]: function forEachChildInJSDocFunctionType(node, cbNode, cbNodes) {
    return visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type);
  },
  [327 /* JSDoc */]: function forEachChildInJSDoc(node, cbNode, cbNodes) {
    return (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment)) || visitNodes(cbNode, cbNodes, node.tags);
  },
  [354 /* JSDocSeeTag */]: function forEachChildInJSDocSeeTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || visitNode2(cbNode, node.name) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
  },
  [317 /* JSDocNameReference */]: function forEachChildInJSDocNameReference(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.name);
  },
  [318 /* JSDocMemberName */]: function forEachChildInJSDocMemberName(node, cbNode, _cbNodes) {
    return visitNode2(cbNode, node.left) || visitNode2(cbNode, node.right);
  },
  [348 /* JSDocParameterTag */]: forEachChildInJSDocParameterOrPropertyTag,
  [355 /* JSDocPropertyTag */]: forEachChildInJSDocParameterOrPropertyTag,
  [337 /* JSDocAuthorTag */]: function forEachChildInJSDocAuthorTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
  },
  [336 /* JSDocImplementsTag */]: function forEachChildInJSDocImplementsTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || visitNode2(cbNode, node.class) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
  },
  [335 /* JSDocAugmentsTag */]: function forEachChildInJSDocAugmentsTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || visitNode2(cbNode, node.class) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
  },
  [352 /* JSDocTemplateTag */]: function forEachChildInJSDocTemplateTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || visitNode2(cbNode, node.constraint) || visitNodes(cbNode, cbNodes, node.typeParameters) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
  },
  [353 /* JSDocTypedefTag */]: function forEachChildInJSDocTypedefTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || (node.typeExpression && node.typeExpression.kind === 316 /* JSDocTypeExpression */ ? visitNode2(cbNode, node.typeExpression) || visitNode2(cbNode, node.fullName) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment)) : visitNode2(cbNode, node.fullName) || visitNode2(cbNode, node.typeExpression) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment)));
  },
  [345 /* JSDocCallbackTag */]: function forEachChildInJSDocCallbackTag(node, cbNode, cbNodes) {
    return visitNode2(cbNode, node.tagName) || visitNode2(cbNode, node.fullName) || visitNode2(cbNode, node.typeExpression) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
  },
  [349 /* JSDocReturnTag */]: forEachChildInJSDocTypeLikeTag,
  [351 /* JSDocTypeTag */]: forEachChildInJSDocTypeLikeTag,
  [350 /* JSDocThisTag */]: forEachChildInJSDocTypeLikeTag,
  [347 /* JSDocEnumTag */]: forEachChildInJSDocTypeLikeTag,
  [357 /* JSDocSatisfiesTag */]: forEachChildInJSDocTypeLikeTag,
  [356 /* JSDocThrowsTag */]: forEachChildInJSDocTypeLikeTag,
  [346 /* JSDocOverloadTag */]: forEachChildInJSDocTypeLikeTag,
  [330 /* JSDocSignature */]: function forEachChildInJSDocSignature(node, cbNode, _cbNodes) {
    return forEach(node.typeParameters, cbNode) || forEach(node.parameters, cbNode) || visitNode2(cbNode, node.type);
  },
  [331 /* JSDocLink */]: forEachChildInJSDocLinkCodeOrPlain,
  [332 /* JSDocLinkCode */]: forEachChildInJSDocLinkCodeOrPlain,
  [333 /* JSDocLinkPlain */]: forEachChildInJSDocLinkCodeOrPlain,
  [329 /* JSDocTypeLiteral */]: function forEachChildInJSDocTypeLiteral(node, cbNode, _cbNodes) {
    return forEach(node.jsDocPropertyTags, cbNode);
  },
  [334 /* JSDocTag */]: forEachChildInJSDocTag,
  [339 /* JSDocClassTag */]: forEachChildInJSDocTag,
  [340 /* JSDocPublicTag */]: forEachChildInJSDocTag,
  [341 /* JSDocPrivateTag */]: forEachChildInJSDocTag,
  [342 /* JSDocProtectedTag */]: forEachChildInJSDocTag,
  [343 /* JSDocReadonlyTag */]: forEachChildInJSDocTag,
  [338 /* JSDocDeprecatedTag */]: forEachChildInJSDocTag,
  [344 /* JSDocOverrideTag */]: forEachChildInJSDocTag,
  [360 /* PartiallyEmittedExpression */]: forEachChildInPartiallyEmittedExpression
};
function forEachChildInCallOrConstructSignature(node, cbNode, cbNodes) {
  return visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode2(cbNode, node.type);
}
function forEachChildInUnionOrIntersectionType(node, cbNode, cbNodes) {
  return visitNodes(cbNode, cbNodes, node.types);
}
function forEachChildInParenthesizedTypeOrTypeOperator(node, cbNode, _cbNodes) {
  return visitNode2(cbNode, node.type);
}
function forEachChildInObjectOrArrayBindingPattern(node, cbNode, cbNodes) {
  return visitNodes(cbNode, cbNodes, node.elements);
}
function forEachChildInCallOrNewExpression(node, cbNode, cbNodes) {
  return visitNode2(cbNode, node.expression) || // TODO: should we separate these branches out?
  visitNode2(cbNode, node.questionDotToken) || visitNodes(cbNode, cbNodes, node.typeArguments) || visitNodes(cbNode, cbNodes, node.arguments);
}
function forEachChildInBlock(node, cbNode, cbNodes) {
  return visitNodes(cbNode, cbNodes, node.statements);
}
function forEachChildInContinueOrBreakStatement(node, cbNode, _cbNodes) {
  return visitNode2(cbNode, node.label);
}
function forEachChildInClassDeclarationOrExpression(node, cbNode, cbNodes) {
  return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode2(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.heritageClauses) || visitNodes(cbNode, cbNodes, node.members);
}
function forEachChildInNamedImportsOrExports(node, cbNode, cbNodes) {
  return visitNodes(cbNode, cbNodes, node.elements);
}
function forEachChildInImportOrExportSpecifier(node, cbNode, _cbNodes) {
  return visitNode2(cbNode, node.propertyName) || visitNode2(cbNode, node.name);
}
function forEachChildInJsxOpeningOrSelfClosingElement(node, cbNode, cbNodes) {
  return visitNode2(cbNode, node.tagName) || visitNodes(cbNode, cbNodes, node.typeArguments) || visitNode2(cbNode, node.attributes);
}
function forEachChildInOptionalRestOrJSDocParameterModifier(node, cbNode, _cbNodes) {
  return visitNode2(cbNode, node.type);
}
function forEachChildInJSDocParameterOrPropertyTag(node, cbNode, cbNodes) {
  return visitNode2(cbNode, node.tagName) || (node.isNameFirst ? visitNode2(cbNode, node.name) || visitNode2(cbNode, node.typeExpression) : visitNode2(cbNode, node.typeExpression) || visitNode2(cbNode, node.name)) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
}
function forEachChildInJSDocTypeLikeTag(node, cbNode, cbNodes) {
  return visitNode2(cbNode, node.tagName) || visitNode2(cbNode, node.typeExpression) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
}
function forEachChildInJSDocLinkCodeOrPlain(node, cbNode, _cbNodes) {
  return visitNode2(cbNode, node.name);
}
function forEachChildInJSDocTag(node, cbNode, cbNodes) {
  return visitNode2(cbNode, node.tagName) || (typeof node.comment === "string" ? void 0 : visitNodes(cbNode, cbNodes, node.comment));
}
function forEachChildInPartiallyEmittedExpression(node, cbNode, _cbNodes) {
  return visitNode2(cbNode, node.expression);
}
function forEachChild(node, cbNode, cbNodes) {
  if (node === void 0 || node.kind <= 165 /* LastToken */) {
    return;
  }
  const fn = forEachChildTable[node.kind];
  return fn === void 0 ? void 0 : fn(node, cbNode, cbNodes);
}
function forEachChildRecursively(rootNode, cbNode, cbNodes) {
  const queue = gatherPossibleChildren(rootNode);
  const parents = [];
  while (parents.length < queue.length) {
    parents.push(rootNode);
  }
  while (queue.length !== 0) {
    const current = queue.pop();
    const parent2 = parents.pop();
    if (isArray(current)) {
      if (cbNodes) {
        const res = cbNodes(current, parent2);
        if (res) {
          if (res === "skip")
            continue;
          return res;
        }
      }
      for (let i = current.length - 1; i >= 0; --i) {
        queue.push(current[i]);
        parents.push(parent2);
      }
    } else {
      const res = cbNode(current, parent2);
      if (res) {
        if (res === "skip")
          continue;
        return res;
      }
      if (current.kind >= 166 /* FirstNode */) {
        for (const child of gatherPossibleChildren(current)) {
          queue.push(child);
          parents.push(current);
        }
      }
    }
  }
}
function gatherPossibleChildren(node) {
  const children = [];
  forEachChild(node, addWorkItem, addWorkItem);
  return children;
  function addWorkItem(n) {
    children.unshift(n);
  }
}
function setExternalModuleIndicator(sourceFile) {
  sourceFile.externalModuleIndicator = isFileProbablyExternalModule(sourceFile);
}
function createSourceFile(fileName, sourceText, languageVersionOrOptions, setParentNodes = false, scriptKind) {
  var _a, _b, _c, _d;
  (_a = tracing) == null ? void 0 : _a.push(
    tracing.Phase.Parse,
    "createSourceFile",
    { path: fileName },
    /*separateBeginAndEnd*/
    true
  );
  mark("beforeParse");
  let result;
  (_b = perfLogger) == null ? void 0 : _b.logStartParseSourceFile(fileName);
  const {
    languageVersion,
    setExternalModuleIndicator: overrideSetExternalModuleIndicator,
    impliedNodeFormat: format,
    jsDocParsingMode
  } = typeof languageVersionOrOptions === "object" ? languageVersionOrOptions : { languageVersion: languageVersionOrOptions };
  if (languageVersion === 100 /* JSON */) {
    result = Parser.parseSourceFile(
      fileName,
      sourceText,
      languageVersion,
      /*syntaxCursor*/
      void 0,
      setParentNodes,
      6 /* JSON */,
      noop,
      jsDocParsingMode
    );
  } else {
    const setIndicator = format === void 0 ? overrideSetExternalModuleIndicator : (file) => {
      file.impliedNodeFormat = format;
      return (overrideSetExternalModuleIndicator || setExternalModuleIndicator)(file);
    };
    result = Parser.parseSourceFile(
      fileName,
      sourceText,
      languageVersion,
      /*syntaxCursor*/
      void 0,
      setParentNodes,
      scriptKind,
      setIndicator,
      jsDocParsingMode
    );
  }
  (_c = perfLogger) == null ? void 0 : _c.logStopParseSourceFile();
  mark("afterParse");
  measure("Parse", "beforeParse", "afterParse");
  (_d = tracing) == null ? void 0 : _d.pop();
  return result;
}
function parseIsolatedEntityName(text, languageVersion) {
  return Parser.parseIsolatedEntityName(text, languageVersion);
}
function parseJsonText(fileName, sourceText) {
  return Parser.parseJsonText(fileName, sourceText);
}
function isExternalModule(file) {
  return file.externalModuleIndicator !== void 0;
}
function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks = false) {
  const newSourceFile = IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
  newSourceFile.flags |= sourceFile.flags & 12582912 /* PermanentlySetIncrementalFlags */;
  return newSourceFile;
}
function parseIsolatedJSDocComment(content, start2, length2) {
  const result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start2, length2);
  if (result && result.jsDoc) {
    Parser.fixupParentReferences(result.jsDoc);
  }
  return result;
}
function parseJSDocTypeExpressionForTests(content, start2, length2) {
  return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start2, length2);
}
var Parser;
((Parser2) => {
  var scanner2 = createScanner(
    99 /* Latest */,
    /*skipTrivia*/
    true
  );
  var disallowInAndDecoratorContext = 8192 /* DisallowInContext */ | 32768 /* DecoratorContext */;
  var NodeConstructor2;
  var TokenConstructor2;
  var IdentifierConstructor2;
  var PrivateIdentifierConstructor2;
  var SourceFileConstructor2;
  function countNode(node) {
    nodeCount++;
    return node;
  }
  var baseNodeFactory = {
    createBaseSourceFileNode: (kind) => countNode(new SourceFileConstructor2(
      kind,
      /*pos*/
      0,
      /*end*/
      0
    )),
    createBaseIdentifierNode: (kind) => countNode(new IdentifierConstructor2(
      kind,
      /*pos*/
      0,
      /*end*/
      0
    )),
    createBasePrivateIdentifierNode: (kind) => countNode(new PrivateIdentifierConstructor2(
      kind,
      /*pos*/
      0,
      /*end*/
      0
    )),
    createBaseTokenNode: (kind) => countNode(new TokenConstructor2(
      kind,
      /*pos*/
      0,
      /*end*/
      0
    )),
    createBaseNode: (kind) => countNode(new NodeConstructor2(
      kind,
      /*pos*/
      0,
      /*end*/
      0
    ))
  };
  var factory2 = createNodeFactory(1 /* NoParenthesizerRules */ | 2 /* NoNodeConverters */ | 8 /* NoOriginalNode */, baseNodeFactory);
  var {
    createNodeArray: factoryCreateNodeArray,
    createNumericLiteral: factoryCreateNumericLiteral,
    createStringLiteral: factoryCreateStringLiteral,
    createLiteralLikeNode: factoryCreateLiteralLikeNode,
    createIdentifier: factoryCreateIdentifier,
    createPrivateIdentifier: factoryCreatePrivateIdentifier,
    createToken: factoryCreateToken,
    createArrayLiteralExpression: factoryCreateArrayLiteralExpression,
    createObjectLiteralExpression: factoryCreateObjectLiteralExpression,
    createPropertyAccessExpression: factoryCreatePropertyAccessExpression,
    createPropertyAccessChain: factoryCreatePropertyAccessChain,
    createElementAccessExpression: factoryCreateElementAccessExpression,
    createElementAccessChain: factoryCreateElementAccessChain,
    createCallExpression: factoryCreateCallExpression,
    createCallChain: factoryCreateCallChain,
    createNewExpression: factoryCreateNewExpression,
    createParenthesizedExpression: factoryCreateParenthesizedExpression,
    createBlock: factoryCreateBlock,
    createVariableStatement: factoryCreateVariableStatement,
    createExpressionStatement: factoryCreateExpressionStatement,
    createIfStatement: factoryCreateIfStatement,
    createWhileStatement: factoryCreateWhileStatement,
    createForStatement: factoryCreateForStatement,
    createForOfStatement: factoryCreateForOfStatement,
    createVariableDeclaration: factoryCreateVariableDeclaration,
    createVariableDeclarationList: factoryCreateVariableDeclarationList
  } = factory2;
  var fileName;
  var sourceFlags;
  var sourceText;
  var languageVersion;
  var scriptKind;
  var languageVariant;
  var parseDiagnostics;
  var jsDocDiagnostics;
  var syntaxCursor;
  var currentToken;
  var nodeCount;
  var identifiers;
  var identifierCount;
  var parsingContext;
  var notParenthesizedArrow;
  var contextFlags;
  var topLevel = true;
  var parseErrorBeforeNextFinishedNode = false;
  function parseSourceFile(fileName2, sourceText2, languageVersion2, syntaxCursor2, setParentNodes = false, scriptKind2, setExternalModuleIndicatorOverride, jsDocParsingMode = 0 /* ParseAll */) {
    var _a;
    scriptKind2 = ensureScriptKind(fileName2, scriptKind2);
    if (scriptKind2 === 6 /* JSON */) {
      const result2 = parseJsonText2(fileName2, sourceText2, languageVersion2, syntaxCursor2, setParentNodes);
      convertToJson(
        result2,
        (_a = result2.statements[0]) == null ? void 0 : _a.expression,
        result2.parseDiagnostics,
        /*returnValue*/
        false,
        /*jsonConversionNotifier*/
        void 0
      );
      result2.referencedFiles = emptyArray;
      result2.typeReferenceDirectives = emptyArray;
      result2.libReferenceDirectives = emptyArray;
      result2.amdDependencies = emptyArray;
      result2.hasNoDefaultLib = false;
      result2.pragmas = emptyMap;
      return result2;
    }
    initializeState(fileName2, sourceText2, languageVersion2, syntaxCursor2, scriptKind2, jsDocParsingMode);
    const result = parseSourceFileWorker(languageVersion2, setParentNodes, scriptKind2, setExternalModuleIndicatorOverride || setExternalModuleIndicator, jsDocParsingMode);
    clearState();
    return result;
  }
  Parser2.parseSourceFile = parseSourceFile;
  function parseIsolatedEntityName2(content, languageVersion2) {
    initializeState(
      "",
      content,
      languageVersion2,
      /*syntaxCursor*/
      void 0,
      1 /* JS */,
      0 /* ParseAll */
    );
    nextToken();
    const entityName = parseEntityName(
      /*allowReservedWords*/
      true
    );
    const isValid = token() === 1 /* EndOfFileToken */ && !parseDiagnostics.length;
    clearState();
    return isValid ? entityName : void 0;
  }
  Parser2.parseIsolatedEntityName = parseIsolatedEntityName2;
  function parseJsonText2(fileName2, sourceText2, languageVersion2 = 2 /* ES2015 */, syntaxCursor2, setParentNodes = false) {
    initializeState(fileName2, sourceText2, languageVersion2, syntaxCursor2, 6 /* JSON */, 0 /* ParseAll */);
    sourceFlags = contextFlags;
    nextToken();
    const pos = getNodePos();
    let statements, endOfFileToken;
    if (token() === 1 /* EndOfFileToken */) {
      statements = createNodeArray([], pos, pos);
      endOfFileToken = parseTokenNode();
    } else {
      let expressions;
      while (token() !== 1 /* EndOfFileToken */) {
        let expression2;
        switch (token()) {
          case 23 /* OpenBracketToken */:
            expression2 = parseArrayLiteralExpression();
            break;
          case 112 /* TrueKeyword */:
          case 97 /* FalseKeyword */:
          case 106 /* NullKeyword */:
            expression2 = parseTokenNode();
            break;
          case 41 /* MinusToken */:
            if (lookAhead(() => nextToken() === 9 /* NumericLiteral */ && nextToken() !== 59 /* ColonToken */)) {
              expression2 = parsePrefixUnaryExpression();
            } else {
              expression2 = parseObjectLiteralExpression();
            }
            break;
          case 9 /* NumericLiteral */:
          case 11 /* StringLiteral */:
            if (lookAhead(() => nextToken() !== 59 /* ColonToken */)) {
              expression2 = parseLiteralNode();
              break;
            }
          default:
            expression2 = parseObjectLiteralExpression();
            break;
        }
        if (expressions && isArray(expressions)) {
          expressions.push(expression2);
        } else if (expressions) {
          expressions = [expressions, expression2];
        } else {
          expressions = expression2;
          if (token() !== 1 /* EndOfFileToken */) {
            parseErrorAtCurrentToken(Diagnostics.Unexpected_token);
          }
        }
      }
      const expression = isArray(expressions) ? finishNode(factoryCreateArrayLiteralExpression(expressions), pos) : Debug.checkDefined(expressions);
      const statement = factoryCreateExpressionStatement(expression);
      finishNode(statement, pos);
      statements = createNodeArray([statement], pos);
      endOfFileToken = parseExpectedToken(1 /* EndOfFileToken */, Diagnostics.Unexpected_token);
    }
    const sourceFile = createSourceFile2(
      fileName2,
      2 /* ES2015 */,
      6 /* JSON */,
      /*isDeclarationFile*/
      false,
      statements,
      endOfFileToken,
      sourceFlags,
      noop
    );
    if (setParentNodes) {
      fixupParentReferences(sourceFile);
    }
    sourceFile.nodeCount = nodeCount;
    sourceFile.identifierCount = identifierCount;
    sourceFile.identifiers = identifiers;
    sourceFile.parseDiagnostics = attachFileToDiagnostics(parseDiagnostics, sourceFile);
    if (jsDocDiagnostics) {
      sourceFile.jsDocDiagnostics = attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
    }
    const result = sourceFile;
    clearState();
    return result;
  }
  Parser2.parseJsonText = parseJsonText2;
  function initializeState(_fileName, _sourceText, _languageVersion, _syntaxCursor, _scriptKind, _jsDocParsingMode) {
    NodeConstructor2 = objectAllocator.getNodeConstructor();
    TokenConstructor2 = objectAllocator.getTokenConstructor();
    IdentifierConstructor2 = objectAllocator.getIdentifierConstructor();
    PrivateIdentifierConstructor2 = objectAllocator.getPrivateIdentifierConstructor();
    SourceFileConstructor2 = objectAllocator.getSourceFileConstructor();
    fileName = normalizePath(_fileName);
    sourceText = _sourceText;
    languageVersion = _languageVersion;
    syntaxCursor = _syntaxCursor;
    scriptKind = _scriptKind;
    languageVariant = getLanguageVariant(_scriptKind);
    parseDiagnostics = [];
    parsingContext = 0;
    identifiers = /* @__PURE__ */ new Map();
    identifierCount = 0;
    nodeCount = 0;
    sourceFlags = 0;
    topLevel = true;
    switch (scriptKind) {
      case 1 /* JS */:
      case 2 /* JSX */:
        contextFlags = 524288 /* JavaScriptFile */;
        break;
      case 6 /* JSON */:
        contextFlags = 524288 /* JavaScriptFile */ | 134217728 /* JsonFile */;
        break;
      default:
        contextFlags = 0 /* None */;
        break;
    }
    parseErrorBeforeNextFinishedNode = false;
    scanner2.setText(sourceText);
    scanner2.setOnError(scanError);
    scanner2.setScriptTarget(languageVersion);
    scanner2.setLanguageVariant(languageVariant);
    scanner2.setScriptKind(scriptKind);
    scanner2.setJSDocParsingMode(_jsDocParsingMode);
  }
  function clearState() {
    scanner2.clearCommentDirectives();
    scanner2.setText("");
    scanner2.setOnError(void 0);
    scanner2.setScriptKind(0 /* Unknown */);
    scanner2.setJSDocParsingMode(0 /* ParseAll */);
    sourceText = void 0;
    languageVersion = void 0;
    syntaxCursor = void 0;
    scriptKind = void 0;
    languageVariant = void 0;
    sourceFlags = 0;
    parseDiagnostics = void 0;
    jsDocDiagnostics = void 0;
    parsingContext = 0;
    identifiers = void 0;
    notParenthesizedArrow = void 0;
    topLevel = true;
  }
  function parseSourceFileWorker(languageVersion2, setParentNodes, scriptKind2, setExternalModuleIndicator2, jsDocParsingMode) {
    const isDeclarationFile = isDeclarationFileName(fileName);
    if (isDeclarationFile) {
      contextFlags |= 33554432 /* Ambient */;
    }
    sourceFlags = contextFlags;
    nextToken();
    const statements = parseList(0 /* SourceElements */, parseStatement);
    Debug.assert(token() === 1 /* EndOfFileToken */);
    const endHasJSDoc = hasPrecedingJSDocComment();
    const endOfFileToken = withJSDoc(parseTokenNode(), endHasJSDoc);
    const sourceFile = createSourceFile2(fileName, languageVersion2, scriptKind2, isDeclarationFile, statements, endOfFileToken, sourceFlags, setExternalModuleIndicator2);
    processCommentPragmas(sourceFile, sourceText);
    processPragmasIntoFields(sourceFile, reportPragmaDiagnostic);
    sourceFile.commentDirectives = scanner2.getCommentDirectives();
    sourceFile.nodeCount = nodeCount;
    sourceFile.identifierCount = identifierCount;
    sourceFile.identifiers = identifiers;
    sourceFile.parseDiagnostics = attachFileToDiagnostics(parseDiagnostics, sourceFile);
    sourceFile.jsDocParsingMode = jsDocParsingMode;
    if (jsDocDiagnostics) {
      sourceFile.jsDocDiagnostics = attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
    }
    if (setParentNodes) {
      fixupParentReferences(sourceFile);
    }
    return sourceFile;
    function reportPragmaDiagnostic(pos, end, diagnostic) {
      parseDiagnostics.push(createDetachedDiagnostic(fileName, sourceText, pos, end, diagnostic));
    }
  }
  let hasDeprecatedTag = false;
  function withJSDoc(node, hasJSDoc) {
    if (!hasJSDoc) {
      return node;
    }
    Debug.assert(!node.jsDoc);
    const jsDoc = mapDefined(getJSDocCommentRanges(node, sourceText), (comment) => JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos));
    if (jsDoc.length)
      node.jsDoc = jsDoc;
    if (hasDeprecatedTag) {
      hasDeprecatedTag = false;
      node.flags |= 536870912 /* Deprecated */;
    }
    return node;
  }
  function reparseTopLevelAwait(sourceFile) {
    const savedSyntaxCursor = syntaxCursor;
    const baseSyntaxCursor = IncrementalParser.createSyntaxCursor(sourceFile);
    syntaxCursor = { currentNode: currentNode2 };
    const statements = [];
    const savedParseDiagnostics = parseDiagnostics;
    parseDiagnostics = [];
    let pos = 0;
    let start2 = findNextStatementWithAwait(sourceFile.statements, 0);
    while (start2 !== -1) {
      const prevStatement = sourceFile.statements[pos];
      const nextStatement = sourceFile.statements[start2];
      addRange(statements, sourceFile.statements, pos, start2);
      pos = findNextStatementWithoutAwait(sourceFile.statements, start2);
      const diagnosticStart = findIndex(savedParseDiagnostics, (diagnostic) => diagnostic.start >= prevStatement.pos);
      const diagnosticEnd = diagnosticStart >= 0 ? findIndex(savedParseDiagnostics, (diagnostic) => diagnostic.start >= nextStatement.pos, diagnosticStart) : -1;
      if (diagnosticStart >= 0) {
        addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart, diagnosticEnd >= 0 ? diagnosticEnd : void 0);
      }
      speculationHelper(() => {
        const savedContextFlags = contextFlags;
        contextFlags |= 65536 /* AwaitContext */;
        scanner2.resetTokenState(nextStatement.pos);
        nextToken();
        while (token() !== 1 /* EndOfFileToken */) {
          const startPos = scanner2.getTokenFullStart();
          const statement = parseListElement(0 /* SourceElements */, parseStatement);
          statements.push(statement);
          if (startPos === scanner2.getTokenFullStart()) {
            nextToken();
          }
          if (pos >= 0) {
            const nonAwaitStatement = sourceFile.statements[pos];
            if (statement.end === nonAwaitStatement.pos) {
              break;
            }
            if (statement.end > nonAwaitStatement.pos) {
              pos = findNextStatementWithoutAwait(sourceFile.statements, pos + 1);
            }
          }
        }
        contextFlags = savedContextFlags;
      }, 2 /* Reparse */);
      start2 = pos >= 0 ? findNextStatementWithAwait(sourceFile.statements, pos) : -1;
    }
    if (pos >= 0) {
      const prevStatement = sourceFile.statements[pos];
      addRange(statements, sourceFile.statements, pos);
      const diagnosticStart = findIndex(savedParseDiagnostics, (diagnostic) => diagnostic.start >= prevStatement.pos);
      if (diagnosticStart >= 0) {
        addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart);
      }
    }
    syntaxCursor = savedSyntaxCursor;
    return factory2.updateSourceFile(sourceFile, setTextRange(factoryCreateNodeArray(statements), sourceFile.statements));
    function containsPossibleTopLevelAwait(node) {
      return !(node.flags & 65536 /* AwaitContext */) && !!(node.transformFlags & 67108864 /* ContainsPossibleTopLevelAwait */);
    }
    function findNextStatementWithAwait(statements2, start3) {
      for (let i = start3; i < statements2.length; i++) {
        if (containsPossibleTopLevelAwait(statements2[i])) {
          return i;
        }
      }
      return -1;
    }
    function findNextStatementWithoutAwait(statements2, start3) {
      for (let i = start3; i < statements2.length; i++) {
        if (!containsPossibleTopLevelAwait(statements2[i])) {
          return i;
        }
      }
      return -1;
    }
    function currentNode2(position) {
      const node = baseSyntaxCursor.currentNode(position);
      if (topLevel && node && containsPossibleTopLevelAwait(node)) {
        node.intersectsChange = true;
      }
      return node;
    }
  }
  function fixupParentReferences(rootNode) {
    setParentRecursive(
      rootNode,
      /*incremental*/
      true
    );
  }
  Parser2.fixupParentReferences = fixupParentReferences;
  function createSourceFile2(fileName2, languageVersion2, scriptKind2, isDeclarationFile, statements, endOfFileToken, flags, setExternalModuleIndicator2) {
    let sourceFile = factory2.createSourceFile(statements, endOfFileToken, flags);
    setTextRangePosWidth(sourceFile, 0, sourceText.length);
    setFields(sourceFile);
    if (!isDeclarationFile && isExternalModule(sourceFile) && sourceFile.transformFlags & 67108864 /* ContainsPossibleTopLevelAwait */) {
      const oldSourceFile = sourceFile;
      sourceFile = reparseTopLevelAwait(sourceFile);
      if (oldSourceFile !== sourceFile)
        setFields(sourceFile);
    }
    return sourceFile;
    function setFields(sourceFile2) {
      sourceFile2.text = sourceText;
      sourceFile2.bindDiagnostics = [];
      sourceFile2.bindSuggestionDiagnostics = void 0;
      sourceFile2.languageVersion = languageVersion2;
      sourceFile2.fileName = fileName2;
      sourceFile2.languageVariant = getLanguageVariant(scriptKind2);
      sourceFile2.isDeclarationFile = isDeclarationFile;
      sourceFile2.scriptKind = scriptKind2;
      setExternalModuleIndicator2(sourceFile2);
      sourceFile2.setExternalModuleIndicator = setExternalModuleIndicator2;
    }
  }
  function setContextFlag(val, flag) {
    if (val) {
      contextFlags |= flag;
    } else {
      contextFlags &= ~flag;
    }
  }
  function setDisallowInContext(val) {
    setContextFlag(val, 8192 /* DisallowInContext */);
  }
  function setYieldContext(val) {
    setContextFlag(val, 16384 /* YieldContext */);
  }
  function setDecoratorContext(val) {
    setContextFlag(val, 32768 /* DecoratorContext */);
  }
  function setAwaitContext(val) {
    setContextFlag(val, 65536 /* AwaitContext */);
  }
  function doOutsideOfContext(context, func) {
    const contextFlagsToClear = context & contextFlags;
    if (contextFlagsToClear) {
      setContextFlag(
        /*val*/
        false,
        contextFlagsToClear
      );
      const result = func();
      setContextFlag(
        /*val*/
        true,
        contextFlagsToClear
      );
      return result;
    }
    return func();
  }
  function doInsideOfContext(context, func) {
    const contextFlagsToSet = context & ~contextFlags;
    if (contextFlagsToSet) {
      setContextFlag(
        /*val*/
        true,
        contextFlagsToSet
      );
      const result = func();
      setContextFlag(
        /*val*/
        false,
        contextFlagsToSet
      );
      return result;
    }
    return func();
  }
  function allowInAnd(func) {
    return doOutsideOfContext(8192 /* DisallowInContext */, func);
  }
  function disallowInAnd(func) {
    return doInsideOfContext(8192 /* DisallowInContext */, func);
  }
  function allowConditionalTypesAnd(func) {
    return doOutsideOfContext(131072 /* DisallowConditionalTypesContext */, func);
  }
  function disallowConditionalTypesAnd(func) {
    return doInsideOfContext(131072 /* DisallowConditionalTypesContext */, func);
  }
  function doInYieldContext(func) {
    return doInsideOfContext(16384 /* YieldContext */, func);
  }
  function doInDecoratorContext(func) {
    return doInsideOfContext(32768 /* DecoratorContext */, func);
  }
  function doInAwaitContext(func) {
    return doInsideOfContext(65536 /* AwaitContext */, func);
  }
  function doOutsideOfAwaitContext(func) {
    return doOutsideOfContext(65536 /* AwaitContext */, func);
  }
  function doInYieldAndAwaitContext(func) {
    return doInsideOfContext(16384 /* YieldContext */ | 65536 /* AwaitContext */, func);
  }
  function doOutsideOfYieldAndAwaitContext(func) {
    return doOutsideOfContext(16384 /* YieldContext */ | 65536 /* AwaitContext */, func);
  }
  function inContext(flags) {
    return (contextFlags & flags) !== 0;
  }
  function inYieldContext() {
    return inContext(16384 /* YieldContext */);
  }
  function inDisallowInContext() {
    return inContext(8192 /* DisallowInContext */);
  }
  function inDisallowConditionalTypesContext() {
    return inContext(131072 /* DisallowConditionalTypesContext */);
  }
  function inDecoratorContext() {
    return inContext(32768 /* DecoratorContext */);
  }
  function inAwaitContext() {
    return inContext(65536 /* AwaitContext */);
  }
  function parseErrorAtCurrentToken(message, ...args) {
    return parseErrorAt(scanner2.getTokenStart(), scanner2.getTokenEnd(), message, ...args);
  }
  function parseErrorAtPosition(start2, length2, message, ...args) {
    const lastError = lastOrUndefined(parseDiagnostics);
    let result;
    if (!lastError || start2 !== lastError.start) {
      result = createDetachedDiagnostic(fileName, sourceText, start2, length2, message, ...args);
      parseDiagnostics.push(result);
    }
    parseErrorBeforeNextFinishedNode = true;
    return result;
  }
  function parseErrorAt(start2, end, message, ...args) {
    return parseErrorAtPosition(start2, end - start2, message, ...args);
  }
  function parseErrorAtRange(range, message, ...args) {
    parseErrorAt(range.pos, range.end, message, ...args);
  }
  function scanError(message, length2, arg0) {
    parseErrorAtPosition(scanner2.getTokenEnd(), length2, message, arg0);
  }
  function getNodePos() {
    return scanner2.getTokenFullStart();
  }
  function hasPrecedingJSDocComment() {
    return scanner2.hasPrecedingJSDocComment();
  }
  function token() {
    return currentToken;
  }
  function nextTokenWithoutCheck() {
    return currentToken = scanner2.scan();
  }
  function nextTokenAnd(func) {
    nextToken();
    return func();
  }
  function nextToken() {
    if (isKeyword(currentToken) && (scanner2.hasUnicodeEscape() || scanner2.hasExtendedUnicodeEscape())) {
      parseErrorAt(scanner2.getTokenStart(), scanner2.getTokenEnd(), Diagnostics.Keywords_cannot_contain_escape_characters);
    }
    return nextTokenWithoutCheck();
  }
  function nextTokenJSDoc() {
    return currentToken = scanner2.scanJsDocToken();
  }
  function nextJSDocCommentTextToken(inBackticks) {
    return currentToken = scanner2.scanJSDocCommentTextToken(inBackticks);
  }
  function reScanGreaterToken() {
    return currentToken = scanner2.reScanGreaterToken();
  }
  function reScanSlashToken() {
    return currentToken = scanner2.reScanSlashToken();
  }
  function reScanTemplateToken(isTaggedTemplate) {
    return currentToken = scanner2.reScanTemplateToken(isTaggedTemplate);
  }
  function reScanLessThanToken() {
    return currentToken = scanner2.reScanLessThanToken();
  }
  function reScanHashToken() {
    return currentToken = scanner2.reScanHashToken();
  }
  function scanJsxIdentifier() {
    return currentToken = scanner2.scanJsxIdentifier();
  }
  function scanJsxText() {
    return currentToken = scanner2.scanJsxToken();
  }
  function scanJsxAttributeValue() {
    return currentToken = scanner2.scanJsxAttributeValue();
  }
  function speculationHelper(callback, speculationKind) {
    const saveToken = currentToken;
    const saveParseDiagnosticsLength = parseDiagnostics.length;
    const saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;
    const saveContextFlags = contextFlags;
    const result = speculationKind !== 0 /* TryParse */ ? scanner2.lookAhead(callback) : scanner2.tryScan(callback);
    Debug.assert(saveContextFlags === contextFlags);
    if (!result || speculationKind !== 0 /* TryParse */) {
      currentToken = saveToken;
      if (speculationKind !== 2 /* Reparse */) {
        parseDiagnostics.length = saveParseDiagnosticsLength;
      }
      parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;
    }
    return result;
  }
  function lookAhead(callback) {
    return speculationHelper(callback, 1 /* Lookahead */);
  }
  function tryParse(callback) {
    return speculationHelper(callback, 0 /* TryParse */);
  }
  function isBindingIdentifier() {
    if (token() === 80 /* Identifier */) {
      return true;
    }
    return token() > 118 /* LastReservedWord */;
  }
  function isIdentifier2() {
    if (token() === 80 /* Identifier */) {
      return true;
    }
    if (token() === 127 /* YieldKeyword */ && inYieldContext()) {
      return false;
    }
    if (token() === 135 /* AwaitKeyword */ && inAwaitContext()) {
      return false;
    }
    return token() > 118 /* LastReservedWord */;
  }
  function parseExpected(kind, diagnosticMessage, shouldAdvance = true) {
    if (token() === kind) {
      if (shouldAdvance) {
        nextToken();
      }
      return true;
    }
    if (diagnosticMessage) {
      parseErrorAtCurrentToken(diagnosticMessage);
    } else {
      parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind));
    }
    return false;
  }
  const viableKeywordSuggestions = Object.keys(textToKeywordObj).filter((keyword) => keyword.length > 2);
  function parseErrorForMissingSemicolonAfter(node) {
    if (isTaggedTemplateExpression(node)) {
      parseErrorAt(skipTrivia(sourceText, node.template.pos), node.template.end, Diagnostics.Module_declaration_names_may_only_use_or_quoted_strings);
      return;
    }
    const expressionText = isIdentifier(node) ? idText(node) : void 0;
    if (!expressionText || !isIdentifierText(expressionText, languageVersion)) {
      parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(27 /* SemicolonToken */));
      return;
    }
    const pos = skipTrivia(sourceText, node.pos);
    switch (expressionText) {
      case "const":
      case "let":
      case "var":
        parseErrorAt(pos, node.end, Diagnostics.Variable_declaration_not_allowed_at_this_location);
        return;
      case "declare":
        return;
      case "interface":
        parseErrorForInvalidName(Diagnostics.Interface_name_cannot_be_0, Diagnostics.Interface_must_be_given_a_name, 19 /* OpenBraceToken */);
        return;
      case "is":
        parseErrorAt(pos, scanner2.getTokenStart(), Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
        return;
      case "module":
      case "namespace":
        parseErrorForInvalidName(Diagnostics.Namespace_name_cannot_be_0, Diagnostics.Namespace_must_be_given_a_name, 19 /* OpenBraceToken */);
        return;
      case "type":
        parseErrorForInvalidName(Diagnostics.Type_alias_name_cannot_be_0, Diagnostics.Type_alias_must_be_given_a_name, 64 /* EqualsToken */);
        return;
    }
    const suggestion = getSpellingSuggestion(expressionText, viableKeywordSuggestions, (n) => n) ?? getSpaceSuggestion(expressionText);
    if (suggestion) {
      parseErrorAt(pos, node.end, Diagnostics.Unknown_keyword_or_identifier_Did_you_mean_0, suggestion);
      return;
    }
    if (token() === 0 /* Unknown */) {
      return;
    }
    parseErrorAt(pos, node.end, Diagnostics.Unexpected_keyword_or_identifier);
  }
  function parseErrorForInvalidName(nameDiagnostic, blankDiagnostic, tokenIfBlankName) {
    if (token() === tokenIfBlankName) {
      parseErrorAtCurrentToken(blankDiagnostic);
    } else {
      parseErrorAtCurrentToken(nameDiagnostic, scanner2.getTokenValue());
    }
  }
  function getSpaceSuggestion(expressionText) {
    for (const keyword of viableKeywordSuggestions) {
      if (expressionText.length > keyword.length + 2 && startsWith(expressionText, keyword)) {
        return `${keyword} ${expressionText.slice(keyword.length)}`;
      }
    }
    return void 0;
  }
  function parseSemicolonAfterPropertyName(name, type, initializer) {
    if (token() === 60 /* AtToken */ && !scanner2.hasPrecedingLineBreak()) {
      parseErrorAtCurrentToken(Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);
      return;
    }
    if (token() === 21 /* OpenParenToken */) {
      parseErrorAtCurrentToken(Diagnostics.Cannot_start_a_function_call_in_a_type_annotation);
      nextToken();
      return;
    }
    if (type && !canParseSemicolon()) {
      if (initializer) {
        parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(27 /* SemicolonToken */));
      } else {
        parseErrorAtCurrentToken(Diagnostics.Expected_for_property_initializer);
      }
      return;
    }
    if (tryParseSemicolon()) {
      return;
    }
    if (initializer) {
      parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(27 /* SemicolonToken */));
      return;
    }
    parseErrorForMissingSemicolonAfter(name);
  }
  function parseExpectedJSDoc(kind) {
    if (token() === kind) {
      nextTokenJSDoc();
      return true;
    }
    Debug.assert(isKeywordOrPunctuation(kind));
    parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind));
    return false;
  }
  function parseExpectedMatchingBrackets(openKind, closeKind, openParsed, openPosition) {
    if (token() === closeKind) {
      nextToken();
      return;
    }
    const lastError = parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(closeKind));
    if (!openParsed) {
      return;
    }
    if (lastError) {
      addRelatedInfo(
        lastError,
        createDetachedDiagnostic(fileName, sourceText, openPosition, 1, Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, tokenToString(openKind), tokenToString(closeKind))
      );
    }
  }
  function parseOptional(t) {
    if (token() === t) {
      nextToken();
      return true;
    }
    return false;
  }
  function parseOptionalToken(t) {
    if (token() === t) {
      return parseTokenNode();
    }
    return void 0;
  }
  function parseOptionalTokenJSDoc(t) {
    if (token() === t) {
      return parseTokenNodeJSDoc();
    }
    return void 0;
  }
  function parseExpectedToken(t, diagnosticMessage, arg0) {
    return parseOptionalToken(t) || createMissingNode(
      t,
      /*reportAtCurrentPosition*/
      false,
      diagnosticMessage || Diagnostics._0_expected,
      arg0 || tokenToString(t)
    );
  }
  function parseExpectedTokenJSDoc(t) {
    const optional = parseOptionalTokenJSDoc(t);
    if (optional)
      return optional;
    Debug.assert(isKeywordOrPunctuation(t));
    return createMissingNode(
      t,
      /*reportAtCurrentPosition*/
      false,
      Diagnostics._0_expected,
      tokenToString(t)
    );
  }
  function parseTokenNode() {
    const pos = getNodePos();
    const kind = token();
    nextToken();
    return finishNode(factoryCreateToken(kind), pos);
  }
  function parseTokenNodeJSDoc() {
    const pos = getNodePos();
    const kind = token();
    nextTokenJSDoc();
    return finishNode(factoryCreateToken(kind), pos);
  }
  function canParseSemicolon() {
    if (token() === 27 /* SemicolonToken */) {
      return true;
    }
    return token() === 20 /* CloseBraceToken */ || token() === 1 /* EndOfFileToken */ || scanner2.hasPrecedingLineBreak();
  }
  function tryParseSemicolon() {
    if (!canParseSemicolon()) {
      return false;
    }
    if (token() === 27 /* SemicolonToken */) {
      nextToken();
    }
    return true;
  }
  function parseSemicolon() {
    return tryParseSemicolon() || parseExpected(27 /* SemicolonToken */);
  }
  function createNodeArray(elements, pos, end, hasTrailingComma) {
    const array = factoryCreateNodeArray(elements, hasTrailingComma);
    setTextRangePosEnd(array, pos, end ?? scanner2.getTokenFullStart());
    return array;
  }
  function finishNode(node, pos, end) {
    setTextRangePosEnd(node, pos, end ?? scanner2.getTokenFullStart());
    if (contextFlags) {
      node.flags |= contextFlags;
    }
    if (parseErrorBeforeNextFinishedNode) {
      parseErrorBeforeNextFinishedNode = false;
      node.flags |= 262144 /* ThisNodeHasError */;
    }
    return node;
  }
  function createMissingNode(kind, reportAtCurrentPosition, diagnosticMessage, ...args) {
    if (reportAtCurrentPosition) {
      parseErrorAtPosition(scanner2.getTokenFullStart(), 0, diagnosticMessage, ...args);
    } else if (diagnosticMessage) {
      parseErrorAtCurrentToken(diagnosticMessage, ...args);
    }
    const pos = getNodePos();
    const result = kind === 80 /* Identifier */ ? factoryCreateIdentifier(
      "",
      /*originalKeywordKind*/
      void 0
    ) : isTemplateLiteralKind(kind) ? factory2.createTemplateLiteralLikeNode(
      kind,
      "",
      "",
      /*templateFlags*/
      void 0
    ) : kind === 9 /* NumericLiteral */ ? factoryCreateNumericLiteral(
      "",
      /*numericLiteralFlags*/
      void 0
    ) : kind === 11 /* StringLiteral */ ? factoryCreateStringLiteral(
      "",
      /*isSingleQuote*/
      void 0
    ) : kind === 282 /* MissingDeclaration */ ? factory2.createMissingDeclaration() : factoryCreateToken(kind);
    return finishNode(result, pos);
  }
  function internIdentifier(text) {
    let identifier = identifiers.get(text);
    if (identifier === void 0) {
      identifiers.set(text, identifier = text);
    }
    return identifier;
  }
  function createIdentifier(isIdentifier3, diagnosticMessage, privateIdentifierDiagnosticMessage) {
    if (isIdentifier3) {
      identifierCount++;
      const pos = getNodePos();
      const originalKeywordKind = token();
      const text = internIdentifier(scanner2.getTokenValue());
      const hasExtendedUnicodeEscape = scanner2.hasExtendedUnicodeEscape();
      nextTokenWithoutCheck();
      return finishNode(factoryCreateIdentifier(text, originalKeywordKind, hasExtendedUnicodeEscape), pos);
    }
    if (token() === 81 /* PrivateIdentifier */) {
      parseErrorAtCurrentToken(privateIdentifierDiagnosticMessage || Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
      return createIdentifier(
        /*isIdentifier*/
        true
      );
    }
    if (token() === 0 /* Unknown */ && scanner2.tryScan(() => scanner2.reScanInvalidIdentifier() === 80 /* Identifier */)) {
      return createIdentifier(
        /*isIdentifier*/
        true
      );
    }
    identifierCount++;
    const reportAtCurrentPosition = token() === 1 /* EndOfFileToken */;
    const isReservedWord = scanner2.isReservedWord();
    const msgArg = scanner2.getTokenText();
    const defaultMessage = isReservedWord ? Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here : Diagnostics.Identifier_expected;
    return createMissingNode(80 /* Identifier */, reportAtCurrentPosition, diagnosticMessage || defaultMessage, msgArg);
  }
  function parseBindingIdentifier(privateIdentifierDiagnosticMessage) {
    return createIdentifier(
      isBindingIdentifier(),
      /*diagnosticMessage*/
      void 0,
      privateIdentifierDiagnosticMessage
    );
  }
  function parseIdentifier(diagnosticMessage, privateIdentifierDiagnosticMessage) {
    return createIdentifier(isIdentifier2(), diagnosticMessage, privateIdentifierDiagnosticMessage);
  }
  function parseIdentifierName(diagnosticMessage) {
    return createIdentifier(tokenIsIdentifierOrKeyword(token()), diagnosticMessage);
  }
  function parseIdentifierNameErrorOnUnicodeEscapeSequence() {
    if (scanner2.hasUnicodeEscape() || scanner2.hasExtendedUnicodeEscape()) {
      parseErrorAtCurrentToken(Diagnostics.Unicode_escape_sequence_cannot_appear_here);
    }
    return createIdentifier(tokenIsIdentifierOrKeyword(token()));
  }
  function isLiteralPropertyName() {
    return tokenIsIdentifierOrKeyword(token()) || token() === 11 /* StringLiteral */ || token() === 9 /* NumericLiteral */;
  }
  function isImportAttributeName2() {
    return tokenIsIdentifierOrKeyword(token()) || token() === 11 /* StringLiteral */;
  }
  function parsePropertyNameWorker(allowComputedPropertyNames) {
    if (token() === 11 /* StringLiteral */ || token() === 9 /* NumericLiteral */) {
      const node = parseLiteralNode();
      node.text = internIdentifier(node.text);
      return node;
    }
    if (allowComputedPropertyNames && token() === 23 /* OpenBracketToken */) {
      return parseComputedPropertyName();
    }
    if (token() === 81 /* PrivateIdentifier */) {
      return parsePrivateIdentifier();
    }
    return parseIdentifierName();
  }
  function parsePropertyName() {
    return parsePropertyNameWorker(
      /*allowComputedPropertyNames*/
      true
    );
  }
  function parseComputedPropertyName() {
    const pos = getNodePos();
    parseExpected(23 /* OpenBracketToken */);
    const expression = allowInAnd(parseExpression);
    parseExpected(24 /* CloseBracketToken */);
    return finishNode(factory2.createComputedPropertyName(expression), pos);
  }
  function parsePrivateIdentifier() {
    const pos = getNodePos();
    const node = factoryCreatePrivateIdentifier(internIdentifier(scanner2.getTokenValue()));
    nextToken();
    return finishNode(node, pos);
  }
  function parseContextualModifier(t) {
    return token() === t && tryParse(nextTokenCanFollowModifier);
  }
  function nextTokenIsOnSameLineAndCanFollowModifier() {
    nextToken();
    if (scanner2.hasPrecedingLineBreak()) {
      return false;
    }
    return canFollowModifier();
  }
  function nextTokenCanFollowModifier() {
    switch (token()) {
      case 87 /* ConstKeyword */:
        return nextToken() === 94 /* EnumKeyword */;
      case 95 /* ExportKeyword */:
        nextToken();
        if (token() === 90 /* DefaultKeyword */) {
          return lookAhead(nextTokenCanFollowDefaultKeyword);
        }
        if (token() === 156 /* TypeKeyword */) {
          return lookAhead(nextTokenCanFollowExportModifier);
        }
        return canFollowExportModifier();
      case 90 /* DefaultKeyword */:
        return nextTokenCanFollowDefaultKeyword();
      case 126 /* StaticKeyword */:
      case 139 /* GetKeyword */:
      case 153 /* SetKeyword */:
        nextToken();
        return canFollowModifier();
      default:
        return nextTokenIsOnSameLineAndCanFollowModifier();
    }
  }
  function canFollowExportModifier() {
    return token() === 60 /* AtToken */ || token() !== 42 /* AsteriskToken */ && token() !== 130 /* AsKeyword */ && token() !== 19 /* OpenBraceToken */ && canFollowModifier();
  }
  function nextTokenCanFollowExportModifier() {
    nextToken();
    return canFollowExportModifier();
  }
  function parseAnyContextualModifier() {
    return isModifierKind(token()) && tryParse(nextTokenCanFollowModifier);
  }
  function canFollowModifier() {
    return token() === 23 /* OpenBracketToken */ || token() === 19 /* OpenBraceToken */ || token() === 42 /* AsteriskToken */ || token() === 26 /* DotDotDotToken */ || isLiteralPropertyName();
  }
  function nextTokenCanFollowDefaultKeyword() {
    nextToken();
    return token() === 86 /* ClassKeyword */ || token() === 100 /* FunctionKeyword */ || token() === 120 /* InterfaceKeyword */ || token() === 60 /* AtToken */ || token() === 128 /* AbstractKeyword */ && lookAhead(nextTokenIsClassKeywordOnSameLine) || token() === 134 /* AsyncKeyword */ && lookAhead(nextTokenIsFunctionKeywordOnSameLine);
  }
  function isListElement2(parsingContext2, inErrorRecovery) {
    const node = currentNode(parsingContext2);
    if (node) {
      return true;
    }
    switch (parsingContext2) {
      case 0 /* SourceElements */:
      case 1 /* BlockStatements */:
      case 3 /* SwitchClauseStatements */:
        return !(token() === 27 /* SemicolonToken */ && inErrorRecovery) && isStartOfStatement();
      case 2 /* SwitchClauses */:
        return token() === 84 /* CaseKeyword */ || token() === 90 /* DefaultKeyword */;
      case 4 /* TypeMembers */:
        return lookAhead(isTypeMemberStart);
      case 5 /* ClassMembers */:
        return lookAhead(isClassMemberStart) || token() === 27 /* SemicolonToken */ && !inErrorRecovery;
      case 6 /* EnumMembers */:
        return token() === 23 /* OpenBracketToken */ || isLiteralPropertyName();
      case 12 /* ObjectLiteralMembers */:
        switch (token()) {
          case 23 /* OpenBracketToken */:
          case 42 /* AsteriskToken */:
          case 26 /* DotDotDotToken */:
          case 25 /* DotToken */:
            return true;
          default:
            return isLiteralPropertyName();
        }
      case 18 /* RestProperties */:
        return isLiteralPropertyName();
      case 9 /* ObjectBindingElements */:
        return token() === 23 /* OpenBracketToken */ || token() === 26 /* DotDotDotToken */ || isLiteralPropertyName();
      case 24 /* ImportAttributes */:
        return isImportAttributeName2();
      case 7 /* HeritageClauseElement */:
        if (token() === 19 /* OpenBraceToken */) {
          return lookAhead(isValidHeritageClauseObjectLiteral);
        }
        if (!inErrorRecovery) {
          return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword();
        } else {
          return isIdentifier2() && !isHeritageClauseExtendsOrImplementsKeyword();
        }
      case 8 /* VariableDeclarations */:
        return isBindingIdentifierOrPrivateIdentifierOrPattern();
      case 10 /* ArrayBindingElements */:
        return token() === 28 /* CommaToken */ || token() === 26 /* DotDotDotToken */ || isBindingIdentifierOrPrivateIdentifierOrPattern();
      case 19 /* TypeParameters */:
        return token() === 103 /* InKeyword */ || token() === 87 /* ConstKeyword */ || isIdentifier2();
      case 15 /* ArrayLiteralMembers */:
        switch (token()) {
          case 28 /* CommaToken */:
          case 25 /* DotToken */:
            return true;
        }
      case 11 /* ArgumentExpressions */:
        return token() === 26 /* DotDotDotToken */ || isStartOfExpression();
      case 16 /* Parameters */:
        return isStartOfParameter(
          /*isJSDocParameter*/
          false
        );
      case 17 /* JSDocParameters */:
        return isStartOfParameter(
          /*isJSDocParameter*/
          true
        );
      case 20 /* TypeArguments */:
      case 21 /* TupleElementTypes */:
        return token() === 28 /* CommaToken */ || isStartOfType();
      case 22 /* HeritageClauses */:
        return isHeritageClause2();
      case 23 /* ImportOrExportSpecifiers */:
        if (token() === 161 /* FromKeyword */ && lookAhead(nextTokenIsStringLiteral)) {
          return false;
        }
        return tokenIsIdentifierOrKeyword(token());
      case 13 /* JsxAttributes */:
        return tokenIsIdentifierOrKeyword(token()) || token() === 19 /* OpenBraceToken */;
      case 14 /* JsxChildren */:
        return true;
      case 25 /* JSDocComment */:
        return true;
      case 26 /* Count */:
        return Debug.fail("ParsingContext.Count used as a context");
      default:
        Debug.assertNever(parsingContext2, "Non-exhaustive case in 'isListElement'.");
    }
  }
  function isValidHeritageClauseObjectLiteral() {
    Debug.assert(token() === 19 /* OpenBraceToken */);
    if (nextToken() === 20 /* CloseBraceToken */) {
      const next = nextToken();
      return next === 28 /* CommaToken */ || next === 19 /* OpenBraceToken */ || next === 96 /* ExtendsKeyword */ || next === 119 /* ImplementsKeyword */;
    }
    return true;
  }
  function nextTokenIsIdentifier() {
    nextToken();
    return isIdentifier2();
  }
  function nextTokenIsIdentifierOrKeyword() {
    nextToken();
    return tokenIsIdentifierOrKeyword(token());
  }
  function nextTokenIsIdentifierOrKeywordOrGreaterThan() {
    nextToken();
    return tokenIsIdentifierOrKeywordOrGreaterThan(token());
  }
  function isHeritageClauseExtendsOrImplementsKeyword() {
    if (token() === 119 /* ImplementsKeyword */ || token() === 96 /* ExtendsKeyword */) {
      return lookAhead(nextTokenIsStartOfExpression);
    }
    return false;
  }
  function nextTokenIsStartOfExpression() {
    nextToken();
    return isStartOfExpression();
  }
  function nextTokenIsStartOfType() {
    nextToken();
    return isStartOfType();
  }
  function isListTerminator(kind) {
    if (token() === 1 /* EndOfFileToken */) {
      return true;
    }
    switch (kind) {
      case 1 /* BlockStatements */:
      case 2 /* SwitchClauses */:
      case 4 /* TypeMembers */:
      case 5 /* ClassMembers */:
      case 6 /* EnumMembers */:
      case 12 /* ObjectLiteralMembers */:
      case 9 /* ObjectBindingElements */:
      case 23 /* ImportOrExportSpecifiers */:
      case 24 /* ImportAttributes */:
        return token() === 20 /* CloseBraceToken */;
      case 3 /* SwitchClauseStatements */:
        return token() === 20 /* CloseBraceToken */ || token() === 84 /* CaseKeyword */ || token() === 90 /* DefaultKeyword */;
      case 7 /* HeritageClauseElement */:
        return token() === 19 /* OpenBraceToken */ || token() === 96 /* ExtendsKeyword */ || token() === 119 /* ImplementsKeyword */;
      case 8 /* VariableDeclarations */:
        return isVariableDeclaratorListTerminator();
      case 19 /* TypeParameters */:
        return token() === 32 /* GreaterThanToken */ || token() === 21 /* OpenParenToken */ || token() === 19 /* OpenBraceToken */ || token() === 96 /* ExtendsKeyword */ || token() === 119 /* ImplementsKeyword */;
      case 11 /* ArgumentExpressions */:
        return token() === 22 /* CloseParenToken */ || token() === 27 /* SemicolonToken */;
      case 15 /* ArrayLiteralMembers */:
      case 21 /* TupleElementTypes */:
      case 10 /* ArrayBindingElements */:
        return token() === 24 /* CloseBracketToken */;
      case 17 /* JSDocParameters */:
      case 16 /* Parameters */:
      case 18 /* RestProperties */:
        return token() === 22 /* CloseParenToken */ || token() === 24 /* CloseBracketToken */;
      case 20 /* TypeArguments */:
        return token() !== 28 /* CommaToken */;
      case 22 /* HeritageClauses */:
        return token() === 19 /* OpenBraceToken */ || token() === 20 /* CloseBraceToken */;
      case 13 /* JsxAttributes */:
        return token() === 32 /* GreaterThanToken */ || token() === 44 /* SlashToken */;
      case 14 /* JsxChildren */:
        return token() === 30 /* LessThanToken */ && lookAhead(nextTokenIsSlash);
      default:
        return false;
    }
  }
  function isVariableDeclaratorListTerminator() {
    if (canParseSemicolon()) {
      return true;
    }
    if (isInOrOfKeyword(token())) {
      return true;
    }
    if (token() === 39 /* EqualsGreaterThanToken */) {
      return true;
    }
    return false;
  }
  function isInSomeParsingContext() {
    Debug.assert(parsingContext, "Missing parsing context");
    for (let kind = 0; kind < 26 /* Count */; kind++) {
      if (parsingContext & 1 << kind) {
        if (isListElement2(
          kind,
          /*inErrorRecovery*/
          true
        ) || isListTerminator(kind)) {
          return true;
        }
      }
    }
    return false;
  }
  function parseList(kind, parseElement) {
    const saveParsingContext = parsingContext;
    parsingContext |= 1 << kind;
    const list = [];
    const listPos = getNodePos();
    while (!isListTerminator(kind)) {
      if (isListElement2(
        kind,
        /*inErrorRecovery*/
        false
      )) {
        list.push(parseListElement(kind, parseElement));
        continue;
      }
      if (abortParsingListOrMoveToNextToken(kind)) {
        break;
      }
    }
    parsingContext = saveParsingContext;
    return createNodeArray(list, listPos);
  }
  function parseListElement(parsingContext2, parseElement) {
    const node = currentNode(parsingContext2);
    if (node) {
      return consumeNode(node);
    }
    return parseElement();
  }
  function currentNode(parsingContext2, pos) {
    var _a;
    if (!syntaxCursor || !isReusableParsingContext(parsingContext2) || parseErrorBeforeNextFinishedNode) {
      return void 0;
    }
    const node = syntaxCursor.currentNode(pos ?? scanner2.getTokenFullStart());
    if (nodeIsMissing(node) || node.intersectsChange || containsParseError(node)) {
      return void 0;
    }
    const nodeContextFlags = node.flags & 101441536 /* ContextFlags */;
    if (nodeContextFlags !== contextFlags) {
      return void 0;
    }
    if (!canReuseNode(node, parsingContext2)) {
      return void 0;
    }
    if (canHaveJSDoc(node) && ((_a = node.jsDoc) == null ? void 0 : _a.jsDocCache)) {
      node.jsDoc.jsDocCache = void 0;
    }
    return node;
  }
  function consumeNode(node) {
    scanner2.resetTokenState(node.end);
    nextToken();
    return node;
  }
  function isReusableParsingContext(parsingContext2) {
    switch (parsingContext2) {
      case 5 /* ClassMembers */:
      case 2 /* SwitchClauses */:
      case 0 /* SourceElements */:
      case 1 /* BlockStatements */:
      case 3 /* SwitchClauseStatements */:
      case 6 /* EnumMembers */:
      case 4 /* TypeMembers */:
      case 8 /* VariableDeclarations */:
      case 17 /* JSDocParameters */:
      case 16 /* Parameters */:
        return true;
    }
    return false;
  }
  function canReuseNode(node, parsingContext2) {
    switch (parsingContext2) {
      case 5 /* ClassMembers */:
        return isReusableClassMember(node);
      case 2 /* SwitchClauses */:
        return isReusableSwitchClause(node);
      case 0 /* SourceElements */:
      case 1 /* BlockStatements */:
      case 3 /* SwitchClauseStatements */:
        return isReusableStatement(node);
      case 6 /* EnumMembers */:
        return isReusableEnumMember(node);
      case 4 /* TypeMembers */:
        return isReusableTypeMember(node);
      case 8 /* VariableDeclarations */:
        return isReusableVariableDeclaration(node);
      case 17 /* JSDocParameters */:
      case 16 /* Parameters */:
        return isReusableParameter(node);
    }
    return false;
  }
  function isReusableClassMember(node) {
    if (node) {
      switch (node.kind) {
        case 176 /* Constructor */:
        case 181 /* IndexSignature */:
        case 177 /* GetAccessor */:
        case 178 /* SetAccessor */:
        case 172 /* PropertyDeclaration */:
        case 240 /* SemicolonClassElement */:
          return true;
        case 174 /* MethodDeclaration */:
          const methodDeclaration = node;
          const nameIsConstructor = methodDeclaration.name.kind === 80 /* Identifier */ && methodDeclaration.name.escapedText === "constructor";
          return !nameIsConstructor;
      }
    }
    return false;
  }
  function isReusableSwitchClause(node) {
    if (node) {
      switch (node.kind) {
        case 296 /* CaseClause */:
        case 297 /* DefaultClause */:
          return true;
      }
    }
    return false;
  }
  function isReusableStatement(node) {
    if (node) {
      switch (node.kind) {
        case 262 /* FunctionDeclaration */:
        case 243 /* VariableStatement */:
        case 241 /* Block */:
        case 245 /* IfStatement */:
        case 244 /* ExpressionStatement */:
        case 257 /* ThrowStatement */:
        case 253 /* ReturnStatement */:
        case 255 /* SwitchStatement */:
        case 252 /* BreakStatement */:
        case 251 /* ContinueStatement */:
        case 249 /* ForInStatement */:
        case 250 /* ForOfStatement */:
        case 248 /* ForStatement */:
        case 247 /* WhileStatement */:
        case 254 /* WithStatement */:
        case 242 /* EmptyStatement */:
        case 258 /* TryStatement */:
        case 256 /* LabeledStatement */:
        case 246 /* DoStatement */:
        case 259 /* DebuggerStatement */:
        case 272 /* ImportDeclaration */:
        case 271 /* ImportEqualsDeclaration */:
        case 278 /* ExportDeclaration */:
        case 277 /* ExportAssignment */:
        case 267 /* ModuleDeclaration */:
        case 263 /* ClassDeclaration */:
        case 264 /* InterfaceDeclaration */:
        case 266 /* EnumDeclaration */:
        case 265 /* TypeAliasDeclaration */:
          return true;
      }
    }
    return false;
  }
  function isReusableEnumMember(node) {
    return node.kind === 306 /* EnumMember */;
  }
  function isReusableTypeMember(node) {
    if (node) {
      switch (node.kind) {
        case 180 /* ConstructSignature */:
        case 173 /* MethodSignature */:
        case 181 /* IndexSignature */:
        case 171 /* PropertySignature */:
        case 179 /* CallSignature */:
          return true;
      }
    }
    return false;
  }
  function isReusableVariableDeclaration(node) {
    if (node.kind !== 260 /* VariableDeclaration */) {
      return false;
    }
    const variableDeclarator = node;
    return variableDeclarator.initializer === void 0;
  }
  function isReusableParameter(node) {
    if (node.kind !== 169 /* Parameter */) {
      return false;
    }
    const parameter = node;
    return parameter.initializer === void 0;
  }
  function abortParsingListOrMoveToNextToken(kind) {
    parsingContextErrors(kind);
    if (isInSomeParsingContext()) {
      return true;
    }
    nextToken();
    return false;
  }
  function parsingContextErrors(context) {
    switch (context) {
      case 0 /* SourceElements */:
        return token() === 90 /* DefaultKeyword */ ? parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(95 /* ExportKeyword */)) : parseErrorAtCurrentToken(Diagnostics.Declaration_or_statement_expected);
      case 1 /* BlockStatements */:
        return parseErrorAtCurrentToken(Diagnostics.Declaration_or_statement_expected);
      case 2 /* SwitchClauses */:
        return parseErrorAtCurrentToken(Diagnostics.case_or_default_expected);
      case 3 /* SwitchClauseStatements */:
        return parseErrorAtCurrentToken(Diagnostics.Statement_expected);
      case 18 /* RestProperties */:
      case 4 /* TypeMembers */:
        return parseErrorAtCurrentToken(Diagnostics.Property_or_signature_expected);
      case 5 /* ClassMembers */:
        return parseErrorAtCurrentToken(Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected);
      case 6 /* EnumMembers */:
        return parseErrorAtCurrentToken(Diagnostics.Enum_member_expected);
      case 7 /* HeritageClauseElement */:
        return parseErrorAtCurrentToken(Diagnostics.Expression_expected);
      case 8 /* VariableDeclarations */:
        return isKeyword(token()) ? parseErrorAtCurrentToken(Diagnostics._0_is_not_allowed_as_a_variable_declaration_name, tokenToString(token())) : parseErrorAtCurrentToken(Diagnostics.Variable_declaration_expected);
      case 9 /* ObjectBindingElements */:
        return parseErrorAtCurrentToken(Diagnostics.Property_destructuring_pattern_expected);
      case 10 /* ArrayBindingElements */:
        return parseErrorAtCurrentToken(Diagnostics.Array_element_destructuring_pattern_expected);
      case 11 /* ArgumentExpressions */:
        return parseErrorAtCurrentToken(Diagnostics.Argument_expression_expected);
      case 12 /* ObjectLiteralMembers */:
        return parseErrorAtCurrentToken(Diagnostics.Property_assignment_expected);
      case 15 /* ArrayLiteralMembers */:
        return parseErrorAtCurrentToken(Diagnostics.Expression_or_comma_expected);
      case 17 /* JSDocParameters */:
        return parseErrorAtCurrentToken(Diagnostics.Parameter_declaration_expected);
      case 16 /* Parameters */:
        return isKeyword(token()) ? parseErrorAtCurrentToken(Diagnostics._0_is_not_allowed_as_a_parameter_name, tokenToString(token())) : parseErrorAtCurrentToken(Diagnostics.Parameter_declaration_expected);
      case 19 /* TypeParameters */:
        return parseErrorAtCurrentToken(Diagnostics.Type_parameter_declaration_expected);
      case 20 /* TypeArguments */:
        return parseErrorAtCurrentToken(Diagnostics.Type_argument_expected);
      case 21 /* TupleElementTypes */:
        return parseErrorAtCurrentToken(Diagnostics.Type_expected);
      case 22 /* HeritageClauses */:
        return parseErrorAtCurrentToken(Diagnostics.Unexpected_token_expected);
      case 23 /* ImportOrExportSpecifiers */:
        if (token() === 161 /* FromKeyword */) {
          return parseErrorAtCurrentToken(Diagnostics._0_expected, "}");
        }
        return parseErrorAtCurrentToken(Diagnostics.Identifier_expected);
      case 13 /* JsxAttributes */:
        return parseErrorAtCurrentToken(Diagnostics.Identifier_expected);
      case 14 /* JsxChildren */:
        return parseErrorAtCurrentToken(Diagnostics.Identifier_expected);
      case 24 /* ImportAttributes */:
        return parseErrorAtCurrentToken(Diagnostics.Identifier_or_string_literal_expected);
      case 25 /* JSDocComment */:
        return parseErrorAtCurrentToken(Diagnostics.Identifier_expected);
      case 26 /* Count */:
        return Debug.fail("ParsingContext.Count used as a context");
      default:
        Debug.assertNever(context);
    }
  }
  function parseDelimitedList(kind, parseElement, considerSemicolonAsDelimiter) {
    const saveParsingContext = parsingContext;
    parsingContext |= 1 << kind;
    const list = [];
    const listPos = getNodePos();
    let commaStart = -1;
    while (true) {
      if (isListElement2(
        kind,
        /*inErrorRecovery*/
        false
      )) {
        const startPos = scanner2.getTokenFullStart();
        const result = parseListElement(kind, parseElement);
        if (!result) {
          parsingContext = saveParsingContext;
          return void 0;
        }
        list.push(result);
        commaStart = scanner2.getTokenStart();
        if (parseOptional(28 /* CommaToken */)) {
          continue;
        }
        commaStart = -1;
        if (isListTerminator(kind)) {
          break;
        }
        parseExpected(28 /* CommaToken */, getExpectedCommaDiagnostic(kind));
        if (considerSemicolonAsDelimiter && token() === 27 /* SemicolonToken */ && !scanner2.hasPrecedingLineBreak()) {
          nextToken();
        }
        if (startPos === scanner2.getTokenFullStart()) {
          nextToken();
        }
        continue;
      }
      if (isListTerminator(kind)) {
        break;
      }
      if (abortParsingListOrMoveToNextToken(kind)) {
        break;
      }
    }
    parsingContext = saveParsingContext;
    return createNodeArray(
      list,
      listPos,
      /*end*/
      void 0,
      commaStart >= 0
    );
  }
  function getExpectedCommaDiagnostic(kind) {
    return kind === 6 /* EnumMembers */ ? Diagnostics.An_enum_member_name_must_be_followed_by_a_or : void 0;
  }
  function createMissingList() {
    const list = createNodeArray([], getNodePos());
    list.isMissingList = true;
    return list;
  }
  function isMissingList(arr) {
    return !!arr.isMissingList;
  }
  function parseBracketedList(kind, parseElement, open, close) {
    if (parseExpected(open)) {
      const result = parseDelimitedList(kind, parseElement);
      parseExpected(close);
      return result;
    }
    return createMissingList();
  }
  function parseEntityName(allowReservedWords, diagnosticMessage) {
    const pos = getNodePos();
    let entity = allowReservedWords ? parseIdentifierName(diagnosticMessage) : parseIdentifier(diagnosticMessage);
    while (parseOptional(25 /* DotToken */)) {
      if (token() === 30 /* LessThanToken */) {
        break;
      }
      entity = finishNode(
        factory2.createQualifiedName(
          entity,
          parseRightSideOfDot(
            allowReservedWords,
            /*allowPrivateIdentifiers*/
            false,
            /*allowUnicodeEscapeSequenceInIdentifierName*/
            true
          )
        ),
        pos
      );
    }
    return entity;
  }
  function createQualifiedName(entity, name) {
    return finishNode(factory2.createQualifiedName(entity, name), entity.pos);
  }
  function parseRightSideOfDot(allowIdentifierNames, allowPrivateIdentifiers, allowUnicodeEscapeSequenceInIdentifierName) {
    if (scanner2.hasPrecedingLineBreak() && tokenIsIdentifierOrKeyword(token())) {
      const matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
      if (matchesPattern) {
        return createMissingNode(
          80 /* Identifier */,
          /*reportAtCurrentPosition*/
          true,
          Diagnostics.Identifier_expected
        );
      }
    }
    if (token() === 81 /* PrivateIdentifier */) {
      const node = parsePrivateIdentifier();
      return allowPrivateIdentifiers ? node : createMissingNode(
        80 /* Identifier */,
        /*reportAtCurrentPosition*/
        true,
        Diagnostics.Identifier_expected
      );
    }
    if (allowIdentifierNames) {
      return allowUnicodeEscapeSequenceInIdentifierName ? parseIdentifierName() : parseIdentifierNameErrorOnUnicodeEscapeSequence();
    }
    return parseIdentifier();
  }
  function parseTemplateSpans(isTaggedTemplate) {
    const pos = getNodePos();
    const list = [];
    let node;
    do {
      node = parseTemplateSpan(isTaggedTemplate);
      list.push(node);
    } while (node.literal.kind === 17 /* TemplateMiddle */);
    return createNodeArray(list, pos);
  }
  function parseTemplateExpression(isTaggedTemplate) {
    const pos = getNodePos();
    return finishNode(
      factory2.createTemplateExpression(
        parseTemplateHead(isTaggedTemplate),
        parseTemplateSpans(isTaggedTemplate)
      ),
      pos
    );
  }
  function parseTemplateType() {
    const pos = getNodePos();
    return finishNode(
      factory2.createTemplateLiteralType(
        parseTemplateHead(
          /*isTaggedTemplate*/
          false
        ),
        parseTemplateTypeSpans()
      ),
      pos
    );
  }
  function parseTemplateTypeSpans() {
    const pos = getNodePos();
    const list = [];
    let node;
    do {
      node = parseTemplateTypeSpan();
      list.push(node);
    } while (node.literal.kind === 17 /* TemplateMiddle */);
    return createNodeArray(list, pos);
  }
  function parseTemplateTypeSpan() {
    const pos = getNodePos();
    return finishNode(
      factory2.createTemplateLiteralTypeSpan(
        parseType(),
        parseLiteralOfTemplateSpan(
          /*isTaggedTemplate*/
          false
        )
      ),
      pos
    );
  }
  function parseLiteralOfTemplateSpan(isTaggedTemplate) {
    if (token() === 20 /* CloseBraceToken */) {
      reScanTemplateToken(isTaggedTemplate);
      return parseTemplateMiddleOrTemplateTail();
    } else {
      return parseExpectedToken(18 /* TemplateTail */, Diagnostics._0_expected, tokenToString(20 /* CloseBraceToken */));
    }
  }
  function parseTemplateSpan(isTaggedTemplate) {
    const pos = getNodePos();
    return finishNode(
      factory2.createTemplateSpan(
        allowInAnd(parseExpression),
        parseLiteralOfTemplateSpan(isTaggedTemplate)
      ),
      pos
    );
  }
  function parseLiteralNode() {
    return parseLiteralLikeNode(token());
  }
  function parseTemplateHead(isTaggedTemplate) {
    if (!isTaggedTemplate && scanner2.getTokenFlags() & 26656 /* IsInvalid */) {
      reScanTemplateToken(
        /*isTaggedTemplate*/
        false
      );
    }
    const fragment = parseLiteralLikeNode(token());
    Debug.assert(fragment.kind === 16 /* TemplateHead */, "Template head has wrong token kind");
    return fragment;
  }
  function parseTemplateMiddleOrTemplateTail() {
    const fragment = parseLiteralLikeNode(token());
    Debug.assert(fragment.kind === 17 /* TemplateMiddle */ || fragment.kind === 18 /* TemplateTail */, "Template fragment has wrong token kind");
    return fragment;
  }
  function getTemplateLiteralRawText(kind) {
    const isLast = kind === 15 /* NoSubstitutionTemplateLiteral */ || kind === 18 /* TemplateTail */;
    const tokenText = scanner2.getTokenText();
    return tokenText.substring(1, tokenText.length - (scanner2.isUnterminated() ? 0 : isLast ? 1 : 2));
  }
  function parseLiteralLikeNode(kind) {
    const pos = getNodePos();
    const node = isTemplateLiteralKind(kind) ? factory2.createTemplateLiteralLikeNode(kind, scanner2.getTokenValue(), getTemplateLiteralRawText(kind), scanner2.getTokenFlags() & 7176 /* TemplateLiteralLikeFlags */) : (
      // Note that theoretically the following condition would hold true literals like 009,
      // which is not octal. But because of how the scanner separates the tokens, we would
      // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.
      // We also do not need to check for negatives because any prefix operator would be part of a
      // parent unary expression.
      kind === 9 /* NumericLiteral */ ? factoryCreateNumericLiteral(scanner2.getTokenValue(), scanner2.getNumericLiteralFlags()) : kind === 11 /* StringLiteral */ ? factoryCreateStringLiteral(
        scanner2.getTokenValue(),
        /*isSingleQuote*/
        void 0,
        scanner2.hasExtendedUnicodeEscape()
      ) : isLiteralKind(kind) ? factoryCreateLiteralLikeNode(kind, scanner2.getTokenValue()) : Debug.fail()
    );
    if (scanner2.hasExtendedUnicodeEscape()) {
      node.hasExtendedUnicodeEscape = true;
    }
    if (scanner2.isUnterminated()) {
      node.isUnterminated = true;
    }
    nextToken();
    return finishNode(node, pos);
  }
  function parseEntityNameOfTypeReference() {
    return parseEntityName(
      /*allowReservedWords*/
      true,
      Diagnostics.Type_expected
    );
  }
  function parseTypeArgumentsOfTypeReference() {
    if (!scanner2.hasPrecedingLineBreak() && reScanLessThanToken() === 30 /* LessThanToken */) {
      return parseBracketedList(20 /* TypeArguments */, parseType, 30 /* LessThanToken */, 32 /* GreaterThanToken */);
    }
  }
  function parseTypeReference() {
    const pos = getNodePos();
    return finishNode(
      factory2.createTypeReferenceNode(
        parseEntityNameOfTypeReference(),
        parseTypeArgumentsOfTypeReference()
      ),
      pos
    );
  }
  function typeHasArrowFunctionBlockingParseError(node) {
    switch (node.kind) {
      case 183 /* TypeReference */:
        return nodeIsMissing(node.typeName);
      case 184 /* FunctionType */:
      case 185 /* ConstructorType */: {
        const { parameters, type } = node;
        return isMissingList(parameters) || typeHasArrowFunctionBlockingParseError(type);
      }
      case 196 /* ParenthesizedType */:
        return typeHasArrowFunctionBlockingParseError(node.type);
      default:
        return false;
    }
  }
  function parseThisTypePredicate(lhs) {
    nextToken();
    return finishNode(factory2.createTypePredicateNode(
      /*assertsModifier*/
      void 0,
      lhs,
      parseType()
    ), lhs.pos);
  }
  function parseThisTypeNode() {
    const pos = getNodePos();
    nextToken();
    return finishNode(factory2.createThisTypeNode(), pos);
  }
  function parseJSDocAllType() {
    const pos = getNodePos();
    nextToken();
    return finishNode(factory2.createJSDocAllType(), pos);
  }
  function parseJSDocNonNullableType() {
    const pos = getNodePos();
    nextToken();
    return finishNode(factory2.createJSDocNonNullableType(
      parseNonArrayType(),
      /*postfix*/
      false
    ), pos);
  }
  function parseJSDocUnknownOrNullableType() {
    const pos = getNodePos();
    nextToken();
    if (token() === 28 /* CommaToken */ || token() === 20 /* CloseBraceToken */ || token() === 22 /* CloseParenToken */ || token() === 32 /* GreaterThanToken */ || token() === 64 /* EqualsToken */ || token() === 52 /* BarToken */) {
      return finishNode(factory2.createJSDocUnknownType(), pos);
    } else {
      return finishNode(factory2.createJSDocNullableType(
        parseType(),
        /*postfix*/
        false
      ), pos);
    }
  }
  function parseJSDocFunctionType() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    if (tryParse(nextTokenIsOpenParen)) {
      const parameters = parseParameters(4 /* Type */ | 32 /* JSDoc */);
      const type = parseReturnType(
        59 /* ColonToken */,
        /*isType*/
        false
      );
      return withJSDoc(finishNode(factory2.createJSDocFunctionType(parameters, type), pos), hasJSDoc);
    }
    return finishNode(factory2.createTypeReferenceNode(
      parseIdentifierName(),
      /*typeArguments*/
      void 0
    ), pos);
  }
  function parseJSDocParameter() {
    const pos = getNodePos();
    let name;
    if (token() === 110 /* ThisKeyword */ || token() === 105 /* NewKeyword */) {
      name = parseIdentifierName();
      parseExpected(59 /* ColonToken */);
    }
    return finishNode(
      factory2.createParameterDeclaration(
        /*modifiers*/
        void 0,
        /*dotDotDotToken*/
        void 0,
        // TODO(rbuckton): JSDoc parameters don't have names (except `this`/`new`), should we manufacture an empty identifier?
        name,
        /*questionToken*/
        void 0,
        parseJSDocType(),
        /*initializer*/
        void 0
      ),
      pos
    );
  }
  function parseJSDocType() {
    scanner2.setInJSDocType(true);
    const pos = getNodePos();
    if (parseOptional(144 /* ModuleKeyword */)) {
      const moduleTag = factory2.createJSDocNamepathType(
        /*type*/
        void 0
      );
      terminate:
        while (true) {
          switch (token()) {
            case 20 /* CloseBraceToken */:
            case 1 /* EndOfFileToken */:
            case 28 /* CommaToken */:
            case 5 /* WhitespaceTrivia */:
              break terminate;
            default:
              nextTokenJSDoc();
          }
        }
      scanner2.setInJSDocType(false);
      return finishNode(moduleTag, pos);
    }
    const hasDotDotDot = parseOptional(26 /* DotDotDotToken */);
    let type = parseTypeOrTypePredicate();
    scanner2.setInJSDocType(false);
    if (hasDotDotDot) {
      type = finishNode(factory2.createJSDocVariadicType(type), pos);
    }
    if (token() === 64 /* EqualsToken */) {
      nextToken();
      return finishNode(factory2.createJSDocOptionalType(type), pos);
    }
    return type;
  }
  function parseTypeQuery() {
    const pos = getNodePos();
    parseExpected(114 /* TypeOfKeyword */);
    const entityName = parseEntityName(
      /*allowReservedWords*/
      true
    );
    const typeArguments = !scanner2.hasPrecedingLineBreak() ? tryParseTypeArguments() : void 0;
    return finishNode(factory2.createTypeQueryNode(entityName, typeArguments), pos);
  }
  function parseTypeParameter() {
    const pos = getNodePos();
    const modifiers = parseModifiers(
      /*allowDecorators*/
      false,
      /*permitConstAsModifier*/
      true
    );
    const name = parseIdentifier();
    let constraint;
    let expression;
    if (parseOptional(96 /* ExtendsKeyword */)) {
      if (isStartOfType() || !isStartOfExpression()) {
        constraint = parseType();
      } else {
        expression = parseUnaryExpressionOrHigher();
      }
    }
    const defaultType = parseOptional(64 /* EqualsToken */) ? parseType() : void 0;
    const node = factory2.createTypeParameterDeclaration(modifiers, name, constraint, defaultType);
    node.expression = expression;
    return finishNode(node, pos);
  }
  function parseTypeParameters() {
    if (token() === 30 /* LessThanToken */) {
      return parseBracketedList(19 /* TypeParameters */, parseTypeParameter, 30 /* LessThanToken */, 32 /* GreaterThanToken */);
    }
  }
  function isStartOfParameter(isJSDocParameter) {
    return token() === 26 /* DotDotDotToken */ || isBindingIdentifierOrPrivateIdentifierOrPattern() || isModifierKind(token()) || token() === 60 /* AtToken */ || isStartOfType(
      /*inStartOfParameter*/
      !isJSDocParameter
    );
  }
  function parseNameOfParameter(modifiers) {
    const name = parseIdentifierOrPattern(Diagnostics.Private_identifiers_cannot_be_used_as_parameters);
    if (getFullWidth(name) === 0 && !some(modifiers) && isModifierKind(token())) {
      nextToken();
    }
    return name;
  }
  function isParameterNameStart() {
    return isBindingIdentifier() || token() === 23 /* OpenBracketToken */ || token() === 19 /* OpenBraceToken */;
  }
  function parseParameter(inOuterAwaitContext) {
    return parseParameterWorker(inOuterAwaitContext);
  }
  function parseParameterForSpeculation(inOuterAwaitContext) {
    return parseParameterWorker(
      inOuterAwaitContext,
      /*allowAmbiguity*/
      false
    );
  }
  function parseParameterWorker(inOuterAwaitContext, allowAmbiguity = true) {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const modifiers = inOuterAwaitContext ? doInAwaitContext(() => parseModifiers(
      /*allowDecorators*/
      true
    )) : doOutsideOfAwaitContext(() => parseModifiers(
      /*allowDecorators*/
      true
    ));
    if (token() === 110 /* ThisKeyword */) {
      const node2 = factory2.createParameterDeclaration(
        modifiers,
        /*dotDotDotToken*/
        void 0,
        createIdentifier(
          /*isIdentifier*/
          true
        ),
        /*questionToken*/
        void 0,
        parseTypeAnnotation(),
        /*initializer*/
        void 0
      );
      const modifier = firstOrUndefined(modifiers);
      if (modifier) {
        parseErrorAtRange(modifier, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters);
      }
      return withJSDoc(finishNode(node2, pos), hasJSDoc);
    }
    const savedTopLevel = topLevel;
    topLevel = false;
    const dotDotDotToken = parseOptionalToken(26 /* DotDotDotToken */);
    if (!allowAmbiguity && !isParameterNameStart()) {
      return void 0;
    }
    const node = withJSDoc(
      finishNode(
        factory2.createParameterDeclaration(
          modifiers,
          dotDotDotToken,
          parseNameOfParameter(modifiers),
          parseOptionalToken(58 /* QuestionToken */),
          parseTypeAnnotation(),
          parseInitializer()
        ),
        pos
      ),
      hasJSDoc
    );
    topLevel = savedTopLevel;
    return node;
  }
  function parseReturnType(returnToken, isType) {
    if (shouldParseReturnType(returnToken, isType)) {
      return allowConditionalTypesAnd(parseTypeOrTypePredicate);
    }
  }
  function shouldParseReturnType(returnToken, isType) {
    if (returnToken === 39 /* EqualsGreaterThanToken */) {
      parseExpected(returnToken);
      return true;
    } else if (parseOptional(59 /* ColonToken */)) {
      return true;
    } else if (isType && token() === 39 /* EqualsGreaterThanToken */) {
      parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(59 /* ColonToken */));
      nextToken();
      return true;
    }
    return false;
  }
  function parseParametersWorker(flags, allowAmbiguity) {
    const savedYieldContext = inYieldContext();
    const savedAwaitContext = inAwaitContext();
    setYieldContext(!!(flags & 1 /* Yield */));
    setAwaitContext(!!(flags & 2 /* Await */));
    const parameters = flags & 32 /* JSDoc */ ? parseDelimitedList(17 /* JSDocParameters */, parseJSDocParameter) : parseDelimitedList(16 /* Parameters */, () => allowAmbiguity ? parseParameter(savedAwaitContext) : parseParameterForSpeculation(savedAwaitContext));
    setYieldContext(savedYieldContext);
    setAwaitContext(savedAwaitContext);
    return parameters;
  }
  function parseParameters(flags) {
    if (!parseExpected(21 /* OpenParenToken */)) {
      return createMissingList();
    }
    const parameters = parseParametersWorker(
      flags,
      /*allowAmbiguity*/
      true
    );
    parseExpected(22 /* CloseParenToken */);
    return parameters;
  }
  function parseTypeMemberSemicolon() {
    if (parseOptional(28 /* CommaToken */)) {
      return;
    }
    parseSemicolon();
  }
  function parseSignatureMember(kind) {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    if (kind === 180 /* ConstructSignature */) {
      parseExpected(105 /* NewKeyword */);
    }
    const typeParameters = parseTypeParameters();
    const parameters = parseParameters(4 /* Type */);
    const type = parseReturnType(
      59 /* ColonToken */,
      /*isType*/
      true
    );
    parseTypeMemberSemicolon();
    const node = kind === 179 /* CallSignature */ ? factory2.createCallSignature(typeParameters, parameters, type) : factory2.createConstructSignature(typeParameters, parameters, type);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function isIndexSignature() {
    return token() === 23 /* OpenBracketToken */ && lookAhead(isUnambiguouslyIndexSignature);
  }
  function isUnambiguouslyIndexSignature() {
    nextToken();
    if (token() === 26 /* DotDotDotToken */ || token() === 24 /* CloseBracketToken */) {
      return true;
    }
    if (isModifierKind(token())) {
      nextToken();
      if (isIdentifier2()) {
        return true;
      }
    } else if (!isIdentifier2()) {
      return false;
    } else {
      nextToken();
    }
    if (token() === 59 /* ColonToken */ || token() === 28 /* CommaToken */) {
      return true;
    }
    if (token() !== 58 /* QuestionToken */) {
      return false;
    }
    nextToken();
    return token() === 59 /* ColonToken */ || token() === 28 /* CommaToken */ || token() === 24 /* CloseBracketToken */;
  }
  function parseIndexSignatureDeclaration(pos, hasJSDoc, modifiers) {
    const parameters = parseBracketedList(16 /* Parameters */, () => parseParameter(
      /*inOuterAwaitContext*/
      false
    ), 23 /* OpenBracketToken */, 24 /* CloseBracketToken */);
    const type = parseTypeAnnotation();
    parseTypeMemberSemicolon();
    const node = factory2.createIndexSignature(modifiers, parameters, type);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers) {
    const name = parsePropertyName();
    const questionToken = parseOptionalToken(58 /* QuestionToken */);
    let node;
    if (token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */) {
      const typeParameters = parseTypeParameters();
      const parameters = parseParameters(4 /* Type */);
      const type = parseReturnType(
        59 /* ColonToken */,
        /*isType*/
        true
      );
      node = factory2.createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type);
    } else {
      const type = parseTypeAnnotation();
      node = factory2.createPropertySignature(modifiers, name, questionToken, type);
      if (token() === 64 /* EqualsToken */)
        node.initializer = parseInitializer();
    }
    parseTypeMemberSemicolon();
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function isTypeMemberStart() {
    if (token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */ || token() === 139 /* GetKeyword */ || token() === 153 /* SetKeyword */) {
      return true;
    }
    let idToken = false;
    while (isModifierKind(token())) {
      idToken = true;
      nextToken();
    }
    if (token() === 23 /* OpenBracketToken */) {
      return true;
    }
    if (isLiteralPropertyName()) {
      idToken = true;
      nextToken();
    }
    if (idToken) {
      return token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */ || token() === 58 /* QuestionToken */ || token() === 59 /* ColonToken */ || token() === 28 /* CommaToken */ || canParseSemicolon();
    }
    return false;
  }
  function parseTypeMember() {
    if (token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */) {
      return parseSignatureMember(179 /* CallSignature */);
    }
    if (token() === 105 /* NewKeyword */ && lookAhead(nextTokenIsOpenParenOrLessThan)) {
      return parseSignatureMember(180 /* ConstructSignature */);
    }
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const modifiers = parseModifiers(
      /*allowDecorators*/
      false
    );
    if (parseContextualModifier(139 /* GetKeyword */)) {
      return parseAccessorDeclaration(pos, hasJSDoc, modifiers, 177 /* GetAccessor */, 4 /* Type */);
    }
    if (parseContextualModifier(153 /* SetKeyword */)) {
      return parseAccessorDeclaration(pos, hasJSDoc, modifiers, 178 /* SetAccessor */, 4 /* Type */);
    }
    if (isIndexSignature()) {
      return parseIndexSignatureDeclaration(pos, hasJSDoc, modifiers);
    }
    return parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers);
  }
  function nextTokenIsOpenParenOrLessThan() {
    nextToken();
    return token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */;
  }
  function nextTokenIsDot() {
    return nextToken() === 25 /* DotToken */;
  }
  function nextTokenIsOpenParenOrLessThanOrDot() {
    switch (nextToken()) {
      case 21 /* OpenParenToken */:
      case 30 /* LessThanToken */:
      case 25 /* DotToken */:
        return true;
    }
    return false;
  }
  function parseTypeLiteral() {
    const pos = getNodePos();
    return finishNode(factory2.createTypeLiteralNode(parseObjectTypeMembers()), pos);
  }
  function parseObjectTypeMembers() {
    let members;
    if (parseExpected(19 /* OpenBraceToken */)) {
      members = parseList(4 /* TypeMembers */, parseTypeMember);
      parseExpected(20 /* CloseBraceToken */);
    } else {
      members = createMissingList();
    }
    return members;
  }
  function isStartOfMappedType() {
    nextToken();
    if (token() === 40 /* PlusToken */ || token() === 41 /* MinusToken */) {
      return nextToken() === 148 /* ReadonlyKeyword */;
    }
    if (token() === 148 /* ReadonlyKeyword */) {
      nextToken();
    }
    return token() === 23 /* OpenBracketToken */ && nextTokenIsIdentifier() && nextToken() === 103 /* InKeyword */;
  }
  function parseMappedTypeParameter() {
    const pos = getNodePos();
    const name = parseIdentifierName();
    parseExpected(103 /* InKeyword */);
    const type = parseType();
    return finishNode(factory2.createTypeParameterDeclaration(
      /*modifiers*/
      void 0,
      name,
      type,
      /*defaultType*/
      void 0
    ), pos);
  }
  function parseMappedType() {
    const pos = getNodePos();
    parseExpected(19 /* OpenBraceToken */);
    let readonlyToken;
    if (token() === 148 /* ReadonlyKeyword */ || token() === 40 /* PlusToken */ || token() === 41 /* MinusToken */) {
      readonlyToken = parseTokenNode();
      if (readonlyToken.kind !== 148 /* ReadonlyKeyword */) {
        parseExpected(148 /* ReadonlyKeyword */);
      }
    }
    parseExpected(23 /* OpenBracketToken */);
    const typeParameter = parseMappedTypeParameter();
    const nameType = parseOptional(130 /* AsKeyword */) ? parseType() : void 0;
    parseExpected(24 /* CloseBracketToken */);
    let questionToken;
    if (token() === 58 /* QuestionToken */ || token() === 40 /* PlusToken */ || token() === 41 /* MinusToken */) {
      questionToken = parseTokenNode();
      if (questionToken.kind !== 58 /* QuestionToken */) {
        parseExpected(58 /* QuestionToken */);
      }
    }
    const type = parseTypeAnnotation();
    parseSemicolon();
    const members = parseList(4 /* TypeMembers */, parseTypeMember);
    parseExpected(20 /* CloseBraceToken */);
    return finishNode(factory2.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), pos);
  }
  function parseTupleElementType() {
    const pos = getNodePos();
    if (parseOptional(26 /* DotDotDotToken */)) {
      return finishNode(factory2.createRestTypeNode(parseType()), pos);
    }
    const type = parseType();
    if (isJSDocNullableType(type) && type.pos === type.type.pos) {
      const node = factory2.createOptionalTypeNode(type.type);
      setTextRange(node, type);
      node.flags = type.flags;
      return node;
    }
    return type;
  }
  function isNextTokenColonOrQuestionColon() {
    return nextToken() === 59 /* ColonToken */ || token() === 58 /* QuestionToken */ && nextToken() === 59 /* ColonToken */;
  }
  function isTupleElementName() {
    if (token() === 26 /* DotDotDotToken */) {
      return tokenIsIdentifierOrKeyword(nextToken()) && isNextTokenColonOrQuestionColon();
    }
    return tokenIsIdentifierOrKeyword(token()) && isNextTokenColonOrQuestionColon();
  }
  function parseTupleElementNameOrTupleElementType() {
    if (lookAhead(isTupleElementName)) {
      const pos = getNodePos();
      const hasJSDoc = hasPrecedingJSDocComment();
      const dotDotDotToken = parseOptionalToken(26 /* DotDotDotToken */);
      const name = parseIdentifierName();
      const questionToken = parseOptionalToken(58 /* QuestionToken */);
      parseExpected(59 /* ColonToken */);
      const type = parseTupleElementType();
      const node = factory2.createNamedTupleMember(dotDotDotToken, name, questionToken, type);
      return withJSDoc(finishNode(node, pos), hasJSDoc);
    }
    return parseTupleElementType();
  }
  function parseTupleType() {
    const pos = getNodePos();
    return finishNode(
      factory2.createTupleTypeNode(
        parseBracketedList(21 /* TupleElementTypes */, parseTupleElementNameOrTupleElementType, 23 /* OpenBracketToken */, 24 /* CloseBracketToken */)
      ),
      pos
    );
  }
  function parseParenthesizedType() {
    const pos = getNodePos();
    parseExpected(21 /* OpenParenToken */);
    const type = parseType();
    parseExpected(22 /* CloseParenToken */);
    return finishNode(factory2.createParenthesizedType(type), pos);
  }
  function parseModifiersForConstructorType() {
    let modifiers;
    if (token() === 128 /* AbstractKeyword */) {
      const pos = getNodePos();
      nextToken();
      const modifier = finishNode(factoryCreateToken(128 /* AbstractKeyword */), pos);
      modifiers = createNodeArray([modifier], pos);
    }
    return modifiers;
  }
  function parseFunctionOrConstructorType() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const modifiers = parseModifiersForConstructorType();
    const isConstructorType = parseOptional(105 /* NewKeyword */);
    Debug.assert(!modifiers || isConstructorType, "Per isStartOfFunctionOrConstructorType, a function type cannot have modifiers.");
    const typeParameters = parseTypeParameters();
    const parameters = parseParameters(4 /* Type */);
    const type = parseReturnType(
      39 /* EqualsGreaterThanToken */,
      /*isType*/
      false
    );
    const node = isConstructorType ? factory2.createConstructorTypeNode(modifiers, typeParameters, parameters, type) : factory2.createFunctionTypeNode(typeParameters, parameters, type);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseKeywordAndNoDot() {
    const node = parseTokenNode();
    return token() === 25 /* DotToken */ ? void 0 : node;
  }
  function parseLiteralTypeNode(negative) {
    const pos = getNodePos();
    if (negative) {
      nextToken();
    }
    let expression = token() === 112 /* TrueKeyword */ || token() === 97 /* FalseKeyword */ || token() === 106 /* NullKeyword */ ? parseTokenNode() : parseLiteralLikeNode(token());
    if (negative) {
      expression = finishNode(factory2.createPrefixUnaryExpression(41 /* MinusToken */, expression), pos);
    }
    return finishNode(factory2.createLiteralTypeNode(expression), pos);
  }
  function isStartOfTypeOfImportType() {
    nextToken();
    return token() === 102 /* ImportKeyword */;
  }
  function parseImportType() {
    sourceFlags |= 4194304 /* PossiblyContainsDynamicImport */;
    const pos = getNodePos();
    const isTypeOf = parseOptional(114 /* TypeOfKeyword */);
    parseExpected(102 /* ImportKeyword */);
    parseExpected(21 /* OpenParenToken */);
    const type = parseType();
    let attributes;
    if (parseOptional(28 /* CommaToken */)) {
      const openBracePosition = scanner2.getTokenStart();
      parseExpected(19 /* OpenBraceToken */);
      const currentToken2 = token();
      if (currentToken2 === 118 /* WithKeyword */ || currentToken2 === 132 /* AssertKeyword */) {
        nextToken();
      } else {
        parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(118 /* WithKeyword */));
      }
      parseExpected(59 /* ColonToken */);
      attributes = parseImportAttributes(
        currentToken2,
        /*skipKeyword*/
        true
      );
      if (!parseExpected(20 /* CloseBraceToken */)) {
        const lastError = lastOrUndefined(parseDiagnostics);
        if (lastError && lastError.code === Diagnostics._0_expected.code) {
          addRelatedInfo(
            lastError,
            createDetachedDiagnostic(fileName, sourceText, openBracePosition, 1, Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}")
          );
        }
      }
    }
    parseExpected(22 /* CloseParenToken */);
    const qualifier = parseOptional(25 /* DotToken */) ? parseEntityNameOfTypeReference() : void 0;
    const typeArguments = parseTypeArgumentsOfTypeReference();
    return finishNode(factory2.createImportTypeNode(type, attributes, qualifier, typeArguments, isTypeOf), pos);
  }
  function nextTokenIsNumericOrBigIntLiteral() {
    nextToken();
    return token() === 9 /* NumericLiteral */ || token() === 10 /* BigIntLiteral */;
  }
  function parseNonArrayType() {
    switch (token()) {
      case 133 /* AnyKeyword */:
      case 159 /* UnknownKeyword */:
      case 154 /* StringKeyword */:
      case 150 /* NumberKeyword */:
      case 163 /* BigIntKeyword */:
      case 155 /* SymbolKeyword */:
      case 136 /* BooleanKeyword */:
      case 157 /* UndefinedKeyword */:
      case 146 /* NeverKeyword */:
      case 151 /* ObjectKeyword */:
        return tryParse(parseKeywordAndNoDot) || parseTypeReference();
      case 67 /* AsteriskEqualsToken */:
        scanner2.reScanAsteriskEqualsToken();
      case 42 /* AsteriskToken */:
        return parseJSDocAllType();
      case 61 /* QuestionQuestionToken */:
        scanner2.reScanQuestionToken();
      case 58 /* QuestionToken */:
        return parseJSDocUnknownOrNullableType();
      case 100 /* FunctionKeyword */:
        return parseJSDocFunctionType();
      case 54 /* ExclamationToken */:
        return parseJSDocNonNullableType();
      case 15 /* NoSubstitutionTemplateLiteral */:
      case 11 /* StringLiteral */:
      case 9 /* NumericLiteral */:
      case 10 /* BigIntLiteral */:
      case 112 /* TrueKeyword */:
      case 97 /* FalseKeyword */:
      case 106 /* NullKeyword */:
        return parseLiteralTypeNode();
      case 41 /* MinusToken */:
        return lookAhead(nextTokenIsNumericOrBigIntLiteral) ? parseLiteralTypeNode(
          /*negative*/
          true
        ) : parseTypeReference();
      case 116 /* VoidKeyword */:
        return parseTokenNode();
      case 110 /* ThisKeyword */: {
        const thisKeyword = parseThisTypeNode();
        if (token() === 142 /* IsKeyword */ && !scanner2.hasPrecedingLineBreak()) {
          return parseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      case 114 /* TypeOfKeyword */:
        return lookAhead(isStartOfTypeOfImportType) ? parseImportType() : parseTypeQuery();
      case 19 /* OpenBraceToken */:
        return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();
      case 23 /* OpenBracketToken */:
        return parseTupleType();
      case 21 /* OpenParenToken */:
        return parseParenthesizedType();
      case 102 /* ImportKeyword */:
        return parseImportType();
      case 131 /* AssertsKeyword */:
        return lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? parseAssertsTypePredicate() : parseTypeReference();
      case 16 /* TemplateHead */:
        return parseTemplateType();
      default:
        return parseTypeReference();
    }
  }
  function isStartOfType(inStartOfParameter) {
    switch (token()) {
      case 133 /* AnyKeyword */:
      case 159 /* UnknownKeyword */:
      case 154 /* StringKeyword */:
      case 150 /* NumberKeyword */:
      case 163 /* BigIntKeyword */:
      case 136 /* BooleanKeyword */:
      case 148 /* ReadonlyKeyword */:
      case 155 /* SymbolKeyword */:
      case 158 /* UniqueKeyword */:
      case 116 /* VoidKeyword */:
      case 157 /* UndefinedKeyword */:
      case 106 /* NullKeyword */:
      case 110 /* ThisKeyword */:
      case 114 /* TypeOfKeyword */:
      case 146 /* NeverKeyword */:
      case 19 /* OpenBraceToken */:
      case 23 /* OpenBracketToken */:
      case 30 /* LessThanToken */:
      case 52 /* BarToken */:
      case 51 /* AmpersandToken */:
      case 105 /* NewKeyword */:
      case 11 /* StringLiteral */:
      case 9 /* NumericLiteral */:
      case 10 /* BigIntLiteral */:
      case 112 /* TrueKeyword */:
      case 97 /* FalseKeyword */:
      case 151 /* ObjectKeyword */:
      case 42 /* AsteriskToken */:
      case 58 /* QuestionToken */:
      case 54 /* ExclamationToken */:
      case 26 /* DotDotDotToken */:
      case 140 /* InferKeyword */:
      case 102 /* ImportKeyword */:
      case 131 /* AssertsKeyword */:
      case 15 /* NoSubstitutionTemplateLiteral */:
      case 16 /* TemplateHead */:
        return true;
      case 100 /* FunctionKeyword */:
        return !inStartOfParameter;
      case 41 /* MinusToken */:
        return !inStartOfParameter && lookAhead(nextTokenIsNumericOrBigIntLiteral);
      case 21 /* OpenParenToken */:
        return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);
      default:
        return isIdentifier2();
    }
  }
  function isStartOfParenthesizedOrFunctionType() {
    nextToken();
    return token() === 22 /* CloseParenToken */ || isStartOfParameter(
      /*isJSDocParameter*/
      false
    ) || isStartOfType();
  }
  function parsePostfixTypeOrHigher() {
    const pos = getNodePos();
    let type = parseNonArrayType();
    while (!scanner2.hasPrecedingLineBreak()) {
      switch (token()) {
        case 54 /* ExclamationToken */:
          nextToken();
          type = finishNode(factory2.createJSDocNonNullableType(
            type,
            /*postfix*/
            true
          ), pos);
          break;
        case 58 /* QuestionToken */:
          if (lookAhead(nextTokenIsStartOfType)) {
            return type;
          }
          nextToken();
          type = finishNode(factory2.createJSDocNullableType(
            type,
            /*postfix*/
            true
          ), pos);
          break;
        case 23 /* OpenBracketToken */:
          parseExpected(23 /* OpenBracketToken */);
          if (isStartOfType()) {
            const indexType = parseType();
            parseExpected(24 /* CloseBracketToken */);
            type = finishNode(factory2.createIndexedAccessTypeNode(type, indexType), pos);
          } else {
            parseExpected(24 /* CloseBracketToken */);
            type = finishNode(factory2.createArrayTypeNode(type), pos);
          }
          break;
        default:
          return type;
      }
    }
    return type;
  }
  function parseTypeOperator(operator) {
    const pos = getNodePos();
    parseExpected(operator);
    return finishNode(factory2.createTypeOperatorNode(operator, parseTypeOperatorOrHigher()), pos);
  }
  function tryParseConstraintOfInferType() {
    if (parseOptional(96 /* ExtendsKeyword */)) {
      const constraint = disallowConditionalTypesAnd(parseType);
      if (inDisallowConditionalTypesContext() || token() !== 58 /* QuestionToken */) {
        return constraint;
      }
    }
  }
  function parseTypeParameterOfInferType() {
    const pos = getNodePos();
    const name = parseIdentifier();
    const constraint = tryParse(tryParseConstraintOfInferType);
    const node = factory2.createTypeParameterDeclaration(
      /*modifiers*/
      void 0,
      name,
      constraint
    );
    return finishNode(node, pos);
  }
  function parseInferType() {
    const pos = getNodePos();
    parseExpected(140 /* InferKeyword */);
    return finishNode(factory2.createInferTypeNode(parseTypeParameterOfInferType()), pos);
  }
  function parseTypeOperatorOrHigher() {
    const operator = token();
    switch (operator) {
      case 143 /* KeyOfKeyword */:
      case 158 /* UniqueKeyword */:
      case 148 /* ReadonlyKeyword */:
        return parseTypeOperator(operator);
      case 140 /* InferKeyword */:
        return parseInferType();
    }
    return allowConditionalTypesAnd(parsePostfixTypeOrHigher);
  }
  function parseFunctionOrConstructorTypeToError(isInUnionType) {
    if (isStartOfFunctionTypeOrConstructorType()) {
      const type = parseFunctionOrConstructorType();
      let diagnostic;
      if (isFunctionTypeNode(type)) {
        diagnostic = isInUnionType ? Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type : Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
      } else {
        diagnostic = isInUnionType ? Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type : Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
      }
      parseErrorAtRange(type, diagnostic);
      return type;
    }
    return void 0;
  }
  function parseUnionOrIntersectionType(operator, parseConstituentType, createTypeNode) {
    const pos = getNodePos();
    const isUnionType = operator === 52 /* BarToken */;
    const hasLeadingOperator = parseOptional(operator);
    let type = hasLeadingOperator && parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType();
    if (token() === operator || hasLeadingOperator) {
      const types = [type];
      while (parseOptional(operator)) {
        types.push(parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType());
      }
      type = finishNode(createTypeNode(createNodeArray(types, pos)), pos);
    }
    return type;
  }
  function parseIntersectionTypeOrHigher() {
    return parseUnionOrIntersectionType(51 /* AmpersandToken */, parseTypeOperatorOrHigher, factory2.createIntersectionTypeNode);
  }
  function parseUnionTypeOrHigher() {
    return parseUnionOrIntersectionType(52 /* BarToken */, parseIntersectionTypeOrHigher, factory2.createUnionTypeNode);
  }
  function nextTokenIsNewKeyword() {
    nextToken();
    return token() === 105 /* NewKeyword */;
  }
  function isStartOfFunctionTypeOrConstructorType() {
    if (token() === 30 /* LessThanToken */) {
      return true;
    }
    if (token() === 21 /* OpenParenToken */ && lookAhead(isUnambiguouslyStartOfFunctionType)) {
      return true;
    }
    return token() === 105 /* NewKeyword */ || token() === 128 /* AbstractKeyword */ && lookAhead(nextTokenIsNewKeyword);
  }
  function skipParameterStart() {
    if (isModifierKind(token())) {
      parseModifiers(
        /*allowDecorators*/
        false
      );
    }
    if (isIdentifier2() || token() === 110 /* ThisKeyword */) {
      nextToken();
      return true;
    }
    if (token() === 23 /* OpenBracketToken */ || token() === 19 /* OpenBraceToken */) {
      const previousErrorCount = parseDiagnostics.length;
      parseIdentifierOrPattern();
      return previousErrorCount === parseDiagnostics.length;
    }
    return false;
  }
  function isUnambiguouslyStartOfFunctionType() {
    nextToken();
    if (token() === 22 /* CloseParenToken */ || token() === 26 /* DotDotDotToken */) {
      return true;
    }
    if (skipParameterStart()) {
      if (token() === 59 /* ColonToken */ || token() === 28 /* CommaToken */ || token() === 58 /* QuestionToken */ || token() === 64 /* EqualsToken */) {
        return true;
      }
      if (token() === 22 /* CloseParenToken */) {
        nextToken();
        if (token() === 39 /* EqualsGreaterThanToken */) {
          return true;
        }
      }
    }
    return false;
  }
  function parseTypeOrTypePredicate() {
    const pos = getNodePos();
    const typePredicateVariable = isIdentifier2() && tryParse(parseTypePredicatePrefix);
    const type = parseType();
    if (typePredicateVariable) {
      return finishNode(factory2.createTypePredicateNode(
        /*assertsModifier*/
        void 0,
        typePredicateVariable,
        type
      ), pos);
    } else {
      return type;
    }
  }
  function parseTypePredicatePrefix() {
    const id = parseIdentifier();
    if (token() === 142 /* IsKeyword */ && !scanner2.hasPrecedingLineBreak()) {
      nextToken();
      return id;
    }
  }
  function parseAssertsTypePredicate() {
    const pos = getNodePos();
    const assertsModifier = parseExpectedToken(131 /* AssertsKeyword */);
    const parameterName = token() === 110 /* ThisKeyword */ ? parseThisTypeNode() : parseIdentifier();
    const type = parseOptional(142 /* IsKeyword */) ? parseType() : void 0;
    return finishNode(factory2.createTypePredicateNode(assertsModifier, parameterName, type), pos);
  }
  function parseType() {
    if (contextFlags & 81920 /* TypeExcludesFlags */) {
      return doOutsideOfContext(81920 /* TypeExcludesFlags */, parseType);
    }
    if (isStartOfFunctionTypeOrConstructorType()) {
      return parseFunctionOrConstructorType();
    }
    const pos = getNodePos();
    const type = parseUnionTypeOrHigher();
    if (!inDisallowConditionalTypesContext() && !scanner2.hasPrecedingLineBreak() && parseOptional(96 /* ExtendsKeyword */)) {
      const extendsType = disallowConditionalTypesAnd(parseType);
      parseExpected(58 /* QuestionToken */);
      const trueType = allowConditionalTypesAnd(parseType);
      parseExpected(59 /* ColonToken */);
      const falseType = allowConditionalTypesAnd(parseType);
      return finishNode(factory2.createConditionalTypeNode(type, extendsType, trueType, falseType), pos);
    }
    return type;
  }
  function parseTypeAnnotation() {
    return parseOptional(59 /* ColonToken */) ? parseType() : void 0;
  }
  function isStartOfLeftHandSideExpression() {
    switch (token()) {
      case 110 /* ThisKeyword */:
      case 108 /* SuperKeyword */:
      case 106 /* NullKeyword */:
      case 112 /* TrueKeyword */:
      case 97 /* FalseKeyword */:
      case 9 /* NumericLiteral */:
      case 10 /* BigIntLiteral */:
      case 11 /* StringLiteral */:
      case 15 /* NoSubstitutionTemplateLiteral */:
      case 16 /* TemplateHead */:
      case 21 /* OpenParenToken */:
      case 23 /* OpenBracketToken */:
      case 19 /* OpenBraceToken */:
      case 100 /* FunctionKeyword */:
      case 86 /* ClassKeyword */:
      case 105 /* NewKeyword */:
      case 44 /* SlashToken */:
      case 69 /* SlashEqualsToken */:
      case 80 /* Identifier */:
        return true;
      case 102 /* ImportKeyword */:
        return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
      default:
        return isIdentifier2();
    }
  }
  function isStartOfExpression() {
    if (isStartOfLeftHandSideExpression()) {
      return true;
    }
    switch (token()) {
      case 40 /* PlusToken */:
      case 41 /* MinusToken */:
      case 55 /* TildeToken */:
      case 54 /* ExclamationToken */:
      case 91 /* DeleteKeyword */:
      case 114 /* TypeOfKeyword */:
      case 116 /* VoidKeyword */:
      case 46 /* PlusPlusToken */:
      case 47 /* MinusMinusToken */:
      case 30 /* LessThanToken */:
      case 135 /* AwaitKeyword */:
      case 127 /* YieldKeyword */:
      case 81 /* PrivateIdentifier */:
      case 60 /* AtToken */:
        return true;
      default:
        if (isBinaryOperator2()) {
          return true;
        }
        return isIdentifier2();
    }
  }
  function isStartOfExpressionStatement() {
    return token() !== 19 /* OpenBraceToken */ && token() !== 100 /* FunctionKeyword */ && token() !== 86 /* ClassKeyword */ && token() !== 60 /* AtToken */ && isStartOfExpression();
  }
  function parseExpression() {
    const saveDecoratorContext = inDecoratorContext();
    if (saveDecoratorContext) {
      setDecoratorContext(
        /*val*/
        false
      );
    }
    const pos = getNodePos();
    let expr = parseAssignmentExpressionOrHigher(
      /*allowReturnTypeInArrowFunction*/
      true
    );
    let operatorToken;
    while (operatorToken = parseOptionalToken(28 /* CommaToken */)) {
      expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher(
        /*allowReturnTypeInArrowFunction*/
        true
      ), pos);
    }
    if (saveDecoratorContext) {
      setDecoratorContext(
        /*val*/
        true
      );
    }
    return expr;
  }
  function parseInitializer() {
    return parseOptional(64 /* EqualsToken */) ? parseAssignmentExpressionOrHigher(
      /*allowReturnTypeInArrowFunction*/
      true
    ) : void 0;
  }
  function parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction) {
    if (isYieldExpression2()) {
      return parseYieldExpression();
    }
    const arrowExpression = tryParseParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) || tryParseAsyncSimpleArrowFunctionExpression(allowReturnTypeInArrowFunction);
    if (arrowExpression) {
      return arrowExpression;
    }
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const expr = parseBinaryExpressionOrHigher(0 /* Lowest */);
    if (expr.kind === 80 /* Identifier */ && token() === 39 /* EqualsGreaterThanToken */) {
      return parseSimpleArrowFunctionExpression(
        pos,
        expr,
        allowReturnTypeInArrowFunction,
        hasJSDoc,
        /*asyncModifier*/
        void 0
      );
    }
    if (isLeftHandSideExpression(expr) && isAssignmentOperator(reScanGreaterToken())) {
      return makeBinaryExpression(expr, parseTokenNode(), parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction), pos);
    }
    return parseConditionalExpressionRest(expr, pos, allowReturnTypeInArrowFunction);
  }
  function isYieldExpression2() {
    if (token() === 127 /* YieldKeyword */) {
      if (inYieldContext()) {
        return true;
      }
      return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
    }
    return false;
  }
  function nextTokenIsIdentifierOnSameLine() {
    nextToken();
    return !scanner2.hasPrecedingLineBreak() && isIdentifier2();
  }
  function parseYieldExpression() {
    const pos = getNodePos();
    nextToken();
    if (!scanner2.hasPrecedingLineBreak() && (token() === 42 /* AsteriskToken */ || isStartOfExpression())) {
      return finishNode(
        factory2.createYieldExpression(
          parseOptionalToken(42 /* AsteriskToken */),
          parseAssignmentExpressionOrHigher(
            /*allowReturnTypeInArrowFunction*/
            true
          )
        ),
        pos
      );
    } else {
      return finishNode(factory2.createYieldExpression(
        /*asteriskToken*/
        void 0,
        /*expression*/
        void 0
      ), pos);
    }
  }
  function parseSimpleArrowFunctionExpression(pos, identifier, allowReturnTypeInArrowFunction, hasJSDoc, asyncModifier) {
    Debug.assert(token() === 39 /* EqualsGreaterThanToken */, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
    const parameter = factory2.createParameterDeclaration(
      /*modifiers*/
      void 0,
      /*dotDotDotToken*/
      void 0,
      identifier,
      /*questionToken*/
      void 0,
      /*type*/
      void 0,
      /*initializer*/
      void 0
    );
    finishNode(parameter, identifier.pos);
    const parameters = createNodeArray([parameter], parameter.pos, parameter.end);
    const equalsGreaterThanToken = parseExpectedToken(39 /* EqualsGreaterThanToken */);
    const body = parseArrowFunctionExpressionBody(
      /*isAsync*/
      !!asyncModifier,
      allowReturnTypeInArrowFunction
    );
    const node = factory2.createArrowFunction(
      asyncModifier,
      /*typeParameters*/
      void 0,
      parameters,
      /*type*/
      void 0,
      equalsGreaterThanToken,
      body
    );
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function tryParseParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) {
    const triState = isParenthesizedArrowFunctionExpression();
    if (triState === 0 /* False */) {
      return void 0;
    }
    return triState === 1 /* True */ ? parseParenthesizedArrowFunctionExpression(
      /*allowAmbiguity*/
      true,
      /*allowReturnTypeInArrowFunction*/
      true
    ) : tryParse(() => parsePossibleParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction));
  }
  function isParenthesizedArrowFunctionExpression() {
    if (token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */ || token() === 134 /* AsyncKeyword */) {
      return lookAhead(isParenthesizedArrowFunctionExpressionWorker);
    }
    if (token() === 39 /* EqualsGreaterThanToken */) {
      return 1 /* True */;
    }
    return 0 /* False */;
  }
  function isParenthesizedArrowFunctionExpressionWorker() {
    if (token() === 134 /* AsyncKeyword */) {
      nextToken();
      if (scanner2.hasPrecedingLineBreak()) {
        return 0 /* False */;
      }
      if (token() !== 21 /* OpenParenToken */ && token() !== 30 /* LessThanToken */) {
        return 0 /* False */;
      }
    }
    const first2 = token();
    const second = nextToken();
    if (first2 === 21 /* OpenParenToken */) {
      if (second === 22 /* CloseParenToken */) {
        const third = nextToken();
        switch (third) {
          case 39 /* EqualsGreaterThanToken */:
          case 59 /* ColonToken */:
          case 19 /* OpenBraceToken */:
            return 1 /* True */;
          default:
            return 0 /* False */;
        }
      }
      if (second === 23 /* OpenBracketToken */ || second === 19 /* OpenBraceToken */) {
        return 2 /* Unknown */;
      }
      if (second === 26 /* DotDotDotToken */) {
        return 1 /* True */;
      }
      if (isModifierKind(second) && second !== 134 /* AsyncKeyword */ && lookAhead(nextTokenIsIdentifier)) {
        if (nextToken() === 130 /* AsKeyword */) {
          return 0 /* False */;
        }
        return 1 /* True */;
      }
      if (!isIdentifier2() && second !== 110 /* ThisKeyword */) {
        return 0 /* False */;
      }
      switch (nextToken()) {
        case 59 /* ColonToken */:
          return 1 /* True */;
        case 58 /* QuestionToken */:
          nextToken();
          if (token() === 59 /* ColonToken */ || token() === 28 /* CommaToken */ || token() === 64 /* EqualsToken */ || token() === 22 /* CloseParenToken */) {
            return 1 /* True */;
          }
          return 0 /* False */;
        case 28 /* CommaToken */:
        case 64 /* EqualsToken */:
        case 22 /* CloseParenToken */:
          return 2 /* Unknown */;
      }
      return 0 /* False */;
    } else {
      Debug.assert(first2 === 30 /* LessThanToken */);
      if (!isIdentifier2() && token() !== 87 /* ConstKeyword */) {
        return 0 /* False */;
      }
      if (languageVariant === 1 /* JSX */) {
        const isArrowFunctionInJsx = lookAhead(() => {
          parseOptional(87 /* ConstKeyword */);
          const third = nextToken();
          if (third === 96 /* ExtendsKeyword */) {
            const fourth = nextToken();
            switch (fourth) {
              case 64 /* EqualsToken */:
              case 32 /* GreaterThanToken */:
              case 44 /* SlashToken */:
                return false;
              default:
                return true;
            }
          } else if (third === 28 /* CommaToken */ || third === 64 /* EqualsToken */) {
            return true;
          }
          return false;
        });
        if (isArrowFunctionInJsx) {
          return 1 /* True */;
        }
        return 0 /* False */;
      }
      return 2 /* Unknown */;
    }
  }
  function parsePossibleParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) {
    const tokenPos = scanner2.getTokenStart();
    if (notParenthesizedArrow == null ? void 0 : notParenthesizedArrow.has(tokenPos)) {
      return void 0;
    }
    const result = parseParenthesizedArrowFunctionExpression(
      /*allowAmbiguity*/
      false,
      allowReturnTypeInArrowFunction
    );
    if (!result) {
      (notParenthesizedArrow || (notParenthesizedArrow = /* @__PURE__ */ new Set())).add(tokenPos);
    }
    return result;
  }
  function tryParseAsyncSimpleArrowFunctionExpression(allowReturnTypeInArrowFunction) {
    if (token() === 134 /* AsyncKeyword */) {
      if (lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) === 1 /* True */) {
        const pos = getNodePos();
        const hasJSDoc = hasPrecedingJSDocComment();
        const asyncModifier = parseModifiersForArrowFunction();
        const expr = parseBinaryExpressionOrHigher(0 /* Lowest */);
        return parseSimpleArrowFunctionExpression(pos, expr, allowReturnTypeInArrowFunction, hasJSDoc, asyncModifier);
      }
    }
    return void 0;
  }
  function isUnParenthesizedAsyncArrowFunctionWorker() {
    if (token() === 134 /* AsyncKeyword */) {
      nextToken();
      if (scanner2.hasPrecedingLineBreak() || token() === 39 /* EqualsGreaterThanToken */) {
        return 0 /* False */;
      }
      const expr = parseBinaryExpressionOrHigher(0 /* Lowest */);
      if (!scanner2.hasPrecedingLineBreak() && expr.kind === 80 /* Identifier */ && token() === 39 /* EqualsGreaterThanToken */) {
        return 1 /* True */;
      }
    }
    return 0 /* False */;
  }
  function parseParenthesizedArrowFunctionExpression(allowAmbiguity, allowReturnTypeInArrowFunction) {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const modifiers = parseModifiersForArrowFunction();
    const isAsync = some(modifiers, isAsyncModifier) ? 2 /* Await */ : 0 /* None */;
    const typeParameters = parseTypeParameters();
    let parameters;
    if (!parseExpected(21 /* OpenParenToken */)) {
      if (!allowAmbiguity) {
        return void 0;
      }
      parameters = createMissingList();
    } else {
      if (!allowAmbiguity) {
        const maybeParameters = parseParametersWorker(isAsync, allowAmbiguity);
        if (!maybeParameters) {
          return void 0;
        }
        parameters = maybeParameters;
      } else {
        parameters = parseParametersWorker(isAsync, allowAmbiguity);
      }
      if (!parseExpected(22 /* CloseParenToken */) && !allowAmbiguity) {
        return void 0;
      }
    }
    const hasReturnColon = token() === 59 /* ColonToken */;
    const type = parseReturnType(
      59 /* ColonToken */,
      /*isType*/
      false
    );
    if (type && !allowAmbiguity && typeHasArrowFunctionBlockingParseError(type)) {
      return void 0;
    }
    let unwrappedType = type;
    while ((unwrappedType == null ? void 0 : unwrappedType.kind) === 196 /* ParenthesizedType */) {
      unwrappedType = unwrappedType.type;
    }
    const hasJSDocFunctionType = unwrappedType && isJSDocFunctionType(unwrappedType);
    if (!allowAmbiguity && token() !== 39 /* EqualsGreaterThanToken */ && (hasJSDocFunctionType || token() !== 19 /* OpenBraceToken */)) {
      return void 0;
    }
    const lastToken = token();
    const equalsGreaterThanToken = parseExpectedToken(39 /* EqualsGreaterThanToken */);
    const body = lastToken === 39 /* EqualsGreaterThanToken */ || lastToken === 19 /* OpenBraceToken */ ? parseArrowFunctionExpressionBody(some(modifiers, isAsyncModifier), allowReturnTypeInArrowFunction) : parseIdentifier();
    if (!allowReturnTypeInArrowFunction && hasReturnColon) {
      if (token() !== 59 /* ColonToken */) {
        return void 0;
      }
    }
    const node = factory2.createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseArrowFunctionExpressionBody(isAsync, allowReturnTypeInArrowFunction) {
    if (token() === 19 /* OpenBraceToken */) {
      return parseFunctionBlock(isAsync ? 2 /* Await */ : 0 /* None */);
    }
    if (token() !== 27 /* SemicolonToken */ && token() !== 100 /* FunctionKeyword */ && token() !== 86 /* ClassKeyword */ && isStartOfStatement() && !isStartOfExpressionStatement()) {
      return parseFunctionBlock(16 /* IgnoreMissingOpenBrace */ | (isAsync ? 2 /* Await */ : 0 /* None */));
    }
    const savedTopLevel = topLevel;
    topLevel = false;
    const node = isAsync ? doInAwaitContext(() => parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction)) : doOutsideOfAwaitContext(() => parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction));
    topLevel = savedTopLevel;
    return node;
  }
  function parseConditionalExpressionRest(leftOperand, pos, allowReturnTypeInArrowFunction) {
    const questionToken = parseOptionalToken(58 /* QuestionToken */);
    if (!questionToken) {
      return leftOperand;
    }
    let colonToken;
    return finishNode(
      factory2.createConditionalExpression(
        leftOperand,
        questionToken,
        doOutsideOfContext(disallowInAndDecoratorContext, () => parseAssignmentExpressionOrHigher(
          /*allowReturnTypeInArrowFunction*/
          false
        )),
        colonToken = parseExpectedToken(59 /* ColonToken */),
        nodeIsPresent(colonToken) ? parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction) : createMissingNode(
          80 /* Identifier */,
          /*reportAtCurrentPosition*/
          false,
          Diagnostics._0_expected,
          tokenToString(59 /* ColonToken */)
        )
      ),
      pos
    );
  }
  function parseBinaryExpressionOrHigher(precedence) {
    const pos = getNodePos();
    const leftOperand = parseUnaryExpressionOrHigher();
    return parseBinaryExpressionRest(precedence, leftOperand, pos);
  }
  function isInOrOfKeyword(t) {
    return t === 103 /* InKeyword */ || t === 165 /* OfKeyword */;
  }
  function parseBinaryExpressionRest(precedence, leftOperand, pos) {
    while (true) {
      reScanGreaterToken();
      const newPrecedence = getBinaryOperatorPrecedence(token());
      const consumeCurrentOperator = token() === 43 /* AsteriskAsteriskToken */ ? newPrecedence >= precedence : newPrecedence > precedence;
      if (!consumeCurrentOperator) {
        break;
      }
      if (token() === 103 /* InKeyword */ && inDisallowInContext()) {
        break;
      }
      if (token() === 130 /* AsKeyword */ || token() === 152 /* SatisfiesKeyword */) {
        if (scanner2.hasPrecedingLineBreak()) {
          break;
        } else {
          const keywordKind = token();
          nextToken();
          leftOperand = keywordKind === 152 /* SatisfiesKeyword */ ? makeSatisfiesExpression(leftOperand, parseType()) : makeAsExpression(leftOperand, parseType());
        }
      } else {
        leftOperand = makeBinaryExpression(leftOperand, parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence), pos);
      }
    }
    return leftOperand;
  }
  function isBinaryOperator2() {
    if (inDisallowInContext() && token() === 103 /* InKeyword */) {
      return false;
    }
    return getBinaryOperatorPrecedence(token()) > 0;
  }
  function makeSatisfiesExpression(left, right) {
    return finishNode(factory2.createSatisfiesExpression(left, right), left.pos);
  }
  function makeBinaryExpression(left, operatorToken, right, pos) {
    return finishNode(factory2.createBinaryExpression(left, operatorToken, right), pos);
  }
  function makeAsExpression(left, right) {
    return finishNode(factory2.createAsExpression(left, right), left.pos);
  }
  function parsePrefixUnaryExpression() {
    const pos = getNodePos();
    return finishNode(factory2.createPrefixUnaryExpression(token(), nextTokenAnd(parseSimpleUnaryExpression)), pos);
  }
  function parseDeleteExpression() {
    const pos = getNodePos();
    return finishNode(factory2.createDeleteExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
  }
  function parseTypeOfExpression() {
    const pos = getNodePos();
    return finishNode(factory2.createTypeOfExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
  }
  function parseVoidExpression() {
    const pos = getNodePos();
    return finishNode(factory2.createVoidExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
  }
  function isAwaitExpression2() {
    if (token() === 135 /* AwaitKeyword */) {
      if (inAwaitContext()) {
        return true;
      }
      return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
    }
    return false;
  }
  function parseAwaitExpression() {
    const pos = getNodePos();
    return finishNode(factory2.createAwaitExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
  }
  function parseUnaryExpressionOrHigher() {
    if (isUpdateExpression()) {
      const pos = getNodePos();
      const updateExpression = parseUpdateExpression();
      return token() === 43 /* AsteriskAsteriskToken */ ? parseBinaryExpressionRest(getBinaryOperatorPrecedence(token()), updateExpression, pos) : updateExpression;
    }
    const unaryOperator = token();
    const simpleUnaryExpression = parseSimpleUnaryExpression();
    if (token() === 43 /* AsteriskAsteriskToken */) {
      const pos = skipTrivia(sourceText, simpleUnaryExpression.pos);
      const { end } = simpleUnaryExpression;
      if (simpleUnaryExpression.kind === 216 /* TypeAssertionExpression */) {
        parseErrorAt(pos, end, Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses);
      } else {
        Debug.assert(isKeywordOrPunctuation(unaryOperator));
        parseErrorAt(pos, end, Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, tokenToString(unaryOperator));
      }
    }
    return simpleUnaryExpression;
  }
  function parseSimpleUnaryExpression() {
    switch (token()) {
      case 40 /* PlusToken */:
      case 41 /* MinusToken */:
      case 55 /* TildeToken */:
      case 54 /* ExclamationToken */:
        return parsePrefixUnaryExpression();
      case 91 /* DeleteKeyword */:
        return parseDeleteExpression();
      case 114 /* TypeOfKeyword */:
        return parseTypeOfExpression();
      case 116 /* VoidKeyword */:
        return parseVoidExpression();
      case 30 /* LessThanToken */:
        if (languageVariant === 1 /* JSX */) {
          return parseJsxElementOrSelfClosingElementOrFragment(
            /*inExpressionContext*/
            true,
            /*topInvalidNodePosition*/
            void 0,
            /*openingTag*/
            void 0,
            /*mustBeUnary*/
            true
          );
        }
        return parseTypeAssertion();
      case 135 /* AwaitKeyword */:
        if (isAwaitExpression2()) {
          return parseAwaitExpression();
        }
      default:
        return parseUpdateExpression();
    }
  }
  function isUpdateExpression() {
    switch (token()) {
      case 40 /* PlusToken */:
      case 41 /* MinusToken */:
      case 55 /* TildeToken */:
      case 54 /* ExclamationToken */:
      case 91 /* DeleteKeyword */:
      case 114 /* TypeOfKeyword */:
      case 116 /* VoidKeyword */:
      case 135 /* AwaitKeyword */:
        return false;
      case 30 /* LessThanToken */:
        if (languageVariant !== 1 /* JSX */) {
          return false;
        }
      default:
        return true;
    }
  }
  function parseUpdateExpression() {
    if (token() === 46 /* PlusPlusToken */ || token() === 47 /* MinusMinusToken */) {
      const pos = getNodePos();
      return finishNode(factory2.createPrefixUnaryExpression(token(), nextTokenAnd(parseLeftHandSideExpressionOrHigher)), pos);
    } else if (languageVariant === 1 /* JSX */ && token() === 30 /* LessThanToken */ && lookAhead(nextTokenIsIdentifierOrKeywordOrGreaterThan)) {
      return parseJsxElementOrSelfClosingElementOrFragment(
        /*inExpressionContext*/
        true
      );
    }
    const expression = parseLeftHandSideExpressionOrHigher();
    Debug.assert(isLeftHandSideExpression(expression));
    if ((token() === 46 /* PlusPlusToken */ || token() === 47 /* MinusMinusToken */) && !scanner2.hasPrecedingLineBreak()) {
      const operator = token();
      nextToken();
      return finishNode(factory2.createPostfixUnaryExpression(expression, operator), expression.pos);
    }
    return expression;
  }
  function parseLeftHandSideExpressionOrHigher() {
    const pos = getNodePos();
    let expression;
    if (token() === 102 /* ImportKeyword */) {
      if (lookAhead(nextTokenIsOpenParenOrLessThan)) {
        sourceFlags |= 4194304 /* PossiblyContainsDynamicImport */;
        expression = parseTokenNode();
      } else if (lookAhead(nextTokenIsDot)) {
        nextToken();
        nextToken();
        expression = finishNode(factory2.createMetaProperty(102 /* ImportKeyword */, parseIdentifierName()), pos);
        sourceFlags |= 8388608 /* PossiblyContainsImportMeta */;
      } else {
        expression = parseMemberExpressionOrHigher();
      }
    } else {
      expression = token() === 108 /* SuperKeyword */ ? parseSuperExpression() : parseMemberExpressionOrHigher();
    }
    return parseCallExpressionRest(pos, expression);
  }
  function parseMemberExpressionOrHigher() {
    const pos = getNodePos();
    const expression = parsePrimaryExpression();
    return parseMemberExpressionRest(
      pos,
      expression,
      /*allowOptionalChain*/
      true
    );
  }
  function parseSuperExpression() {
    const pos = getNodePos();
    let expression = parseTokenNode();
    if (token() === 30 /* LessThanToken */) {
      const startPos = getNodePos();
      const typeArguments = tryParse(parseTypeArgumentsInExpression);
      if (typeArguments !== void 0) {
        parseErrorAt(startPos, getNodePos(), Diagnostics.super_may_not_use_type_arguments);
        if (!isTemplateStartOfTaggedTemplate()) {
          expression = factory2.createExpressionWithTypeArguments(expression, typeArguments);
        }
      }
    }
    if (token() === 21 /* OpenParenToken */ || token() === 25 /* DotToken */ || token() === 23 /* OpenBracketToken */) {
      return expression;
    }
    parseExpectedToken(25 /* DotToken */, Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
    return finishNode(factoryCreatePropertyAccessExpression(expression, parseRightSideOfDot(
      /*allowIdentifierNames*/
      true,
      /*allowPrivateIdentifiers*/
      true,
      /*allowUnicodeEscapeSequenceInIdentifierName*/
      true
    )), pos);
  }
  function parseJsxElementOrSelfClosingElementOrFragment(inExpressionContext, topInvalidNodePosition, openingTag, mustBeUnary = false) {
    const pos = getNodePos();
    const opening = parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext);
    let result;
    if (opening.kind === 286 /* JsxOpeningElement */) {
      let children = parseJsxChildren(opening);
      let closingElement;
      const lastChild = children[children.length - 1];
      if ((lastChild == null ? void 0 : lastChild.kind) === 284 /* JsxElement */ && !tagNamesAreEquivalent(lastChild.openingElement.tagName, lastChild.closingElement.tagName) && tagNamesAreEquivalent(opening.tagName, lastChild.closingElement.tagName)) {
        const end = lastChild.children.end;
        const newLast = finishNode(
          factory2.createJsxElement(
            lastChild.openingElement,
            lastChild.children,
            finishNode(factory2.createJsxClosingElement(finishNode(factoryCreateIdentifier(""), end, end)), end, end)
          ),
          lastChild.openingElement.pos,
          end
        );
        children = createNodeArray([...children.slice(0, children.length - 1), newLast], children.pos, end);
        closingElement = lastChild.closingElement;
      } else {
        closingElement = parseJsxClosingElement(opening, inExpressionContext);
        if (!tagNamesAreEquivalent(opening.tagName, closingElement.tagName)) {
          if (openingTag && isJsxOpeningElement(openingTag) && tagNamesAreEquivalent(closingElement.tagName, openingTag.tagName)) {
            parseErrorAtRange(opening.tagName, Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, getTextOfNodeFromSourceText(sourceText, opening.tagName));
          } else {
            parseErrorAtRange(closingElement.tagName, Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, getTextOfNodeFromSourceText(sourceText, opening.tagName));
          }
        }
      }
      result = finishNode(factory2.createJsxElement(opening, children, closingElement), pos);
    } else if (opening.kind === 289 /* JsxOpeningFragment */) {
      result = finishNode(factory2.createJsxFragment(opening, parseJsxChildren(opening), parseJsxClosingFragment(inExpressionContext)), pos);
    } else {
      Debug.assert(opening.kind === 285 /* JsxSelfClosingElement */);
      result = opening;
    }
    if (!mustBeUnary && inExpressionContext && token() === 30 /* LessThanToken */) {
      const topBadPos = typeof topInvalidNodePosition === "undefined" ? result.pos : topInvalidNodePosition;
      const invalidElement = tryParse(() => parseJsxElementOrSelfClosingElementOrFragment(
        /*inExpressionContext*/
        true,
        topBadPos
      ));
      if (invalidElement) {
        const operatorToken = createMissingNode(
          28 /* CommaToken */,
          /*reportAtCurrentPosition*/
          false
        );
        setTextRangePosWidth(operatorToken, invalidElement.pos, 0);
        parseErrorAt(skipTrivia(sourceText, topBadPos), invalidElement.end, Diagnostics.JSX_expressions_must_have_one_parent_element);
        return finishNode(factory2.createBinaryExpression(result, operatorToken, invalidElement), pos);
      }
    }
    return result;
  }
  function parseJsxText() {
    const pos = getNodePos();
    const node = factory2.createJsxText(scanner2.getTokenValue(), currentToken === 13 /* JsxTextAllWhiteSpaces */);
    currentToken = scanner2.scanJsxToken();
    return finishNode(node, pos);
  }
  function parseJsxChild(openingTag, token2) {
    switch (token2) {
      case 1 /* EndOfFileToken */:
        if (isJsxOpeningFragment(openingTag)) {
          parseErrorAtRange(openingTag, Diagnostics.JSX_fragment_has_no_corresponding_closing_tag);
        } else {
          const tag = openingTag.tagName;
          const start2 = Math.min(skipTrivia(sourceText, tag.pos), tag.end);
          parseErrorAt(start2, tag.end, Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, getTextOfNodeFromSourceText(sourceText, openingTag.tagName));
        }
        return void 0;
      case 31 /* LessThanSlashToken */:
      case 7 /* ConflictMarkerTrivia */:
        return void 0;
      case 12 /* JsxText */:
      case 13 /* JsxTextAllWhiteSpaces */:
        return parseJsxText();
      case 19 /* OpenBraceToken */:
        return parseJsxExpression(
          /*inExpressionContext*/
          false
        );
      case 30 /* LessThanToken */:
        return parseJsxElementOrSelfClosingElementOrFragment(
          /*inExpressionContext*/
          false,
          /*topInvalidNodePosition*/
          void 0,
          openingTag
        );
      default:
        return Debug.assertNever(token2);
    }
  }
  function parseJsxChildren(openingTag) {
    const list = [];
    const listPos = getNodePos();
    const saveParsingContext = parsingContext;
    parsingContext |= 1 << 14 /* JsxChildren */;
    while (true) {
      const child = parseJsxChild(openingTag, currentToken = scanner2.reScanJsxToken());
      if (!child)
        break;
      list.push(child);
      if (isJsxOpeningElement(openingTag) && (child == null ? void 0 : child.kind) === 284 /* JsxElement */ && !tagNamesAreEquivalent(child.openingElement.tagName, child.closingElement.tagName) && tagNamesAreEquivalent(openingTag.tagName, child.closingElement.tagName)) {
        break;
      }
    }
    parsingContext = saveParsingContext;
    return createNodeArray(list, listPos);
  }
  function parseJsxAttributes() {
    const pos = getNodePos();
    return finishNode(factory2.createJsxAttributes(parseList(13 /* JsxAttributes */, parseJsxAttribute)), pos);
  }
  function parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext) {
    const pos = getNodePos();
    parseExpected(30 /* LessThanToken */);
    if (token() === 32 /* GreaterThanToken */) {
      scanJsxText();
      return finishNode(factory2.createJsxOpeningFragment(), pos);
    }
    const tagName = parseJsxElementName();
    const typeArguments = (contextFlags & 524288 /* JavaScriptFile */) === 0 ? tryParseTypeArguments() : void 0;
    const attributes = parseJsxAttributes();
    let node;
    if (token() === 32 /* GreaterThanToken */) {
      scanJsxText();
      node = factory2.createJsxOpeningElement(tagName, typeArguments, attributes);
    } else {
      parseExpected(44 /* SlashToken */);
      if (parseExpected(
        32 /* GreaterThanToken */,
        /*diagnosticMessage*/
        void 0,
        /*shouldAdvance*/
        false
      )) {
        if (inExpressionContext) {
          nextToken();
        } else {
          scanJsxText();
        }
      }
      node = factory2.createJsxSelfClosingElement(tagName, typeArguments, attributes);
    }
    return finishNode(node, pos);
  }
  function parseJsxElementName() {
    const pos = getNodePos();
    const initialExpression = parseJsxTagName();
    if (isJsxNamespacedName(initialExpression)) {
      return initialExpression;
    }
    let expression = initialExpression;
    while (parseOptional(25 /* DotToken */)) {
      expression = finishNode(factoryCreatePropertyAccessExpression(expression, parseRightSideOfDot(
        /*allowIdentifierNames*/
        true,
        /*allowPrivateIdentifiers*/
        false,
        /*allowUnicodeEscapeSequenceInIdentifierName*/
        false
      )), pos);
    }
    return expression;
  }
  function parseJsxTagName() {
    const pos = getNodePos();
    scanJsxIdentifier();
    const isThis2 = token() === 110 /* ThisKeyword */;
    const tagName = parseIdentifierNameErrorOnUnicodeEscapeSequence();
    if (parseOptional(59 /* ColonToken */)) {
      scanJsxIdentifier();
      return finishNode(factory2.createJsxNamespacedName(tagName, parseIdentifierNameErrorOnUnicodeEscapeSequence()), pos);
    }
    return isThis2 ? finishNode(factory2.createToken(110 /* ThisKeyword */), pos) : tagName;
  }
  function parseJsxExpression(inExpressionContext) {
    const pos = getNodePos();
    if (!parseExpected(19 /* OpenBraceToken */)) {
      return void 0;
    }
    let dotDotDotToken;
    let expression;
    if (token() !== 20 /* CloseBraceToken */) {
      if (!inExpressionContext) {
        dotDotDotToken = parseOptionalToken(26 /* DotDotDotToken */);
      }
      expression = parseExpression();
    }
    if (inExpressionContext) {
      parseExpected(20 /* CloseBraceToken */);
    } else {
      if (parseExpected(
        20 /* CloseBraceToken */,
        /*diagnosticMessage*/
        void 0,
        /*shouldAdvance*/
        false
      )) {
        scanJsxText();
      }
    }
    return finishNode(factory2.createJsxExpression(dotDotDotToken, expression), pos);
  }
  function parseJsxAttribute() {
    if (token() === 19 /* OpenBraceToken */) {
      return parseJsxSpreadAttribute();
    }
    const pos = getNodePos();
    return finishNode(factory2.createJsxAttribute(parseJsxAttributeName(), parseJsxAttributeValue()), pos);
  }
  function parseJsxAttributeValue() {
    if (token() === 64 /* EqualsToken */) {
      if (scanJsxAttributeValue() === 11 /* StringLiteral */) {
        return parseLiteralNode();
      }
      if (token() === 19 /* OpenBraceToken */) {
        return parseJsxExpression(
          /*inExpressionContext*/
          true
        );
      }
      if (token() === 30 /* LessThanToken */) {
        return parseJsxElementOrSelfClosingElementOrFragment(
          /*inExpressionContext*/
          true
        );
      }
      parseErrorAtCurrentToken(Diagnostics.or_JSX_element_expected);
    }
    return void 0;
  }
  function parseJsxAttributeName() {
    const pos = getNodePos();
    scanJsxIdentifier();
    const attrName = parseIdentifierNameErrorOnUnicodeEscapeSequence();
    if (parseOptional(59 /* ColonToken */)) {
      scanJsxIdentifier();
      return finishNode(factory2.createJsxNamespacedName(attrName, parseIdentifierNameErrorOnUnicodeEscapeSequence()), pos);
    }
    return attrName;
  }
  function parseJsxSpreadAttribute() {
    const pos = getNodePos();
    parseExpected(19 /* OpenBraceToken */);
    parseExpected(26 /* DotDotDotToken */);
    const expression = parseExpression();
    parseExpected(20 /* CloseBraceToken */);
    return finishNode(factory2.createJsxSpreadAttribute(expression), pos);
  }
  function parseJsxClosingElement(open, inExpressionContext) {
    const pos = getNodePos();
    parseExpected(31 /* LessThanSlashToken */);
    const tagName = parseJsxElementName();
    if (parseExpected(
      32 /* GreaterThanToken */,
      /*diagnosticMessage*/
      void 0,
      /*shouldAdvance*/
      false
    )) {
      if (inExpressionContext || !tagNamesAreEquivalent(open.tagName, tagName)) {
        nextToken();
      } else {
        scanJsxText();
      }
    }
    return finishNode(factory2.createJsxClosingElement(tagName), pos);
  }
  function parseJsxClosingFragment(inExpressionContext) {
    const pos = getNodePos();
    parseExpected(31 /* LessThanSlashToken */);
    if (parseExpected(
      32 /* GreaterThanToken */,
      Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment,
      /*shouldAdvance*/
      false
    )) {
      if (inExpressionContext) {
        nextToken();
      } else {
        scanJsxText();
      }
    }
    return finishNode(factory2.createJsxJsxClosingFragment(), pos);
  }
  function parseTypeAssertion() {
    Debug.assert(languageVariant !== 1 /* JSX */, "Type assertions should never be parsed in JSX; they should be parsed as comparisons or JSX elements/fragments.");
    const pos = getNodePos();
    parseExpected(30 /* LessThanToken */);
    const type = parseType();
    parseExpected(32 /* GreaterThanToken */);
    const expression = parseSimpleUnaryExpression();
    return finishNode(factory2.createTypeAssertion(type, expression), pos);
  }
  function nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate() {
    nextToken();
    return tokenIsIdentifierOrKeyword(token()) || token() === 23 /* OpenBracketToken */ || isTemplateStartOfTaggedTemplate();
  }
  function isStartOfOptionalPropertyOrElementAccessChain() {
    return token() === 29 /* QuestionDotToken */ && lookAhead(nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate);
  }
  function tryReparseOptionalChain(node) {
    if (node.flags & 64 /* OptionalChain */) {
      return true;
    }
    if (isNonNullExpression(node)) {
      let expr = node.expression;
      while (isNonNullExpression(expr) && !(expr.flags & 64 /* OptionalChain */)) {
        expr = expr.expression;
      }
      if (expr.flags & 64 /* OptionalChain */) {
        while (isNonNullExpression(node)) {
          node.flags |= 64 /* OptionalChain */;
          node = node.expression;
        }
        return true;
      }
    }
    return false;
  }
  function parsePropertyAccessExpressionRest(pos, expression, questionDotToken) {
    const name = parseRightSideOfDot(
      /*allowIdentifierNames*/
      true,
      /*allowPrivateIdentifiers*/
      true,
      /*allowUnicodeEscapeSequenceInIdentifierName*/
      true
    );
    const isOptionalChain2 = questionDotToken || tryReparseOptionalChain(expression);
    const propertyAccess = isOptionalChain2 ? factoryCreatePropertyAccessChain(expression, questionDotToken, name) : factoryCreatePropertyAccessExpression(expression, name);
    if (isOptionalChain2 && isPrivateIdentifier(propertyAccess.name)) {
      parseErrorAtRange(propertyAccess.name, Diagnostics.An_optional_chain_cannot_contain_private_identifiers);
    }
    if (isExpressionWithTypeArguments(expression) && expression.typeArguments) {
      const pos2 = expression.typeArguments.pos - 1;
      const end = skipTrivia(sourceText, expression.typeArguments.end) + 1;
      parseErrorAt(pos2, end, Diagnostics.An_instantiation_expression_cannot_be_followed_by_a_property_access);
    }
    return finishNode(propertyAccess, pos);
  }
  function parseElementAccessExpressionRest(pos, expression, questionDotToken) {
    let argumentExpression;
    if (token() === 24 /* CloseBracketToken */) {
      argumentExpression = createMissingNode(
        80 /* Identifier */,
        /*reportAtCurrentPosition*/
        true,
        Diagnostics.An_element_access_expression_should_take_an_argument
      );
    } else {
      const argument = allowInAnd(parseExpression);
      if (isStringOrNumericLiteralLike(argument)) {
        argument.text = internIdentifier(argument.text);
      }
      argumentExpression = argument;
    }
    parseExpected(24 /* CloseBracketToken */);
    const indexedAccess = questionDotToken || tryReparseOptionalChain(expression) ? factoryCreateElementAccessChain(expression, questionDotToken, argumentExpression) : factoryCreateElementAccessExpression(expression, argumentExpression);
    return finishNode(indexedAccess, pos);
  }
  function parseMemberExpressionRest(pos, expression, allowOptionalChain) {
    while (true) {
      let questionDotToken;
      let isPropertyAccess = false;
      if (allowOptionalChain && isStartOfOptionalPropertyOrElementAccessChain()) {
        questionDotToken = parseExpectedToken(29 /* QuestionDotToken */);
        isPropertyAccess = tokenIsIdentifierOrKeyword(token());
      } else {
        isPropertyAccess = parseOptional(25 /* DotToken */);
      }
      if (isPropertyAccess) {
        expression = parsePropertyAccessExpressionRest(pos, expression, questionDotToken);
        continue;
      }
      if ((questionDotToken || !inDecoratorContext()) && parseOptional(23 /* OpenBracketToken */)) {
        expression = parseElementAccessExpressionRest(pos, expression, questionDotToken);
        continue;
      }
      if (isTemplateStartOfTaggedTemplate()) {
        expression = !questionDotToken && expression.kind === 233 /* ExpressionWithTypeArguments */ ? parseTaggedTemplateRest(pos, expression.expression, questionDotToken, expression.typeArguments) : parseTaggedTemplateRest(
          pos,
          expression,
          questionDotToken,
          /*typeArguments*/
          void 0
        );
        continue;
      }
      if (!questionDotToken) {
        if (token() === 54 /* ExclamationToken */ && !scanner2.hasPrecedingLineBreak()) {
          nextToken();
          expression = finishNode(factory2.createNonNullExpression(expression), pos);
          continue;
        }
        const typeArguments = tryParse(parseTypeArgumentsInExpression);
        if (typeArguments) {
          expression = finishNode(factory2.createExpressionWithTypeArguments(expression, typeArguments), pos);
          continue;
        }
      }
      return expression;
    }
  }
  function isTemplateStartOfTaggedTemplate() {
    return token() === 15 /* NoSubstitutionTemplateLiteral */ || token() === 16 /* TemplateHead */;
  }
  function parseTaggedTemplateRest(pos, tag, questionDotToken, typeArguments) {
    const tagExpression = factory2.createTaggedTemplateExpression(
      tag,
      typeArguments,
      token() === 15 /* NoSubstitutionTemplateLiteral */ ? (reScanTemplateToken(
        /*isTaggedTemplate*/
        true
      ), parseLiteralNode()) : parseTemplateExpression(
        /*isTaggedTemplate*/
        true
      )
    );
    if (questionDotToken || tag.flags & 64 /* OptionalChain */) {
      tagExpression.flags |= 64 /* OptionalChain */;
    }
    tagExpression.questionDotToken = questionDotToken;
    return finishNode(tagExpression, pos);
  }
  function parseCallExpressionRest(pos, expression) {
    while (true) {
      expression = parseMemberExpressionRest(
        pos,
        expression,
        /*allowOptionalChain*/
        true
      );
      let typeArguments;
      const questionDotToken = parseOptionalToken(29 /* QuestionDotToken */);
      if (questionDotToken) {
        typeArguments = tryParse(parseTypeArgumentsInExpression);
        if (isTemplateStartOfTaggedTemplate()) {
          expression = parseTaggedTemplateRest(pos, expression, questionDotToken, typeArguments);
          continue;
        }
      }
      if (typeArguments || token() === 21 /* OpenParenToken */) {
        if (!questionDotToken && expression.kind === 233 /* ExpressionWithTypeArguments */) {
          typeArguments = expression.typeArguments;
          expression = expression.expression;
        }
        const argumentList = parseArgumentList();
        const callExpr = questionDotToken || tryReparseOptionalChain(expression) ? factoryCreateCallChain(expression, questionDotToken, typeArguments, argumentList) : factoryCreateCallExpression(expression, typeArguments, argumentList);
        expression = finishNode(callExpr, pos);
        continue;
      }
      if (questionDotToken) {
        const name = createMissingNode(
          80 /* Identifier */,
          /*reportAtCurrentPosition*/
          false,
          Diagnostics.Identifier_expected
        );
        expression = finishNode(factoryCreatePropertyAccessChain(expression, questionDotToken, name), pos);
      }
      break;
    }
    return expression;
  }
  function parseArgumentList() {
    parseExpected(21 /* OpenParenToken */);
    const result = parseDelimitedList(11 /* ArgumentExpressions */, parseArgumentExpression);
    parseExpected(22 /* CloseParenToken */);
    return result;
  }
  function parseTypeArgumentsInExpression() {
    if ((contextFlags & 524288 /* JavaScriptFile */) !== 0) {
      return void 0;
    }
    if (reScanLessThanToken() !== 30 /* LessThanToken */) {
      return void 0;
    }
    nextToken();
    const typeArguments = parseDelimitedList(20 /* TypeArguments */, parseType);
    if (reScanGreaterToken() !== 32 /* GreaterThanToken */) {
      return void 0;
    }
    nextToken();
    return typeArguments && canFollowTypeArgumentsInExpression() ? typeArguments : void 0;
  }
  function canFollowTypeArgumentsInExpression() {
    switch (token()) {
      case 21 /* OpenParenToken */:
      case 15 /* NoSubstitutionTemplateLiteral */:
      case 16 /* TemplateHead */:
        return true;
      case 30 /* LessThanToken */:
      case 32 /* GreaterThanToken */:
      case 40 /* PlusToken */:
      case 41 /* MinusToken */:
        return false;
    }
    return scanner2.hasPrecedingLineBreak() || isBinaryOperator2() || !isStartOfExpression();
  }
  function parsePrimaryExpression() {
    switch (token()) {
      case 15 /* NoSubstitutionTemplateLiteral */:
        if (scanner2.getTokenFlags() & 26656 /* IsInvalid */) {
          reScanTemplateToken(
            /*isTaggedTemplate*/
            false
          );
        }
      case 9 /* NumericLiteral */:
      case 10 /* BigIntLiteral */:
      case 11 /* StringLiteral */:
        return parseLiteralNode();
      case 110 /* ThisKeyword */:
      case 108 /* SuperKeyword */:
      case 106 /* NullKeyword */:
      case 112 /* TrueKeyword */:
      case 97 /* FalseKeyword */:
        return parseTokenNode();
      case 21 /* OpenParenToken */:
        return parseParenthesizedExpression();
      case 23 /* OpenBracketToken */:
        return parseArrayLiteralExpression();
      case 19 /* OpenBraceToken */:
        return parseObjectLiteralExpression();
      case 134 /* AsyncKeyword */:
        if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {
          break;
        }
        return parseFunctionExpression();
      case 60 /* AtToken */:
        return parseDecoratedExpression();
      case 86 /* ClassKeyword */:
        return parseClassExpression();
      case 100 /* FunctionKeyword */:
        return parseFunctionExpression();
      case 105 /* NewKeyword */:
        return parseNewExpressionOrNewDotTarget();
      case 44 /* SlashToken */:
      case 69 /* SlashEqualsToken */:
        if (reScanSlashToken() === 14 /* RegularExpressionLiteral */) {
          return parseLiteralNode();
        }
        break;
      case 16 /* TemplateHead */:
        return parseTemplateExpression(
          /*isTaggedTemplate*/
          false
        );
      case 81 /* PrivateIdentifier */:
        return parsePrivateIdentifier();
    }
    return parseIdentifier(Diagnostics.Expression_expected);
  }
  function parseParenthesizedExpression() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(21 /* OpenParenToken */);
    const expression = allowInAnd(parseExpression);
    parseExpected(22 /* CloseParenToken */);
    return withJSDoc(finishNode(factoryCreateParenthesizedExpression(expression), pos), hasJSDoc);
  }
  function parseSpreadElement() {
    const pos = getNodePos();
    parseExpected(26 /* DotDotDotToken */);
    const expression = parseAssignmentExpressionOrHigher(
      /*allowReturnTypeInArrowFunction*/
      true
    );
    return finishNode(factory2.createSpreadElement(expression), pos);
  }
  function parseArgumentOrArrayLiteralElement() {
    return token() === 26 /* DotDotDotToken */ ? parseSpreadElement() : token() === 28 /* CommaToken */ ? finishNode(factory2.createOmittedExpression(), getNodePos()) : parseAssignmentExpressionOrHigher(
      /*allowReturnTypeInArrowFunction*/
      true
    );
  }
  function parseArgumentExpression() {
    return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement);
  }
  function parseArrayLiteralExpression() {
    const pos = getNodePos();
    const openBracketPosition = scanner2.getTokenStart();
    const openBracketParsed = parseExpected(23 /* OpenBracketToken */);
    const multiLine = scanner2.hasPrecedingLineBreak();
    const elements = parseDelimitedList(15 /* ArrayLiteralMembers */, parseArgumentOrArrayLiteralElement);
    parseExpectedMatchingBrackets(23 /* OpenBracketToken */, 24 /* CloseBracketToken */, openBracketParsed, openBracketPosition);
    return finishNode(factoryCreateArrayLiteralExpression(elements, multiLine), pos);
  }
  function parseObjectLiteralElement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    if (parseOptionalToken(26 /* DotDotDotToken */)) {
      const expression = parseAssignmentExpressionOrHigher(
        /*allowReturnTypeInArrowFunction*/
        true
      );
      return withJSDoc(finishNode(factory2.createSpreadAssignment(expression), pos), hasJSDoc);
    }
    const modifiers = parseModifiers(
      /*allowDecorators*/
      true
    );
    if (parseContextualModifier(139 /* GetKeyword */)) {
      return parseAccessorDeclaration(pos, hasJSDoc, modifiers, 177 /* GetAccessor */, 0 /* None */);
    }
    if (parseContextualModifier(153 /* SetKeyword */)) {
      return parseAccessorDeclaration(pos, hasJSDoc, modifiers, 178 /* SetAccessor */, 0 /* None */);
    }
    const asteriskToken = parseOptionalToken(42 /* AsteriskToken */);
    const tokenIsIdentifier = isIdentifier2();
    const name = parsePropertyName();
    const questionToken = parseOptionalToken(58 /* QuestionToken */);
    const exclamationToken = parseOptionalToken(54 /* ExclamationToken */);
    if (asteriskToken || token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */) {
      return parseMethodDeclaration(pos, hasJSDoc, modifiers, asteriskToken, name, questionToken, exclamationToken);
    }
    let node;
    const isShorthandPropertyAssignment2 = tokenIsIdentifier && token() !== 59 /* ColonToken */;
    if (isShorthandPropertyAssignment2) {
      const equalsToken = parseOptionalToken(64 /* EqualsToken */);
      const objectAssignmentInitializer = equalsToken ? allowInAnd(() => parseAssignmentExpressionOrHigher(
        /*allowReturnTypeInArrowFunction*/
        true
      )) : void 0;
      node = factory2.createShorthandPropertyAssignment(name, objectAssignmentInitializer);
      node.equalsToken = equalsToken;
    } else {
      parseExpected(59 /* ColonToken */);
      const initializer = allowInAnd(() => parseAssignmentExpressionOrHigher(
        /*allowReturnTypeInArrowFunction*/
        true
      ));
      node = factory2.createPropertyAssignment(name, initializer);
    }
    node.modifiers = modifiers;
    node.questionToken = questionToken;
    node.exclamationToken = exclamationToken;
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseObjectLiteralExpression() {
    const pos = getNodePos();
    const openBracePosition = scanner2.getTokenStart();
    const openBraceParsed = parseExpected(19 /* OpenBraceToken */);
    const multiLine = scanner2.hasPrecedingLineBreak();
    const properties = parseDelimitedList(
      12 /* ObjectLiteralMembers */,
      parseObjectLiteralElement,
      /*considerSemicolonAsDelimiter*/
      true
    );
    parseExpectedMatchingBrackets(19 /* OpenBraceToken */, 20 /* CloseBraceToken */, openBraceParsed, openBracePosition);
    return finishNode(factoryCreateObjectLiteralExpression(properties, multiLine), pos);
  }
  function parseFunctionExpression() {
    const savedDecoratorContext = inDecoratorContext();
    setDecoratorContext(
      /*val*/
      false
    );
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const modifiers = parseModifiers(
      /*allowDecorators*/
      false
    );
    parseExpected(100 /* FunctionKeyword */);
    const asteriskToken = parseOptionalToken(42 /* AsteriskToken */);
    const isGenerator = asteriskToken ? 1 /* Yield */ : 0 /* None */;
    const isAsync = some(modifiers, isAsyncModifier) ? 2 /* Await */ : 0 /* None */;
    const name = isGenerator && isAsync ? doInYieldAndAwaitContext(parseOptionalBindingIdentifier) : isGenerator ? doInYieldContext(parseOptionalBindingIdentifier) : isAsync ? doInAwaitContext(parseOptionalBindingIdentifier) : parseOptionalBindingIdentifier();
    const typeParameters = parseTypeParameters();
    const parameters = parseParameters(isGenerator | isAsync);
    const type = parseReturnType(
      59 /* ColonToken */,
      /*isType*/
      false
    );
    const body = parseFunctionBlock(isGenerator | isAsync);
    setDecoratorContext(savedDecoratorContext);
    const node = factory2.createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseOptionalBindingIdentifier() {
    return isBindingIdentifier() ? parseBindingIdentifier() : void 0;
  }
  function parseNewExpressionOrNewDotTarget() {
    const pos = getNodePos();
    parseExpected(105 /* NewKeyword */);
    if (parseOptional(25 /* DotToken */)) {
      const name = parseIdentifierName();
      return finishNode(factory2.createMetaProperty(105 /* NewKeyword */, name), pos);
    }
    const expressionPos = getNodePos();
    let expression = parseMemberExpressionRest(
      expressionPos,
      parsePrimaryExpression(),
      /*allowOptionalChain*/
      false
    );
    let typeArguments;
    if (expression.kind === 233 /* ExpressionWithTypeArguments */) {
      typeArguments = expression.typeArguments;
      expression = expression.expression;
    }
    if (token() === 29 /* QuestionDotToken */) {
      parseErrorAtCurrentToken(Diagnostics.Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0, getTextOfNodeFromSourceText(sourceText, expression));
    }
    const argumentList = token() === 21 /* OpenParenToken */ ? parseArgumentList() : void 0;
    return finishNode(factoryCreateNewExpression(expression, typeArguments, argumentList), pos);
  }
  function parseBlock(ignoreMissingOpenBrace, diagnosticMessage) {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const openBracePosition = scanner2.getTokenStart();
    const openBraceParsed = parseExpected(19 /* OpenBraceToken */, diagnosticMessage);
    if (openBraceParsed || ignoreMissingOpenBrace) {
      const multiLine = scanner2.hasPrecedingLineBreak();
      const statements = parseList(1 /* BlockStatements */, parseStatement);
      parseExpectedMatchingBrackets(19 /* OpenBraceToken */, 20 /* CloseBraceToken */, openBraceParsed, openBracePosition);
      const result = withJSDoc(finishNode(factoryCreateBlock(statements, multiLine), pos), hasJSDoc);
      if (token() === 64 /* EqualsToken */) {
        parseErrorAtCurrentToken(Diagnostics.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses);
        nextToken();
      }
      return result;
    } else {
      const statements = createMissingList();
      return withJSDoc(finishNode(factoryCreateBlock(
        statements,
        /*multiLine*/
        void 0
      ), pos), hasJSDoc);
    }
  }
  function parseFunctionBlock(flags, diagnosticMessage) {
    const savedYieldContext = inYieldContext();
    setYieldContext(!!(flags & 1 /* Yield */));
    const savedAwaitContext = inAwaitContext();
    setAwaitContext(!!(flags & 2 /* Await */));
    const savedTopLevel = topLevel;
    topLevel = false;
    const saveDecoratorContext = inDecoratorContext();
    if (saveDecoratorContext) {
      setDecoratorContext(
        /*val*/
        false
      );
    }
    const block = parseBlock(!!(flags & 16 /* IgnoreMissingOpenBrace */), diagnosticMessage);
    if (saveDecoratorContext) {
      setDecoratorContext(
        /*val*/
        true
      );
    }
    topLevel = savedTopLevel;
    setYieldContext(savedYieldContext);
    setAwaitContext(savedAwaitContext);
    return block;
  }
  function parseEmptyStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(27 /* SemicolonToken */);
    return withJSDoc(finishNode(factory2.createEmptyStatement(), pos), hasJSDoc);
  }
  function parseIfStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(101 /* IfKeyword */);
    const openParenPosition = scanner2.getTokenStart();
    const openParenParsed = parseExpected(21 /* OpenParenToken */);
    const expression = allowInAnd(parseExpression);
    parseExpectedMatchingBrackets(21 /* OpenParenToken */, 22 /* CloseParenToken */, openParenParsed, openParenPosition);
    const thenStatement = parseStatement();
    const elseStatement = parseOptional(93 /* ElseKeyword */) ? parseStatement() : void 0;
    return withJSDoc(finishNode(factoryCreateIfStatement(expression, thenStatement, elseStatement), pos), hasJSDoc);
  }
  function parseDoStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(92 /* DoKeyword */);
    const statement = parseStatement();
    parseExpected(117 /* WhileKeyword */);
    const openParenPosition = scanner2.getTokenStart();
    const openParenParsed = parseExpected(21 /* OpenParenToken */);
    const expression = allowInAnd(parseExpression);
    parseExpectedMatchingBrackets(21 /* OpenParenToken */, 22 /* CloseParenToken */, openParenParsed, openParenPosition);
    parseOptional(27 /* SemicolonToken */);
    return withJSDoc(finishNode(factory2.createDoStatement(statement, expression), pos), hasJSDoc);
  }
  function parseWhileStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(117 /* WhileKeyword */);
    const openParenPosition = scanner2.getTokenStart();
    const openParenParsed = parseExpected(21 /* OpenParenToken */);
    const expression = allowInAnd(parseExpression);
    parseExpectedMatchingBrackets(21 /* OpenParenToken */, 22 /* CloseParenToken */, openParenParsed, openParenPosition);
    const statement = parseStatement();
    return withJSDoc(finishNode(factoryCreateWhileStatement(expression, statement), pos), hasJSDoc);
  }
  function parseForOrForInOrForOfStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(99 /* ForKeyword */);
    const awaitToken = parseOptionalToken(135 /* AwaitKeyword */);
    parseExpected(21 /* OpenParenToken */);
    let initializer;
    if (token() !== 27 /* SemicolonToken */) {
      if (token() === 115 /* VarKeyword */ || token() === 121 /* LetKeyword */ || token() === 87 /* ConstKeyword */ || token() === 160 /* UsingKeyword */ && lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLineDisallowOf) || // this one is meant to allow of
      token() === 135 /* AwaitKeyword */ && lookAhead(nextTokenIsUsingKeywordThenBindingIdentifierOrStartOfObjectDestructuringOnSameLine)) {
        initializer = parseVariableDeclarationList(
          /*inForStatementInitializer*/
          true
        );
      } else {
        initializer = disallowInAnd(parseExpression);
      }
    }
    let node;
    if (awaitToken ? parseExpected(165 /* OfKeyword */) : parseOptional(165 /* OfKeyword */)) {
      const expression = allowInAnd(() => parseAssignmentExpressionOrHigher(
        /*allowReturnTypeInArrowFunction*/
        true
      ));
      parseExpected(22 /* CloseParenToken */);
      node = factoryCreateForOfStatement(awaitToken, initializer, expression, parseStatement());
    } else if (parseOptional(103 /* InKeyword */)) {
      const expression = allowInAnd(parseExpression);
      parseExpected(22 /* CloseParenToken */);
      node = factory2.createForInStatement(initializer, expression, parseStatement());
    } else {
      parseExpected(27 /* SemicolonToken */);
      const condition = token() !== 27 /* SemicolonToken */ && token() !== 22 /* CloseParenToken */ ? allowInAnd(parseExpression) : void 0;
      parseExpected(27 /* SemicolonToken */);
      const incrementor = token() !== 22 /* CloseParenToken */ ? allowInAnd(parseExpression) : void 0;
      parseExpected(22 /* CloseParenToken */);
      node = factoryCreateForStatement(initializer, condition, incrementor, parseStatement());
    }
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseBreakOrContinueStatement(kind) {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(kind === 252 /* BreakStatement */ ? 83 /* BreakKeyword */ : 88 /* ContinueKeyword */);
    const label = canParseSemicolon() ? void 0 : parseIdentifier();
    parseSemicolon();
    const node = kind === 252 /* BreakStatement */ ? factory2.createBreakStatement(label) : factory2.createContinueStatement(label);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseReturnStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(107 /* ReturnKeyword */);
    const expression = canParseSemicolon() ? void 0 : allowInAnd(parseExpression);
    parseSemicolon();
    return withJSDoc(finishNode(factory2.createReturnStatement(expression), pos), hasJSDoc);
  }
  function parseWithStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(118 /* WithKeyword */);
    const openParenPosition = scanner2.getTokenStart();
    const openParenParsed = parseExpected(21 /* OpenParenToken */);
    const expression = allowInAnd(parseExpression);
    parseExpectedMatchingBrackets(21 /* OpenParenToken */, 22 /* CloseParenToken */, openParenParsed, openParenPosition);
    const statement = doInsideOfContext(67108864 /* InWithStatement */, parseStatement);
    return withJSDoc(finishNode(factory2.createWithStatement(expression, statement), pos), hasJSDoc);
  }
  function parseCaseClause() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(84 /* CaseKeyword */);
    const expression = allowInAnd(parseExpression);
    parseExpected(59 /* ColonToken */);
    const statements = parseList(3 /* SwitchClauseStatements */, parseStatement);
    return withJSDoc(finishNode(factory2.createCaseClause(expression, statements), pos), hasJSDoc);
  }
  function parseDefaultClause() {
    const pos = getNodePos();
    parseExpected(90 /* DefaultKeyword */);
    parseExpected(59 /* ColonToken */);
    const statements = parseList(3 /* SwitchClauseStatements */, parseStatement);
    return finishNode(factory2.createDefaultClause(statements), pos);
  }
  function parseCaseOrDefaultClause() {
    return token() === 84 /* CaseKeyword */ ? parseCaseClause() : parseDefaultClause();
  }
  function parseCaseBlock() {
    const pos = getNodePos();
    parseExpected(19 /* OpenBraceToken */);
    const clauses = parseList(2 /* SwitchClauses */, parseCaseOrDefaultClause);
    parseExpected(20 /* CloseBraceToken */);
    return finishNode(factory2.createCaseBlock(clauses), pos);
  }
  function parseSwitchStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(109 /* SwitchKeyword */);
    parseExpected(21 /* OpenParenToken */);
    const expression = allowInAnd(parseExpression);
    parseExpected(22 /* CloseParenToken */);
    const caseBlock = parseCaseBlock();
    return withJSDoc(finishNode(factory2.createSwitchStatement(expression, caseBlock), pos), hasJSDoc);
  }
  function parseThrowStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(111 /* ThrowKeyword */);
    let expression = scanner2.hasPrecedingLineBreak() ? void 0 : allowInAnd(parseExpression);
    if (expression === void 0) {
      identifierCount++;
      expression = finishNode(factoryCreateIdentifier(""), getNodePos());
    }
    if (!tryParseSemicolon()) {
      parseErrorForMissingSemicolonAfter(expression);
    }
    return withJSDoc(finishNode(factory2.createThrowStatement(expression), pos), hasJSDoc);
  }
  function parseTryStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(113 /* TryKeyword */);
    const tryBlock = parseBlock(
      /*ignoreMissingOpenBrace*/
      false
    );
    const catchClause = token() === 85 /* CatchKeyword */ ? parseCatchClause() : void 0;
    let finallyBlock;
    if (!catchClause || token() === 98 /* FinallyKeyword */) {
      parseExpected(98 /* FinallyKeyword */, Diagnostics.catch_or_finally_expected);
      finallyBlock = parseBlock(
        /*ignoreMissingOpenBrace*/
        false
      );
    }
    return withJSDoc(finishNode(factory2.createTryStatement(tryBlock, catchClause, finallyBlock), pos), hasJSDoc);
  }
  function parseCatchClause() {
    const pos = getNodePos();
    parseExpected(85 /* CatchKeyword */);
    let variableDeclaration;
    if (parseOptional(21 /* OpenParenToken */)) {
      variableDeclaration = parseVariableDeclaration();
      parseExpected(22 /* CloseParenToken */);
    } else {
      variableDeclaration = void 0;
    }
    const block = parseBlock(
      /*ignoreMissingOpenBrace*/
      false
    );
    return finishNode(factory2.createCatchClause(variableDeclaration, block), pos);
  }
  function parseDebuggerStatement() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    parseExpected(89 /* DebuggerKeyword */);
    parseSemicolon();
    return withJSDoc(finishNode(factory2.createDebuggerStatement(), pos), hasJSDoc);
  }
  function parseExpressionOrLabeledStatement() {
    const pos = getNodePos();
    let hasJSDoc = hasPrecedingJSDocComment();
    let node;
    const hasParen = token() === 21 /* OpenParenToken */;
    const expression = allowInAnd(parseExpression);
    if (isIdentifier(expression) && parseOptional(59 /* ColonToken */)) {
      node = factory2.createLabeledStatement(expression, parseStatement());
    } else {
      if (!tryParseSemicolon()) {
        parseErrorForMissingSemicolonAfter(expression);
      }
      node = factoryCreateExpressionStatement(expression);
      if (hasParen) {
        hasJSDoc = false;
      }
    }
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function nextTokenIsIdentifierOrKeywordOnSameLine() {
    nextToken();
    return tokenIsIdentifierOrKeyword(token()) && !scanner2.hasPrecedingLineBreak();
  }
  function nextTokenIsClassKeywordOnSameLine() {
    nextToken();
    return token() === 86 /* ClassKeyword */ && !scanner2.hasPrecedingLineBreak();
  }
  function nextTokenIsFunctionKeywordOnSameLine() {
    nextToken();
    return token() === 100 /* FunctionKeyword */ && !scanner2.hasPrecedingLineBreak();
  }
  function nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() {
    nextToken();
    return (tokenIsIdentifierOrKeyword(token()) || token() === 9 /* NumericLiteral */ || token() === 10 /* BigIntLiteral */ || token() === 11 /* StringLiteral */) && !scanner2.hasPrecedingLineBreak();
  }
  function isDeclaration2() {
    while (true) {
      switch (token()) {
        case 115 /* VarKeyword */:
        case 121 /* LetKeyword */:
        case 87 /* ConstKeyword */:
        case 100 /* FunctionKeyword */:
        case 86 /* ClassKeyword */:
        case 94 /* EnumKeyword */:
          return true;
        case 160 /* UsingKeyword */:
          return isUsingDeclaration();
        case 135 /* AwaitKeyword */:
          return isAwaitUsingDeclaration();
        case 120 /* InterfaceKeyword */:
        case 156 /* TypeKeyword */:
          return nextTokenIsIdentifierOnSameLine();
        case 144 /* ModuleKeyword */:
        case 145 /* NamespaceKeyword */:
          return nextTokenIsIdentifierOrStringLiteralOnSameLine();
        case 128 /* AbstractKeyword */:
        case 129 /* AccessorKeyword */:
        case 134 /* AsyncKeyword */:
        case 138 /* DeclareKeyword */:
        case 123 /* PrivateKeyword */:
        case 124 /* ProtectedKeyword */:
        case 125 /* PublicKeyword */:
        case 148 /* ReadonlyKeyword */:
          const previousToken = token();
          nextToken();
          if (scanner2.hasPrecedingLineBreak()) {
            return false;
          }
          if (previousToken === 138 /* DeclareKeyword */ && token() === 156 /* TypeKeyword */) {
            return true;
          }
          continue;
        case 162 /* GlobalKeyword */:
          nextToken();
          return token() === 19 /* OpenBraceToken */ || token() === 80 /* Identifier */ || token() === 95 /* ExportKeyword */;
        case 102 /* ImportKeyword */:
          nextToken();
          return token() === 11 /* StringLiteral */ || token() === 42 /* AsteriskToken */ || token() === 19 /* OpenBraceToken */ || tokenIsIdentifierOrKeyword(token());
        case 95 /* ExportKeyword */:
          let currentToken2 = nextToken();
          if (currentToken2 === 156 /* TypeKeyword */) {
            currentToken2 = lookAhead(nextToken);
          }
          if (currentToken2 === 64 /* EqualsToken */ || currentToken2 === 42 /* AsteriskToken */ || currentToken2 === 19 /* OpenBraceToken */ || currentToken2 === 90 /* DefaultKeyword */ || currentToken2 === 130 /* AsKeyword */ || currentToken2 === 60 /* AtToken */) {
            return true;
          }
          continue;
        case 126 /* StaticKeyword */:
          nextToken();
          continue;
        default:
          return false;
      }
    }
  }
  function isStartOfDeclaration() {
    return lookAhead(isDeclaration2);
  }
  function isStartOfStatement() {
    switch (token()) {
      case 60 /* AtToken */:
      case 27 /* SemicolonToken */:
      case 19 /* OpenBraceToken */:
      case 115 /* VarKeyword */:
      case 121 /* LetKeyword */:
      case 160 /* UsingKeyword */:
      case 100 /* FunctionKeyword */:
      case 86 /* ClassKeyword */:
      case 94 /* EnumKeyword */:
      case 101 /* IfKeyword */:
      case 92 /* DoKeyword */:
      case 117 /* WhileKeyword */:
      case 99 /* ForKeyword */:
      case 88 /* ContinueKeyword */:
      case 83 /* BreakKeyword */:
      case 107 /* ReturnKeyword */:
      case 118 /* WithKeyword */:
      case 109 /* SwitchKeyword */:
      case 111 /* ThrowKeyword */:
      case 113 /* TryKeyword */:
      case 89 /* DebuggerKeyword */:
      case 85 /* CatchKeyword */:
      case 98 /* FinallyKeyword */:
        return true;
      case 102 /* ImportKeyword */:
        return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
      case 87 /* ConstKeyword */:
      case 95 /* ExportKeyword */:
        return isStartOfDeclaration();
      case 134 /* AsyncKeyword */:
      case 138 /* DeclareKeyword */:
      case 120 /* InterfaceKeyword */:
      case 144 /* ModuleKeyword */:
      case 145 /* NamespaceKeyword */:
      case 156 /* TypeKeyword */:
      case 162 /* GlobalKeyword */:
        return true;
      case 129 /* AccessorKeyword */:
      case 125 /* PublicKeyword */:
      case 123 /* PrivateKeyword */:
      case 124 /* ProtectedKeyword */:
      case 126 /* StaticKeyword */:
      case 148 /* ReadonlyKeyword */:
        return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
      default:
        return isStartOfExpression();
    }
  }
  function nextTokenIsBindingIdentifierOrStartOfDestructuring() {
    nextToken();
    return isBindingIdentifier() || token() === 19 /* OpenBraceToken */ || token() === 23 /* OpenBracketToken */;
  }
  function isLetDeclaration() {
    return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuring);
  }
  function nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLineDisallowOf() {
    return nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine(
      /*disallowOf*/
      true
    );
  }
  function nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine(disallowOf) {
    nextToken();
    if (disallowOf && token() === 165 /* OfKeyword */)
      return false;
    return (isBindingIdentifier() || token() === 19 /* OpenBraceToken */) && !scanner2.hasPrecedingLineBreak();
  }
  function isUsingDeclaration() {
    return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine);
  }
  function nextTokenIsUsingKeywordThenBindingIdentifierOrStartOfObjectDestructuringOnSameLine(disallowOf) {
    if (nextToken() === 160 /* UsingKeyword */) {
      return nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine(disallowOf);
    }
    return false;
  }
  function isAwaitUsingDeclaration() {
    return lookAhead(nextTokenIsUsingKeywordThenBindingIdentifierOrStartOfObjectDestructuringOnSameLine);
  }
  function parseStatement() {
    switch (token()) {
      case 27 /* SemicolonToken */:
        return parseEmptyStatement();
      case 19 /* OpenBraceToken */:
        return parseBlock(
          /*ignoreMissingOpenBrace*/
          false
        );
      case 115 /* VarKeyword */:
        return parseVariableStatement(
          getNodePos(),
          hasPrecedingJSDocComment(),
          /*modifiers*/
          void 0
        );
      case 121 /* LetKeyword */:
        if (isLetDeclaration()) {
          return parseVariableStatement(
            getNodePos(),
            hasPrecedingJSDocComment(),
            /*modifiers*/
            void 0
          );
        }
        break;
      case 135 /* AwaitKeyword */:
        if (isAwaitUsingDeclaration()) {
          return parseVariableStatement(
            getNodePos(),
            hasPrecedingJSDocComment(),
            /*modifiers*/
            void 0
          );
        }
        break;
      case 160 /* UsingKeyword */:
        if (isUsingDeclaration()) {
          return parseVariableStatement(
            getNodePos(),
            hasPrecedingJSDocComment(),
            /*modifiers*/
            void 0
          );
        }
        break;
      case 100 /* FunctionKeyword */:
        return parseFunctionDeclaration(
          getNodePos(),
          hasPrecedingJSDocComment(),
          /*modifiers*/
          void 0
        );
      case 86 /* ClassKeyword */:
        return parseClassDeclaration(
          getNodePos(),
          hasPrecedingJSDocComment(),
          /*modifiers*/
          void 0
        );
      case 101 /* IfKeyword */:
        return parseIfStatement();
      case 92 /* DoKeyword */:
        return parseDoStatement();
      case 117 /* WhileKeyword */:
        return parseWhileStatement();
      case 99 /* ForKeyword */:
        return parseForOrForInOrForOfStatement();
      case 88 /* ContinueKeyword */:
        return parseBreakOrContinueStatement(251 /* ContinueStatement */);
      case 83 /* BreakKeyword */:
        return parseBreakOrContinueStatement(252 /* BreakStatement */);
      case 107 /* ReturnKeyword */:
        return parseReturnStatement();
      case 118 /* WithKeyword */:
        return parseWithStatement();
      case 109 /* SwitchKeyword */:
        return parseSwitchStatement();
      case 111 /* ThrowKeyword */:
        return parseThrowStatement();
      case 113 /* TryKeyword */:
      case 85 /* CatchKeyword */:
      case 98 /* FinallyKeyword */:
        return parseTryStatement();
      case 89 /* DebuggerKeyword */:
        return parseDebuggerStatement();
      case 60 /* AtToken */:
        return parseDeclaration();
      case 134 /* AsyncKeyword */:
      case 120 /* InterfaceKeyword */:
      case 156 /* TypeKeyword */:
      case 144 /* ModuleKeyword */:
      case 145 /* NamespaceKeyword */:
      case 138 /* DeclareKeyword */:
      case 87 /* ConstKeyword */:
      case 94 /* EnumKeyword */:
      case 95 /* ExportKeyword */:
      case 102 /* ImportKeyword */:
      case 123 /* PrivateKeyword */:
      case 124 /* ProtectedKeyword */:
      case 125 /* PublicKeyword */:
      case 128 /* AbstractKeyword */:
      case 129 /* AccessorKeyword */:
      case 126 /* StaticKeyword */:
      case 148 /* ReadonlyKeyword */:
      case 162 /* GlobalKeyword */:
        if (isStartOfDeclaration()) {
          return parseDeclaration();
        }
        break;
    }
    return parseExpressionOrLabeledStatement();
  }
  function isDeclareModifier(modifier) {
    return modifier.kind === 138 /* DeclareKeyword */;
  }
  function parseDeclaration() {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const modifiers = parseModifiers(
      /*allowDecorators*/
      true
    );
    const isAmbient = some(modifiers, isDeclareModifier);
    if (isAmbient) {
      const node = tryReuseAmbientDeclaration(pos);
      if (node) {
        return node;
      }
      for (const m of modifiers) {
        m.flags |= 33554432 /* Ambient */;
      }
      return doInsideOfContext(33554432 /* Ambient */, () => parseDeclarationWorker(pos, hasJSDoc, modifiers));
    } else {
      return parseDeclarationWorker(pos, hasJSDoc, modifiers);
    }
  }
  function tryReuseAmbientDeclaration(pos) {
    return doInsideOfContext(33554432 /* Ambient */, () => {
      const node = currentNode(parsingContext, pos);
      if (node) {
        return consumeNode(node);
      }
    });
  }
  function parseDeclarationWorker(pos, hasJSDoc, modifiersIn) {
    switch (token()) {
      case 115 /* VarKeyword */:
      case 121 /* LetKeyword */:
      case 87 /* ConstKeyword */:
      case 160 /* UsingKeyword */:
      case 135 /* AwaitKeyword */:
        return parseVariableStatement(pos, hasJSDoc, modifiersIn);
      case 100 /* FunctionKeyword */:
        return parseFunctionDeclaration(pos, hasJSDoc, modifiersIn);
      case 86 /* ClassKeyword */:
        return parseClassDeclaration(pos, hasJSDoc, modifiersIn);
      case 120 /* InterfaceKeyword */:
        return parseInterfaceDeclaration(pos, hasJSDoc, modifiersIn);
      case 156 /* TypeKeyword */:
        return parseTypeAliasDeclaration(pos, hasJSDoc, modifiersIn);
      case 94 /* EnumKeyword */:
        return parseEnumDeclaration(pos, hasJSDoc, modifiersIn);
      case 162 /* GlobalKeyword */:
      case 144 /* ModuleKeyword */:
      case 145 /* NamespaceKeyword */:
        return parseModuleDeclaration(pos, hasJSDoc, modifiersIn);
      case 102 /* ImportKeyword */:
        return parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, modifiersIn);
      case 95 /* ExportKeyword */:
        nextToken();
        switch (token()) {
          case 90 /* DefaultKeyword */:
          case 64 /* EqualsToken */:
            return parseExportAssignment(pos, hasJSDoc, modifiersIn);
          case 130 /* AsKeyword */:
            return parseNamespaceExportDeclaration(pos, hasJSDoc, modifiersIn);
          default:
            return parseExportDeclaration(pos, hasJSDoc, modifiersIn);
        }
      default:
        if (modifiersIn) {
          const missing = createMissingNode(
            282 /* MissingDeclaration */,
            /*reportAtCurrentPosition*/
            true,
            Diagnostics.Declaration_expected
          );
          setTextRangePos(missing, pos);
          missing.modifiers = modifiersIn;
          return missing;
        }
        return void 0;
    }
  }
  function nextTokenIsStringLiteral() {
    return nextToken() === 11 /* StringLiteral */;
  }
  function nextTokenIsFromKeywordOrEqualsToken() {
    nextToken();
    return token() === 161 /* FromKeyword */ || token() === 64 /* EqualsToken */;
  }
  function nextTokenIsIdentifierOrStringLiteralOnSameLine() {
    nextToken();
    return !scanner2.hasPrecedingLineBreak() && (isIdentifier2() || token() === 11 /* StringLiteral */);
  }
  function parseFunctionBlockOrSemicolon(flags, diagnosticMessage) {
    if (token() !== 19 /* OpenBraceToken */) {
      if (flags & 4 /* Type */) {
        parseTypeMemberSemicolon();
        return;
      }
      if (canParseSemicolon()) {
        parseSemicolon();
        return;
      }
    }
    return parseFunctionBlock(flags, diagnosticMessage);
  }
  function parseArrayBindingElement() {
    const pos = getNodePos();
    if (token() === 28 /* CommaToken */) {
      return finishNode(factory2.createOmittedExpression(), pos);
    }
    const dotDotDotToken = parseOptionalToken(26 /* DotDotDotToken */);
    const name = parseIdentifierOrPattern();
    const initializer = parseInitializer();
    return finishNode(factory2.createBindingElement(
      dotDotDotToken,
      /*propertyName*/
      void 0,
      name,
      initializer
    ), pos);
  }
  function parseObjectBindingElement() {
    const pos = getNodePos();
    const dotDotDotToken = parseOptionalToken(26 /* DotDotDotToken */);
    const tokenIsIdentifier = isBindingIdentifier();
    let propertyName = parsePropertyName();
    let name;
    if (tokenIsIdentifier && token() !== 59 /* ColonToken */) {
      name = propertyName;
      propertyName = void 0;
    } else {
      parseExpected(59 /* ColonToken */);
      name = parseIdentifierOrPattern();
    }
    const initializer = parseInitializer();
    return finishNode(factory2.createBindingElement(dotDotDotToken, propertyName, name, initializer), pos);
  }
  function parseObjectBindingPattern() {
    const pos = getNodePos();
    parseExpected(19 /* OpenBraceToken */);
    const elements = allowInAnd(() => parseDelimitedList(9 /* ObjectBindingElements */, parseObjectBindingElement));
    parseExpected(20 /* CloseBraceToken */);
    return finishNode(factory2.createObjectBindingPattern(elements), pos);
  }
  function parseArrayBindingPattern() {
    const pos = getNodePos();
    parseExpected(23 /* OpenBracketToken */);
    const elements = allowInAnd(() => parseDelimitedList(10 /* ArrayBindingElements */, parseArrayBindingElement));
    parseExpected(24 /* CloseBracketToken */);
    return finishNode(factory2.createArrayBindingPattern(elements), pos);
  }
  function isBindingIdentifierOrPrivateIdentifierOrPattern() {
    return token() === 19 /* OpenBraceToken */ || token() === 23 /* OpenBracketToken */ || token() === 81 /* PrivateIdentifier */ || isBindingIdentifier();
  }
  function parseIdentifierOrPattern(privateIdentifierDiagnosticMessage) {
    if (token() === 23 /* OpenBracketToken */) {
      return parseArrayBindingPattern();
    }
    if (token() === 19 /* OpenBraceToken */) {
      return parseObjectBindingPattern();
    }
    return parseBindingIdentifier(privateIdentifierDiagnosticMessage);
  }
  function parseVariableDeclarationAllowExclamation() {
    return parseVariableDeclaration(
      /*allowExclamation*/
      true
    );
  }
  function parseVariableDeclaration(allowExclamation) {
    const pos = getNodePos();
    const hasJSDoc = hasPrecedingJSDocComment();
    const name = parseIdentifierOrPattern(Diagnostics.Private_identifiers_are_not_allowed_in_variable_declarations);
    let exclamationToken;
    if (allowExclamation && name.kind === 80 /* Identifier */ && token() === 54 /* ExclamationToken */ && !scanner2.hasPrecedingLineBreak()) {
      exclamationToken = parseTokenNode();
    }
    const type = parseTypeAnnotation();
    const initializer = isInOrOfKeyword(token()) ? void 0 : parseInitializer();
    const node = factoryCreateVariableDeclaration(name, exclamationToken, type, initializer);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseVariableDeclarationList(inForStatementInitializer) {
    const pos = getNodePos();
    let flags = 0;
    switch (token()) {
      case 115 /* VarKeyword */:
        break;
      case 121 /* LetKeyword */:
        flags |= 1 /* Let */;
        break;
      case 87 /* ConstKeyword */:
        flags |= 2 /* Const */;
        break;
      case 160 /* UsingKeyword */:
        flags |= 4 /* Using */;
        break;
      case 135 /* AwaitKeyword */:
        Debug.assert(isAwaitUsingDeclaration());
        flags |= 6 /* AwaitUsing */;
        nextToken();
        break;
      default:
        Debug.fail();
    }
    nextToken();
    let declarations;
    if (token() === 165 /* OfKeyword */ && lookAhead(canFollowContextualOfKeyword)) {
      declarations = createMissingList();
    } else {
      const savedDisallowIn = inDisallowInContext();
      setDisallowInContext(inForStatementInitializer);
      declarations = parseDelimitedList(
        8 /* VariableDeclarations */,
        inForStatementInitializer ? parseVariableDeclaration : parseVariableDeclarationAllowExclamation
      );
      setDisallowInContext(savedDisallowIn);
    }
    return finishNode(factoryCreateVariableDeclarationList(declarations, flags), pos);
  }
  function canFollowContextualOfKeyword() {
    return nextTokenIsIdentifier() && nextToken() === 22 /* CloseParenToken */;
  }
  function parseVariableStatement(pos, hasJSDoc, modifiers) {
    const declarationList = parseVariableDeclarationList(
      /*inForStatementInitializer*/
      false
    );
    parseSemicolon();
    const node = factoryCreateVariableStatement(modifiers, declarationList);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseFunctionDeclaration(pos, hasJSDoc, modifiers) {
    const savedAwaitContext = inAwaitContext();
    const modifierFlags = modifiersToFlags(modifiers);
    parseExpected(100 /* FunctionKeyword */);
    const asteriskToken = parseOptionalToken(42 /* AsteriskToken */);
    const name = modifierFlags & 2048 /* Default */ ? parseOptionalBindingIdentifier() : parseBindingIdentifier();
    const isGenerator = asteriskToken ? 1 /* Yield */ : 0 /* None */;
    const isAsync = modifierFlags & 1024 /* Async */ ? 2 /* Await */ : 0 /* None */;
    const typeParameters = parseTypeParameters();
    if (modifierFlags & 32 /* Export */)
      setAwaitContext(
        /*value*/
        true
      );
    const parameters = parseParameters(isGenerator | isAsync);
    const type = parseReturnType(
      59 /* ColonToken */,
      /*isType*/
      false
    );
    const body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, Diagnostics.or_expected);
    setAwaitContext(savedAwaitContext);
    const node = factory2.createFunctionDeclaration(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parseConstructorName() {
    if (token() === 137 /* ConstructorKeyword */) {
      return parseExpected(137 /* ConstructorKeyword */);
    }
    if (token() === 11 /* StringLiteral */ && lookAhead(nextToken) === 21 /* OpenParenToken */) {
      return tryParse(() => {
        const literalNode = parseLiteralNode();
        return literalNode.text === "constructor" ? literalNode : void 0;
      });
    }
  }
  function tryParseConstructorDeclaration(pos, hasJSDoc, modifiers) {
    return tryParse(() => {
      if (parseConstructorName()) {
        const typeParameters = parseTypeParameters();
        const parameters = parseParameters(0 /* None */);
        const type = parseReturnType(
          59 /* ColonToken */,
          /*isType*/
          false
        );
        const body = parseFunctionBlockOrSemicolon(0 /* None */, Diagnostics.or_expected);
        const node = factory2.createConstructorDeclaration(modifiers, parameters, body);
        node.typeParameters = typeParameters;
        node.type = type;
        return withJSDoc(finishNode(node, pos), hasJSDoc);
      }
    });
  }
  function parseMethodDeclaration(pos, hasJSDoc, modifiers, asteriskToken, name, questionToken, exclamationToken, diagnosticMessage) {
    const isGenerator = asteriskToken ? 1 /* Yield */ : 0 /* None */;
    const isAsync = some(modifiers, isAsyncModifier) ? 2 /* Await */ : 0 /* None */;
    const typeParameters = parseTypeParameters();
    const parameters = parseParameters(isGenerator | isAsync);
    const type = parseReturnType(
      59 /* ColonToken */,
      /*isType*/
      false
    );
    const body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, diagnosticMessage);
    const node = factory2.createMethodDeclaration(
      modifiers,
      asteriskToken,
      name,
      questionToken,
      typeParameters,
      parameters,
      type,
      body
    );
    node.exclamationToken = exclamationToken;
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parsePropertyDeclaration(pos, hasJSDoc, modifiers, name, questionToken) {
    const exclamationToken = !questionToken && !scanner2.hasPrecedingLineBreak() ? parseOptionalToken(54 /* ExclamationToken */) : void 0;
    const type = parseTypeAnnotation();
    const initializer = doOutsideOfContext(16384 /* YieldContext */ | 65536 /* AwaitContext */ | 8192 /* DisallowInContext */, parseInitializer);
    parseSemicolonAfterPropertyName(name, type, initializer);
    const node = factory2.createPropertyDeclaration(
      modifiers,
      name,
      questionToken || exclamationToken,
      type,
      initializer
    );
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function parsePropertyOrMethodDeclaration(pos, hasJSDoc, modifiers) {
    const asteriskToken = parseOptionalToken(42 /* AsteriskToken */);
    const name = parsePropertyName();
    const questionToken = parseOptionalToken(58 /* QuestionToken */);
    if (asteriskToken || token() === 21 /* OpenParenToken */ || token() === 30 /* LessThanToken */) {
      return parseMethodDeclaration(
        pos,
        hasJSDoc,
        modifiers,
        asteriskToken,
        name,
        questionToken,
        /*exclamationToken*/
        void 0,
        Diagnostics.or_expected
      );
    }
    return parsePropertyDeclaration(pos, hasJSDoc, modifiers, name, questionToken);
  }
  function parseAccessorDeclaration(pos, hasJSDoc, modifiers, kind, flags) {
    const name = parsePropertyName();
    const typeParameters = parseTypeParameters();
    const parameters = parseParameters(0 /* None */);
    const type = parseReturnType(
      59 /* ColonToken */,
      /*isType*/
      false
    );
    const body = parseFunctionBlockOrSemicolon(flags);
    const node = kind === 177 /* GetAccessor */ ? factory2.createGetAccessorDeclaration(modifiers, name, parameters, type, body) : factory2.createSetAccessorDeclaration(modifiers, name, parameters, body);
    node.typeParameters = typeParameters;
    if (isSetAccessorDeclaration(node))
      node.type = type;
    return withJSDoc(finishNode(node, pos), hasJSDoc);
  }
  function isClassMemberStart() {
    let idToken;
    if (token() === 60 /* AtToken */) {
      return true;
    }
    while (isModifierKind(token())) {
      idToken = token();
      if (isClassMemberModifier(idToken)) {
        return true;
      }
      nextToken();
    }
    if (token() === 42 /* AsteriskToken */) {
      return true;
    }
    if (isLiteralPropertyName()) {
      idToken = token();
      nextToken();
    }
    if (token() === 23 /* OpenBracketToken */) {
      return true;
    }
    if (idToken !== void 0) {
      if (!isKeyword(idToken) || idToken === 153 /* SetKeyword */ || idToken === 139 /* GetKeyword */) {
        return true;
      }
      switch (token()) {
        case 21 /* OpenParenToken */:
        case 30 /* LessThanToken */:
        case 54 /* ExclamationToken */:
        case 59 /* ColonToken */:
        case 64 /* EqualsToken */:
        case 58 /* QuestionToken */:
          return tru