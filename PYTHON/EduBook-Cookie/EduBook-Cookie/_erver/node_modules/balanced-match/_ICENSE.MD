    } else if (checkType.flags & 1 /* Any */ || isIntersectionEmpty(checkType, extendsType)) {
        return getSimplifiedType(falseType2, writing);
      }
    }
    return type;
  }
  function isIntersectionEmpty(type1, type2) {
    return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & 131072 /* Never */);
  }
  function substituteIndexedMappedType(objectType, index) {
    const mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
    const templateMapper = combineTypeMappers(objectType.mapper, mapper);
    return instantiateType(getTemplateTypeFromMappedType(objectType.target || objectType), templateMapper);
  }
  function getIndexedAccessType(objectType, indexType, accessFlags = 0 /* None */, accessNode, aliasSymbol, aliasTypeArguments) {
    return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
  }
  function indexTypeLessThan(indexType, limit) {
    return everyType(indexType, (t) => {
      if (t.flags & 384 /* Strin