{"version":3,"names":["_semver","require","_corejs2BuiltIns","_coreJsCompat","_pluginsCompatData","_moduleTransformations","_options","_helperValidatorOption","corejs2DefaultWebIncludes","v","OptionValidator","allPluginsList","Object","keys","pluginsList","modulePlugins","moduleTransformations","map","m","getValidIncludesAndExcludes","type","corejs","set","Set","add","corejs2Polyfills","corejs3Polyfills","Array","from","flatMap","array","fn","prototype","concat","apply","normalizePluginName","plugin","replace","exports","expandIncludesAndExcludes","filterList","length","filterableItems","invalidFilters","selectedPlugins","filter","re","RegExp","e","push","items","item","test","invariant","join","checkDuplicateIncludeExcludes","include","exclude","duplicates","opt","indexOf","normalizeTargets","targets","isArray","browsers","assign","validateModulesOption","modulesOpt","ModulesOption","auto","toString","false","validateUseBuiltInsOption","builtInsOpt","UseBuiltInsOption","normalizeCoreJSOption","useBuiltIns","proposals","rawVersion","undefined","console","warn","version","Boolean","semver","coerce","String","major","RangeError","normalizeOptions","opts","validateTopLevelOptions","TopLevelOptions","validateBooleanOption","loose","spec","bugfixes","configPath","validateStringOption","process","cwd","debug","forceAllTransforms","ignoreBrowserslistConfig","modules","shippedProposals","browserslistEnv"],"sources":["../src/normalize-options.ts"],"sourcesContent":["import semver, { type SemVer } from \"semver\";\nimport corejs2Polyfills from \"@babel/compat-data/corejs2-built-ins\";\n// @ts-expect-error Fixme: TS can not infer types from ../data/core-js-compat.js\n// but we can't import core-js-compat/data.json because JSON imports do\n// not work on Node 14\nimport corejs3Polyfills from \"../data/core-js-compat.js\";\nimport { plugins as pluginsList } from \"./plugins-compat-data.ts\";\nimport moduleTransformations from \"./module-transformations.ts\";\nimport {\n  TopLevelOptions,\n  ModulesOption,\n  UseBuiltInsOption,\n} from \"./options.ts\";\nimport { OptionValidator } from \"@babel/helper-validator-option\";\n\nconst corejs2DefaultWebIncludes = [\n  \"web.timers\",\n  \"web.immediate\",\n  \"web.dom.iterable\",\n];\n\nimport type {\n  BuiltInsOption,\n  CorejsOption,\n  ModuleOption,\n  Options,\n  PluginListOption,\n} from \"./types.ts\";\n\nconst v = new OptionValidator(PACKAGE_JSON.name);\n\nconst allPluginsList = Object.keys(pluginsList);\n\n// NOTE: Since module plugins are handled separately compared to other plugins (via the \"modules\" option) it\n// should only be possible to exclude and not include module plugins, otherwise it's possible that preset-env\n// will add a module plugin twice.\nconst modulePlugins = [\n  \"transform-dynamic-import\",\n  ...Object.keys(moduleTransformations).map(m => moduleTransformations[m]),\n];\n\nconst getValidIncludesAndExcludes = (\n  type: \"include\" | \"exclude\",\n  corejs: number | false,\n) => {\n  const set = new Set(allPluginsList);\n  if (type === \"exclude\") modulePlugins.map(set.add, set);\n  if (corejs) {\n    if (process.env.BABEL_8_BREAKING) {\n      Object.keys(corejs3Polyfills).map(set.add, set);\n    } else {\n      if (corejs === 2) {\n        Object.keys(corejs2Polyfills).map(set.add, set);\n        corejs2DefaultWebIncludes.map(set.add, set);\n      } else {\n        Object.keys(corejs3Polyfills).map(set.add, set);\n      }\n    }\n  }\n  return Array.from(set);\n};\n\nfunction flatMap<T, U>(array: Array<T>, fn: (item: T) => Array<U>): Array<U> {\n  return Array.prototype.concat.apply([], array.map(fn));\n}\n\nexport const normalizePluginName = (plugin: string) =>\n  plugin.replace(/^(@babel\\/|babel-)(plugin-)?/, \"\");\n\nconst expandIncludesAndExcludes = (\n  filterList: PluginListOption = [],\n  type: \"include\" | \"exclude\",\n  corejs: number | false,\n) => {\n  if (filterList.length === 0) return [];\n\n  const filterableItems = getValidIncludesAndExcludes(type, corejs);\n\n  const invalidFilters: PluginListOption = [];\n  const selectedPlugins = flatMap(filterList, filter => {\n    let re: RegExp;\n    if (typeof filter === \"string\") {\n      try {\n        re = new RegExp(`^${normalizePluginName(filter)}$`);\n      } catch (e) {\n        invalidFilters.push(filter);\n        return [];\n      }\n    } else {\n      re = filter;\n    }\n    const items = filterableItems.filter(item => {\n      return process.env.BABEL_8_BREAKING\n        ? re.test(item)\n        : re.test(item) ||\n            // For backwards compatibility, we also support matching against the\n            // proposal- name.\n            re.test(item.replace(/^transform-/, \"proposal-\"));\n    });\n    if (items.length === 0) invalidFilters.push(filter);\n    return items;\n  });\n\n  v.invariant(\n    invalidFilters.length === 0,\n    `The plugins/built-ins '${invalidFilters.join(\n      \", \",\n    )}' passed to the '${type}' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`,\n  );\n\n  return selectedPlugins;\n};\n\nexport const checkDuplicateIncludeExcludes = (\n  include: Array<string> = [],\n  exclude: Array<string> = [],\n) => {\n  const duplicates = include.filter(opt => exclude.indexOf(opt) >= 0);\n\n  v.invariant(\n    duplicates.length === 0,\n    `The plugins/built-ins '${duplicates.join(\n      \", \",\n    )}' were found in both the \"include\" and\n    \"exclude\" options.`,\n  );\n};\n\nconst normalizeTargets = (\n  targets: string | string[] | Options[\"targets\"],\n): Options[\"targets\"] => {\n  // TODO: Allow to use only query or strings as a targets from next breaking change.\n  if (typeof targets === \"string\" || Array.isArray(targets)) {\n    return { browsers: targets };\n  }\n  return { ...targets };\n};\n\nexport const validateModulesOption = (\n  modulesOpt: ModuleOption = ModulesOption.auto,\n) => {\n  v.invariant(\n    // @ts-expect-error we have provided fallback for undefined keys\n    ModulesOption[modulesOpt.toString()] || modulesOpt ==