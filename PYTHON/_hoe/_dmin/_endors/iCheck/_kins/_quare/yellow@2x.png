n The ignore patterns.\n * @property {boolean|undefined} noInlineConfig The flag that disables directive comments.\n * @property {DependentParser|undefined} parser The parser loader.\n * @property {Object|undefined} parserOptions The parser options.\n * @property {Record<string, DependentPlugin>|undefined} plugins The plugin loaders.\n * @property {string|undefined} processor The processor name to refer plugin's processor.\n * @property {boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.\n * @property {boolean|undefined} root The flag to express root.\n * @property {Record<string, RuleConf>|undefined} rules The rule settings\n * @property {Object|undefined} settings The shared settings.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The element type.\n */\n\n/**\n * @typedef {Object} ConfigArrayInternalSlots\n * @property {Map<string, ExtractedConfig>} cache The cache to extract configs.\n * @property {ReadonlyMap<string, Environment>|null} envMap The map from environment ID to environment definition.\n * @property {ReadonlyMap<string, Processor>|null} processorMap The map from processor ID to environment definition.\n * @property {ReadonlyMap<string, Rule>|null} ruleMap The map from rule ID to rule definition.\n */\n\n/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>} */\nconst internalSlotsMap = new class extends WeakMap {\n    get(key) {\n        let value = super.get(key);\n\n        if (!value) {\n            value = {\n                cache: new Map(),\n                envMap: null,\n                processorMap: null,\n                ruleMap: null\n            };\n            super.set(key, value);\n        }\n\n        return value;\n    }\n}();\n\n/**\n * Get the indices which are matched to a given file.\n * @param {ConfigArrayElement[]} elements The elements.\n * @param {string} filePath The path to a target file.\n * @returns {number[]} The indices.\n */\nfunction getMatchedIndices(elements, filePath) {\n    const indices = [];\n\n    for (let i = elements.length - 1; i >= 0; --i) {\n        const element = elements[i];\n\n        if (!element.criteria || (filePath && element.criteria.test(filePath))) {\n            indices.push(i);\n        }\n    }\n\n    return indices;\n}\n\n/**\n * Check if a value is a non-null object.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(x) {\n    return typeof x === \"object\" && x !== null;\n}\n\n/**\n * Merge two objects.\n *\n * Assign every property values of `y` to `x` if `x` doesn't have the property.\n * If `x`'s property value is an object, it does recursive.\n * @param {Object} target The destination to merge\n * @param {Object|undefined} source The source to merge.\n * @returns {void}\n */\nfunction mergeWithoutOverwrite(target, source) {\n    if (!isNonNullObject(source)) {\n        return;\n    }\n\n    for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        if (isNonNullObject(target[key])) {\n            mergeWithoutOverwrite(target[key], source[key]);\n        } else if (target[key] === void 0) {\n            if (isNonNullObject(source[key])) {\n                target[key] = Array.isArray(source[key]) ? [] : {};\n                mergeWithoutOverwrite(target[key], source[key]);\n            } else if (source[key] !== void 0) {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n\n/**\n * The error for plugin conflicts.\n */\nclass PluginConflictError extends Error {\n\n    /**\n     * Initialize this error object.\n     * @param {string} pluginId The plugin ID.\n     * @param {{filePath:string, importerName:string}[]} plugins The resolved plugins.\n     */\n    constructor(pluginId, plugins) {\n        super(`Plugin \"${pluginId}\" was conflicted between ${plugins.map(p => `\"${p.importerName}\"`).join(\" and \")}.`);\n        this.messageTemplate = \"plugin-conflict\";\n        this.messageData = { pluginId, plugins };\n    }\n}\n\n/**\n * Merge plugins.\n * `target`'s definition is prior to `source`'s.\n * @param {Record<string, DependentPlugin>} target The destination to merge\n * @param {Record<string, DependentPlugin>|undefined} source The source to merge.\n * @returns {void}\