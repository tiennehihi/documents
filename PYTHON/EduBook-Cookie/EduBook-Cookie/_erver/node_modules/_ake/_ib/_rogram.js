 & (524288 /* Object */ | 2097152 /* Intersection */)) {
          invokeOnce(source, target, inferFromObjectTypes);
        }
      }
    }
    function inferWithPriority(source, target, newPriority) {
      const savePriority = priority;
      priority |= newPriority;
      inferFromTypes(source, target);
      priority = savePriority;
    }
    function inferFromContravariantTypesWithPriority(source, target, newPriority) {
      const savePriority = priority;
      priority |= newPriority;
      inferFromContravariantTypes(source, target);
      priority = savePriority;
    }
    function inferToMultipleTypesWithPriority(source, targets, targetFlags, newPriority) {
      const savePriority = priority;
      priority |= newPriority;
      inferToMultipleTypes(source, targets, targetFlags);
      priority = savePriority;
    }
    function invokeOnce(source, target, action) {
      const key = source.id + "," + target.id;
      const status = visited && visited.get(key);
      if (status !== void 0) {
        inferencePriority = Math.min(inferencePriority, status);
        return;
      }
      (visited || (visited = /* @__PURE__ */ new Map())).set(key, -1 /* Circularity */);
      const saveInferencePriority = inferencePriority;
      inferencePriority = 2048 /* MaxValue */;
      const saveExpandingFlags = expandingFlags;
      (sourceStack ?? (sourceStack = [])).push(source);
      (targetStack ?? (targetStack = [])).push(target);
      if (isDeeplyNestedType(source, sourceStack, sourceStack.length, 2))
        expandingFlags |= 1 /* Source */;
      if (isDeeplyNestedType(target, targetStack, targetStack.length, 2))
        expandingFlags |= 2 /* Target */;
      if (expandingFlags !== 3 /* Both */) {
        action(source, target);
      } else {
        inferencePriority = -1 /* Circularity */;
      }
      targetStack.pop();
      sourceStack.pop();
      expandingFlags = saveExpandingFlags;
      visited.set(key, inferencePriority);
      inferencePriority = Math.min(inferencePriority, saveInferencePriority);
    }
    function inferFromMatchingTypes(sources, targets, matches) {
      let matchedSources;
      let matchedTargets;
      for (const t of targets) {
        for (const s of sources) {
          if (matches(s, t)) {
            inferFromTypes(s, t);
            matchedSources = appendIfUnique(matchedSources, s);
            matchedTargets = appendIfUnique(matchedTargets, t);
          }
        }
      }
      return [
        matchedSources ? filter(sources, (t) => !contains(matchedSources, t)) : sources,
        matchedTargets ? filter(targets, (t) => !contains(matchedTargets, t)) : targets
      ];
    }
    function inferFromTypeArguments(sourceTypes, targetTypes, variances) {
      const count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
      for (let i = 0; i < count; i++) {
        if (i < variances.length && (variances[i] & 7 /* VarianceMask */) === 2 /* Contravariant */) {
          inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
        } else {
          inferFromTypes(sourceTypes[i], targetTypes[i]);
        }
      }
    }
    function inferFromContravariantTypes(source, target) {
      contravariant = !contravariant;
      inferFromTypes(source, target);
      contravariant = !contravariant;
    }
    function inferFromContravariantTypesIfStrictFunctionTypes(source, target) {
      if (strictFunctionTypes || priority & 1024 /* AlwaysStrict */) {
        inferFromContravariantTypes(source, target);
      } else {
        inferFromTypes(source, target);
      }
    }
    function getInferenceInfoForType(type) {
      if (type.flags & 8650752 /* TypeVariable */) {
        for (const inference of inferences) {
          if (type === inference.typeParameter) {
            return inference;
          }
        }
      }
      return void 0;
    }
    function getSingleTypeVariableFromIntersectionTypes(types) {
      let typeVariable;
      for (const type of types) {
        const t = type.flags & 2097152 /* Intersection */ && find(type.types, (t2) => !!getInferenceInfoForType(t2));
        if (!t || typeVariable && t !== typeVariable) {
          return void 0;
        }
        typeVariable = t;
      }
      return typeVariable;
    }
    function inferToMultipleTypes(source, targets, targetFlags) {
      let typeVariableCount = 0;
      if (targetFlags & 1048576 /* Union */) {
        let nakedTypeVariable;
        const sources = source.flags & 1048576 /* Union */ ? source.types : [source];
        const matched = new Array(sources.length);
        let inferenceCircularity = false;
        for (const t of targets) {
          if (getInferenceInfoForType(t)) {
            nakedTypeVariable = t;
            typeVariableCount++;
          } else {
            for (let i = 0; i < sources.length; i++) {
              const saveInferencePriority = inferencePriority;
              inferencePriority = 2048 /* MaxValue */;
              inferFromTypes(sources[i], t);
              if (inferencePriority === priority)
                matched[i] = true;
              inferenceCircularity = inferenceCircularity || inferencePriority === -1 /* Circularity */;
              inferencePriority = Math.min(inferencePriority, saveInferencePriority);
            }
          }
        }
        if (typeVariableCount === 0) {
          const intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(targets);
          if (intersectionTypeVariable) {
            inferWithPriority(source, intersectionTypeVariable, 1 /* NakedTypeVariable */);
          }
          return;
        }
        if (typeVariableCount === 1 && !inferenceCircularity) {
          const unmatched = flatMap(sources, (s, i) => matched[i] ? void 0 : s);
          if (unmatched.length) {
            inferFromTypes(getUnionType(unmatched), nakedTypeVariable);
            return;
          }
        }
      } else {
        for (const t of targets) {
          if (getInferenceInfoForType(t)) {
            typeVariableCount++;
          } else {
            inferFromTypes(source, t);
          }
        }
      }
      if (targetFlags & 2097152 /* Intersection */ ? typeVariableCount === 1 : typeVariableCount > 0) {
        for (const t of targets) {
          if (getInferenceInfoForType(t)) {
            inferWithPriority(source, t, 1 /* NakedTypeVariable */);
          }
        }
      }
    }
    function inferToMappedType(source, target, constraintType) {
      if (constraintTyp