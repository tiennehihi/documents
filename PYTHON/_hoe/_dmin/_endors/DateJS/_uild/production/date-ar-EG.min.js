 type: AST_NODE_TYPES.MemberExpression;
    property: Expression;
    computed: true;
}
export declare interface MemberExpressionNonComputedName extends MemberExpressionBase {
    type: AST_NODE_TYPES.MemberExpression;
    property: Identifier | PrivateIdentifier;
    computed: false;
}
export declare interface MetaProperty extends BaseNode {
    type: AST_NODE_TYPES.MetaProperty;
    meta: Identifier;
    property: Identifier;
}
export declare type MethodDefinition = MethodDefinitionComputedName | MethodDefinitionNonComputedName;
/** this should not be directly used - instead use MethodDefinitionComputedNameBase or MethodDefinitionNonComputedNameBase */
declare interface MethodDefinitionBase extends BaseNode {
    key: PropertyName;
    value: FunctionExpression | TSEmptyBodyFunctionExpression;
    computed: boolean;
    static: boolean;
    kind: 'constructor' | 'get' | 'method' | 'set';
    optional?: boolean;
    decorators?: Decorator[];
    accessibility?: Accessibility;
    typeParameters?: TSTypeParameterDeclaration;
    override?: boolean;
}
export declare interface MethodDefinitionComputedName extends MethodDefinitionComputedNameBase {
    type: AST_NODE_TYPES.MethodDefinition;
}
declare interface MethodDefinitionComputedNameBase extends MethodDefinitionBase {
    key: PropertyNameComputed;
    computed: true;
}
export declare interface MethodDefinitionNonComputedName extends ClassMethodDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.MethodDefinition;
}
declare interface MethodDefinitionNonComputedNameBase extends MethodDefinitionBase {
    key: PropertyNameNonComputed;
    computed: false;
}
export declare type Modifier = TSAbstractKeyword | TSAsyncKeyword | TSPrivateKeyword | TSProtectedKeyword | TSPublicKeyword | TSReadonlyKeyword | TSStaticKeyword;
declare type ModuleBody_TODOFixThis = TSModuleBlock | TSModuleDeclaration;
export declare type NamedExportDeclarations = ClassDeclarationWithName | ClassDeclarationWithOptionalName | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;
export declare interface NewExpression extends BaseNode {
    type: AST_NODE_TYPES.NewExpression;
    callee: LeftHandSideExpression;
    arguments: CallExpressionArgument[];
    typeParameters?: TSTypeParameterInstantiation;
}
export declare type Node = AccessorProperty | ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BlockStatement | BreakStatement | CallExpression | CatchClause | ChainExpression | ClassBody | ClassDeclaration | ClassExpression | ConditionalExpression | ContinueStatement | DebuggerStatement | Decorator | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportExpression | ImportNamespaceSpecifier | ImportSpecifier | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | Literal | LogicalExpression | MemberExpression | MetaProperty | MethodDefinition | NewExpression | ObjectExpression | ObjectPattern | PrivateIdentifier | Program | Property | PropertyDefinition | RestElement | ReturnStatement | SequenceExpression | SpreadElement | StaticBlock | Super | SwitchCase | SwitchStatement | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThrowStatement | TryStatement | TSAbstractAccessorProperty | TSAbstractKeyword | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSAnyKeyword | TSArrayType | TSAsExpression | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSClassImplements | TSConditionalType | TSConstructorType | TSConstructSignatureDeclaration | TSDeclareFunction | TSDeclareKeyword | TSEmptyBodyFunctionExpression | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExportKeyword | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexedAccessType | TSIndexSignature | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSInterfaceHeritage | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSPrivateKeyword | TSPropertySignature | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSSatisfiesExpression | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
declare interface NodeOrTokenData {
    /**
     * The source location information of the node.
     *
     * The loc property is defined as nullable by ESTree, but ESLint requires this property.
     *
     * @see {SourceLocation}
     */
    loc: SourceLocation;
    /**
     * @see {Range}
     */
    range: Range;
    type: string;
}
export declare interface NullLiteral extends LiteralBase {
    value: null;
    raw: 'null';
}
export declare interface NullToken extends BaseToken {
    type: AST_TOKEN_TYPES.Null;
}
export declare interface NumberLiteral extends LiteralBase {
    value: number;
}
export declare interface NumericToken extends BaseToken {
    type: AST_TOKEN_TYPES.Numeric;
}
export declare interface ObjectExpression extends BaseNode {
    type: AST_NODE_TYPES.ObjectExpression;
    properties: ObjectLiteralElement[];
}
export declare type ObjectLiteralElement = Property | SpreadElement;
export declare type ObjectLiteralElementLike = ObjectLiteralElement;
export declare interface ObjectPattern extends BaseNode {
    type: AST_NODE_TYPES.ObjectPattern;
    properties: (Property | RestElement)[];
    typeAnnotation?: TSTypeAnnotation;
    optional?: boolean;
    decorators?: Decorator[];
}
export declare type OptionalRangeAndLoc<T> = Pick<T, Exclude<keyof T, 'loc' | 'range'>> & {
    range?: Range;
    loc?: SourceLocation;
};
export declare type Parameter = ArrayPattern | AssignmentPattern | Identifier | ObjectPattern | RestElement | TSParameterProperty;
export declare interface Position {
    /**
     * Line number (1-indexed)
     */
    line: number;
    /**
     * Column number on the line (0-indexed)
     */
    column: number;
}
export declare type PrimaryExpression = ArrayExpression | ArrayPattern | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | JSXOpeningElement | LiteralExpression | MetaProperty | ObjectExpression | ObjectPattern | Super | TemplateLiteral | ThisExpression | TSNullKeyword;
export declare interface PrivateIdentifier extends BaseNode {
    type: AST_NODE_TYPES.PrivateIdentifier;
    name: string;
}
export declare interface Program extends BaseNode {
    type: AST_NODE_TYPES.Program;
    body: ProgramStatement[];
    sourceType: 'module' | 'script';
    comments?: Comment[];
    tokens?: Token[];
}
export declare type ProgramStatement = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | Statement | TSImportEqualsDeclaration | TSNamespaceExportDeclaration;
export declare type Property = PropertyComputedName | PropertyNonComputedName;
declare interface PropertyBase extends BaseNode {
    type: AST_NODE_TYPES.Property;
    key: PropertyName;
    value: AssignmentPattern | BindingName | Expression | TSEmptyBodyFunctionExpression;
    computed: boolean;
    method: boolean;
    shorthand: boolean;
    optional?: boolean;
    kind: 'get' | 'init' | 'set';
}
export declare interface PropertyComputedName extends PropertyBase {
    key: PropertyNameComputed;
    computed: true;
}
export declare type PropertyDefinition = PropertyDefinitionComputedName | PropertyDefinitionNonComputedName;
declare interface PropertyDefinitionBase extends BaseNode {
    key: PropertyName;
    value: Expression | null;
    computed: boolean;
    static: boolean;
    declare: boolean;
    readonly?: boolean;
    decorators?: Decorator[];
    accessibility?: Accessibility;
    optional?: boolean;
    definite?: boolean;
    typeAnnotation?: TSTypeAnnotation;
    override?: boolean;
}
export declare interface PropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {
    type: AST_NODE_TYPES.PropertyDefinition;
}
declare interface PropertyDefinitionComputedNameBase extends PropertyDefinitionBase {
    key: PropertyNameComputed;
    computed: true;
}
export declare interface PropertyDefinitionNonComputedName extends ClassPropertyDefinitionNonComputedNameBase {
    type: AST_NODE_TYPES.PropertyDefinition;
}
declare interface PropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {
    key: PropertyNameNonComputed;
    computed: false;
}
export declare type PropertyName = ClassPropertyNameNonComputed | PropertyNameComputed | PropertyNameNonComputed;
export declare type PropertyNameComputed = Expression;
export declare type PropertyNameNonComputed = Identifier | NumberLiteral | StringLiteral;
export declare interface PropertyNonComputedName extends PropertyBase {
    key: PropertyNameNonComputed;
    computed: false;
}
export declare interface PunctuatorToken extends BaseToken {
    type: AST_TOKEN_TYPES.Punctuator;
    value: ValueOf<PunctuatorTokenToText>;
}
export declare interface PunctuatorTokenToText extends AssignmentOperatorToText {
    [SyntaxKind.OpenBraceToken]: '{';
    [SyntaxKind.CloseBraceToken]: '}';
    [SyntaxKind.OpenParenToken]: '(';
    [SyntaxKind.CloseParenToken]: ')';
    [SyntaxKind.OpenBracketToken]: '[';
    [SyntaxKind.CloseBracketToken]: ']';
    [SyntaxKind.DotToken]: '.';
    [SyntaxKind.DotDotDotToken]: '...';
    [SyntaxKind.SemicolonToken]: ';';
    [SyntaxKind.CommaToken]: ',';
    [SyntaxKind.QuestionDotToken]: '?.';
    [SyntaxKind.LessThanToken]: '<';
    [SyntaxKind.LessThanSlashToken]: '</';
    [SyntaxKind.GreaterThanToken]: '>';
    [SyntaxKind.LessThanEqualsToken]: '<=';
    [SyntaxKind.GreaterThanEqualsToken]: '>=';
    [SyntaxKind.EqualsEqualsToken]: '==';
    [SyntaxKind.ExclamationEqualsToken]: '!=';
    [SyntaxKind.EqualsEqualsEqualsToken]: '===';
    [SyntaxKind.ExclamationEqualsEqualsToken]: '!==';
    [SyntaxKind.EqualsGreaterThanToken]: '=>';
    [SyntaxKind.PlusToken]: '+';
    [SyntaxKind.MinusToken]: '-';
    [SyntaxKind.AsteriskToken]: '*';
    [SyntaxKind.AsteriskAsteriskToken]: '**';
    [SyntaxKind.SlashToken]: '/';
    [SyntaxKind.PercentToken]: '%';
    [SyntaxKind.PlusPlusToken]: '++';
    [SyntaxKind.MinusMinusToken]: '--';
    [SyntaxKind.LessThanLessThanToken]: '<<';
    [SyntaxKind.GreaterThanGreaterThanToken]: '>>';
    [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>';
    [SyntaxKind.AmpersandToken]: '&';
    [SyntaxKind.BarToken]: '|';
    [SyntaxKind.CaretToken]: '^';
    [SyntaxKind.ExclamationToken]: '!';
    [SyntaxKind.TildeToken]: '~';
    [SyntaxKind.AmpersandAmpersandToken]: '&&';
    [SyntaxKind.BarBarToken]: '||';
    [SyntaxKind.QuestionToken]: '?';
    [SyntaxKind.ColonToken]: ':';
    [SyntaxKind.AtToken]: '@';
    [SyntaxKind.QuestionQuestionToken]: '??';
    [SyntaxKind.BacktickToken]: '`';
    [SyntaxKind.HashToken]: '#';
}
/**
 * An array of two numbers.
 * Both numbers are a 0-based index which is the position in the array of source code characters.
 * The first is the start position of the node, the second is the end position of the node.
 */
export declare type Range = [
    number,
    number
];
export declare interface RegExpLiteral extends LiteralBase {
    value: RegExp | null;
    regex: {
        pattern: string;
        flags: string;
    };
}
export declare interface RegularExpressionToken extends BaseToken {
    type: AST_TOKEN_TYPES.RegularExpression;
    regex: {
        pattern: string;
        flags: string;
    };
}
export declare interface RestElement extends BaseNode {
    type: AST_NODE_TYPES.RestElement;
    argument: DestructuringPattern;
    typeAnnotation?: TSTypeAnnotation;
    optional?: boolean;
    value?: AssignmentPattern;
    decorators?: Decorator[];
}
export declare interface ReturnStatement extends BaseNode {
    type: AST_NODE_TYPES.ReturnStatement;
    argument: Expression | null;
}
export declare interface SequenceExpression extends BaseNode {
    type: AST_NODE_TYPES.SequenceExpression;
    expressions: Expression[];
}
export declare interface SourceLocation {
    /**
     * The position of the first character of the parsed source region
     */
    start: Position;
    /**
     * The position of the first character after the parsed source region
     */
    end: Position;
}
export declare interface SpreadElement extends BaseNode {
    type: AST_NODE_TYPES.SpreadElement;
    argument: Expression;
}
export declare type Statement = BlockStatement | BreakStatement | ClassDeclarationWithName | ContinueStatement | DebuggerStatement | DoWhileStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclarationWithName | IfStatement | ImportDeclaration | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | TSDeclareFunction | TSEnumDeclaration | TSExportAssignment | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration | VariableDeclaration | WhileStatement | WithStatement;
export declare interface StaticBlock extends BaseNode {
    type: AST_NODE_TYPES.StaticBlock;
    body: Statement[];
}
export declare interface StringLiteral extends LiteralBase {
    value: string;
}
export declare interface StringToken extends BaseToken {
    type: AST_TOKEN_TYPES.String;
}
export declare interface Super extends BaseNode {
    type: AST_NODE_TYPES.Super;
}
export declare interface SwitchCase extends BaseNode {
    type: AST_NODE_TYPES.SwitchCase;
    test: Expression | null;
    consequent: Statement[];
}
export declare interface SwitchStatement extends BaseNode {
    type: AST_NODE_TYPES.SwitchStatement;
    discriminant: Expression;
    cases: SwitchCase[];
}
export declare interface TaggedTemplateExpression extends BaseNode {
    type: AST_NODE_TYPES.TaggedTemplateExpression;
    typeParameters?: TSTypeParameterInstantiation;
    tag: LeftHandSideExpression;
    quasi: TemplateLiteral;
}
export declare interface TemplateElement extends BaseNode {
    type: AST_NODE_TYPES.TemplateElement;
    value: {
        raw: string;
        cooked: string;
    };
    tail: boolean;
}
export declare interface TemplateLiteral extends BaseNode {
    type: AST_NODE_TYPES.TemplateLiteral;
    quasis: TemplateElement[];
    expressions: Expression[];
}
export declare interface TemplateToken extends BaseToken {
    type: AST_TOKEN_TYPES.Template;
}
export declare interface ThisExpression extends BaseNode {
    type: AST_NODE_TYPES.ThisExpression;
}
export declare interface ThrowStatement extends BaseNode {
    type: AST_NODE_TYPES.ThrowStatement;
    argument: Statement | TSAsExpression | null;
}
export dea');
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":13}],19:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":13}],20:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":13}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

},{"../type":13}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":13}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":13}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":13}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

},{"../type":13}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":13}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

},{"../type":13}],29:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":13}],"/":[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":1}]},{},[])("/")
});
                                                                                                                                 omÌÕŒ´×b¹¼Z`½¶¥8ë	ÆÙ×ˆà±i÷•‘IJøêÁÃ¥QqĞ`Ú¿{å¡à3Û[ö$…v½y8û Ç& 	‡ˆ>Áq~Tmá'Ã-^jİ¤e 
ó4:ºBã}U§£3c”4êêåôÄGV_œ®‹æˆÈ!Õ>©¡ğ^şÏÁtšå¼.ú®CZm/‰|_pm¤W™¨d8¹•f)Î¸µ³pêÍPà
ÑJioÊj“TüÌkÀ÷¡YæíâõÇštk(@sB¸_ãß}4fâ"¬YÿÉ/lyY‚·ıO;½nî½ßè½ÚK²q]k†B6èÀ[Ç¡Ïj»~jnÇº§®Ù´ôÚş¦.¤“¼ÑŒoÉÃvç­™Û¨l¶;¯øÊ8v£x]ËÕG”E¢Ö’|ßrQ¶Dl¦È#92<
&´56Ö ®#UC›
TÒSZé–[d¢u´>O\«Ñ/]İ½DxŒ2æÿ:Ò=‘U9hÒO¨×®@ÀKTWŞ• Ü8©4ÇIÒó ş
°,¬b¼ÒQ9S–š—«Zé›â¹Fw(·%u¯Í!UšÒXY¦ù»H4´kÌN6Id,Ãá¶8¬HÌÛğg·Wµ·†äÕã‚8ò‚Ì ƒ) uì{p¦¢œ‘L6@Û“ğ©5n„Íhá¥õ¬³òKR|ìç{íIÏo¹Œ‘3·Æ-ØÓQ…5aìo[•Y0	dŒ¸ªWÿ”á"Šõ8HõûÌx©ìÎÜQáV7ŠWÄÊ.í¶ıW¯iËBacÈÇˆäëúò¼}2ÃÈ/)õ’²ç{¿ø…çã¾æ²„ªJa|äR>0BÔ‰¯ÓàèüDÚ˜Ÿëà…A@'T„p,®C3Øm¤¨;Îææ3<ËM!J¼\õ;ÿãs_'è¯Æ-Î=Hí¯®S‹Û·.«“Ï9¹éÄ¿Ã<°uš=M‡†Úİ'±;sq,{DÏ’´™‚dÀ€"}¼\KƒıJì‚-p…kCq-ò®Yş!‚ÊLàı6s¹Õ³Â÷TéÒ!¡ºÄ¶T0’N•CĞÒx–B¤pß•‹{WpHŠŠdl›#°ôŸy‡2-'qš ˜†C< ôŞSZ„áªàİR7×Ù;âS·]ƒı¨ÅØ9şJ‘(Åİ;úÿ+Å•"BêË/ô¿2hfjk.ï­ Zp_$‰¢Ô0ågîtfa§naò“*É¥-Bjéæ<OŞ†’•¶!«lÎèò’ˆæ×ÒI6
ZĞwÎSäo^”ì§©IÈïŒ	¶†Û[Âà0…-,Z•èâ#DÍ÷Ç‚ßÀm¼°C™±¾= ¯»8øCµæ6îLE'›g•.±©Ôğ$ñ¼ôĞ,å<¤Ác·ºŸğv=\ff=Ôò¶ÿÆÙDÈb/¡×¡¼6%"P8¨ÜnŸÔºkS`î9rºÓÕ0Ô©ºÚI½\)väŞ	}›!nB¡İT™	áİe)»‹®B,ëÄ’Æ½›õşÇ‚^ğÿ]Ff—/ÑÚ( ¾­jÊw<Í³¹›„)ŞÎ¸|´í÷üLø¶ŠO–Šÿ0à(ì—µ¬rXXÉê¶­…Ò34õìş8o5€Ã…©Ÿ“½7„: S•1Šedğè+g¨:‹ÀóÏÁN‡]¢íÑœÏ$?6ªZ¥ø
Wwá`:r\Q¨êRÇ¶â>+¥ÿ	=åp*F}=2ãùÉÍAˆ¶íëxÖmøRñ¤Èo²µâòµ–“@ˆ‚?NİĞüñTÑÑç¢@É÷ƒK9öû¡gÃ`. , )š(qZŸD¸tëşİçaÃ»©GëéØr»'¹@êe}^¥‡N^ôÜ}Í1Ë,ø”P2¨âÒªà6Nöûõeq¹u_4@“ò0ñ·sÎAf!f+Í¿ŞEÛ‡u)Èª@~€GÿÏ]Öà	è¹ï¦¬Í×³OÊª#€ği`u¥ ''2¢f
³êRbæ©Ó]¾¶ Ô§73ê{¹ªcá§9öáO],ğ	i–ïtQV¬w|Æ,â=r3;“óQK0)”ûïcÛFs ‡ĞÎ&¡äeU•„3Té3øóEv÷d	¿</	ÍãåìŞ2ßÑ$5¥ğkpÜˆAòqnK)¬œÅ°óÓÙ¬2ÁH½ãô_fú<:	ğî¨‰“oñæßÈèX‚­ûéŒ8œéR=BøZğƒ:BÒË°/n".îğIéók…e{ß¤¥3É.Ø€Ü[¨Ówİ¿_AÍG¦n5™×^âÇ#ø±.¾Ãoá8+Ò_¨§=N°ö×J9å«W—‡ƒíŠù´ÓQIò”?Å]X ¶±)p\•QÊ ˜.iD“ğ"à~İ—7MH0ùb&ò"Åã‡Ù^»wÈí	Æñv–hå326Ü“Èw1G{a‚N_Úá»ÕN®Ü±¼¤µe½†Üh'SHÊòû’é)v3Ê+[[m$bQœãã·!cÃJ?Œ˜%”"4FC½àÌ1­µ)6^y¯1ÆÿHveG[9€RIoÄÅOœ·ÎDdw5¸*ç1ÎÆ’J'ÛaÉşáím 4÷Ÿ)8ïu9†3İÀÎ¿ïLµÿôĞv%úI^Šëä§…"~¬êH3¯qM]Onä.åZ~wx]Ë½8±âünxè†Š7rn! 3Óğğ Q’´­¼‡øØ„ÛRìĞbC°mş¹@mîóâJdÇ•˜_…5+õ¯¾cÃ×…ôtYºz–Y³P?]Váµ/ú˜ø %“Enórã‰ÍMQğ*¯4»Âñ}­b³‚‰r²ñä÷äfºØj¯ OÉ;åx÷ıŸ©´"Æ6V*{ƒœ­ü+d¿£9ıû±(€°!”ÍÆ‚aÀX6	H{ÏÃ›s÷ï©—š\TD©&MÁ}¿»Íî ÿ,c×kp[#Õ^$mn1{[­¢DĞ¯z\İÍÌ½®,ñUi†‡*új™ Ù§VpÙ!pMgÔ
WÌv|Á­bSˆf
^ƒğ¬ À¾(ÙXşüPŞôçë« w$‰†Â"$R_F|&©’¢Vá;Şk!u<ïAğÕWkiTµ“Ğ’CqİªûozÂÁ·ñ¨Î¯wŞ˜Nƒ'·ğk-^£2opÚÚiëõjß$ÃP£Â¶]õŠ‘¦sŞÓ9¦H³FB‘KŠµ
×”èØŒIÊº}†9”œñÄP*eJâÃÃ«XçÕkÑÃªb·8g_s²8€óò÷ûœz³{ì &íG*$ñRõÍßnnûöİÉ¬Ëi"ªÎÄŸŠüØPîf):´Ó4Êâ½ğ}3œ]>D İËÜN—<< h£Jµc.ŞP¶oè¸MÙ/‡¶ïÀ!”Õ¶ °Tp*Fx|şù¿w®u¥¥^^Z
›÷-•Y†¦ŠI¹7_=„s!7 sm Rxâ‘C¢zØ@6—KÎ%
ïK>·—¯åº½Óë$Šá8ş1-ÎŠúèsáºAuQ”ÁãÁM³¦î+ZQ71xä‹NØr"á[† ˆFË}(së+õ×]#%J2Ôì$Ã=^è¹Ú6½üy±)aYŒ$‰aúüUÒjg¶›E©ÆJÖ~İZ#·Âl’é€ğ…9ÂŒCoÀ:$¦Ã 7ågÜÇüñ˜j
ô‚˜¡)÷Æ9çÀêdËº-Öp¹Å"áà3¥Ù®½X†R–g9ÓC‘u^WİÃ¯¡Èyñøë·»«‡ ©øò9ÿóøOSU`!<ÚõÏOmôçM°,][l¡Ô(+g=—Mä-İ£G>œÚY”ª[„"dº{ùb!Q~8Ù…1rÁ[Ÿ•N§áÛÙ0	À!”İª’Ã¢(˜t8„"v÷ıs|k×[ëz/J%J±—‘2Ş ¶®kÍgY ˜õ"£<pZ½ëh3¥ôÿßóCY…e¿İúåë«´-aòn8‰Òš^z-’<4Pª»”aÇ?*ÅÜéÔÚãè,¢éE"’aW
éËŒúÅ%F+êáaX¶øcÊMãş›"ÉÜLd)Š‚±­˜ôsòõs‹úÙP-G$‡ZœùÄá-¿:i¼(~£ü0caMTÂHu\üÄ1 X»‰ÔıÍJî±’Ñ?b`(ºŸ¢Ö‰0ÄŞ^Å!* Lî–³Ô\Ggã./ß—hå2ŠynMSÆhï¢J(4"y_Öƒ[zÀ.9 -))#Û„E‹›Ø~ş¡ Ûr°	7§'7¥ÊÏcmƒÈæ;,¿ïõë€ö*şÿİd3÷Ç?ïÏVÿoT/Ã¶şKìû¸º»`\¡G  `*ÈÔª„6!”Íª‘¡ XT6	„¡ 'ç÷ªkßë//zÔ¡UÒ§3-­Ø_Ÿ½áİÚïåÿ4Îzt÷¿æİD³G§¬øç7yïG‹Ùj$+Fİ¸~¥jäòh~ŞğÑ	ı¤mŸG-„÷†)z,AŸéaíÙÏ­¤³L£ˆã 	ıdÖÊuÔ1›;—¿W>VHüÃÛ½Îà¼1‘1Ö4 Më¢ˆÁ„Ä¬Xİ]J7ABl2µÆ×8¢Q r){³ië¼€ğ!†òn8³³8S;FÜÓİ «- |»´ºğÃáÜëÚˆÃÚ]D¤›q•ƒ7”Á\¨‚Z`c1~On˜Îü¸=s’Wc,qÆŠèÆè§”,+§PÖàæú×
&I‡)ìÍLBé” UË!‚ç:~Ñ °D 3II¬ßëÛ%^Ü]Ã"mæÿÄo;meá/p´Ü–aéó£°T	kc6ş¹-ÿû\G$ûü®ë·8  !AæCı!¥H8ƒPd<šè,³ãÖc“º vå|©%Û:gI‚hÙ¡ûVui­Ùa°Úá~,ÏÔ¨3óİŸÈ*¢…Ğ\›3õné\Pc_6…}Ş ;Øìık¥şæ§"à¿ëÀĞ7hNZaSá¾AÄºZwæİ:¨i»ßÚP+v*Í°(K¤J½,èF¼  G	 b¼&ô‹¦q•Íİ¨Ï‹ähÛü}ö±ùöÿo•f¶|ËÇï(kc#ö*†Œb\Ùü—DéduÀ°fk¾dsÕ2h/“cğğò[—ËÖÈŠÂ Wş´¶º­[¯ 6‚û–Ï”¨šŒ†O÷	OM~9µGYVÔä§‘(ZxÊ)Z³NXŒ É£8ÖòŒ¼|FâÌâ<‰—©à¹-2aíg´Z4 K­‰.0¤3†#)™²Ä‚â©uås¹ÎKkn1öW^æ‹/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import type { Config } from '@jest/types';
export declare type ResolverConfig = {
    defaultPlatform?: string | null;
    extensions: Array<string>;
    hasCoreModules: boolean;
    moduleDirectories: Array<string>;
    moduleNameMapper?: Array<ModuleNameMapperConfig> | null;
    modulePaths?: Array<Config.Path>;
    platforms?: Array<string>;
    resolver?: Config.Path | null;
    rootDir: Config.Path;
};
declare type ModuleNameMapperConfig = {
    regex: RegExp;
    moduleName: string | Array<string>;
};
export {};
                                                                                                                                                                                                                                                                                                  cLªÅ¥ó£v¹ÜÂ\ìÛ¨Š("§ˆı1Î[çó™¿l{³:¸[–YHÇÙ öóÜÇö[foFrg((|vf£I•ã¢ ­ëmÛÉ-n€ä4P0nV
eòa3õì|	¶¶@ Ò‚=BácûX5g„lkGV$üS4hä“I©Ze|G”=Õx îÁÈ¢‘öş3Ù2ÁØªâ0µ
H;./E*;8k?ÃG=Ì0J£ÑLbyş&!b€Ä;ÃfŸõr¸PV”Ô¢)±3kÄ½RT!»"06õ´ˆöo?¯n« …_Ÿ¦Á^ÿÍ—~^BŒ§ ™‘@@Ò-xã¯àÔEÚË§Ø®a,DçX»¥xÛµ#J÷UwAƒ6ˆ!5Œ’à¸§-X§†v¸o(î)Ùâ36»úş‘¨wÜ¯ÜE9×ä{¯óŸ¤1‰ØR*Pc~v78®*X€jà3Î
ˆbŞTº›Å£¡-× 21f>ÁßÆô•MB»‘ü_%÷ËCk¸p³X¸Ÿî‚akbû^¤Ü Õ»)y?= ¶}Šhp	 ëúaz¨š+ÌûúÏE:ìßºJ÷/ª?4QÇ9³87Ï5²ÅÇ^˜ĞT¹>+¤O²ğSï­eäÅGßt*÷{¾#»;ŒÄ›ì.™ÁÉÕ±›¶F£Z'pƒÆÌÒ2A&4b„*Ïu e ùÉ5÷‹J	ìTa¹6†Ê@§ÌÛ8Ùj6ï[¾Ë;T˜®m¬ûyIêKXÄ(f&(i´ï'üQåµx'ÚyT û&
¬K¯ÎéÛÑSøkå†•¹ÃgcîpÀ$IÔ”péaÖàïOÓ4¨N¨qpÈà¾µa[²[´ƒGäùk­µ?‘}9¡·H?mÚ©Øı²ËÃÈŒÇr;÷›Õ ¼‰ƒÄ!¤Lü•œšrjƒò­4ƒ<¹üÍsÂ"[™}÷DÆk·—ü_©(fØª½zo¶û¦oŒ;Cğ²,jä×dÚj²;]¥Ğ/^/‹ş‚6;ÛéCqİƒ¿€sj­Z=W[åU?JÈp™0MñG'ÉD÷rM´WZ¥ —âQéğê±ŒRAC™÷'ŞSì@…ºÛ/†bFQ+
ù¬Ò[z…”•:òx}òƒ#oğ?ççrŒ¯¼…©8¶¥CkÔ÷0S¡éÏ Ò×½ÑºøÿÛÅn'õ%è9İ€òCøqİbÀiQ3öıĞ%"íÄÕX9nÎ¤¬–P™ˆtoİß¢h~u+#©Á¼µú\¢gĞ}u€À0‚zAÕõ«>Å+¹‘7S™ÄóX3¯˜®“óUòè­¸÷ğ	÷¡?ï6–¿²ƒâj•Ó¦øi{x©bŞqˆ&]—û
eñŞÃú)w1ÏnD ­ŒÆ=	,ZpÒ×¨´ÅŠwd”LMõÈ†)ğÇP¯£`gåÔM‘É).”–ï†’‰L++Õ÷äwÀ(Ğ5=íDY¸ÉZ:9¨z}³}Õ;VjÛ v7Ÿá]CCÌÂ…%úâMM’¨›ü:kg¦¨±	imç%Ã|ë¢[Ì"É”z1ì–|œŸ‘Mî ğc=ÜŸM³òrÑÄÿ8 ëÌ¿¢‹ 9óN¯‚à©FH´—Â†»rûØ¹»„Ofar°£ƒ“ŒJ  R*<_âÍåßm"WƒĞô'

®Ãª±‘÷¬tY¬8¬•ºÏXu¦¬şË0/x$ñ÷#¾’¯U:6NliÔÄ·ÏÄ%ÇUZZáİ´‚îû+‡ğNc ó8˜Ë†-’ ğ*5ûRxçêW
¾‚—dÀVÒLß©];
ªĞô0	ÃÕ/R¤í 3iÁG&|Â¬+Œ™¸	j°’óÒ^ÜŒ0P=³t½©Wa…Á}6•mM9œT@2…´»iÄVçëü½póv(œ‹LÖ+ì¦CÔjVKò’;°ØKßjQ5 Rgr^yBÃ¡©å$xªà*®âï—§I» ×Ifd’øyæ!•­Ö{{"ûM3`5âz’Ÿµ^ïö>hU³;¨‡øº~7c´eèq[|ûb%Ú®¬³yQ!rs
£Ÿ¿§ƒ4 š¬{V5HX ¢¶>,Xf©r<ÎŞ¬‹/Dú¢H2@Ühò‘
¬$í¶sŸr>¬ÌÔ•tqúåj¨yòÔ§:fm1¸Ä…êáî”{@†r×E¡6v”İRûQØsC+¿§­İí²?û…[öø ØĞ‚
SQ•›™Ë´¢î•IFZ´v¡Ä¼jó0R×0¹g~ƒƒÆ+¢-€”ËÈªÈiˆ[›ƒ<Î7&À¯éwfÇm·i£ëfP°KN`ƒ¿¿74Ô¸b¨6é×1QîGãçï»Dx:v'ŠĞÿ“8\†œÄíÏ¤•İ\Âò	n¦Æ’ÈŞnİ¹K•©D^‹áfNÃ°¸’f°='ø‰…Lˆï`Ö‡`…­jOB±Xsi–3ˆƒ½‰T—½p‰c-s+xå}héÕV6®[!Gæ`]¾‘T¤{lÖÂQÂšÉÓ£•l¦:ÛfÑ©jƒVÖì$PÓã†6°7™FróRÅ¿i%>­ÙLË,ä4€ÿ˜œMáÛsçè÷ z–¤
Iuæ˜+)Mı‚¬µÒGı·?|åsB¯.€xÃ1Ïim÷Êk¿0¤Èh ğåhŞ 8v‚ÃUtÛq7Õ5èÔ1"—wzwã_"p]ğÚs‡ÉCÅÛ$=Ê‰¦´©6Ü”w¤¿ÛâiÜ‘”ˆ(çôÆë;j}›Áñ4¥" BŒ|*
v~¹_$Š¬Ä×Hx“ÆzA˜v	Lã7‘äwÊîÒ1 ½ÊÌJ^$z~9¡Ñ]]¾áøæ-+_IZuJ¶×™J<Üù©z³Ş[şš¹uÙÙ­Ã¾×,n rq­ÚP4Ú,5“3-	X¹û·b$Ğ•1ÁíŒZwÿBŸ^“pú Ïl§(W1ªašîâ5à9!ö¨ŞÚ_BÙHKÁA ä
â“Lâ†ï{†Ê6……­ç0`1Iyr>àÄÊj÷´äB‹·çİZÑ»÷¤ÌO:è
=z‰B¬ˆò*ÄÁ ?e¿rk_fV¡¶åºŞík3*1…-şÈ;. éoŠ!eË[Õ¿çš5ı‡†¬¾1á¦%'SC¿U]†¹oHL[u²æaÚêZGAXÃSĞX–®³6ùCqCà{E>E¨|*m-J}¨¼^&âYffkÓÍáï^;È¤SşD‡ëDã’Ñ±œê7§ø¹îó‘Š0oŸì"ĞtûÜbE/ÕW-•AÀ×ì»·Ì”‘[ ËÉ
ÊÂÚ`^š“p»¤è£ +º=0æ~ª¸÷«ºG.%†!õÅV/xq*,V“Ç°uÖñ"2Ë„)Ï] —BÄ:_¡Í­~7×™VïL4ŒûÔ¸¶D}ÈK+D³•F=cl4ÑÃÃ°fh~Zz;ş6J5›æø‡Kò98•mk‰í¶W©=R2ˆÊ;ŞŸğŠ˜ØY>àÆhã@Ÿ»Ï¹n5c¼[kÔX|ßĞwkiI—¾Ìõi¬¢a]ye]“ Ò«ÎÒçO~ÒÉ~è¤’á})QèEÖìõÒ÷Ø¬¼Å0hÓÄÖ7Tf4ğ_·aø{äAQã=dW¿5¤Âï™ïß0WbSüƒm\Ì^CvÃs­D”õsZK,v—œdQé¸!¸2ÕÿÛÑ9Ç5Ì¸úîVéó
×ßxpéH	£Ö(³!Éyi¶O¤ÿu–Ş<ÕS<^Rƒç?_„»şOÍùå^óŠ³G©Ë„<63Öœ•÷–Oşi•x&¦ <IPdÌì›İ­1\æ/¡{n¤â¨‡¼»k*¾”Ø¿|È¤@G„æ¼ÉCŸÆ_ÿ¶J<†%;OÎ l>:QÁßç¸RM rÌÚDo$=äu¬y%Í{éJÄïìlˆ¶º+º
½§«gÉ ü!ÚQÄ»‘'æèØ|Ë%ŸËnşATHsV·lÖÂr­¯ôÊùÓñ]ïy>dA<ŒjwF:^lPO´š¬`hxE/îSƒ°Rê,Ì‘ôZpMvp°Ç¤»Ï² FT¶0”¨2ÌG¡ZÕ–Îé-¥nú´ø_¿d´] ÓSàW&CâÎMÈ&ú»VrºœšˆKÆ–l»çù–­–&CÒä"_˜o	È¹úŒÇx7–›‰ºÏáÎ8]ÑhG±5ÑOw>QÎJH¢–û¼”€ZÁ¾b½ïddxH¥{ê«RO¡RÖ$ÈfE¸]orR(‡ìÌÙì	ı Öä¶nÃ-Äö<ğwÏ±â‹ÿ¯!çÒÏvûÏ©áŒßj#EÙG“í_ùç¶ªŸËº\nó"üÙeĞ£²÷è4ëÙEãŒ?Ãˆâî¿b	ağl:²¯Ñ´5‰šı¶.3Å¾\ãc‚!s*:¼Ëy&šYø¼ÙW)shÒ ¤’¢ ¢s;šèî!-k",Ül‹4LáÜ¬nX69%ïgƒ¦VÌ*?rØÄà4ÙÚòÕoí©x&¹òLÅChòxB­Óù{–×
èW$Œ3u±a½ëµáÓÉ5Øüwı&	ÍiÄqœ•µ=lŞe½çªv¡ùboæÅ½LIEbøÛ¼¡A#¾=Hë^á¥¹?DIË‚xæFz´ˆ›dßüD»ÀUnÃÊj­mö@y6î® VT}n9é¨‚bğN’-»=®Ówë92Gë‰õª-ÓİV?b!Ğ8Oå˜IÙ(Íî?¿ƒædøÒ£EaÓ3Ü`[O£[Õ/q“aêt\éÛï¦EnÔ¦ â§(z°1£;…– †k¢Å•[Ş‘Û†ì†NY  Z`îi“Á<¾W¡-à3¬}“¥qš+@y=Qh…­—
ïàÙğŸB$&Îµ;’ˆÓ¶túÁµÄÿu>Î8ı£aKéŞı¶ŞÜî“%¯PIÔonEgÔA$p’\Í«ï²½®†È_‚&lHDT`_NØ¡±"ÈÚ}ÓC°ü¦Ê_¶D–çë"­–%t¬sKpd‡¤Œ
G°F…ûA™ ±¦ş]Ó|=P2”s_ã†[„ÿÑÇÊç“kÍ„a%´ QÃ°ÖòÑ"• *ùØ8¾LˆÕ{´¡ÇÏĞUËŠ¿]cpËD6Z5Ñ\×~ØËŒp*bÕ‡è£ë5ÑcL¬§°Ñ,õDpxçºè<ù}µ,ma?ƒE©ëImÅjÁ ÛØka?zWÔ
vÚ‚K• ãî¶ŞÛÔìŒÓ:øĞhª¨>[à‚/ÿÑ íQ8cp!Ÿ§¨@‚­ĞfÅñÅI«?bë‘¦Yâ(Élœ`äœ(bûºDZ X(´eµo˜Ñ.UÏ–¨ëO±uá+íğl‰ÁG{¾¼5Z…›#·+X#H¾ş]¯«P-`ƒs2Ãm´÷KŒrùµ©€!š‘õ¦z Ãç}x8×'hü0ƒ!±"€©;‡÷]eÅÙ)‡jlu’DFz7>.9¢†¿ãQjAK÷ÎÍ£É÷#É‰9&/rÿÒçÍMÈfØòÒşûO³™R¸øÎJÉ´.Nÿ‰3$J%¹ÎôN¾ÙÇL€îÎ&£¸üÄºJcêD2R±‘øÈ¹`r–~oæ*ø©ù¿K€İ66MdĞc«×ò‚¾œmÂ,ü
=óIpœÇæÊºä-¹‹{‰fåxê’5bñ²‘3+¥Ï"€à•J@=İ™É{™(‰Ùgb<¢0ùÅ/','Ñ™)öõ¤dì÷1ê™cr•Ü½(¤ê…qÊÿÚµ‰/å(`#‚Èôê¬ÆSÚğ"§2°)ıa	úT:ålóÍ™·À’c°í“åî²o­x}Ïª«°)‰Î‰Ù\ttï03À)@xduç)şÀ¤oãiX­®bÌ¸Y¹‹{™<B€VRÑ.¤Z,ÒŸ\É&×‰©ù-æz[~|®İñ*„vŒF¢<_¹G½¤ÔN¼âùŸ¾E <2„Ûq…èŸA“ª€£”U§ |„ ÑÒ²îj{{‡uNO·
¤ì|¬ÙÖ;¥©p6}NàÈ¹:Œ(ÒEwˆ=ÕÒ—ŒÿÜNØu<Á ¹,¬÷2úÙd]7h³°?v{Å±c,dJ _ŞoŠ£UJƒKÙF0:Ëk:»­È¬ÌÛE€.æ<‚íÑº‘|ˆÌ2Gve½éæ©–ÉîÓà~N±­,½ÙÒ—½0£ë.=A“Öt2ûĞ{ Òd5fÅéËAÏÓSwú±v
¶§ËŠVÌ¯e–Íry,ñ‡ºb–ÎWª~Ç¾š!Q!fÌXWr¾­ÕƒnÀÌ{	•6O¼P¥»åü¿:šPeµağ58I;?“mp0¦pÀÍ\2·Á¸ŠäbÛğcFË¾y&V^£Â|ì•%ún×ç4‘9Zª:€B}ÀWcÏ Dz:Kb _¼<^ÔcÜœç„2¹ìî.pÿ·(pÎT¾[œ_Ísõ!òRn°H]Kı(– Ê·>Ş ÚÌ¯µ Ï=«Á]º¦¢¢ÍT\l4Hãƒ«pLƒ1ô–q°Cßf˜0Å:¿‰ôC¬|^¨>j•=×¦iÿ¾)Q¿ywæÄTb2`í|åš*3ôŒi‰9Xk©ó€	dé½ª3‡”ß6¦³QAt8šÏòm”¸ÒUnhÿÇü~ç;GçÌ*¤OUdı°¿¹'¼ı, )àÿÓÖO
!$DNvM±ØC2>Ô¶¿eQ‹~Ôp`¬‡Gûz[™Lá"¼­İHÚìáz9›„Ñ 0ÕfM’"@Yı72Øş
÷É­¾	’h\SÌvæ¡ßo 7GfÎúkA’k´çR˜’‘ÊF$Ğñó¾BÊd Ô¶C	×·à3^`‡"ıDô|ˆMÕèW{åRÄG 1gŒ¾øóUæçON·/qå Œ«<²P…›µüQ 8]§tuèâª_ós%,¿²2ø™
Ï@¨)Å=#H%¼Ï‚´1È·rû	);#±š“ªß7ùleÓI¬–g;éªÕ:c”ÇQêµ£OsOµF ô…&àò@}?vwmø§«x™Åñ”£eÛì’§·p—e0Ç;hğk±(ƒ¯Gt•J„´Œıı ©M”}Š`1˜¶˜d‚íïF¥—Œ^Rˆt‰ûc½Eô= Ÿ°µ0\^;³'hš‡2 bÇk·ı{ÉÏ[ö~¡úúÇ¤…èÊiıh‹¡ìw” Ê‚µÏN²3…´a„¬	M®Ó ¡xÂoª÷ÓÓŠµd»¨rÒ¯
¯ÖwR¡ÏËvõœ>£hØii¥•å-´×fDÊÕ•ö{k gvçşKŸ[é”;Õ¹°Ç¿›}ºVrçø°‘n“Pgr‘s§×Ô8 ÄÍøV˜aIğŒ‡H—Y°Ãrzïh(|q¡¼Ëù«0Ääì˜yœÁ†4	ó¢…›› ĞG€ø"ûÇœµå•åÉ>É,òàÁß±ç¢;Hrq©¬zØò_£²¸±w¯¶Gf¹&İÌcêfQ¶ê}e½<+u%â¿s' wvô÷·â’ÔáùÎ÷¹¥€è‘)èok,Î¦	¥m‘õ±½ä<tÿùûu¨œ‡(ˆ‘À¿éºOİd\¿F+Ü¬zÎÖ-×Á÷ö1r«òBì44BÛâ1É}uEF­Q²a.ı¢òNGm#vQ1!Rq5NARıáïI÷:p–›¤Ñæ©»À‰ÙCuÔjq)”J¹t¯™æRÛ£#ËWH¦BÌèp¯&"è:j%3#Ü£hûÏèòM£nŞ7ûVÖ-"r†ó1oÖì WşF«™‰l"dVãƒìh50mG¼ÄZ¤lÙ-À5øfFB£ê~)ÔÈÉüp~7à~–¤Âì·³òƒSF=&áßÛ#HSƒ(œTÎõ§p‘j¤²úã¨¥™ °£†İ"-i:õ¾ø†ZÌ¤Ùğ	zÛ¾G¨²<÷ÎRˆã‘YàD'ÿ&^¿ÇîùJµ©™$P”[?•#2çœ>ÿ¤ƒ2p’¾¸º0h…Åâ`m!Æ«'{¶Ş^ròÅÆ‚Ækm/Ğ’ÌûÛXg …5Ü¢¹Im¸ÑİºÁ¬K$%„*/A«r´D•7`Õ&šµıybÚ--úæà>QµèÌıYeü…²!Ûª­)¬+¼:´gë]¼Áş.M‚vg!ä¾aé	ÙJğsà¬:¨Úîí?³*ûs]ÈÒqÙ•€|ö¸¸ÓC.4”>[c*B'Ùù°óñ<›ùìÄ€)ªvp#_ÿQÒ[z½úœ¾<9	óË¿úZ[_ïĞ~âélƒµt©úX7ÛqÔÂ¦>gğ†é§]váUâG&¢*#êj,z³¬b(r!Àqma”È­@ ]z®]nø#¾Kútùê¶7UÄ'ŒRÿdèbìê’°‹y›Äe"!EtğŠ»ïLXLÛ]ëÒJÛj}Uª(ŠQõ¾á fb(7û»kbÓùÿı‡{EàÓñ6ì±Ğµq^1Õ=L%˜³eG•íå0;Y!š°ˆÜ1\é`èœ³a(ÈÀòôô\=_…°§G+ÃÊJ:nTÒRb<ÍÃôÆ/Ä“œä¡æ¢ÏAê@<mˆ—>Š™$;ò®Z§ˆ®XK	¢ó«hÇRe,Ç˜î••:¦éoè©íğWu®\¿>u'’a'Y…xd•;oGwìª¶Üyğë~=º8ÏˆqHBGÿi¾<2¨øàOb–¦kˆûøàò#ÛfuÆŞÍÄˆ¨=ı†_ç Ûßz)˜d†·Áşo. ½·”ıw„@ÄzƒqŠNKÛ_ÒÕ·'ÚSÊÓ¢›¨Ç¬î©ä$†ÆÍÃ2Êèa“–)-shSÔßâËØÿhgĞ×ß·İ'k‹ÕˆãZëg¢drÀ¿¿Ç×Ñÿë›¿€SÕ²î[ÇŒ{íù]emêğñ.<ˆ¢TÁ«04ò¶.MÇ7IÊô3.·’®cÖıvİw§}œwŞç‘Mß ÅqŠa«Nô€             AèK R¹öÊ·ˆøéÙQ´Øõ? yÕÑú3?Ş§À=@LÖvÚ¼Â³KÊ8Ò=?7F·§§x.“)ÿ{KùÄRh£è oaÃ§Êw-Š‡è¼gŞÆÄiø¡j½&†µ Ïê»	xRÉ-¨A©­‹Û+œô9Ohu õ|`á*…şj›kdÖØ(RêíŸ;çh¢äÄXİ‰“X¶*oòÌ¹Õág¯×ªrJ»“«ÜÚœõ½ûßÂSsÒÀ1ôAK8Z»ç8´{hpsÛu«’{S=§™¿â!õi÷e‚~ÈÑÍ¥pÃ³„7>§F¾Z8¦BßÖ‰+5I
¯ûÜëù^`@^”^|x|Ö]2 Cî°ÃzF[I6$šÀKfœÁbxªm°¤uõmBµà¥NMõt¥µ£T=-EÓåÌœZ×Bë¹Ó„´Í‹¤Nm
£¿Ó—bÄ·ƒ’ š^yİ’lÆÚ®äÑõãkb=0ÔàTºè¶\­ñ«=şY7£%RfAÖƒíû]³)&oQ¾òlU,S!¨’ Ë+¯[ˆ®/·†)ôBñeX`Ñşöpå6é2ZÚ4j¬Êp,õß!V&†Ã®nLÎÃZèl™à¿È–İáıİz³mK©Y
ÁF«½@Ü1sŞr¬Ìé²æ×î,W&¡w÷œƒõó‹¥¨MßeD^‰«æHn¯b
|î·İ˜o¤ÍßvË ÀY5Ê¥Ä¸,
˜n’PãĞOÅãâ¶*øBf´Ğ~Uq¤{¿çÇüé£‰:d\áèõ@UOLp 
–²ê ÊÕ¤c "ò±Ú
1‡¸´xòÆ¬Ã…yfº¨ÃóüP‰ŸKù:æk‘LiÁÒûS6Ë9æ’q€t4Š¹›Ş%²¨Å*½tl$€0	6TİFi…İR–ZQÍşmfŒ-1w|D¤í"Õ+)2_±óÏ4mü…x^[³!tòíôvK/ `ôé.Z¬_O÷÷¨E~ğrh†iíÏA_PëT¶«ã9Š"P PÃŠ‰ÆÈï¡.l‡¹†ü=¼Ãî†ù2ÓÈµoùê¨äšó7$¦6üºÕn[úøOV]U1Õ™n&? ‰õ2Î3ØÙQ\ÂÒö êU›ºm@L£öÉvê4UÏ$ÉV°HTï#¾‘?K’"I¦÷’Éz×?:?¦F8%ˆp•³½ÅÇT-ó.n@<<»±µk‹0Áƒ~ÄêëgviæMî@R_­j è>îş*W{ˆ«ËA·ÎUúq±†×Pÿı‹ÛG[ò'‹³lØoÏ[‹ÀãÒpµıı|o6¯°w ô¿ãbIíL«+ ³	ÚÛP`ì8~cşC³f“uR6mî’ê{©Ñ×­ê¥HÀÒD­<P%l¯ŞèÿSÑ­º¿`oŞHºƒÔñQëËò‡Ìêb>cãÊ<²yc†iítsÈsãBœİg$³¥*–Í!üÌÊr¹šnèUetƒÚÍâÛ×Çú´h‚Ü	«#Kn¼½1…ñ_r[Õ¼èÍ?‚I7/€……\º°—”ı°6f¦Íøå¹fôËîO§‰
Ôa÷	1¾¸<;f…•W^ò}Èõû)ÆSKL3V×÷?œo?ƒntG§X”¼G¨©ódÒÌ´¦ÓûÓâÑª¿õNZRp¬mrâxc¿Ù{~œçpæq!üÑ*køÔ”/Ãsì -r“Fô·zÍªÛ’	mE]}ü%¨PyÚOÖ¢~Vè©-;v^lew<ñÕ</ç=aÔ›°!gàšTÙÉ¾r€½c.51`õ;”gŸ©è!_²ÛúhAÖşO–3%ÌG~NÅğU‡ƒLÃ)é¸¥ÑÙ‡(œ…ös_\åk ‹T1£nqóäâ1;B)<;¬„cR	Oë0N¢WD=U*QñŒñş¹¶EÖH¾°i9e÷ÉD0‘•8 ·±y€h.EØ°¿Nhó&¼³J…ûW vOO2[åD÷Úgs:[·½[
³ÓL‡ZêR_õú®n¨.‚ó-IF»k‘æ^Ì´ŞJ€™ƒéÚ¸å©ÃEoiåÈ¥Çî+=à º¼ã—¢`3Êñ_•…»J¦°Š±Ú&'¨S8÷E¤ÉsÅ‚ø4ºŸR+#zç¥İñSmÿL%lpäùyMN»ŸPX¿	Z¤Cjg§KL÷™±b}=µŠÁÏÑÔ@S¯Ç…m`ŒÊæjÎ5:LµßXüH|i¡vqK‘íšJq¹SdƒÏpÍÒ‘52×…Çá‚ÑßPÆÑF ‡CÙgk¥,ô|¤¢+eşÈšH?RµÍÎÅ‡<S½ÅÑx=1¥›üö&P­n²îœä+EÎÓ@–	âPâÆÖñ4OŒ¡í}R\ÈC M(îşµø M3hÌ*ûH@HÀıYû*löf_Ï$(®8ªŞ)AÓYo3IŒ$|g­…4t3¹“½ëĞ’GÓ‹Ë-[,¢ëº(7«Š‡$•×°?ÔÎÌ—ïº÷d!‰.­ÜË‚u9Ã
3C«¥d`‡ĞËñğV}”üáäãx‡ëw¨+… 9YŸ[…û¬Z29ş¦™3úáˆ@æ¢Rp—ß)ö®<*÷² ‘ñ™ê*”Û `ÅÛCî¢j5áƒ‰ñJàÓÿ…û¹,tE&²#›²v˜“jOhe ‰½}UÙLåMK!	ö¯Ÿ›4§scÁ4JaåÀ…¹wC-å?aÂÆ•¬óù6¨QmœÓ«´á­[®y‡×I…ªÿ°äÎ«ÿÀ _>4ƒ(åºCãîpäİÖû×rUêOVÿghoôKz“Û>Ôkñ 3î™T"t¾%/¥^ëÉCTu^ä;ëIÔ;ø…ú ÀĞÛûßÌÖÙl_jåbO[z€€nFËâDA½^êˆDX`ıBÈtü¡À'ùæƒárWõµD#¥Š©rêÔzìc5qĞ2õ Î–GE5K{dÙë%Êi:tl‚19°/åÇ’ÉÖùŒ0£…Ét¸(„Ø»8A‚â_î¿ÍÕ¹á“ŸáhÁ~%Ë°Ö»uE~áxç,§»™Mb:Æ¨Oş0ãŠ/«‰	6¿œmÀ3åº·‚<v‘ãL-”²pvq1‡<Òº5ÍDÒ$:n:‚ÇÊ(0.«CÀ¯_ñ¦º‰ñîŸùñZc=Âş6Ú•İıÕO<ÚÌQ}„"]šF
7ºÚêÏÆ“´½Ã¦ ÛºX^tÉlnn©JÃÈV–mFÎ†Á€ÂO©2¼½÷räæÇUEÔÒf­#ôÀFÇ¿“FRånõ#¼¥9/µBhş·ÈÇ´¼õ©¸ÎÉIRÕàLnïhÁK,4Áğdì©)AŞ‹¨`¹T\³AvŞW_r¶[æ½AÙån5 7í£êÙÃ0JŸ()P"ö‹tÛÎòÃo~ôAÑT¸óPm7®ãrì*ÍRÉNu \dY´Tvï¸qÍf¹¢zk=„8äì6-0…fÂÁ¤;·4"e½$Œ¬¤Ã·rTc‡ŠyÃ%ŠaÿCo1l©¥Oï8ËÒºöix©¿‰ëÓî¡¢ãZ^t¶ ÎY½FU¿òË0d§7qˆ>Ê8Œ{ìrÆ3^‚ZyFÇrÆdT§,áô¤ÜpÃµ¿B¨ü³ŞZ2+â•¥³´ÓDÎÈrÔÀ¶İ197¢1&sŠòNN"¼¾c>È‰¡¬)a•¥¦š÷aNÍœ3ıæ¡mâu¶S¬Şng
TÖÖúŸ@»îı8eœÁ7RŸjè)ëíÑå^ *‰â*ìø*ßîc´k»¶ç«/k´OfÒàe‰ŸdšÈ=«ÈÂÑ›6$×œî™yƒ©½±@5&ı ³Vå Ï«¯âd=ƒ´¥‘1ï`ºcøö±À0˜ÉnôÇPU3´9å*6"ÏÛHbŞ¶ífn3„É=³ÆX-µóïlªìªºõÉò€I•Ô÷£G£ä·ÖtB)íáßçvÔ…ÇÚ!ûm ¥è]]‰n´ùE­w*©·Pün¢:e8ãî©µùD$Á8ÍIó0-yòğ¸«I¼1şZgS> ´ı£ºaê½XA± ªÖÓ?yô@£â	¡Ç°§­ZcáÊÌİÅÙsÖôP>ã$†ø#22ò‰ßƒ]Õ8Ç—¤3JAY'Ó¶¤ÙÖ…èİÅºow¡ßçË!1Ä±<{ŒäUqÓ^êÌí5°á‡Ö»Ûw»QãSw:céCßÓCØ>1}‘ìBwCwc³ŠãíË`iCå*[]µä¿Œ°%¾J³™©w’º‰3¥Æîù©*W¾ªG„Y¯Nn!9y¥Àéï’6Ö·R8®ÕA´§È+C[Áé–AöøıøÚ,ê°‘Ù§> ~º}‘&Û0n™üQŒrút´®w›÷Oq2şUù!gnØûœ^Së(Æz^™CÖøÀN¼ÔÜñz±Î:¡lÙG§iÀJ¸º©÷iÙÃ²—Q‘ìºÂ;s'EecX]ß'N`I9W5 UŒ‘v‚F*¸ÃÛi·ßX6n[6íî¤÷éŞ°‚ø&1(Pšz/‡s 1ìˆĞìY´_¼ŞÀ>³nÓqA!	¨ê,TÈFŠpkÑpõÇî¥ş­—rŒ!G.\Õ!Á3ê“Ezh×ZĞó¤VÎ§	¼xùâr)y²·›Ñf¥‰2z¬ôıä=\ïP7á2ˆE¦íœ1É¶ø é2Áª?©ÿ#‘”‘¤ÖÂán¤ze+=º‰¦¸k¾–èÅf-y‡S–›H¡ÏoLÃÂ=mÏÓÄÊYvúèşºñ‰uÌ7Må+yl€g3ÿ¨¾Ø¨‚yÛu?^À¦ıªqæ6²õ¼²wÏ N’ì7G~3±aæåÑOYl‘bˆÛ¡"ˆJ›ë¤SQ„ô"
6f.¾-ÄæxMŞÉåäÓPŠ‰ŸÉ±éè4ÛAMä„’Å?õR…ó¶«™(8îZF¼ÁŒÑœıBñpŸ;Æ5j–?F´'v1˜lª=îsGê¥šı,ÇWs´Ãë‹Ğ×ü©p¼fäø<x8¹İ€Ö£W]<‘áV Å*pff9ì¬Õ>Ùy*‹İú§TÍx5ïº,¿Ó°ÆMSgï¯z5±ïOŞ$‘£§Âc\lA^ì­l{½ÁÅ:Äß¢hªBµYpBS¦f÷ã­'ïäÑoí"5‰(ß!?|GÒEWá¸ßı:m÷£jŠ@êtĞ€‘EI\1Œ•Ş¹ãÕ4ŸÚê»R>ÜƒM¦£‹'‹5U²‡ª&ˆëf»è2 İQ¤fçé?$ZçZìúŠÒÓbÏ·:i‚vU®¼g^PA(ŒìScÁurZ[5¸»ánh‹0‚•Ë».ôh€*öK^ïšV(‘&?œÇ{Ñ¾ÚML¿.–xˆÌÕ6Ï:³3Bß§‘ÜÆ.ÜŞ ÉrIîƒå²/8
I1§…î=§| ğÑÄSSÜ.xãm×sY×ñŞ¥ÔÆ>n›ö'ş:k¯]\çšÂ‰•ÚÎÅs~H›?bø;ªÈ&¾·26Dw3RN¡íõ¹”Åe›Íğš´mİÓzµai–¢œÄ^²>ß¦ùMº ç¼pÍŒùˆûÿ÷ƒŒŞñº9£4dÙ ºşÕñy“9è—\`¶”¤—ú˜0+wš+°İ}FÖVû®QTÜWãZçN™cÅ} ›^…Ìz.›Ôz°yæLLÏ3g±Y‚Ú¾İf=vü-¿úù4p'eŸ¼QÇáŞXÉvö‡J6Ú–ØpÃÔÌÑçêSA7q©uÿcc¸äˆF·8YL2`(ºOb,E|Æ­Àì†´+|…€(ì”Í™–®¿‘mE²Cİ.c“!ÈÿÔS
|[‡€†Ò´¦¢ÏjØn÷#ÉAe$E%eÚ¤»Û9Áµ=ÄÆ2¨UdµYÖà‚™½O!}È:á3…ÃwÙFƒS_8âF´ÀpMì1Ä·`?"Îk*îÔFfæŠøìy/¿ljøö-¬Q%Siğv‰¬ıÍ_Ày#¥\¼PZ–“	\¥6×F·é°½8
ïáÄ¸‘ÑRs}K;ßNéÜ¢é½ßÒ~”dÃ€·	ãüı¢ÍNß¿9ï¦ª	¸¯-mué‹g­RëtÀ¯ÀWèÀ;­~ö1(ƒ0Ìƒ³Sb‹¤$¯ŠQÄ(˜æ¦£ïŸwˆÃ
ü.#˜ºXRç¾.†u,Ÿï}(ã ¥¡ƒŒz<Ã/z–%„¸şÿ¼É‰‹…E·ZQsş¡JÊiÒgvÆ¥¢³¥?$;'-m×¢ÄÎdÌµIÿé¹yà>ÁâUı‹Ø"IĞ[Ö½³c18èÂváÁÎ€ä8…`Ü,\P<oı½"Ã\AD:CÅ¯¹g~£®ùwéjôã ‡¶nmá¤pa°n²¯™ˆCüO²4´§‡¹qĞ‡ÙtË ˆÆÑÄZù¹ 6æ“uú€µtu
LœÏoíøû:ÛkÉó‰“¤Ó'‘»²íß¢©¢kÙl[Èæ,ÈI¹¡ÅršE¯”ß	½ôk¥Ù;zû%Üùı	}‰]m«aú"ËÀx@w¥us{ÿG¶(:Ë°hLM‰8[‰_Ã’`„n[xÒSS¨,öÈú7@İ/ëwŸõä6±–r?ï´õÜ+vOè,z†ªÀÔ¬ à"Q*(iºI°‰Şö§-í^K4£eÃ9¥IwCÎ¤ ’Ej¼<àš\¡ &÷,_êØª9;D©şE,ØB"±Ÿrcjs¶B€
nwã¶™nr;‰ğ\œZ²Ä³ù¤~g¾b´H~Zñ<Ôf?!æçş_[ªÙ¯øô'+áÃEK¦V)˜M"\BéÀš¯^/»U¤¤ïªf"É¸älÉõm{
Po­f>—Xfü È¼ôåUx/	Ïì—h¹i©6n'yüó/RMw!6õ…ÍC’÷‘æ%û[z8…óe9¤'À|=4ó¨]Š>ÉrKÕß…*ˆò ó›ùî(¿ò@a…À¬ƒZUóRxœ·•°éÜ#K©¨ˆ “Çêâ»l¡Óf«„Äá"Ød}iâ2oãÇ`Í²záßÍëm`{IO(¼5ZN—.<¿ËU#¡ËÁ­[É¤¡Ú/ïá'`ÁÌ§)ë´ĞÀH¶ƒN+#‘¯GcVù¼-ùd~6Ÿf_‚âÓb›p«ˆøsM¯Ú28–$<HhŸÈ»º®íÙ÷¨¢¦>²3—²‘-Óf™lŸ€[Ëûr¢r¯-äRíÊ;’:'µya>nYCT&ÎDuìÇ†«ëİàS¹ÚK#hšJ¤ÏĞ.	u_kz3Ìñ,Í¾vªnĞÖÇõBJ1KÕ_ıœ‘Kd»”·äÕ.îÃA™Îôcj9_kyÁ—F7ÌZEqA³×Ô,ÅæØ6	İà+¨aJ"Nìô.®’ÊP5¦®EìI±À«J¯³,ˆm‹ºúhAfz^É"E3V Ğ¼ş2Ø‹è©¤®-¿şÉu}Ş9ôWKç¢uŸ{Š•Óõ%g[0ğ–)×ÿ)"^L rdo|Wp¥^çÅ
ÑRë6f©ó‘ÍÂ*d_|hfáX'(Sq'î‘!g”W<–ç‰¿ü¤KÏúÇƒ@,Ô\[®{G¼ûQ¾=çß‚Ä­	Á‡ø¦±&Y´¼N´şgYáİ%G²_ÃÁPÛÜ¸óº’DF&•‡Ã\“fõ¤İª`ücšñ²z—	¶¾pãnT!ëEJ'ëÑI»Â8«+Òè6Ö¾\	Ø"¿&!€òš1ĞÖqŠhC"Ñu~Z­§˜µªş:w.¯‡y$¨F€¤Ô€×!Ì)ä·ÿâD^’ rÀ8ãË(òæİ¹ş„eë´Ùœ»ˆ­3O‰ôa® ™¨Vjº½ªWñüçï±<èUÌU½²K"à9‡x’&Ég¿JšÃŠÖª¹´²xÓ2‡Ş‰xDèx¬; aÌæÜ}¢S®p)ËRTŠÜ½+ZZO+Éˆn·v"[TWş›Ş&h=­d¯Ò§.,0ñ­¡×À–á‚×§¡4°°1âvEŸzŞ ‚Ş/¼µozš¶>’œ 2Hvì‘ˆ?×i€iô\iÎÕg#aRLpÎ¿ÍmÇ¥±F\ı-!Ğ
Wm6@½PÂä|~õ9ÁHpj –~¥ÕaƒIä,Q^’¨Yn¸`üé^cÿ,Sª â¸‚çÿR]á}â“å\1ÅgßHCÙ!’æ‰q«¿’š§¤|ô¹­Wpı(®¨bRşŠ*w;y#ÚUîy~Q R>º{¤j‡hè‹Ë1]ZíÈ~âu	JHUĞº+gm°B8ÂRë6Ç†‘¢ã9!‘¢9ÒÆ…g&ƒK!š¦%–té’	ÌÚpÉX3¯×±¯Óv†¤É#{‹"ƒÁ¯&û#9~°2-WµJÇÂ¤®c×au¢ÂBÈûk‘¶ŞÁÑi›Æbç-óè>¤Ó4®Öš‚IjisÙíS—iÏÛbªƒ,À]rû#àô0Û´h×üãH/ !”İª–ÅA0¨Œ4î¾Ì¼óÏ[­Fª.¤B¹´µ@xsïl±ˆşãÙ^§‡öï¾™ºÿøæ½ÈÕ˜Z@f@£ìŠOpŸÛƒ'e«îµµåÄİë„¢ïr¼›@EÛÍğ‡ˆ0#¿—.úM'×UİüwÍ¦š¿+o`:Û…ñy}ë€]ESW)%CuñO*tè«F7k¨ ¤òçk/ŒH vı¬4HoÎD2Aå’J/ÃdÒ,¾¡&w©| ÆW2âløclÀ§ceş1¥3Léöj·ä#ÃK‰îİÃ•r¥œøß6¡ã4ÌG§îšã×ÿá×é‹°–º*ïÄeºJn7 ï÷Vêû¥¶¸bÕec÷³(‡+êğ®IT')j€Œ"Ìj¥eyï¯Wv®¯ë·û&±~Ï=Ò•-'İM	Òb?ŸæK%øıØ5ôı—SÑ®€¢°¸.n˜­ŠÜÀ!”Å¢ ÅP à'§Û÷£^>7ªpËÒ¤’T‘Q1ª~g1ç°Pa‡¨øZûEö—6a>Óu;Ü­G÷"yí¦²\*şcó¹²cÿ´'nÎªõ†/¹’•LGú«òW“óbÒe4»-T6TFbu3—„r00­ïRèt™s†“d1Éd –ÏC¹°or_|)5BP}Bä
Î.ü€à@5·_ğÙöm—´à.ÈN
²sQ‰Ô„b3·Ë›	Änv˜	éèl/‰è6™J™’H
yLãgIÁãs\o9´$?‡¬¶˜_z¨Ï2‚~!ïÄßMÖMoYï:$F3œ©O¶ôl„(C—¿¼P 'ÎrÂRßrÈèq‡w±SDÏ8kr¥Íâ)É)üWÈYÒ:~ÉIV„ÎªTçãsi¹«©z CkBEòoN¤\g«ïKƒÕsQÇ¯Òi×‰<¢‡cİÁÔé_Äks#9µlÍ—©©ïNz‰í*<7Ó‹®3ìÂ¦÷ë©×»u#  lAêC¥vC<Æùñô,(}{Ù“¤÷6²))°µĞ€U2¶b]§ñ9AMcR:PÒm`WÃíı|ó¡?tƒ07öÌ}lºP› õ#œ—İŸ‡ŸjşQ‚n/Yx1süÎIêÛ [2‡ _ì0üxÿh¥ÿ¼C{WhŸ;–ùöåR"W;BRæ´qf„ÑÑ™ù¤×†­jP`Â÷–.~²Æ:ƒÑ³‘>§²§¹ÍgÉÂ¾´Ò÷GAì+t²³œ‰šN3åßq'Á£ÿ.¦ÏÜ4½´–9Ğ_LÉ{H4sÄ%Äd^[înñ]‡\
:“ï¼wÃÄİOš/±9ŸO0÷ íWÉÑæiR©pœ×AĞªCÌÂhŸı aC‚iƒ—©Su¸u
“‰&ú[ªGø>Pö–Uh€'›¯‡/Œ)óçG‰+NŸm/Ş5
gì…öüã9’bÊéJ:·^TÇM–)¨·.Ç@Ró…ıÍX¤¿¿¨
_Tâ«á‰ş¡îUÆ[ì×°…açEM.cˆ€F`H_á{Z%kDDe†åİµ-‡·ŸJ‚‚ÖTÎÒQÓõ[9#™	ø^RÓºùİH#º©IÓ‹ßÆçåzoø{B\XWPzÈfDê«œcöæKáæTQuéëfèc^Ã³Ãh<UxÑ{Qœğç²|CñÎ0»ò¯3^¢ÒFÊªe@—,
.xÖR.yds%ëƒ~ø›,+(I›nÊÆà
	ß*6@»âC+|ıÄò™êü|æt¹Ğuoá¢¹3+ÄŸ7òÕ´»Â]†dî•í1bVì~sÔÄ×uaáæßµ¢–ïâÖ›¼¯¥â'Ü;zœ§ qE$FºõLÅG[¦qÊı/ÿ„0øCŠ­†ê„7S˜Õ/p!¸2¶” …z­’2'H1²&Ü1 ÷(Ş'	…ã¿*•åç:ãé‹¥¬wWv{D1ÕŞMØ©¸ WÌ,€Ô˜lÛŠ˜~]YÎ¼ılUT5’`×.±ÜkOöUöx¿ÊcPÃøfPŸZßÄ'use strict';

exports.type = 'perItem';

exports.active = true;

exports.description = 'optimizes path data: writes in shorter form, applies transformations';

exports.params = {
    applyTransforms: true,
    applyTransformsStroked: true,
    makeArcs: {
        threshold: 2.5, // coefficient of rounding error
        tolerance: 0.5  // percentage of radius
    },
    straightCurves: true,
    lineShorthands: true,
    curveSmoothShorthands: true,
    floatPrecision: 3,
    transformPrecision: 5,
    removeUseless: true,
    collapseRepeated: true,
    utilizeAbsolute: true,
    leadingZero: true,
    negativeExtraSpace: true,
    noSpaceAfterFlags: true,
    forceAbsolutePath: false
};

var pathElems = require('./_collections.js').pathElems,
    path2js = require('./_path.js').path2js,
    js2path = require('./_path.js').js2path,
    applyTransforms = require('./_path.js').applyTransforms,
    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,
    roundData,
    precision,
    error,
    arcThreshold,
    arcTolerance,
    hasMarkerMid,
    hasStrokeLinecap;

/**
 * Convert absolute Path to relative,
 * collapse repeated instructions,
 * detect and convert Lineto shorthands,
 * remove useless instructions like "l0,0",
 * trim useless delimiters and leading zeros,
 * decrease accuracy of floating-point numbers.
 *
 * @see http://www.w3.org/TR/SVG/paths.html#PathData
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 *
 * @author Kir Belevich
 */
exports.fn = function(item, params) {

    if (item.isElem(pathElems) && item.hasAttr('d')) {

        precision = params.floatPrecision;
        error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;
        roundData = precision > 0 && precision < 20 ? strongRound : round;
        if (params.makeArcs) {
            arcThreshold = params.makeArcs.threshold;
            arcTolerance = params.makeArcs.tolerance;
        }
        hasMarkerMid = item.hasAttr('marker-mid');

        var stroke = item.computedAttr('stroke'),
            strokeLinecap = item.computedAttr('stroke');
        hasStrokeLinecap = stroke && stroke != 'none' && strokeLinecap && strokeLinecap != 'butt';

        var data = path2js(item);

        // TODO: get rid of functions returns
        if (data.length) {
            convertToRelative(data);

            if (params.applyTransforms) {
                data = applyTransforms(item, data, params);
            }

            data = filters(data, params);

            if (params.utilizeAbsolute) {
                data = convertToMixed(data, params);
            }

            js2path(item, data, params);
        }

    }

};

/**
 * Convert absolute path data coordinates to relative.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
function convertToRelative(path) {

    var point = [0, 0],
        subpathPoint = [0, 0],
        baseItem;

    path.forEach(function(item, index) {

        var instruction = item.instruction,
            data = item.data;

        // data !== !z
        if (data) {

            // already relative
            // recalculate current point
            if ('mcslqta'.indexOf(instruction) > -1) {

                point[0] += data[data.length - 2];
                point[1] += data[data.length - 1];

                if (instruction === 'm') {
                    subpathPoint[0] = point[0];
                    subpathPoint[1] = point[1];
                    baseItem = item;
                }

            } else if (instruction === 'h') {

                point[0] += data[0];

            } else if (instruction === 'v') {

                point[1] += data[0];

            }

            // convert absolute path data coordinates to relative
            // if "M" was not transformed from "m"
            // M â†’ m
            if (instruction === 'M') {

                if (index > 0) instruction = 'm';

                data[0] -= point[0];
                data[1] -= point[1];

                subpathPoint[0] = point[0] += data[0];
                subpathPoint[1] = point[1] += data[1];

                baseItem = item;

            }

            // L â†’ l
            // T â†’ t
            else if ('LT'.indexOf(instruction) > -1) {

                instruction = instruction.toLowerCase();

                // x y
                // 0 1
                data[0] -= point[0];
                data[1] -= point[1];

                point[0] += data[0];
                point[1] += data[1];

            // C â†’ c
            } else if (instruction === 'C') {

                instruction = 'c';

                // x1 y1 x2 y2 x y
                // 0  1  2  3  4 5
                data[0] -= point[0];
                data[1] -= point[1];
                data[2] -= point[0];
                data[3] -= point[1];
                data[4] -= point[0];
                data[5] -= point[1];

                point[0] += data[4];
                point[1] += data[5];

            // S â†’ s
            // Q â†’ q
            } else if ('SQ'.indexOf(instruction) > -1) {

                instruction = instruction.toLowerCase();

                // x1 y1 x y
                // 0  1  2 3
                data[0] -= point[0];
                data[1] -= point[1];
                data[2] -= point[0];
                data[3] -= point[1];

                point[0] += data[2];
                point[1] += data[3];

            // A â†’ a
            } else if (instruction === 'A') {

                instruction = 'a';

                // rx ry x-axis-rotation large-arc-flag sweep-flag x y
                // 0  1  2               3              4          5 6
                data[5] -= point[0];
                data[6] -= point[1];

                point[0] += data[5];
                point[1] += data[6];

            // H â†’ h
            } else if (instruction === 'H') {

                instruction = 'h';

                data[0] -= point[0];

                point[0] += data[0];

            // V â†’ v
            } else if (instruction === 'V') {

                instruction = 'v';

                data[0] -= point[1];

                point[1] += data[0];

            }

            item.instruction = instruction;
            item.data = data;

            // store absolute coordinates for later use
            item.coords = point.slice(-2);

        }

        // !data === z, reset current point
        else if (instruction == 'z') {
            if (baseItem) {
                item.coords = baseItem.coords;
            }
            point[0] = subpathPoint[0];
            point[1] = subpathPoint[1];
        }

        item.base = index > 0 ? path[index - 1].coords : [0, 0];

    });

    return path;

}

/**
 * Main filters loop.
 *
 * @param {Array} path input path data
 * @param {Object} params plugin params
 * @return {Array} output path data
 */
function filters(path, params) {

    var stringify = data2Path.bind(null, params),
        relSubpoint = [0, 0],
        pathBase = [0, 0],
        prev = {};

    path = path.filter(function(item, index, path) {

        var instruction = item.instruction,
            data = item.data,
            next = path[index + 1];

        if (data) {

            var sdata = data,
                circle;

            if (instruction === 's') {
                sdata = [0, 0].concat(data);

                if ('cs'.indexOf(prev.instruction) > -1) {
                    var pdata = prev.data,
                        n = pdata.length;

                    // (-x, -y) of the prev tangent point relative to the current point
                    sdata[0] = pdata[n - 2] - pdata[n - 4];
                    sdata[1] = pdata[n - 1] - pdata[n - 3];
                }

            }

            // convert curves to arcs if possible
            if (
                params.makeArcs &&
                (instruction == 'c' || instruction == 's') &&
                isConvex(sdata) &&
                (circle = findCircle(sdata))
            ) {
                var r = roundData([circle.radius])[0],
                    angle = findArcAngle(sdata, circle),
                    sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
                    arc = {
                        instruction: 'a',
                        data: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
                        coords: item.coords.slice(),
                        base: item.base
                    },
                    output = [arc],
                    // relative coordinates to adjust the found circle
                    relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],
                    relCircle = { center: relCenter, radius: circle.radius },
                    arcCurves = [item],
                    hasPrev = 0,
               