ateImportAttributes(
                factory.createNodeArray([
                  factory.createImportAttribute(
                    factory.createStringLiteral("resolution-mode"),
                    factory.createStringLiteral(swappedMode === 99 /* ESNext */ ? "import" : "require")
                  )
                ])
              );
            }
          }
          if (!attributes) {
            context.encounteredError = true;
            if (context.tracker.reportLikelyUnsafeImportRequiredError) {
              context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier);
            }
          }
        }
        const lit = factory.createLiteralTypeNode(factory.createStringLiteral(specifier));
        if (context.tracker.trackExternalModuleSymbolOfImportTypeNode)
          context.tracker.trackExternalModuleSymbolOfImportTypeNode(chain[0]);
        context.approximateLength += specifier.length + 10;
        if (!nonRootParts || isEntityName(nonRootParts)) {
          if (nonRootParts) {
            const lastId = isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right;
            setIdentifierTypeArguments(
              lastId,
              /*typeArguments*/
              void 0
            );
          }
          return factory.createImportTypeNode(lit, attributes, nonRootParts, typeParameterNodes, isTypeOf);
        } else {
          const splitNode = getTopmostIndexedAccessType(nonRootParts);
          const qualifier = splitNode.objectType.typeName;
          return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes, isTypeOf), splitNode.indexType);
        }
      }
      const entityName = createAccessFromSymbolChain(chain, chain.length - 1, 0);
      if (isIndexedAccessTypeNode(entityName)) {
        return entityName;
      }
      if (isTypeOf) {
        return factory.createTypeQueryNode(entityName);
      } else {
        const lastId = isIdentifier(entityName) ? entityName : entityName.right;
        const lastTypeArgs = getIdentifierTypeArguments(lastId);
        setIdentifierTypeArguments(
          lastId,
          /*typeArguments*/
          void 0
        );
        return factory.createTypeReferenceNode(entityName, lastTypeArgs);
      }
      function createAccessFromSymbolChain(chain2, index, stopper) {
        const typeParameterNodes = index === chain2.length - 1 ? overrideTypeArguments : lookupTypeParameterNodes(chain2, index, context);
        const symbol2 = chain2[index];
        const parent2 = chain2[index - 1];
        let symbolName2;
        if (index === 0) {
          context.flags |= 16777216 /* InInitialEntityName */;
          symbolName2 = getNameOfSymbolAsWritten(symbol2, context);
          context.approximateLength += (symbolName2 ? symbolName2.length : 0) + 1;
          context.flags ^= 16777216 /* InInitialEntityName */;
        } else {
          if (parent2 && getExportsOfSymbol(parent2)) {
            const exports2 = getExportsOfSymbol(parent2);
            forEachEntry(exports2, (ex, name) => {
              if (getSymbolIfSameReference(ex, symbol2) && !isLateBoundName(name) && name !== "export=" /* ExportEquals */) {
                symbolName2 = unescapeLeadingUnderscores(name);
                return true;
              }
            });
          }
        }
        if (symbolName2 === void 0) {
          const name = firstDefined(symbol2.declarations, getNameOfDeclaration);
          if (name && isComputedPropertyName(name) && isEntityName(name.expression)) {
            const LHS = createAccessFromSymbolChain(chain2, index - 1, stopper);
            if (isEntityName(LHS)) {
              return fact