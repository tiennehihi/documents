peFromConditionalType(target2),
                    3 /* Both */,
                    /*reportErrors*/
                    false
                  )) {
                    return result2;
                  }
                }
              }
            }
          }
        }
        if (sourceFlags & 33554432 /* Substitution */) {
          if (result2 = isRelatedTo(
            source2.baseType,
            target2.baseType,
            3 /* Both */,
            /*reportErrors*/
            false
          )) {
            if (result2 &= isRelatedTo(
              source2.constraint,
              target2.constraint,
              3 /* Both */,
              /*reportErrors*/
              false
            )) {
              return result2;
            }
          }
        }
        if (!(sourceFlags & 524288 /* Object */)) {
          return 0 /* False */;
        }
      } else if (sourceFlags & 3145728 /* UnionOrIntersection */ || targetFlags & 3145728 /* UnionOrIntersection */) {
        if (result2 = unionOrIntersectionRelatedTo(source2, target2, reportErrors2, intersectionState)) {
          return result2;
        }
        if (!(sourceFlags & 465829888 /* Instantiable */ || sourceFlags & 524288 /* Object */ && targetFlags & 1048576 /* Union */ || sourceFlags & 2097152 /* Intersection */ && targetFlags & (524288 /* Object */ | 1048576 /* Union */ | 465829888 /* Instantiable */))) {
          return 0 /* False */;
        }
      }
      if (sourceFlags & (524288 /* Object */ | 16777216 /* Conditional */) && source2.aliasSymbol && source2.aliasTypeArguments && source2.aliasSymbol === target2.aliasSymbol && !(isMarkerType(source2) || isMarkerType(target2))) {
        const variances = getAliasVariances(source2.aliasSymbol);
        if (variances === emptyArray) {
          return 1 /* Unknown */;
        }
        const params = getSymbolLinks(source2.aliasSymbol).typeParameters;
        const minParams = getMinTypeArgumentCount(params);
        const sourceTypes = fillMissingTypeArguments(source2.aliasTypeArguments, params, minParams, isInJSFile(source2.aliasSymbol.valueDeclaration));
        const targetTypes = fillMissingTypeArguments(target2.aliasTypeArguments, params, minParams, isInJSFile(source2.aliasSymbol.valueDeclaration));
        const varianceResult = relateVariances(sourceTypes, targetTypes, variances, intersectionState);
        if (varianceResult !== void 0) {
          return varianceResult;
        }
      }
      if (isSingleElementGenericTupleType(source2) && !source2.target.readonly && (result2 = isRelatedTo(getTypeArguments(source2)[0], target2, 1 /* Source */)) || isSingleElementGenericTupleType(target2) && (target2.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source2) || source2)) && (result2 = isRelatedTo(source2, getTypeArguments(target2)[0], 2 /* Target */))) {
        return resu