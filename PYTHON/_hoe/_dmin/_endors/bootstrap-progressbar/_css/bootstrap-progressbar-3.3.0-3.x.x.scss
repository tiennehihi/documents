tack=[],pos=0,line=1,column=0,token=void 0,key=void 0,root=void 0;do{token=lex(),parseStates[parseState]()}while("eof"!==token.type);return"function"==typeof D?internalize({"":root},"",D):root};function internalize(u,D,e){const r=u[D];if(null!=r&&"object"==typeof r)if(Array.isArray(r))for(let u=0;u<r.length;u++){const D=String(u),t=internalize(r,D,e);void 0===t?delete r[D]:Object.defineProperty(r,D,{value:t,writable:!0,enumerable:!0,configurable:!0})}else for(const u in r){const D=internalize(r,u,e);void 0===D?delete r[u]:Object.defineProperty(r,u,{value:D,writable:!0,enumerable:!0,configurable:!0})}return e.call(u,D,r)}let lexState,buffer,doubleQuote,sign,c;function lex(){for(lexState="default",buffer="",doubleQuote=!1,sign=1;;){c=peek();const u=lexStates[lexState]();if(u)return u}}function peek(){if(source[pos])return String.fromCodePoint(source.codePointAt(pos))}function read(){const u=peek();return"\n"===u?(line++,column=0):u?column+=u.length:column++,u&&(pos+=u.length),u}const lexStates={default(){switch(c){case"\t":case"\v":case"\f":case" ":case"Â ":case"\ufeff":case"\n":case"\r":case"\u2028":case"\u2029":return void read();case"/":return read(),void(lexState="comment");case void 0:return read(),newToken("eof")}if(!util.isSpaceSeparator(c))return lexStates[parseState]();read()},comment(){switch(c){case"*":return read(),void(lexState="multiLineComment");case"/":return read(),void(lexState="singleLin