  if (null == f2 ? void 0 : f2.closest) {
          var n = this.toRgb(), t = 1 / 0, b = "black";
          if (!l.length)
            for (var c in a)
              l[c] = new e(a[c]).toRgb();
          for (var g in a) {
            var u = (d2 = n, i = l[g], Math.pow(d2.r - i.r, 2) + Math.pow(d2.g - i.g, 2) + Math.pow(d2.b - i.b, 2));
            u < t && (t = u, b = g);
          }
          return b;
        }
      };
      f.string.push([function(f2) {
        var r2 = f2.toLowerCase(), d2 = "transparent" === r2 ? "#0000" : a[r2];
        return d2 ? new e(d2).toRgb() : null;
      }, "name"]);
    };
  }
});

// node_modules/postcss-minify-gradients/src/isColorStop.js
var require_isColorStop = __commonJS({
  "node_modules/postcss-minify-gradients/src/isColorStop.js"(exports2, module2) {
    "use strict";
    var { unit } = require_lib();
    var { colord, extend } = require_colord();
    var namesPlugin = require_names();
    extend([
      /** @type {any} */
      namesPlugin
    ]);
    var lengthUnits = /* @__PURE__ */ new Set([
      "PX",
      "IN",
      "CM",
      "MM",
      "EM",
      "REM",
      "POINTS",
      "PC",
      "EX",
      "CH",
      "VW",
      "VH",
      "VMIN",
      "VMAX",
      "%"
    ]);
    function isCSSLengthUnit(input) {
      return lengthUnits.has(input.toUpperCase());
    }
    function isStop(str) {
      if (str) {
        let stop = false;
        const node = unit(str);
        if (node) {
          const number = Number(node.number);
          if (number === 0 || !isNaN(number) && isCSSLengthUnit(node.unit)) {
            stop = true;
          }
        } else {
          stop = /^calc\(\S+\)$/g.test(str);
        }
        return stop;
      }
      return true;
    }
    module2.exports = function isColorStop(color, stop) {
      return colord(color).isValid() && isStop(stop);
    };
  }
});

// node_modules/postcss-minify-gradients/src/index.js
var require_src5 = __commonJS({
  "node_modules/postcss-minify-gradients/src/index.js"(exports2, module2) {
    "use strict";
    var valueParser = require_lib();
    var { getArguments } = require_src4();
    var isColorStop = require_isColorStop();
    var angles = {
      top: "0deg",
      right: "90deg",
      bottom: "180deg",
      left: "270deg"
    };
    function isLessThan(a, b) {
      return a.unit.toLowerCase() === b.unit.toLowerCase() && parseFloat(a.number) >= parseFloat(b.number);
    }
    function optimise(decl) {
      const value = decl.value;
      if (!value) {
        return;
      }
      const normalizedValue = value.toLowerCase();
      if (normalizedValue.includes("var(") || normalizedValue.includes("env(")) {
        return;
      }
      if (!normalizedValue.includes("gradient")) {
        return;
      }
      decl.value = valueParser(value).walk((node) => {
        if (node.type !== "function" || !node.nodes.length) {
          return false;
        }
        const lowerCasedValue = node.value.toLowerCase();
        if (lowerCasedValue === "linear-gradient" || lowerCasedValue === "repeating-linear-gradient" || lowerCasedValue === "-webkit-linear-gradient" || lowerCasedValue === "-webkit-repeating-linear-gradient") {
          let args = getArguments(node);
          if (node.nodes[0].value.toLowerCase() === "to" && args[0].length === 3) {
            node.nodes = node.nodes.slice(2);
            node.nodes[0].value = angles[
              /** @type {'top'|'right'|'bottom'|'left'}*/
              node.nodes[0].value.toLowerCase()
            ];
          }
          let lastStop;
          args.forEach((arg, index) => {
            if (arg.length !== 3) {
              return;
            }
            let isFinalStop = index === args.length - 1;
            let thisStop = valueParser.unit(arg[2].value);
            if (lastStop === void 0) {
              lastStop = thisStop;
              if (!isFinalStop && lastStop && lastStop.number === "0" && lastStop.unit.toLowerCase() !== "deg") {
                arg[1].value = arg[2].value = "";
              }
              return;
            }
            if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
              arg[2].value = "0";
            }
            lastStop = thisStop;
            if (isFinalStop && arg[2].value === "100%") {
              arg[1].value = arg[2].value = "";
            }
          });
          return false;
        }
        if (lowerCasedValue === "radial-gradient" || lowerCasedValue === "repeating-radial-gradient") {
          let args = getArguments(node);
          let lastStop;
          const hasAt = args[0].find((n) => n.value.toLowerCase() === "at");
          args.forEach((arg, index) => {
            if (!arg[2] || !index && hasAt) {
              return;
            }
            let thisStop = valueParser.unit(arg[2].value);
            if (!lastStop) {
              lastStop = thisStop;
              return;
            }
            if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
              arg[2].value = "0";
            }
            lastStop = thisStop;
          });
          return false;
        }
        if (lowerCasedValue === "-webkit-radial-gradient" || lowerCasedValue === "-webkit-repeating-radial-gradient") {
          let args = getArguments(node);
          let lastStop;
          args.forEach((arg) => {
            let color;
            let stop;
            if (arg[2] !== void 0) {
              if (arg[0].type === "function") {
                color = `${arg[0].value}(${valueParser.stringify(arg[0].nodes)})`;
              } else {
                color = arg[0].value;
              }
              if (arg[2].type === "function") {
                stop = `${arg[2].value}(${valueParser.stringify(arg[2].nodes)})`;
              } else {
                stop = arg[2].value;
              }
            } else {
              if (arg[0].type === "function") {
                color = `${arg[0].value}(${valueParser.stringify(arg[0].nodes)})`;
              }
              color = arg[0].value;
            }
            color = color.toLowerCase();
            const colorStop = stop !== void 0 ? isColorStop(color, stop.toLowerCase()) : isColorStop(color);
            if (!colorStop || !arg[2]) {
              return;
            }
            let thisStop = valueParser.unit(arg[2].value);
            if (!lastStop) {
              lastStop = thisStop;
              return;
            }
            if (lastStop && thisStop && isLessThan(lastStop, thisStop)) {
              arg[2].value = "0";
            }
            lastStop = thisStop;
          });
          return false;
        }
      }).toString();
    }
    function pluginCreator() {
      return {
        postcssPlugin: "postcss-minify-gradients",
        OnceExit(css) {
          css.walkDecls(optimise);
        }
      };
    }
    pluginCreator.postcss = true;
    module2.exports = pluginCreator;
  }
});

// node_modules/@trysound/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@trysound/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return re