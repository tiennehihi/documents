nt = param && getBaseConstraintOfType(param);
                  if (constraint && isTupleType(constraint) && !constraint.target.hasRestElement) {
                    const impliedArity = constraint.target.fixedLength;
                    inferFromTypes(sliceTupleType(source, startLength, sourceArity - (startLength + impliedArity)), elementTypes[startLength]);
                    inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength), elementTypes[startLength + 1]);
                  }
                } else if (elementFlags[startLength] & 4 /* Rest */ && elementFlags[startLength + 1] & 8 /* Variadic */) {
                  const param = (_b = getInferenceInfoForType(elementTypes[startLength + 1])) == null ? void 0 : _b.typeParameter;
                  const constraint = param && getBaseConstraintOfType(param);
                  if (constraint && isTupleType(constraint) && !constraint.target.hasRestElement) {
                    const impliedArity = constraint.target.fixedLength;
                    const endIndex = sourceArity - getEndElementCount(target.target, 3 /* Fixed */);
                    const startIndex = endIndex - impliedArity;
                    const trailingSlice = createTupleType(
                      getTypeArguments(source).slice(startIndex, endIndex),
                      source.target.elementFlags.slice(startIndex, endIndex),
                      /*readonly*/
                      false,
                      source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex)
                    );
                    inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity), elementTypes[startLength]);
                    inferFromTypes(trailingSlice, elementTypes[startLength + 1]);
                  }
                }
              } else if (middleLength === 1 && elementFlags[startLength] & 8 /* Variadic */) {
                const endsInOptional = target.target.elementFlags[targetArity - 1] & 2 /* Optional */;
                const sourceSlice = sliceTupleType(source, startLength, endLength);
                inferWithPriority(sourceSlice, elementTypes[startLength], endsInOptional ? 2 /* SpeculativeTuple */ : 0);
              } else if (middleLength === 1 && elementFlags[startLength] & 4 /* Rest */) {
                const restType = getElementTypeOfSliceOfTupleType(source, startLength, endLength);
                if (restType) {
                  inferFromTypes(restType, elementTypes[startLength]);
                }
              }
            }
            for (let i = 0; i < endLength; i++) {
              inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);
            }
            return;
          }
          if (isArrayType(target)) {
            inferFromIndexTypes(source, target);
            return;
          }
        }
        inferFromProperties(source, target);
        inferFromSignatures(source, target, 0 /* Call */);
        inferFromSignatures(source, target, 1 /* Construct */);
        inferFromIndexTypes(source, target);
      }
    }
    function inferFromProperties(source, target) {
      const properties = getPropertiesOfObjectType(target);
      for (const targetProp of properties) {
        const sourceProp = getPropertyOfType(source, targetProp.escapedName);
        if (sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag)) {
          inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
        }
      }
    }
    function inferFromSignatures(source, target, kind) {
      const sourceSignatures = getSignaturesOfType(source, kind);
      const sourceLen = sourceSignatures.length;
      if (sourceLen > 0) {
        const targetSignatures = getSignaturesOfType(target, kind);
        const targetLen = targetSignatures.length;
        for (let i = 0; i < targetLen; i++) {
          const sourceIndex = Math.max(sourceLen - targetLen + i, 0);
          inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));
        }
      }
    }
    function inferFromSignature(source, target) {
      if (!(source.flags & 64 /* IsNonInferrable */)) {
        const saveBivariant = bivariant;
        const kind = target.declaration ? target.declaration.kind : 0 /* Unknown */;
        bivariant = bivariant || kind === 174 /* MethodDeclaration */ || kind === 173 /* MethodSignature */ || kind === 176 /* Constructor */;
        applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes);
        bivariant = saveBivariant;
      }
      applyToReturnTypes(source, target, inferFromTypes);
    }
    function inferFromIndexTypes(source, target) {
      const priority2 = getObjectFlags(source) & getObjectFlags(target) & 32 /* Mapped */ ? 8 /* HomomorphicMappedType */ : 0;
      const indexInfos = getIndexInfosOfType(target);
      if (isObjectTypeWithInferableIndex(source)) {
        for (const targetInfo of indexInfos) {
          const propTypes = [];
          for (const prop of getPropertiesOfType(source)) {
            if (isApplicableIndexType(getLiteralTypeFromProperty(prop, 8576 /* StringOrNumberLiteralOrUnique */), targetInfo.keyType)) {
              const propType = getTypeOfSymbol(prop);
              propTypes.push(prop.flags & 16777216 /* Optional */ ? removeMissingOrUndefinedType(propType) : propType);
            }
          }
          for (const info of getIndexInfosOfType(source)) {
            if (isApplicableIndexType(info.keyType, targetInfo.keyType)) {
              propTypes.push(info.type);
            }
          }
          if (propTypes.length) {
            inferWithPriority(getUnionType(propTypes), targetInfo.type, priority2);
          }
        }
      }
      for (const targetInfo of indexInfos) {
        const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
        if (sourceInfo) {
          inferWithPriority(sourceInfo.type, targetInfo.type, priority2);
        }
      }
    }
  }
  function isTypeOrBaseIdenticalTo(s, t) {
    return t === missingType ? s === t : isTypeIdenticalTo(s, t) || !!(t.flags & 4 /* String */ && s.flags & 128 /* StringLiteral */ || t.flags & 8 /* Number */ && s.flags & 256 /* NumberLiteral */);
  }
  function isTypeCloselyMatchedBy(s, t) {
    return !!(s.flags & 524288 /* Object */ && t.flags & 524288 /* Object */ && s.symbol && s.symbol === t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol);
  }
  function hasPrimitiveConstraint(type) {
    const constraint = getConstraintOfTypeParameter(type);
    return !!constraint && maybeTypeOfKind(constraint.flags & 16777216 /* Conditional */ ? getDefaultConstraintOfConditionalType(constraint) : constraint, 402784252 /* Primitive */ | 4194304 /* Index */ | 134217728 /* TemplateLiteral */ | 268435456 /* StringMapping */);
  }
  function isObjectLiteralType2(type) {
    return !!(getObjectFlags(type) & 128 /* ObjectLiteral */);
  }
  function isObjectOrArrayLiteralType(type) {
    return !!(getObjectFlags(type) & (128 /* ObjectLiteral */ | 16384 /* ArrayLiteral */));
  }
  function unionObjectAndArrayLiteralCandidates(candidates) {
    if (candidates.length > 1) {
      const objectLiterals = filter(candidates, isObjectOrArrayLiteralType);
      if (objectLiterals.length) {
        const literalsType = getUnionType(objectLiterals, 2 /* Subtype */);
        return concatenate(filter(candidates, (t) => !isObjectOrArrayLiteralType(t)), [literalsType]);
      }
    }
    return candidates;
  }
  function getContravariantInference(inference) {
    return inference.priority & 416 /* PriorityImpliesCombination */ ? getIntersectionType(inference.contraCandidates) : getCommonSubtype(inference.contraCandidates);
  }
  function getCovariantInference(inference, signature) {
    const candidates = unionObjectAndArrayLiteralCandidates(inference.candidates);
    const primitiveConstraint = hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter);
    const widenLiteralTypes = !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter));
    const baseCandidates = primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) : widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) : candidates;
    const unwidenedType = inference.priority & 416 /* PriorityImpliesCombination */ ? getUnionType(baseCandidates, 2 /* Subtype */) : getCommonSupertype(baseCandidates);
    return getWidenedType(unwidenedType);
  }
  function getInferredType(context, index) {
    const inference = context.inferences[index];
    if (!inference.inferredType) {
      let inferredType;
      let fallbackType;
      if (context.signature) {
        const inferredCovariantType = inference.candidates ? getCovariantInference(inference, context.signature) : void 0;
        const inferredContravariantType = inference.contraCandidates 