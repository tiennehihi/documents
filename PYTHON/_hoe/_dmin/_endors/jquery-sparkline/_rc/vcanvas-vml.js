    }\n\n    // translate plugins\n    if (eslintrcConfig.plugins && typeof eslintrcConfig.plugins === \"object\") {\n        debug(`Translating plugins: ${eslintrcConfig.plugins}`);\n\n        flatConfig.plugins = {};\n\n        for (const pluginName of Object.keys(eslintrcConfig.plugins)) {\n\n            debug(`Translating plugin: ${pluginName}`);\n            debug(`Resolving plugin '${pluginName} relative to ${resolvePluginsRelativeTo}`);\n\n            const { original: plugin, error } = eslintrcConfig.plugins[pluginName];\n\n            if (error) {\n                throw error;\n            }\n\n            flatConfig.plugins[pluginName] = plugin;\n\n            // create a config for any processors\n            if (plugin.processors) {\n                for (const processorName of Object.keys(plugin.processors)) {\n                    if (processorName.startsWith(\".\")) {\n                        debug(`Assigning processor: ${pluginName}/${processorName}`);\n\n                        configs.unshift({\n                            files: [`**/*${processorName}`],\n                            processor: pluginProcessors.get(`${pluginName}/${processorName}`)\n                        });\n                    }\n\n                }\n            }\n        }\n    }\n\n    // translate env - must come after plugins\n    if (eslintrcConfig.env && typeof eslintrcConfig.env === \"object\") {\n        for (const envName of Object.keys(eslintrcConfig.env)) {\n\n            // only add environments that are true\n            if (eslintrcConfig.env[envName]) {\n                debug(`Translating environment: ${envName}`);\n\n                if (environments.has(envName)) {\n\n                    // built-in environments should be defined first\n                    configs.unshift(...translateESLintRC({\n                        criteria: eslintrcConfig.criteria,\n                        ...environments.get(envName)\n                    }, {\n                        resolveConfigRelativeTo,\n                        resolvePluginsRelativeTo\n                    }));\n                } else if (pluginEnvironments.has(envName)) {\n\n                    // if the environment comes from a plugin, it should come after the plugin config\n                    configs.push(...translateESLintRC({\n                        criteria: eslintrcConfig.criteria,\n                        ...pluginEnvironments.get(envName)\n                    }, {\n                        resolveConfigRelativeTo,\n                        resolvePluginsRelativeTo\n                    }));\n                }\n            }\n        }\n    }\n\n    // only add if there are actually keys in the config\n    if (Object.keys(flatConfig).length > 0) {\n        configs.push(flatConfig);\n    }\n\n    return configs;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A compatibility class for working with configs.\n */\nclass FlatCompat {\n\n    constructor({\n        baseDirectory = process.cwd(),\n        resolvePluginsRelativeTo = baseDirectory,\n        recommendedConfig,\n        allConfig\n    } = {}) {\n        this.baseDirectory = baseDirectory;\n        this.resolvePluginsRelativeTo = resolvePluginsRelativeTo;\n        this[cafactory] = new ConfigArrayFactory({\n            cwd: baseDirectory,\n            resolvePluginsRelativeTo,\n            getEslintAllConfig: () => {\n\n                if (!allConfig) {\n                    throw new TypeError(\"Missing parameter 'allConfig' in FlatCompat constructor.\");\n                }\n\n                return allConfig;\n            },\n            getEslintRecommendedConfig: () => {\n\n                if (!recommendedConfig) {\n                    throw new TypeError(\"Missing parameter 'recommendedConfig' in FlatCompat constructor.\");\n                }\n\n                return recommendedConfig;\n            }\n        });\n    }\n\n    /**\n     * Translates an ESLintRC-style config into a flag-config-style config.\n     * @param {Object} eslintrcConfig The ESLintRC-style config object.\n     * @returns {Object} A flag-config-style config object.\n     */\n    config(eslintrcConfig) {\n        const eslintrcArray = this[cafactory].create(eslintrcConfig, {\n            basePath: this.baseDirectory\n        });\n\n        const flatArray = [];\n        let hasIgnorePatterns = false;\n\n        eslintrcArray.forEach(configData => {\n            if (configData.type === \"config\") {\n                hasIgnorePatterns = hasIgnorePatterns || configData.ignorePattern;\n                flatArray.push(...translateESLintRC(configData, {\n                    resolveConfigRelativeTo: path.join(this.baseDirectory, \"__placeholder.js\"),\n                    resolvePluginsRelativeTo: path.join(this.resolvePluginsRelativeTo, \"__placeholder.js\"),\n                    pluginEnvironments: eslintrcArray.pluginEnvironments,\n                    pluginProcessors: eslintrcArray.pluginProcessors\n                }));\n            }\n        });\n\n        // combine ignorePatterns to emulate ESLintRC behavior better\n        if (hasIgnorePatterns) {\n            flatArray.unshift({\n                ignores: [filePath => {\n\n                    // Compute the final config for this file.\n                    // This filters config array elements by `files`/`excludedFiles` then merges the elements.\n                    const finalConfig = eslintrcArray.extractConfig(filePath);\n\n                    // Test the `ignorePattern` properties of the final config.\n                    return Boolean(finalConfig.ignores) && finalConfig.ignores(filePath);\n                }]\n            });\n        }\n\n        return flatArray;\n    }\n\n    /**\n     * Translates the `env` section of an ESLintRC-style config.\n     * @param {Object} envConfig The `env` section of an ESLintRC config.\n     * @returns {Object[]} An array of flag-config objects representing the environments.\n     */\n    env(envConfig) {\n        return this.config({\n            env: envConfig\n        });\n    }\n\n    /**\n     * Translates the `extends` section of an ESLintRC-style config.\n     * @param {...string} configsToExtend The names of the configs to load.\n     * @returns {Object[]} An array of flag-config objects representing the config.\n     */\n    extends(...configsToExtend) {\n        return this.config({\n            extends: configsToExtend\n        });\n    }\n\n    /**\n     * Translates the `plugins` section of an ESLintRC-style config.\n     * @param {...string} plugins The names of the plugins to load.\n     * @returns {Object[]} An array of flag-config objects representing the plugins.\n     */\n    plugins(...plugins) {\n        return this.config({\n            plugins\n        });\n    }\n}\n\nexport { FlatCompat };\n","/**\n * @fileoverview Package exports for @eslint/eslintrc\n * @author Nicholas C. Zakas\n */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport {\n    ConfigArrayFactory,\n    createContext as createConfigArrayFactoryContext\n} from \"./config-array-factory.js\";\n\nimport { CascadingConfigArrayFactory } from \"./cascading-config-array-factory.js\";\nimport * as ModuleResolver from \"./shared/relative-module-resolver.js\";\nimport { ConfigArray, getUsedExtractedConfigs } from \"./config-array/index.js\";\nimport { ConfigDependency } from \"./config-array/config-dependency.js\";\nimport { ExtractedConfig } from \"./config-array/extracted-config.js\";\nimport { IgnorePattern } from \"./config-arr