Static2) {
  return isPropertyDeclaration(member) && (!!member.initializer || !requireInitializer) && hasStaticModifier(member) === isStatic2;
}
function isStaticPropertyDeclaration(member) {
  return isPropertyDeclaration(member) && hasStaticModifier(member);
}
function isInitializedProperty(member) {
  return member.kind === 172 /* PropertyDeclaration */ && member.initializer !== void 0;
}
function isNonStaticMethodOrAccessorWithPrivateName(member) {
  return !isStatic(member) && (isMethodOrAccessor(member) || isAutoAccessorPropertyDeclaration(member)) && isPrivateIdentifier(member.name);
}
function getDecoratorsOfParameters(node) {
  let decorators;
  if (node) {
    const parameters = node.parameters;
    const firstParameterIsThis = parameters.length > 0 && parameterIsThisKeyword(parameters[0]);
    const firstParameterOffset = firstParameterIsThis ? 1 : 0;
    const numParameters = firstParameterIsThis ? parameters.length - 1 : parameters.length;
    for (let i = 0; i < numParameters; i++) {
      const parameter = parameters[i + firstParameterOffset];
      if (decorators || hasDecorators(parameter)) {
        if (!decorators) {
          decorators = new Array(numParameters);
        }
        decorators[i] = getDecorators(parameter);
      }
    }
  }
  return decorators;
}
function getAllDecoratorsOfClass(node) {
  const decorators = getDecorators(node);
  const parameters = getDecoratorsOfParameters(getFirstConstructorWithBody(node));
  if (!some(decorators) && !some(parameters)) {
    return void 0;
  }
  return {
    decorators,
    parameters
  };
}
function getAllDecoratorsOfClassElement(member, parent2, useLegacyDecorators) {
  switch (member.kind) {
    case 177 /* GetAccessor */:
    case 178 /* SetAccessor */:
      if (!useLegacyDecorators) {
        return getAllDecoratorsOfMethod(member);
      }
      return getAllDecoratorsOfAccessors(member, parent2);
    case 174 /* MethodDeclaration */:
      return getAllDecoratorsOfMethod(member);
    case 172 /* PropertyDeclaration */:
      return getAllDecoratorsOfProperty(member);
    default:
      return void 0;
  }
}
function getAllDecoratorsOfAccessors(accessor, parent2) {
  if (!accessor.body) {
    return void 0;
  }
  const { firstAccessor, secondAccessor, getAccessor, setAccessor } = getAllAccessorDeclarations(parent2.members, accessor);
  const firstAccessorWithDecorators = hasDecorators(firstAccessor) ? firstAccessor : secondAccessor && hasDecorators(secondAccessor) ? secondAccessor : void 0;
  if (!firstAccessorWithDecorators || accessor !== firstAccessorWithDecorators) {
    return void 0;
  }
  const decorators = getDecorators(firstAccessorWithDecorators);
  const parameters = getDecoratorsOfParameters(setAccessor);
  if (!some(decorators) && !some(parameters)) {
    return void 0;
  }
  return {
    decorators,
    parameters,
    getDecorators: getAccessor && getDecorators(getAccessor),
    setDecorators: setAccessor && getDecorators(setAccessor)
  };
}
function getAllDecoratorsOfMethod(method) {
  if (!method.body) {
    return void 0;
  }
  const decorators = getDecorators(method);
  const parameters = getDecoratorsOfParameters(method);
  if (!some(decorators) && !some(parameters)) {
    return void 0;
  }
  return { decorators, parameters };
}
function getAllDecoratorsOfProperty(property) {
  const decorators = getDecorators(property);
  if (!some(decorators)) {
    return void 0;
  }
  return { decorators };
}
function walkUpLexicalEnvironments(env, cb) {
  while (env) {
    const result = cb(env);
    if (result !== void 0)
      return result;
    env = env.previous;
  }
}
function newPrivateEnvironment(data) {
  return { data };
}
function getPrivateIdentifier(privateEnv, name) {
  var _a, _b;
  return isGeneratedPrivateIdentifier(name) ? (_a = privateEnv == null ? void 0 : privateEnv.generatedIdentifiers) == null ? void 0 : _a.get(getNodeForGeneratedName(name)) : (_b = privateEnv == null ? void 0 : privateEnv.identifiers) == null ? void 0 : _b.get(name.escapedText);
}
function setPrivateIdentifier(privateEnv, name, entry) {
  if (isGeneratedPrivateIdentifier(name)) {
    privateEnv.generatedIdentifiers ?? (privateEnv.generatedIdentifiers = /* @__PURE__ */ new Map());
    privateEnv.generatedIdentifiers.set(getNodeForGeneratedName(name), entry);
  } else {
    privateEnv.identifiers ?? (privateEnv.identifiers = /* @__PURE__ */ new Map());
    privateEnv.identifiers.set(name.escapedText, entry);
  }
}
function accessPrivateIdentifier(env, name) {
  return walkUpLexicalEnvironments(env, (env2) => getPrivateIdentifier(env2.privateEnv, name));
}
function isSimpleParameter(node) {
  return !node.initializer && isIdentifier(node.name);
}
function isSimpleParameterList(nodes) {
  return every(nodes, isSimpleParameter);
}

// src/compiler/transformers/destructuring.ts
var FlattenLevel = /* @__PURE__ */ ((FlattenLevel2) => {
  FlattenLevel2[FlattenLevel2["All"] = 0] = "All";
  FlattenLevel2[FlattenLevel2["ObjectRest"] = 1] = "ObjectRest";
  return FlattenLevel2;
})(FlattenLevel || {});
function flattenDestructuringAssignment(node, visitor, context, level, needsValue, createAssignmentCallback) {
  let location = node;
  let value;
  if (isDestructuringAssignment(node)) {
    value = node.right;
    while (isEmptyArrayLiteral(node.left) || isEmptyObjectLiteral(node.left)) {
      if (isDestructuringAssignment(value)) {
        location = node = value;
        value = node.right;
      } else {
        return Debug.checkDefined(visitNode(value, visitor, isExpression));
      }
    }
  }
  let expressions;
  const flattenContext = {
    context,
    level,
    downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
    hoistTempVariables: true,
    emitExpression,
    emitBindingOrAssignment,
    createArrayBindingOrAssignmentPattern: (elements) => makeArrayAssignmentPattern(context.factory, elements),
    createObjectBindingOrAssignmentPattern: (elements) => makeObjectAssignmentPattern(context.factory, elements),
    createArrayBindingOrAssignmentElement: makeAssignmentElement,
    visitor
  };
  if (value) {
    value = visitNode(value, visitor, isExpression);
    Debug.assert(value);
    if (isIdentifier(value) && bindingOrAssignmentElementAssignsToName(node, value.escapedText) || bindingOrAssignmentElementContainsNonLiteralComputedName(node)) {
      value = ensureIdentifier(
        flattenContext,
        value,
        /*reuseIdentifierExpressions*/
        false,
        location
      );
    } else if (needsValue) {
      value = ensureIdentifier(
        flattenContext,
        value,
        /*reuseIdentifierExpressions*/
        true,
        location
      );
    } else if (nodeIsSynthesized(node)) {
      location = value;
    }
  }
  flattenBindingOrAssignmentElement(
    flattenContext,
    node,
    value,
    location,
    /*skipInitializer*/
    isDestructuringAssignment(node)
  );
  if (value && needsValue) {
    if (!some(expressions)) {
      return value;
    }
    expressions.push(value);
  }
  return context.factory.inlineExpressions(expressions) || context.factory.createOmittedExpression();
  function emitExpression(expression) {
    expressions = append(expressions, expression);
  }
  function emitBindingOrAssignment(target, value2, location2, original) {
    Debug.assertNode(target, createAssignmentCallback ? isIdentifier : isExpression);
    const expression = createAssignmentCallback ? createAssignmentCallback(target, value2, location2) : setTextRange(
      context.factory.createAssignment(Debug.checkDefined(visitNode(target, visitor, isExpression)), value2),
      location2
    );
    expression.original = original;
    emitExpression(expression);
  }
}
function bindingOrAssignmentElementAssignsToName(element, escapedName) {
  const target = getTargetOfBindingOrAssignmentElement(element);
  if (isBindingOrAssignmentPattern(target)) {
    return bindingOrAssignmentPatternAssignsToName(target, escapedName);
  } else if (isIdentifier(target)) {
    return target.escapedText === escapedName;
  }
  return false;
}
function bindingOrAssignmentPatternAssignsToName(pattern, escapedName) {
  const elements = getElementsOfBindingOrAssignmentPattern(pattern);
  for (const element of elements) {
    if (bindingOrAssignmentElementAssignsToName(element, escapedName)) {
      return true;
    }
  }
  return false;
}
function bindingOrAssignmentElementContainsNonLiteralComputedName(element) {
  const propertyName = tryGetPropertyNameOfBindingOrAssignmentElement(element);
  if (propertyName && isComputedPropertyName(propertyName) && !isLiteralExpression(propertyName.expression)) {
    return true;
  }
  const target = getTargetOfBindingOrAssignmentElement(element);
  return !!target && isBindingOrAssignmentPattern(target) && bindingOrAssignmentPatternContainsNonLiteralComputedName(target);
}
function bindingOrAssignmentPatternContainsNonLiteralComputedName(pattern) {
  return !!forEach(getElementsOfBindingOrAssignmentPattern(pattern), bindingOrAssignmentElementContainsNonLiteralComputedName);
}
function flattenDestructuringBinding(node, visitor, context, level, rval, hoistTempVariables = false, skipInitializer) {
  let pendingExpressions;
  const pendingDeclarations = [];
  const declarations = [];
  const flattenContext = {
    context,
    level,
    downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
    hoistTempVariables,
    emitExpression,
    emitBindingOrAssignment,
    createArrayBindingOrAssignmentPattern: (elements) => makeArrayBindingPattern(context.factory, elements),
    createObjectBindingOrAssignmentPattern: (elements) => makeObjectBindingPattern(context.factory, elements),
    createArrayBindingOrAssignmentElement: (name) => makeBindingElement(context.factory, name),
    visitor
  };
  if (isVariableDeclaration(node)) {
    let initializer = getInitializerOfBindingOrAssignmentElement(node);
    if (initializer && (isIdentifier(initializer) && bindingOrAssignmentElementAssignsToName(node, initializer.escapedText) || bindingOrAssignmentElementContainsNonLiteralComputedName(node))) {
      initializer = ensureIdentifier(
        flattenContext,
        Debug.checkDefined(visitNode(initializer, flattenContext.visitor, isExpression)),
        /*reuseIdentifierExpressions*/
        false,
        initializer
      );
      node = context.factory.updateVariableDeclaration(
        node,
        node.name,
        /*exclamationToken*/
        void 0,
        /*type*/
        void 0,
        initializer
      );
    }
  }
  flattenBindingOrAssignmentElement(flattenContext, node, rval, node, skipInitializer);
  if (pendingExpressions) {
    const temp = context.factory.createTempVariable(
      /*recordTempVariable*/
      void 0
    );
    if (hoistTempVariables) {
      const value = context.factory.inlineExpressions(pendingExpressions);
      pendingExpressions = void 0;
      emitBindingOrAssignment(
        temp,
        value,
        /*location*/
        void 0,
        /*original*/
        void 0
      );
    } else {
      context.hoistVariableDeclaration(temp);
      const pendingDeclaration = last(pendingDeclarations);
      pendingDeclaration.pendingExpressions = append(
        pendingDeclaration.pendingExpressions,
        context.factory.createAssignment(temp, pendingDeclaration.value)
      );
      addRange(pendingDeclaration.pendingExpressions, pendingExpressions);
      pendingDeclaration.value = temp;
    }
  }
  for (const { pendingExpressions: pendingExpressions2, name, value, location, original } of pendingDeclarations) {
    const variable = context.factory.createVariableDeclaration(
      name,
      /*exclamationToken*/
      void 0,
      /*type*/
      void 0,
      pendingExpressions2 ? context.factory.inlineExpressions(append(pendingExpressions2, value)) : value
    );
    variable.original = original;
    setTextRange(variable, location);
    declarations.push(variable);
  }
  return declarations;
  function emitExpression(value) {
    pendingExpressions = append(pendingExpressions, value);
  }
  function emitBindingOrAssignment(target, value, location, original) {
    Debug.assertNode(target, isBindingName);
    if (pendingExpressions) {
      value = context.factory.inlineExpressions(append(pendingExpressions, value));
      pendingExpressions = void 0;
    }
    pendingDeclarations.push({ pendingExpressions, name: target, value, location, original });
  }
}
function flattenBindingOrAssignmentElement(flattenContext, element, value, location, skipInitializer) {
  const bindingTarget = getTargetOfBindingOrAssignmentElement(element);
  if (!skipInitializer) {
    const initializer = visitNode(getInitializerOfBindingOrAssignmentElement(element), flattenContext.visitor, isExpression);
    if (initializer) {
      if (value) {
        value = createDefaultValueCheck(flattenContext, value, initializer, location);
        if (!isSimpleInlineableExpression(initializer) && isBindingOrAssignmentPattern(bindingTarget)) {
          value = ensureIdentifier(
            flattenContext,
            value,
            /*reuseIdentifierExpressions*/
            true,
            location
          );
        }
      } else {
        value = initializer;
      }
    } else if (!value) {
      value = flattenContext.context.factory.createVoidZero();
    }
  }
  if (isObjectBindingOrAssignmentPattern(bindingTarget)) {
    flattenObjectBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
  } else if (isArrayBindingOrAssignmentPattern(bindingTarget)) {
    flattenArrayBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
  } else {
    flattenContext.emitBindingOrAssignment(
      bindingTarget,
      value,
      location,
      /*original*/
      element
    );
  }
}
function flattenObjectBindingOrAssignmentPattern(flattenContext, parent2, pattern, value, location) {
  const elements = getElementsOfBindingOrAssignmentPattern(pattern);
  const numElements = elements.length;
  if (numElements !== 1) {
    const reuseIdentifierExpressions = !isDeclarationBindingElement(parent2) || numElements !== 0;
    value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
  }
  let bindingElements;
  let computedTempVariables;
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    if (!getRestIndicatorOfBindingOrAssignmentElement(element)) {
      const propertyName = getPropertyNameOfBindingOrAssignmentElement(element);
      if (flattenContext.level >= 1 /* ObjectRest */ && !(element.transformFlags & (32768 /* ContainsRestOrSpread */ | 65536 /* ContainsObjectRestOrSpread */)) && !(getTargetOfBindingOrAssignmentElement(element).transformFlags & (32768 /* ContainsRestOrSpread */ | 65536 /* ContainsObjectRestOrSpread */)) && !isComputedPropertyName(propertyName)) {
        bindingElements = append(bindingElements, visitNode(element, flattenContext.visitor, isBindingOrAssignmentElement));
      } else {
        if (bindingElements) {
          flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
          bindingElements = void 0;
        }
        const rhsValue = createDestructuringPropertyAccess(flattenContext, value, propertyName);
        if (isComputedPropertyName(propertyName)) {
          computedTempVariables = append(computedTempVariables, rhsValue.argumentExpression);
        }
        flattenBindingOrAssignmentElement(
          flattenContext,
          element,
          rhsValue,
          /*location*/
          element
        );
      }
    } else if (i === numElements - 1) {
      if (bindingElements) {
        flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        bindingElements = void 0;
      }
      const rhsValue = flattenContext.context.getEmitHelperFactory().createRestHelper(value, elements, computedTempVariables, pattern);
      flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
    }
  }
  if (bindingElements) {
    flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
  }
}
function flattenArrayBindingOrAssignmentPattern(flattenContext, parent2, pattern, value, location) {
  const elements = getElementsOfBindingOrAssignmentPattern(pattern);
  const numElements = elements.length;
  if (flattenContext.level < 1 /* ObjectRest */ && flattenContext.downlevelIteration) {
    value = ensureIdentifier(
      flattenContext,
      setTextRange(
        flattenContext.context.getEmitHelperFactory().createReadHelper(
          value,
          numElements > 0 && getRestIndicatorOfBindingOrAssignmentElement(elements[numElements - 1]) ? void 0 : numElements
        ),
        location
      ),
      /*reuseIdentifierExpressions*/
      false,
      location
    );
  } else if (numElements !== 1 && (flattenContext.level < 1 /* ObjectRest */ || numElements === 0) || every(elements, isOmittedExpression)) {
    const reuseIdentifierExpressions = !isDeclarationBindingElement(parent2) || numElements !== 0;
    value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
  }
  let bindingElements;
  let restContainingElements;
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    if (flattenContext.level >= 1 /* ObjectRest */) {
      if (element.transformFlags & 65536 /* ContainsObjectRestOrSpread */ || flattenContext.hasTransformedPriorElement && !isSimpleBindingOrAssignmentElement(element)) {
        flattenContext.hasTransformedPriorElement = true;
        const temp = flattenContext.context.factory.createTempVariable(
          /*recordTempVariable*/
          void 0
        );
        if (flattenContext.hoistTempVariables) {
          flattenContext.context.hoistVariableDeclaration(temp);
        }
        restContainingElements = append(restContainingElements, [temp, element]);
        bindingElements = append(bindingElements, flattenContext.createArrayBindingOrAssignmentElement(temp));
      } else {
        bindingElements = append(bindingElements, element);
      }
    } else if (isOmittedExpression(element)) {
      continue;
    } else if (!getRestIndicatorOfBindingOrAssignmentElement(element)) {
      const rhsValue = flattenContext.context.factory.createElementAccessExpression(value, i);
      flattenBindingOrAssignmentElement(
        flattenContext,
        element,
        rhsValue,
        /*location*/
        element
      );
    } else if (i === numElements - 1) {
      const rhsValue = flattenContext.context.factory.createArraySliceCall(value, i);
      flattenBindingOrAssignmentElement(
        flattenContext,
        element,
        rhsValue,
        /*location*/
        element
      );
    }
  }
  if (bindingElements) {
    flattenContext.emitBindingOrAssignment(flattenContext.createArrayBindingOrAssignmentPattern(bindingElements), value, location, pattern);
  }
  if (restContainingElements) {
    for (const [id, element] of restContainingElements) {
      flattenBindingOrAssignmentElement(flattenContext, element, id, element);
    }
  }
}
function isSimpleBindingOrAssignmentElement(element) {
  const target = getTargetOfBindingOrAssignmentElement(element);
  if (!target || isOmittedExpression(target))
    return true;
  const propertyName = tryGetPropertyNameOfBindingOrAssignmentElement(element);
  if (propertyName && !isPropertyNameLiteral(propertyName))
    return false;
  const initializer = getInitializerOfBindingOrAssignmentElement(element);
  if (initializer && !isSimpleInlineableExpression(initializer))
    return false;
  if (isBindingOrAssignmentPattern(target))
    return every(getElementsOfBindingOrAssignmentPattern(target), isSimpleBindingOrAssignmentElement);
  return isIdentifier(target);
}
function createDefaultValueCheck(flattenContext, value, defaultValue, location) {
  value = ensureIdentifier(
    flattenContext,
    value,
    /*reuseIdentifierExpressions*/
    true,
    location
  );
  return flattenContext.context.factory.createConditionalExpression(
    flattenContext.context.factory.createTypeCheck(value, "undefined"),
    /*questionToken*/
    void 0,
    defaultValue,
    /*colonToken*/
    void 0,
    value
  );
}
function createDestructuringPropertyAccess(flattenContext, value, propertyName) {
  const { factory: factory2 } = flattenContext.context;
  if (isComputedPropertyName(propertyName)) {
    const argumentExpression = ensureIdentifier(
      flattenContext,
      Debug.checkDefined(visitNode(propertyName.expression, flattenContext.visitor, isExpression)),
      /*reuseIdentifierExpressions*/
      false,
      /*location*/
      propertyName
    );
    return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
  } else if (isStringOrNumericLiteralLike(propertyName)) {
    const argumentExpression = factory2.cloneNode(propertyName);
    return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
  } else {
    const name = flattenContext.context.factory.createIdentifier(idText(propertyName));
    return flattenContext.context.factory.createPropertyAccessExpression(value, name);
  }
}
function ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location) {
  if (isIdentifier(value) && reuseIdentifierExpressions) {
    return value;
  } else {
    const temp = flattenContext.context.factory.createTempVariable(
      /*recordTempVariable*/
      void 0
    );
    if (flattenContext.hoistTempVariables) {
      flattenContext.context.hoistVariableDeclaration(temp);
      flattenContext.emitExpression(setTextRange(flattenContext.context.factory.createAssignment(temp, value), location));
    } else {
      flattenContext.emitBindingOrAssignment(
        temp,
        value,
        location,
        /*original*/
        void 0
      );
    }
    return temp;
  }
}
function makeArrayBindingPattern(factory2, elements) {
  Debug.assertEachNode(elements, isArrayBindingElement);
  return factory2.createArrayBindingPattern(elements);
}
function makeArrayAssignmentPattern(factory2, elements) {
  Debug.assertEachNode(elements, isArrayBindingOrAssignmentElement);
  return factory2.createArrayLiteralExpression(map(elements, factory2.converters.convertToArrayAssignmentElement));
}
function makeObjectBindingPattern(factory2, elements) {
  Debug.assertEachNode(elements, isBindingElement);
  return factory2.createObjectBindingPattern(elements);
}
function makeObjectAssignmentPattern(factory2, elements) {
  Debug.assertEachNode(elements, isObjectBindingOrAssignmentElement);
  return factory2.createObjectLiteralExpression(map(elements, factory2.converters.convertToObjectAssignmentElement));
}
function makeBindingElement(factory2, name) {
  return factory2.createBindingElement(
    /*dotDotDotToken*/
    void 0,
    /*propertyName*/
    void 0,
    name
  );
}
function makeAssignmentElement(name) {
  return name;
}

// src/compiler/transformers/classThis.ts
function createClassThisAssignmentBlock(factory2, classThis, thisExpression = factory2.createThis()) {
  const expression = factory2.createAssignment(classThis, thisExpression);
  const statement = factory2.createExpressionStatement(expression);
  const body = factory2.createBlock(
    [statement],
    /*multiLine*/
    false
  );
  const block = factory2.createClassStaticBlockDeclaration(body);
  getOrCreateEmitNode(block).classThis = classThis;
  return block;
}
function isClassThisAssignmentBlock(node) {
  var _a;
  if (!isClassStaticBlockDeclaration(node) || node.body.statements.length !== 1) {
    return false;
  }
  const statement = node.body.statements[0];
  return isExpressionStatement(statement) && isAssignmentExpression(
    statement.expression,
    /*excludeCompoundAssignment*/
    true
  ) && isIdentifier(statement.expression.left) && ((_a = node.emitNode) == null ? void 0 : _a.classThis) === statement.expression.left && statement.expression.right.kind === 110 /* ThisKeyword */;
}
function classHasClassThisAssignment(node) {
  var _a;
  return !!((_a = node.emitNode) == null ? void 0 : _a.classThis) && some(node.members, isClassThisAssignmentBlock);
}
function injectClassThisAssignmentIfMissing(factory2, node, classThis, thisExpression) {
  if (classHasClassThisAssignment(node)) {
    return node;
  }
  const staticBlock = createClassThisAssignmentBlock(factory2, classThis, thisExpression);
  if (node.name) {
    setSourceMapRange(staticBlock.body.statements[0], node.name);
  }
  const members = factory2.createNodeArray([staticBlock, ...node.members]);
  setTextRange(members, node.members);
  const updatedNode = isClassDeclaration(node) ? factory2.updateClassDeclaration(
    node,
    node.modifiers,
    node.name,
    node.typeParameters,
    node.heritageClauses,
    members
  ) : factory2.updateClassExpression(
    node,
    node.modifiers,
    node.name,
    node.typeParameters,
    node.heritageClauses,
    members
  );
  getOrCreateEmitNode(updatedNode).classThis = classThis;
  return updatedNode;
}

// src/compiler/transformers/namedEvaluation.ts
function getAssignedNameOfIdentifier(factory2, name, expression) {
  const original = getOriginalNode(skipOuterExpressions(expression));
  if ((isClassDeclaration(original) || isFunctionDeclaration(original)) && !original.name && hasSyntacticModifier(original, 2048 /* Default */)) {
    return factory2.createStringLiteral("default");
  }
  return factory2.createStringLiteralFromNode(name);
}
function getAssignedNameOfPropertyName(context, name, assignedNameText) {
  const { factory: factory2 } = context;
  if (assignedNameText !== void 0) {
    const assignedName2 = factory2.createStringLiteral(assignedNameText);
    return { assignedName: assignedName2, name };
  }
  if (isPropertyNameLiteral(name) || isPrivateIdentifier(name)) {
    const assignedName2 = factory2.createStringLiteralFromNode(name);
    return { assignedName: assignedName2, name };
  }
  if (isPropertyNameLiteral(name.expression) && !isIdentifier(name.expression)) {
    const assignedName2 = factory2.createStringLiteralFromNode(name.expression);
    return { assignedName: assignedName2, name };
  }
  const assignedName = factory2.getGeneratedNameForNode(name);
  context.hoistVariableDeclaration(assignedName);
  const key = context.getEmitHelperFactory().createPropKeyHelper(name.expression);
  const assignment = factory2.createAssignment(assignedName, key);
  const updatedName = factory2.updateComputedPropertyName(name, assignment);
  return { assignedName, name: updatedName };
}
function createClassNamedEvaluationHelperBlock(context, assignedName, thisExpression = context.factory.createThis()) {
  const { factory: factory2 } = context;
  const expression = context.getEmitHelperFactory().createSetFunctionNameHelper(thisExpression, assignedName);
  const statement = factory2.createExpressionStatement(expression);
  const body = factory2.createBlock(
    [statement],
    /*multiLine*/
    false
  );
  const block = factory2.createClassStaticBlockDeclaration(body);
  getOrCreateEmitNode(block).assignedName = assignedName;
  return block;
}
function isClassNamedEvaluationHelperBlock(node) {
  var _a;
  if (!isClassStaticBlockDeclaration(node) || node.body.statements.length !== 1) {
    return false;
  }
  const statement = node.body.statements[0];
  return isExpressionStatement(statement) && isCallToHelper(statement.expression, "___setFunctionName") && statement.expression.arguments.length >= 2 && statement.expression.arguments[1] === ((_a = node.emitNode) == null ? void 0 : _a.assignedName);
}
function classHasExplicitlyAssignedName(node) {
  var _a;
  return !!((_a = node.emitNode) == null ? void 0 : _a.assignedName) && some(node.members, isClassNamedEvaluationHelperBlock);
}
function classHasDeclaredOrExplicitlyAssignedName(node) {
  return !!node.name || classHasExplicitlyAssignedName(node);
}
function injectClassNamedEvaluationHelperBlockIfMissing(context, node, assignedName, thisExpression) {
  if (classHasExplicitlyAssignedName(node)) {
    return node;
  }
  const { factory: factory2 } = context;
  const namedEvaluationBlock = createClassNamedEvaluationHelperBlock(context, assignedName, thisExpression);
  if (node.name) {
    setSourceMapRange(namedEvaluationBlock.body.statements[0], node.name);
  }
  const insertionIndex = findIndex(node.members, isClassThisAssignmentBlock) + 1;
  const leading = node.members.slice(0, insertionIndex);
  const trailing = node.members.slice(insertionIndex);
  const members = factory2.createNodeArray([...leading, namedEvaluationBlock, ...trailing]);
  setTextRange(members, node.members);
  node = isClassDeclaration(node) ? factory2.updateClassDeclaration(
    node,
    node.modifiers,
    node.name,
    node.typeParameters,
    node.heritageClauses,
    members
  ) : factory2.updateClassExpression(
    node,
    node.modifiers,
    node.name,
    node.typeParameters,
    node.heritageClauses,
    members
  );
  getOrCreateEmitNode(node).assignedName = assignedName;
  return node;
}
function finishTransformNamedEvaluation(context, expression, assignedName, ignoreEmptyStringLiteral) {
  if (ignoreEmptyStringLiteral && isStringLiteral(assignedName) && isEmptyStringLiteral(assignedName)) {
    return expression;
  }
  const { factory: factory2 } = context;
  const innerExpression = skipOuterExpressions(expression);
  const updatedExpression = isClassExpression(innerExpression) ? cast(injectClassNamedEvaluationHelperBlockIfMissing(context, innerExpression, assignedName), isClassExpression) : context.getEmitHelperFactory().createSetFunctionNameHelper(innerExpression, assignedName);
  return factory2.restoreOuterExpressions(expression, updatedExpression);
}
function transformNamedEvaluationOfPropertyAssignment(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const { assignedName, name } = getAssignedNameOfPropertyName(context, node.name, assignedNameText);
  const initializer = finishTransformNamedEvaluation(context, node.initializer, assignedName, ignoreEmptyStringLiteral);
  return factory2.updatePropertyAssignment(
    node,
    name,
    initializer
  );
}
function transformNamedEvaluationOfShorthandAssignmentProperty(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const assignedName = assignedNameText !== void 0 ? factory2.createStringLiteral(assignedNameText) : getAssignedNameOfIdentifier(factory2, node.name, node.objectAssignmentInitializer);
  const objectAssignmentInitializer = finishTransformNamedEvaluation(context, node.objectAssignmentInitializer, assignedName, ignoreEmptyStringLiteral);
  return factory2.updateShorthandPropertyAssignment(
    node,
    node.name,
    objectAssignmentInitializer
  );
}
function transformNamedEvaluationOfVariableDeclaration(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const assignedName = assignedNameText !== void 0 ? factory2.createStringLiteral(assignedNameText) : getAssignedNameOfIdentifier(factory2, node.name, node.initializer);
  const initializer = finishTransformNamedEvaluation(context, node.initializer, assignedName, ignoreEmptyStringLiteral);
  return factory2.updateVariableDeclaration(
    node,
    node.name,
    node.exclamationToken,
    node.type,
    initializer
  );
}
function transformNamedEvaluationOfParameterDeclaration(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const assignedName = assignedNameText !== void 0 ? factory2.createStringLiteral(assignedNameText) : getAssignedNameOfIdentifier(factory2, node.name, node.initializer);
  const initializer = finishTransformNamedEvaluation(context, node.initializer, assignedName, ignoreEmptyStringLiteral);
  return factory2.updateParameterDeclaration(
    node,
    node.modifiers,
    node.dotDotDotToken,
    node.name,
    node.questionToken,
    node.type,
    initializer
  );
}
function transformNamedEvaluationOfBindingElement(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const assignedName = assignedNameText !== void 0 ? factory2.createStringLiteral(assignedNameText) : getAssignedNameOfIdentifier(factory2, node.name, node.initializer);
  const initializer = finishTransformNamedEvaluation(context, node.initializer, assignedName, ignoreEmptyStringLiteral);
  return factory2.updateBindingElement(
    node,
    node.dotDotDotToken,
    node.propertyName,
    node.name,
    initializer
  );
}
function transformNamedEvaluationOfPropertyDeclaration(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const { assignedName, name } = getAssignedNameOfPropertyName(context, node.name, assignedNameText);
  const initializer = finishTransformNamedEvaluation(context, node.initializer, assignedName, ignoreEmptyStringLiteral);
  return factory2.updatePropertyDeclaration(
    node,
    node.modifiers,
    name,
    node.questionToken ?? node.exclamationToken,
    node.type,
    initializer
  );
}
function transformNamedEvaluationOfAssignmentExpression(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const assignedName = assignedNameText !== void 0 ? factory2.createStringLiteral(assignedNameText) : getAssignedNameOfIdentifier(factory2, node.left, node.right);
  const right = finishTransformNamedEvaluation(context, node.right, assignedName, ignoreEmptyStringLiteral);
  return factory2.updateBinaryExpression(
    node,
    node.left,
    node.operatorToken,
    right
  );
}
function transformNamedEvaluationOfExportAssignment(context, node, ignoreEmptyStringLiteral, assignedNameText) {
  const { factory: factory2 } = context;
  const assignedName = assignedNameText !== void 0 ? factory2.createStringLiteral(assignedNameText) : factory2.createStringLiteral(node.isExportEquals ? "" : "default");
  const expression = finishTransformNamedEvaluation(context, node.expression, assignedName, ignoreEmptyStringLiteral);
  return factory2.updateExportAssignment(
    node,
    node.modifiers,
    expression
  );
}
function transformNamedEvaluation(context, node, ignoreEmptyStringLiteral, assignedName) {
  switch (node.kind) {
    case 303 /* PropertyAssignment */:
      return transformNamedEvaluationOfPropertyAssignment(context, node, ignoreEmptyStringLiteral, assignedName);
    case 304 /* ShorthandPropertyAssignment */:
      return transformNamedEvaluationOfShorthandAssignmentProperty(context, node, ignoreEmptyStringLiteral, assignedName);
    case 260 /* VariableDeclaration */:
      return transformNamedEvaluationOfVariableDeclaration(context, node, ignoreEmptyStringLiteral, assignedName);
    case 169 /* Parameter */:
      return transformNamedEvaluationOfParameterDeclaration(context, node, ignoreEmptyStringLiteral, assignedName);
    case 208 /* BindingElement */:
      return transformNamedEvaluationOfBindingElement(context, node, ignoreEmptyStringLiteral, assignedName);
    case 172 /* PropertyDeclaration */:
      return transformNamedEvaluationOfPropertyDeclaration(context, node, ignoreEmptyStringLiteral, assignedName);
    case 226 /* BinaryExpression */:
      return transformNamedEvaluationOfAssignmentExpression(context, node, ignoreEmptyStringLiteral, assignedName);
    case 277 /* ExportAssignment */:
      return transformNamedEvaluationOfExportAssignment(context, node, ignoreEmptyStringLiteral, assignedName);
  }
}

// src/compiler/transformers/taggedTemplate.ts
var ProcessLevel = /* @__PURE__ */ ((ProcessLevel2) => {
  ProcessLevel2[ProcessLevel2["LiftRestriction"] = 0] = "LiftRestriction";
  ProcessLevel2[ProcessLevel2["All"] = 1] = "All";
  return ProcessLevel2;
})(ProcessLevel || {});
function processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, level) {
  const tag = visitNode(node.tag, visitor, isExpression);
  Debug.assert(tag);
  const templateArguments = [void 0];
  const cookedStrings = [];
  const rawStrings = [];
  const template = node.template;
  if (level === 0 /* LiftRestriction */ && !hasInvalidEscape(template)) {
    return visitEachChild(node, visitor, context);
  }
  const { factory: factory2 } = context;
  if (isNoSubstitutionTemplateLiteral(template)) {
    cookedStrings.push(createTemplateCooked(factory2, template));
    rawStrings.push(getRawLiteral(factory2, template, currentSourceFile));
  } else {
    cookedStrings.push(createTemplateCooked(factory2, template.head));
    rawStrings.push(getRawLiteral(factory2, template.head, currentSourceFile));
    for (const templateSpan of template.templateSpans) {
      cookedStrings.push(createTemplateCooked(factory2, templateSpan.literal));
      rawStrings.push(getRawLiteral(factory2, templateSpan.literal, currentSourceFile));
      templateArguments.push(Deb