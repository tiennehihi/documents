 ancestry, LEFT_SIDE, options) ||\n                    selector.right.subject &&\n                    left(node, ancestry, options) &&\n                    adjacent(node, right, ancestry, RIGHT_SIDE, options);\n        }\n\n        case 'nth-child': {\n            const nth = selector.index.value;\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    nthChild(node, ancestry, nth, options);\n        }\n\n        case 'nth-last-child': {\n            const nth = -selector.index.value;\n            const right = getMatcher(selector.right);\n            return (node, ancestry, options) =>\n                right(node, ancestry, options) &&\n                    nthChild(node, ancestry, nth, options);\n        }\n\n        case 'class': {\n\n            return (node, ancestry, options) => {\n                \n                if (options && options.matchClass) {\n                    return options.matchClass(selector.name, node, ancestry);\n                }\n                \n                if (options && options.nodeTypeKey) return false;\n                \n                const name = selector.name.toLowerCase();\n\n                switch(name){\n                    case 'statement':\n                        if(node.type.slice(-9) === 'Statement') return true;\n                        // fallthrough: interface Declaration <: Statement { }\n                    case 'declaration':\n                        return node.type.slice(-11) === 'Declaration';\n                    case 'pattern':\n                        if(node.type.slice(-7) === 'Pattern') return true;\n                        // fallthrough: interface Expression <: Node, Pattern { }\n                    case 'expression':\n                        return node.type.slice(-10) === 'Expression' ||\n                            node.type.slice(-7) === 'Literal' ||\n                            (\n                                node.type === 'Identifier' &&\n                                (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')\n                            ) ||\n                            node.type === 'MetaProperty';\n                    case 'function':\n                        return node.type === 'FunctionDeclaration' ||\n                            node.type === 'FunctionExpression' ||\n                            node.type === 'ArrowFunctionExpression';\n                }\n                throw new Error(`Unknown class name: ${selector.name}`);\n            };\n        }\n    }\n\n    throw new Error(`Unknown selector type: ${selector.type}`);\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n\n/**\n * @callback ClassMatcher\n * @param {string} className The name of the class to match.\n * @param {external:AST} node The node to match against.\n * @param {Array<external:AST>} ancestry The ancestry of the node.\n * @returns {boolean} True if the node matches the class, false if not.\n */\n\n/**\n * @typedef {object} ESQueryOptions\n * @property {string} [nodeTypeKey=\"type\"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n    if (!selector) { return true; }\n    if (!node) { return false; }\n    if (!ancestry) { ancestry = []; }\n\n    return getMatcher(selector)(node, ancestry, options);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n\n    const nodeType = node[nodeTypeKey];\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n        return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n        return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n        return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n        return key !== nodeTypeKey;\n    });\n}\n\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @param {ESQueryOptions|undefined} options The options to use.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node, options) {\n    const nodeTypeKey = (options && options.nodeTypeKey) || 'type';\n    return node !== null && typeof node === 'object' && typeof node[nodeTypeKey] === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, matcher, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)) {\n            const startIndex = listProp.indexOf(node);\n            if (startIndex < 0) { continue; }\n            let lowerBound, upperBound;\n            if (side === LEFT_SIDE) {\n                lowerBound = 0;\n                upperBound = startIndex;\n            } else {\n                lowerBound = startIndex + 1;\n                upperBound = listProp.length;\n            }\n            for (let k = lowerBound; k < upperBound; ++k) {\n                if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, matcher, ancestry, side, options) {\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)) {\n            const idx = listProp.indexOf(node);\n            if (idx < 0) { continue; }\n            if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {\n                return true;\n            }\n            if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) &&  matcher(listProp[idx + 1], ancestry, options)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if the given node is the `nth` child.\n * If `nth` is negative then the position is counted\n * from the end of the list of children.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {Integer} nth\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, nth, options) {\n    if (nth === 0) { return false; }\n    const [parent] = ancestry;\n    if (!parent) { return false; }\n    const keys = getVisitorKeys(parent, options);\n    for (let i = 0; i < keys.length; ++i) {\n        const listProp = parent[keys[i]];\n        if (Array.isArray(listProp)){\n            const idx = nth < 0 ? listProp.length + nth : nth - 1;\n            if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n    if (selector == null || typeof selector != 'object') { return []; }\n    if (ancestor == null) { ancestor = selector; }\n    const results = selector.subject ? [ancestor] : [];\n    const keys = Object.keys(selector);\n    for (let i = 0; i < keys.length; ++i) {\n        const p = keys[i];\n        const sel = selector[p];\n        results.push(...subjects(sel, p === 'left' ? sel : ancestor));\n    }\n    return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n    if (!selector) { return; }\n    const ancestry = [];\n    const matcher = getMatcher(selector);\n    const altSubjects = subjects(selector).map(getMatcher);\n    estraverse.traverse(ast, {\n        enter (node, parent) {\n            if (parent != null) { ancestry.unshift(parent); }\n            if (matcher(node, ancestry, options)) {\n                if (altSubjects.length) {\n                    for (let i = 0, l = altSubjects.length; i < l; ++i) {\n                        if (altSubjects[i](node, ancestry, options)) {\n                            visitor(node, parent, ancestry);\n                        }\n                        for (let k = 0, m = ancestry.length; k < m; ++k) {\n                            const succeedingAncestry = ancestry.slice(k + 1);\n                            if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {\n                                visitor(ancestry[k], parent, succeedingAncestry);\n                            }\n                        }\n                    }\n                } else {\n                    visitor(node, parent, ancestry);\n                }\n            }\n        },\n        leave () { ancestry.shift(); },\n        keys: options && options.visitorKeys,\n        fallback: options && options.fallback || 'iteration'\n    });\n}\n\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n    const results = [];\n    traverse(ast, selector, function (node) {\n        results.push(node);\n    }, options);\n    return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n    return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n}\n\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"],"names":["module","exports","peg$SyntaxError","message","expected","found","location","this","name","Error","captureStackTrace","child","parent","ctor","constructor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","i","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","j","descriptions","type","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c8","peg$c11","peg$c14","peg$c18","peg$c22","peg$c25","peg$c28","peg$c31","peg$c33","peg$c35","peg$c36","peg$c38","peg$c39","a","peg$c40","peg$c41","peg$c43","peg$c45","op","value","operator","peg$c48","peg$c49","peg$c50","peg$c52","peg$c53","peg$c54","b","peg$c55","d","match","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c65","peg$c66","peg$c67","peg$c69","peg$c71","peg$c72","peg$c74","peg$c75","peg$c76","peg$c80","peg$c83","peg$c86","peg$c89","peg$c92","peg$c95","peg$c98","peg$c101","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$resultsCache","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","push","s0","s1","s2","ss","key","cached","nextPos","result","peg$parse_","peg$parseselectors","selectors","peg$c1","peg$parseidentifierName","test","charAt","peg$parsebinaryOp","s3","s4","s5","s6","s7","peg$parseselector","concat","map","peg$parsesequence","reduce","memo","rhs","left","right","subject","as","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattrName","peg$parseattrEqOps","substr","peg$parsetype","flgs","peg$parseflags","RegExp","peg$parseregex","peg$parseattrOps","peg$parsestring","leadingDecimals","apply","parseFloat","peg$parsenumber","peg$parsepath","peg$parseattrValue","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","nth","peg$parsefirstChild","nthLast","peg$parselastChild","parseInt","peg$parsenthChild","peg$parsenthLastChild","peg$parseclass","n","index","factory","getPath","obj","keys","MATCHER_CACHE","WeakMap","getMatcher","selector","matcher","get","generateMatcher","set","toLowerCase","node","ancestry","nodeTypeKey","path","split","inPath","ancestor","fromPathIndex","current","field","isArray","k","matchers","estraverse","traverse","enter","unshift","leave","shift","visitorKeys","fallback","l","sibling","adjacent","nthChild","matchClass","getVisitorKeys","nodeType","VisitorKeys","Object","filter","isNode","_typeof","side","listProp","startIndex","indexOf","lowerBound","upperBound","idx","ast","visitor","altSubjects","subjects","results","sel","m","succeedingAncestry","parser","query","matches"],"mappings":"mnEAQ2CA,EAAOC,UAC9CD,UAEK,WASP,SAASE,EAAgBC,EAASC,EAAUC,EAAOC,GACjDC,KAAKJ,QAAWA,EAChBI,KAAKH,SAAWA,EAChBG,KAAKF,MAAWA,EAChBE,KAAKD,SAAWA,EAChBC,KAAKC,KAAW,cAEuB,mBAA5BC,MAAMC,mBACfD,MAAMC,kBAAkBH,KAAML,GAq9ElC,OAn+EA,SAAsBS,EAAOC,GAC3B,SAASC,IAASN,KAAKO,YAAcH,EACrCE,EAAKE,UAAYH,EAAOG,UACxBJ,EAAMI,UAAY,IAAIF,EAexBG,CAAad,EAAiBO,OAE9BP,EAAgBe,aAAe,SAASb,EAAUC,GAChD,IAAIa,EAA2B,CACzBC,QAAS,SAASC,GAChB,MAAO,IAAOC,EAAcD,EAAYE,MAAQ,KAGlDC,MAAS,SAASH,GAChB,IACII,EADAC,EAAe,GAGnB,IAAKD,EAAI,EAAGA,EAAIJ,EAAYM,MAAMC,OAAQH,IACxCC,GAAgBL,EAAYM,MAAMF,aAAcI,MAC5CC,EAAYT,EAAYM,MAAMF,GAAG,IAAM,IAAMK,EAAYT,EAAYM,MAAMF,GAAG,IAC9EK,EAAYT,EAAYM,MAAMF,IAGpC,MAAO,KAAOJ,EAAYU,SAAW,IAAM,IAAML,EAAe,KAGlEM,IAAK,SAASX,GACZ,MAAO,iBAGTY,IAAK,SAASZ,GACZ,MAAO,gBAGTa,MAAO,SAASb,GACd,OAAOA,EAAYc,cAI3B,SAASC,EAAIC,GACX,OAAOA,EAAGC,WAAW,GAAGC,SAAS,IAAIC,cAGvC,SAASlB,EAAcmB,GACrB,OAAOA,EACJvar assert = require('assert');
var jp = require('../');

var data = require('./data/store.json');

suite('orig-google-code-issues', function() {
    
  test('comma in eval', function() {
    var pathExpression = '$..book[?(@.price && ",")]'
    var results = jp.query(data, pathExpression);
    assert.deepEqual(results, data.store.book);
  });

  test('member names with dots', function() {
    var data = { 'www.google.com': 42, 'www.wikipedia.org': 190 };
    var results = jp.query(data, "$['www.google.com']");
    assert.deepEqual(results, [ 42 ]);
  });

  test('nested objects with filter', function() {
    var data = { dataResult: { object: { objectInfo: { className: "folder", typeName: "Standard Folder", id: "uniqueId" } } } };
    var results = jp.query(data, "$..object[?(@.className=='folder')]");
    assert.deepEqual(results, [ data.dataResult.object.objectInfo ]);
  });

  test('script expressions with @ char', function() {
    var data = { "DIV": [{ "@class": "value", "val": 5 }] };
    var results = jp.query(data, "$..DIV[?(@['@class']=='value')]");
    assert.deepEqual(results, data.DIV);
  });

  test('negative slices', function() {
    var results = jp.query(data, "$..book[-1:].title");
    assert.deepEqual(results, ['The Lord of the Rings']);
  });

});

                                                                                                                                                                                                                                                       >ƒç‡äTî¯?óÂ¾Gáší£Ğ´úSÓ
Cw¸ªô‹TÉ­o³Hê70z¾¥ß¼Ã
·¦¡VwWíÇûædw:Ú—VÙÅ ş<	­)¸æ†ÜÉóô©Ò|ˆï¸Éo›Ş'zóƒ>‡<izµ^¾Í8·FªŸ«ÄZºİK‡Hº£ŞqÒ‡ôc8 ¸™‹Éßû¥åVèƒ±³ƒ~ˆ¢*hØ²­a.äh¹í2İÒÏ1tnı¦ÉåËòœıV)•ÉğI='û8Ûÿ‚5Cryí	òÔˆ˜ƒ|ìéúáëD{ı08Ñ ©KôÁğWou-®E ²¾§†ì0&|ío½vşmiÑ# ûŞoäÿ’àòû1ÿ5zhAŸf?€ó$5‡Ö/a•ÀLı–$h•>+([ğNáÖ9|Äâ"9=•/0«µÆtZìÓkÜÖÖ}6íçüşj××÷j™å^‰s: »‘QHÏØõš£D:øŒ×@ÿ=x=£¥"`hTúFôÓFíDí9D¦ùm¿˜ìarZ+Ó·¿t-óô%ıDÅ@%­w79ˆd%‡ùŠÍ¾³ĞGñM`-{ÔÆ—ås6@Ï1¶2ŞØ4¸¹À€b¬ï½s2ğ¨6^H¦”·T¨0ƒ°^³å·õ{Š¸£¤Î‘3TøÔ÷>D©QÔvîkRÒŠbtKÃæÓ€`OO!•˜ÕV}UÕfë wæQMÛŠ8gÏª“r€ËQe–Y¯˜£
Â.D7¸¨(7‹U,›H¢óòöªĞ£%L™¡™±
À#LA=Ÿë,´[®jû¶ 6Kì<“Ï”ØáD¶_¥á.ß\¶Œ~?­tµ}ÍÌ"UJ<—2eáÊÿš ‡ÆrAY.¬êXà€_îÈN¶òKsş¼¯xH­ÆæÕV¹ ò¯X}±tÏH3Ñ?[å 2j­-ˆ•«g‚8ëK9„¤²ĞbÊ(ÚSÑ‡I7¬ãtR*ˆûUbÔ‡èñLš¥Q®¬š‰V¬š¿¸²pş{…9a/»©¡÷Ï5ĞÜ¤v+ësÅrç³¸¸tG¤!bkÀXæ±à:8D5“¡%¯È¢ó‡å\’!¨Ÿµ4k©|<ˆÚ-A•'úÀšO¤HgÁOCX*dí#ÀÕl'¶ƒwéçı'·næ2=bˆ$0BKŒ“•MzÖì{±Ñ‘oòÿãóš‹Y¬—ko¾äg@U…¹ï"İ®â8*²°³­ÛŠ>şƒÙ<ÔjIrB©4’D5-I?¯6hoìEŒfxßE+ÉÔf;F£h±Ìkêï™#HLiıØùŠ³ÊRù‘øsü

'1Ìvé3¡–-`œ(üµ¡¡²¤íÚ ì2³œúĞªßiK¿pSt °„“\ß¿ÿıqf Îwyµx{õÎqò(_A†jåÿŒW<øÕ)»a^[Öò'1àcŞÕåß˜EÃ‡åhÏŞl¸q†üÒÿë½ü&àí/Ğ²úÏx}-7qó_Qô> o>¾·é¼›k#]çjH,Ÿã1Îúƒzîl?¤\Q8¸Lü şè2Kô”—õŞk~fÚk)…&u5¯5L/–IÜv
w¥–¿îÿ÷A¹å«L¬¯)DºÕHEå^cËèşî´¾¿D„8Ç8;×ÄU=7¶qÔıjûl$3r)EºÄüÉÄıED¢L»uR«Äêâ¯4&/âh6„*cù­w'ÙwèC'œZgÏFšlÅjÔÿıl“+>{8,iÍ¤Z·ó<v­G'såVÌö²½JÎÄ !”½¢™bÁĞ"='I­Ü¥DA$R2ÕX$¶y«"b=uó÷;ÇEy9·Î¦k–€åóVæo/õ‰X1„…¬†tmÃ8hì®kŸÁè6ã§Š³©Ğê©M¹N1³‘MÎ%WÓ¤ÁpÍ‡e2&\k¢ã¦¦È¿gúeUÛdûH®PæÓT'Êœ-ÄäÇT!f	òëËÙç§Dh ‰ŞK =É3A3ã&İZ¿¾ÏÖû,«Ğß2²v³8³w`dhJ\U–äúãß“5úºg“,Fê(=%¥d³ğ¾1ˆæw×ç#eÆ„IÇ©Eè$|-”…©Ò¶ÀÄ>p‚ˆC~ïQÛŞe"8ª.PÛÁ0J‹4Çã™)lf ÄL !„
ñ;—}K•QS.Ê‘Vï…ïÍ¸ê*7vB™I\^pø†s‚FWDàEÙÚRñ1H¢ÈbjxÇ_»Ñëêï6´×†«}vdc:ÃğC&11Õ½¥í£VàÍÛY5u÷”{t>ÀZ»i/°»{íîa£€Jm£€º+9À;İÎ˜¨ •€ÓåĞ?Ş¸!*”­¢Â±!0™ë¯ŞU¬¹H«•)p™
ŒœŠ>IÑ7ŸÂù_SGŒ\ƒÌ:7¾ÇÏ–è-}‚3yä†õˆÒ)w™4lLaİ£“—kõmv!3¬«¹.šD¡s{t·7%Ï¶“Tä)bÊN†U;·täÆğ|ü´Õ„ç9.@D/ ~n©É£™ƒ‚öW_esº»ï‚¬$;¾ \NF¤Z4ş]¥
ÍNDıˆR®™_$à©µæmì«I„ì§´'9ƒ6é¤H¥¦ºÌf÷œ7]1gX\Æ×L­vê¥
ü")i‰j3…#=5t,A	SÓQÄ(@i¨¦ôªÄ»)òÿ©ô=°ìG-Áãáäb)L1„,Q0Dx­ñÏdc|I)ZÉ\a”ë±Æøß­b¿¯É“›û¤Ú+gcJ)ƒ= c%$ò!UD®+¶›uGû'_üVXz9d¶„ó¤[åîjx(HS‡ äñäe^Ï
‘m˜…+µ”,`Ëë„êİ^ß )óğòòSøC¦Lq9ÃË}w`   AöK$èT4ˆu6Ù`)-íÇBŠ÷ zÀôòÀÆŸkqÏÙ¿ËyÆ	%÷- o‰•‹ı%azÓÈváànf~À1«ù;†²U¹S6^±sJ3æt¡	¯á¼ Å›hx!´éì÷µóA/„ZY„#a:6"·µÎvvl±œ¸sîÉi¡RŞCã{J‡y î0ƒ¼3U¢¼¯ù,-<¥8¹‘ÈãÀ¡ƒ‘(\Õ>‘üò#)*ß,ò$rëgšwhş~tÔ—lÄª=a®pg¦½1xü‹Ø 	¬òúzİjø¿Ëéi£à—1W<ƒÚcmˆíâ·3Ò`tZu‚Â<Wô ƒ_ğ õO€9ñ;E)Bw²ÒŞ÷ÈµÊ]öd"‘0ŸÇŠ9šÚ,ÏÀ+óÉë #İÕcºI‚jîİ¯İÕT!<*Ñ‘G@Äµ‡HŸâÍ7‹!Ê¤™Sîğc˜ÉY¦ÉÈSC°%Y7:¼Ï§Ç[2Æ²wŞÚ Œu[d£r<‘;¯òŒDÌ¶7ÊL¿~~v>-‚.aïk¦©æ”ñÕÔ[6Ëo@‚°w<By¹âæËVÊB‹ÿÿˆ?5”zœá)$	6±º“Œ`õ,O‹ÆkÌ¨ÉF p0*}ßÈ¦em!®Äê…v”Wu^3ˆÆaKÚ ’‡ÿ²	ÓÁqµí@¬#	ƒÀ²qÀxvš^ÔËwCz5ØÈ-iZØ5Éóïïòø›¾ÑâÿøĞºugKÊ>Ö.­!¯ÉÄ(Í–Kô«Tù	…12&ìË×YÔS~£s,C¿x©+[z×¤:I44‹U”é´ùÓ:ÁÒ7i×ÄjŠŞÖÕg%3<¸ÿbošìmî{Ÿu\|fŞzuÏ³‰5ƒgøïœì)q×¼‚5µ¶PÎ‚£ä,šæWxw¯”jÎÿ,¡F£"‘vjÂ>ÙÄ3F½÷ ‹çí	”Eñ‰'¢_©#›ÙHÛ@>‹Owæáß"Ó±Âİs¦ñ^%^òí¿ã-+Ïš‡•dĞ…[\x.ñ	³†»· f¶çb0ã?÷”„[!ãÓ¾€¦ÇíÚ1W‰€	º3Ü†GÍåÕ$‰¼ Ã f´«­‹}î½|Ô¬µ¿ÌG[öHXß¿…&UèNSA>QvàÇîI.d±L&Áó[•¤Ë²‹¶ßÌ)Uú¤DzÏúVE~àé55œùÙU¹è¬{]´iO`¦8R·“,j¥dŞeRã8¡Êà´<íüI æœ;Ëò¨úz+Ë/âèá ÉTk+ÊÈádÛåll;Y$]+ådÉ„Œœ-ß¾Nè'?‘³veN,Ä|ºÒK°Xx+ä`ÓtîK	ÍO,È¦@™2Õ¡Fş€%ã¤ÃåµŒXÉp8™Á·ªºWç½DkAŠù¿f] ª´6é>^kª^÷şˆŞ›V	­‡Ë@oüÒ!»tı5M/d:êçë}†ßOïn %–`»G|WFt’YÍ¯#0Ç—ãú³3É l gänÁSñµƒyQåê"j~¹_ŒÎ]ºqC™+ônQ•(‚CNïPg$é½/¬Bï¹|´•‡¾µÑ?ƒ, &øóú\SİÍËñFÿ[¾¬\dò%[ˆsÑ%´#ßQáaÍ»›yT¾§8ÜQu2¼„„ÈÅÜÄµvû–ÿvŸ Ç¿'ÛÖOş¾'è˜&˜r~Rºê¹&-Á!†¥÷zÆO÷‘Øç‡çŸT¶h1Öî¾Z]Xæõ¸+UÄ(š¿F!KÃ¹ÌóÀ";t-ø¼f‹ ).øÌI×µÎ¹ÑV®fáT5qCßFÓóQP$$ïºĞ¸ ´jßÆ¾âeüp.GòŒM]]çÔ“¯İ¡låÒ<F‰?ÙÀÀÖáãE5s—L`ŠsØŞCú8*öİ¶akH}O—>CSÌ¹¬6+u3¹>)¸íq®á‘æÈ¥|%÷Tu"6µÄ¤BÉ? ßQ?”øO\EX‰™‡óo`u´øæìÙ±Òú[9æa 
ÄËUÖÜ?gÊ®˜£3Ibü`Ÿ|2“éKÑËÃ7 vø‹]İİ”G”Üht˜^†<I¡Ùs¥ƒ€¤O›	>¶NrVêûh?wL‰$eb¢*;ã×]¯wÌBÍ±‘\œÅø·‰Ša|ewzÅ¿s
È0E»ü®xbAå¹ê®}Ö¶@~ÑÓ|Ñ0Çõš‚a-l?ZJ„ª²´ØÎ]æÊ3Ašy­|ëp¦)~ù³æÖ»·¢¬‰@-3?s?§­0¼@VûÓ/ÅQB„õu÷úáâôE
øx´H€à)™-6Ä•lÏÃI$Õˆú¯ÀÕòÇ!¨®5¾4×üÌ¸‰Ç4ğşÎAú©¥µ‰XºìEõÇí€ÊŠl,X_¯å ÉÓ-²w”Z« ×­fyÊd¸x9›ö¨÷-}’ñáp'¢T-eqÁ˜:?3ˆM„]Y{CŠsó í/ç†œÂ±cë1Ú¯ß½+‚„èiíï€à$0}–xY¨Ã¾Õ…ˆ]wª; yí‡È\Hö¨ÛKü2§¦R¨ÀJ¼ÍÌrÕ‰·¾–çQë@v½ğÕHÿˆ¢1ÉæS}º¢á_·C@Õsay–†	¨»wï,•}DñËoö¥"¦¬58Š=Êçàk‰&‘K¸5¥¨ĞB”!`ß¼OádÂ]–ow‰
Ÿò³:àO­Ú]7ş)5+t<4Gn×ÎDPW8î7Î½–BÀ yRÏ@iıfğ³ªğÙ÷mÛc~Ön¡õ<íòØp„`§>ƒ!ù”SHöúŸ
y2åš±'‡Pûi/ÍµxeèÎvæpé5STmÎçK1óäÎyä{%O˜ÓÚ•BNî¥NÃîh˜Ñ}`¼Ô#°OëŸBf)ç¬âj81ßª1±¤¢Õ½âXßÙd‡C[1=£=]9˜Ø;ùí5$ğÎ£»8ÓYRÒß{BøóÆú ¤•ÒrÕ»ši¸9Î*ÿñ´’lnS1Ğ¤õyØì,1úÇO‘Î•˜Œ>kh"îOğ Ø3[l¯
•ìÂeŠµGvS‘Öçè+¯ì«hTL@r+S»Ô‰l0Ï¸´!:>=Xh€Ğ#ìv<şŞê²UÛ7_¸ıª41Î«÷ ¬…Ôà±n§Y,Hm\Kü8‚µ
wŞy7ÿˆæî Îz¥ûğ+ŸtRæXÿ¬hÛlûà_*¤¾)Íù¿¯Rø0©®¬Å%“ì‰âzpİ±ÊÃ” ™Õj•ÜQó(f«m!~­lzş`ÍK5nØèò	KÜAæäÉ\`P/Š5¹¡qåotEÄo€ªãéÒÂú«Õï6wÿØ~H**9¿H<í’1^¶Ôƒ8şÍÚ,æ¯2¥ÛÃ>Ëà]e_c±=ğ%WrpÓnĞŠëŒê*Ÿ‚Ö¡
†RŠKË¿fª7:®K‰*al‰!
~H‹æ£i1¢’» KA¢®Tw*Óı¥+ÅF‰¦È§nkDÈÂg_#Ùüá½‰b@&’Š:€ØY-ã»FüÀâI&ÕHz¡PÈ#S¡R©Mıa¦B£©yã«çî/Ò¨ş3³¹Äè³‚è¶€ıæz¡7êºVÒÀ9ö{F¨i#“ê 9"}Í4,2\`ÑÈSm¥ëéÀÖPß]& Fï:;Æõxs8¯äw›š•ó>-êxx]¹€_FG„^b{ #¥ğ’D)yÎObğõü|f{–½PÁˆ³Çf–“Üõi@ètÌIdÓ—™s§Y­Ÿ‡QHÌ”¹¸û%±…ŠÛªY02oõİ¸Ğ9Uø‹ƒ´S¢”N¶B$ƒÛr;dğ"+)éùGg&‰´|Vfo4‚[˜Yt	¶ßz}4Q¬ã/ê ÎLòP)4§	åBÁ‚æGû›‚™bu¸<¶\Ä‚ğå¨Œ*õú¢¢±¤Â¬®Î›øñ›Òf¶"xÙş+×.´¡[hpFé_1¤BéW›BY7åÅXC ^/?¸ UX&H)Í”<d/Iyò}ğ†şr™ü?xö­‹A.>‡geT]0Ãè«N `½È˜Ø×Õ~[XøŒ÷ÁRRLOãGgnLëóD`ÆméYĞ;oc¯sÛV¤BÃI¨[§L1››·İ´Ãms>‰¸«mUÇ~z\tÀ[’+½¤8EÜ[Ö0ºœ—¨;½í8>zµ›§Ê.Û
Ó.ØšuñåÈà®Şã±aÛÁË'ğëY6ôÿ²E	§@‡Ù`öWwâzÙVšËD7í\ŸüUZ9~]Y_»«âf2û÷
@î¡+¥T ¬Ûš$™%q4U—Ñ3îLtowş¸BÙãlS³¶_ÓcYô>àkDqÄËšJıèïëÈ±¼ô09ºĞ¿´7T?¼ÖªE±Æ.Ğ+‡zùa¢ìw‚Iš4ß?ÆŠ‰1Şóó®MBÁÔ”È¡ÙvêbÆäòûÌÆëªåQ;Óâÿ°J€¸„æ½g¼!6œ†Q	ıİ’kEv"Œ8
1{¡“h“µ—>%\ a™¿aÇLÎPaï+©&úÔ“cğYf… ™SjEİŞ¿’ÙfÌ"!(à;u‡MÖ‡?íQÊ0øªCÙH3D>˜ÌÈ2®[s'©İd×2!õ¶<{L;Å{á©KØÊJ=OCÄX‘Œ§šŠ}°…]Õóºø‡ğ`2™#.Rú Ş(Gˆã²¦ƒ.¹Ğ_E²J!Jqô­º.“çŠh{ÕYŸzb-ä
a¹>-åå.‰jğXŞGÏµ:ZÔ¢Iyw!Ö‹>·ºt¯Ò5w+¬ÿv»Z¯ÄF‡èr=şĞpëÁªWO 3ÙÜVÆÑX½³?àÛ¿p@hE~ÈãU±%/ë6Vbºk<Fõ4˜ Á¤æ\Ä–9é»e)µÿ7Ğ¬ÚDseóÔÏÑ±ıJ6¦¶ı7¿Äâ£y;E¶çT?UnØHŞpë‹71€“*tÏyÎ´Ù‹ªá€ Òª6uÕ*‚ò@ÅÜ!6Dx ³•l¸‹EkDÓ‘yy¦GbÿïØÚÓèËY7–m'õ7}ÌÌO.ÇLà´“òç«Pµoüõ~Ë„ã!’Îæó.)ê“`/=­RËúòŸ‚‚³ßçóëÄšFÒf@ïqùêÇÎÄõUFÕ3*ñÆê…ÙæA³üÎkÄúª4"ìˆµféªCSß×ô†ü|Ä.Sî<´|PßIÃæY«,Ğ˜­ğYT+K÷¤‹AûKö¥İaB¬ã¢’5¤BæÆ¥-Ïp¨¤ÒçÃÚs-ÎÌJ­lN¹*‚Ec'ò[™æêxH„°Uá*I{ËŒî0-üR_c
7îºH÷ü&	Â¿\Ö&Yüy…f`°ù]
Êã§ƒ…ÏQL€_ú7ZÓšD~y¹‚ÇÕ­}ææi]«¡Wg`?aeëÏwˆ½›Ô÷*OX'ñ”ÃÃ5^)ö”¨¹™@.ÿ %Kúb×ñ†År/¯Ù„Ûà€ãDIpÀšÁËĞ†Ÿå¸Ò™ô+féD½³˜!6G¿E3Éµ‚pwX¼ÉwjşrzU^­O§¤2¸LX¤QK­Ä	uÑŞØ! È˜Ô#½/_E–á@Y{…Q‚jkrÚ%R+5ä—P¼ÄÓHûÒñY„&ì dÃ½¾~‡Óö¤±‚Rkb‰HbvFšÍ/G&cA	áŒ QXüÇ½£@³<®ÉJ-ÃÑºË@ÊÜ°*·Ä÷ê†o!]æU(T¹äÅ“
‡inPP\y0Û-S&s,~Åª˜øôßÊİ÷¾h¤™(@{ÁFÙ¢1	ø;d_äÊ1—Ü)Ó—¥5-ÁD—ƒ/{«j¾šIÓ€âŞµ’»Èµ£¾ î‡D) ™ÎP´Œ]œ”–°Cù…]2¼ÿY”\¬R“–Ø}xåáâ L½æ¸É0cí"Ä€— ~fø$nÃsHy1øp-{P,Lù5Ëó´MÈVÕr?8±9n°£áqæR¹8Õ›CH‡^‰— DÛxØ„ûz(.CŒŸşûãkTÂÒdÊ¥W"'t¨æŠK€»*~¤}Å;¶9·¾,Áö1J¦”£)…r¯"|ºw¬%Ãvÿ¢íÑĞÈ¿T–ÌaDzÀü^XÚI²ê$7WË¦0m*8H«Z:Ù«jÂ<~µ™­Ğêßhß®[“¬6Î…ì¦¨­–FÆÏş?%­–F'ÏêbÉ.€é}CGÙF	"t¢$ÏQt,rU‹X·Å!ßXŸyÓËŠÏcçH€ÔÏ;¿2š]¡>C²æĞ×ŒãyÄè­<Ğ Ì¢‚4F
DºáYî¬¯ı<ŠæC†I¸Ÿ€æè5“›
pbo¸—!-©öGÆ?ôØ*¸3œ^YwdÊŸÉ%Åè©¼4j Œ 4fÆÜbÛ«6$y\çWîrf§ÓÁÑÅ3ŞD¦æ‰%¸Õ½$Ì; ;òÁTÊ©T:]ù¡îã€wüò½4zÂÖŒLE¸šiò#Á²X/ĞeßõäòyÖ0[¿îå %>£ñ‡(	)C>?ğxÕólWKÚ’iá½ıÔgw·0·2õo¶~Ó§ÛãÈÓÈl`$¶ó ¶¼iÕÜ$Ï’çÊ‰KÚüµXf¡xı7û¢w9h,‡
öÙ¨P˜lh¾Üšƒ_€D|Úí‡ˆ«+¥¯	/EÅ8Ü|ñ¼ÆE—QÌ¦ÇÄæ:ÆA€šiÔvtP˜8§Çë(Ÿc—j4 æ±ï©eâ8hêÕ¤U²ã¤ÔO±ZU#/šØW×æõkÔâ%~Ã§_ÜPW™BvöÃÎc¹5^ÎÆ“è7İ=‚§8dó@¯ˆ-ìúP74æ€tÿÀ!4p2è4 ì¨¸Äƒèxw®°ÛÚ3%Ë{ŞéDAOs‡•®æÚÙì«ËlAZ9²³ĞŞaBô¡ÆõCo³,«tóD&D–hnÉ(Ü»»Ü€î|S\Ñ^eêŠ7·ˆÊ›¸Øb¢à%=ĞûáÉU€ñ¨Ø+5TêåZ$fzfÊ³“R¤|CNtoN”+«)şLƒ~Î tú\Ğj‰±˜²”±P®j‘¾ÓğÑs…]ÄW±C]{Ø9ÙXÖzä=(Y%.Æç|+É1ÚZSóó£‹7™#JøFiW±«dÇ@'YşàVß>#à:
¢—çáÿí©Â(¯‘Ú¸í´ğÑ\š²»<%j¿<Š%]‡ºù8ïpÿrY‰Æ´Lg‰¸$–;>!-ÿô²–¯äjlö__*?jGP×3¤V+¸äx<\š
ÜäûyEOU¡¤wü©³D×`cD•4ÆŸYjÒ·ÂÈl–èH=¹=ñ½ÜÖ0R”9OÂ+ÉAïohFQv¿‘‘:Íëì<uj²Ñ:±7F«?¬R×;“FÀCkıMÈlèhŞŠ\¬;ZÈ5Üƒ ÇjYaÏ¬C‰eœÑij—5Ò• TõÊğ5&şØã:Ÿ¶|}ˆ]FY{wYŞáRî°‹oB·UKÍ˜ŞWÖTMwíQî7Ä±lú-A®ô/ĞxŸ<uó$*¡œÈ°8>ıkéÜgV6Šn}mfBUm7û?œ¢	Åu­—1¸õ]Zˆ™~x¯ö³p"Zy–ªŠ€“@Î°ßÚD¡¨A¹İ× 	5$VºöëkœÕ$é‘$ó‚ÓLÉ9‘bnëgÈ¶VÍ°˜¢â’÷ı8}Åo%9¦}k€«šğ|ù;ğM~+t)©¥ß(ô3‰ëXºí6•~ ¿Óf-?Î<Ô•·…¬§	››cõfßØ$È¶,ıøÿl©²Ú·üåjÛÎ‰K°ˆ"÷a
[†?Hb@Äqa>;ÈçãqŞ
~7G>p1\!:Q©Á4c§„½W…1—ÒLZf”«*;_ó[ç0.(+†áöÓs‹kJmø³æ4¾šQÁAŒDI8Ÿ±9Õ\¶–;Û/àÿø5×É<9ÌYãÖÓò°³~g˜‰½VzÒ±w¼<Yôm„«†ÿ?e'-ŞUz¦ûZº÷ù2kÑãSéè‹±5VşeàÊ7½B*Å9Ã¡áZİ“mxÀ~x¬Ÿlı\ªÉ_Š²‡	÷´R×Â¥¼àáuõ|¶ñƒÏ~öGzIn[0#âGÔã6ˆ<7²aW²®åÓÒ²K­‡ÚÔïÓ¬7ÔXOøíòòâÎT ¢® k×KÔl,ŞSûD-İ«¿î·o	¹—6zŸëıèÒşqœãˆ‹z]'×`kÚôı=„‡lf˜lÿ¥g7u@zëTM=µ·1”
cb½@zKF1J3¥;lhÔbºg6úVÖÑyv…G&Îg¡S]¹ò4]^Ğå{tZÜaÚç-M1ÉL"Û7áP‰-……y¤B|µGÊ†é²OäÛv/A/Ÿ1,?ÿ5h¢˜ü+¯1)/”„9Ó°›[y+	mº$I"ú@}×ğ‹?M ”ØÊu2„¼$0.èñ›7Ëf9¾”}@Ğö¹gRîˆšµcÃS×#	°{ÈàåÜ™äeznM9ÿÿûÚk1r7JÂ¯¡æv½ákò	¹)jçoVWÍŠWÂĞNlc(¦6¤_ú×?çÚH7
ÈÑ-<˜‰ÏÆâß*Õk<iSİÒÁVUËxUl¶<¿À~€[ieÂãà]
ş³¹täu­·ÕïqÇ`dÀÖĞD“%G…Ó÷Eˆ:+ÕØlO¶³÷Fñ·9q9áY-LHš‰ˆH ¡Û±f¹JVâa[î–iîPª#Éğü2i¹½+:ìLOŒ±\©¤n
^¼^tm<s°8ş×äâ	û‘U7Ëí?ƒÚ/¢ÛƒqÊ´$²[ã¿¨·S2§ËlAß³>+g·@À¾ÍèÄüpĞ“j®-ïø+B€)c£´-F2…)I½Ü:Ä’ß
w6¨v!£uè:ó ¨¬ŠX§æ”#'(óÒ}‡¾§ÔÔ|‘”ëtƒ‘l’7ŞIMŒX¿[d‘ïh§ cÖ';à–nrÑ2ßrç:W¶²ÍÔÖÕ_	}ÅÒx~®Z¨*bvÛNam¾W°!ş‡éâ¢Ş†/ƒÊ:ÿ¹¼Ğq30[±To6Êòz.lRjğ™ŸŞ™&´qƒ5aùûm‡ÛäS£ì¦Œ_î¦É)ÿœ±˜d‡öªD/—¸+M“â²ô†¾Ì4Z¸’Ÿ¬=‡’©Ùb)*‰bTCt°Ğàgí»ÜD>ø)Óİ€´8      !LÙJY†Ü³²3~İ®l¸E~}¢XŠı=«íñ©-'ÎkÅu—rZ-Üã Ë{¢5\˜şí¶Ì»UZdòÖÉ„iÒOÃ.a­€§Ôç¥¤®Gg@È[—í°{è^Î.°__^T[E,E­¡|+[¯ ³¡qEœ#nKk¶¿C´ĞÚÉÜŸ·´µ
÷Ğ=Îîßæğ"=U/"ˆºÁ§–ãôÚP­–X½d†ÜB[ÅS;E³Á];ú)£°†Ü´(T°‘IU_Ô¥17l^»0~ÊŸÿòÀë{õ€:íë’"ªzgÔ-³(»ç¨éÅü|F_Huû¿s¶=@ˆlÕÜcS=æó2 3sË_´n¹Ù;2VĞlÉtÜåW_Æ¯©²’q¦]­b «aßy£îÜ_>ƒ¶
ãOÛÎ©Ş¶w„u{sLËxö«Ø‰“ÊŸäØ¹ÑÉo³’WqE&©	f’r
È éí»šüüs«}ºËßT/×(·såR{¦YÙ²èæÀ¸ÖŒ©ÂÃÁ¯:<*XÌøæµİ)ó­UÍ¡ˆ¸¸ª•ln÷{™	'¦ü2@†GoŒQÉ
°¯‚œJ{TğÀ¾ş¹ã~  AøK„gØÔ¸åp&>x–ÛdÚ¾Ê@Ê­:‚¶\OÄÙo9óÎúBívRŠ[ã½ö™mYÇÏ ³ıê¥í?ïºp$>3™Èês›e'»JlhÃ»‘Ñ/}oGœ„°Ø¾ïlnÅ˜6ô]—«HŞšzZD¼´­ÆŠ²5…ßE9kQü ¹í„M2ê’1OhášXv:
éÌ7}l:7ƒ$´Ùİ-gßc¶ùïnAfÅSv(|éíªşF ´
6*DÈúÕ'…§Ö/›cRRÍ"VÉ@?µ ÂŒıÿÃåâºÌ;×T4gÖHãÆOB -MS3ªãA¤ï©åË;¥â	‡q: ~"}mn÷=aÛVç­§Ç”?-9i§ZY!Qqp`!¥:0Q‚&¿r-ÊVØ½ÃS¢‘Ï‹MÂ£´±û÷²ÁÁ\'!¯”ğê8œúÃ{æÙVØ™/
.ŸûKíhr:ˆkş—ê(cjhÚ=úŠï‰˜5Y§œ¦eC1¡ü Ì ÄâyK!Î¢Öƒñ²şÀ"CYWà((¢ı 4DÓ‚ùÉQb¯·Úõ)lãöC±ëÙ¯ÂêóZKì:·¨ŒoHÌ«ësõ¹‰âZÖXD2¤.Êr‹ygt9­Úî¢XqS·Š¸*Ûç·_,!¿ı6·1‚,½VşL½ ¼*Ömñtp|8ôm£VçÔÀ”½ÀKqe‘š×)øZÛŸ~¬ËGĞÔÎ^©LÁÊkâ…B§^âX8 ‘ÛÛşÓ¶¥HÏvzìëÏóGÎOÄ|!ôåînMî±Ë	u"Ñ<zØöykÆşŠlsé0
‰÷Ì ƒçcX¨¼Äå†e}¾ºW;KµkJxs:(EŸ:xx^ºÙM™|AóŠ~DArœ‘¼‹„¬€çK§Ò®…Şp¼Tém1å2}VÜ„pf”—ºÔQ“5ï°¹˜ÄînHñ­“¦hÃÃ™yù¶Ä_Z¶IR87Ç½=Šê0ˆ¶oÁ4|¡œLÏ°¶¡,9T,ry9­r}÷Zîü‡f\>‘ÔêNù}œñ‰šxØßõÓCñ´ÇûùG,‹ƒ©¦ùşÆf6İ1+ñàÜHÁ«V¡gFÍh_u²ÏõÎ°Œt¡8Y=ÕL[¡ÓTÓ/õj‘G£…R"«FïxyµÃ€ETX’l_ªª¸;öIØ/GÕµ¯Ìéépí6•OB‹ÔÏÕ¯Aµø`*Z#eä(Ú³=ÆJ[˜ }98CWÚ½W+0e¿:*«]‡
«òÅĞ³ZBíM°åu•–Ï©z	E>vÁ¦éBŒ‹sU¾@
´U²ó…X—@Â×Ş‚¨‚AMFå\L¾D!š:?£í9¹ãˆ’‰¶)==ŞBc÷O–?©ÅzN´QîòIT\_^G:p{“Ùx¨(£AcĞ|
8ùWÖôN—ÙYtÂ„ñ×xà‡ï}êÕ­UŸwÑ¡”ëz4ò2OæKšt´^Œ:Ól$ÂĞ€ >‡u ƒc¬ï²
5¦¶c§mgî„;²Ï˜ÏmÑ¯AÖ½İ@wH1ü”•¯àw’1APZ.~ş*Íóx—¿K©t"Y(^Æ{W°€ä°Æû¡öG°ó ,¦Æ(V·ßB®‘ºà¼ß‡.ıbCxo9+éRÓÜW:â†+kğK¾ørauh–>G¦9¯¬4[KAÜp “€ƒz´§®Út¦ö`ÛÖrãâuÓûp¾|`±ÏéÏê]v“èî¨ŞjÂA®˜gĞv7¯â+DÔÒñ¼ı 7Üğ1ßYÛv +ê›à [,9sIÓ¿øJ¥¿	¿šJBßÀæ‚P–(‹=‚ş37|&òùÊ¦™ÓŸI ´<®”\1‚ÃìDï÷œHu@ºVâè.Ñ°ÙÒw«ô6Ä¤OBU{ÑÚD×gfÛšøùïÚÅ‚şˆ€˜yÄŒĞİĞKs³$«M¸ ²oçd„pàŒ ó>ÉÙ6éŒ]7ãâ5*ñç'|­éP&íw‹Ê?Ùmq»t„ÌF$Ì`'Oå»©v¤¯&Ò8]ùÙRšÃ>›˜æ	*oğ×gS‰ßÍ¥'¶hËˆ·ˆ>h.ç¹XŞEjmì‰,;>M®Õ,j`{È¦vœ=üvD,ùÆ•	Ğœ^ákÏ
)òÅT‹’3½ tÇÕŒ"z;±î4*ê± %”À O…•JÄGìvPÓÅ¶ô»ÃCKH®N_ò7j®n%ö·Nüüpù8öñç7Õ®‰93Ù2÷¬ªë–¤Á??5eÑ—{ô«_‰¯=
˜JÛš(<oi¼s`ciªnÌ¦"4Õ0É¢J©ØØ-ÍùT¨´Ô[ÃÊ¥qÇÊ*£¸h?–3†N§İ³óW¹#:j¥Ì&™w¤ñAŒJJW_•ü(Hcc ¡ •¥®=¦fĞÁÇ©Ÿkn“±ıJÄ¤—ÑÏ!øCõ‚ıàÃñøñß÷©Vd`O‡¡³Ÿµ;¾øÌ¬Ï]¹ŸĞÕ¯Oíøûb#× #±Yg¾máñëÃ&ÔEh¹z@6™ ŞßÂ'‚><EÑrèš}ä8¨X7Jè}¤Ø>Ì¹€¾Ï‹à¢!‘ö3iU÷tJÖV/òIG—º/ÿ‘$£VğckñºÏõª+¸€È¢ê·ÃÄb,Š©¶î Yxh·‚1Ó!_ï’È&àlË‘åy'"„u¯ó+ÇÖ[ÀÍê¶TpU£V‹éHŸ»û®U¬­„ÉZÄ³ÍšÆT+h{ö˜|Ó·K^µØúô†ûuS=°Ÿ¢¤”ºÕ®ûÖ¥Ç»séêDíÚâ±Ö®â6A÷voº¿À:Áp¹áT°ê[O¨ ¢w`4†µ]¯ÈºŞ.–pËuÚïÖk™¶5ˆä¨@‚?ê±Â’ƒœè5ZsÊ`"Èür[zghã…şk¤„ >q´ÁH¬Öù+¤òğKEÍÜg`x»»"3ÏÄ2»Eœ ¸¯‘ÌŠo–ñÖ¼zˆ
Ãï‰
x#–+Æ’ûÆ‚yrêw¹„Ğ:•áêi¸"Ò#Š0ZÑ·„Ëµx 9Éµ¸ÔÔu†ì^÷¤….·ß:NJeáÖˆAÎ¢ìÊ¼:øzœWCN2©Àåò‡Îoc`ı½o›)»Áš4úk n£ğJ1¨Ä/"Côñµÿ)Õ{G3VÏœV&e@Ïêt»aÚTP—«œuè†Çú'©¯Ï¨'ºÔIÇ%h Njq"2"%):İÎT
´¨ê¨¾*Õ¶ÓŠ_+Ë,¬˜*1wˆZßhÜCkí!»9Ëbìò¨ÿ¶]ö·)ÿ¶Ù¬6º½¡?º›†ñƒ^\
v™-D@²]Ê_‡‰˜[†ãc¸I?§îQâ#c‘sd«df•¥µİÃòÂ¸—ùNıœNæ¦9C¿Š-(‹¯W”Èœ¥&wÓÇz{S—ğîBe}`µÍäÔ œÉbPBc,‡QDU­^üH|t25¡TwáT3”À·"Âú7 ‰ı$³£”È­‹ğ ÉYælâåîJå
óŸ¥ãe­¥Ûh8ÂÈd…4Tı[Xl
liq€{©	EÑı-	Ÿ}M5ZİïÜñTgkú†àQ#p›¼$tr¯UµÃûqRP¾èpe—u¿qÒ].Ê|Vm¡å<L3$ClÆ·êŞÌ 9Yç¾»s=}ß ¡b‚FM£Óùá
£I~(ÔlEşß2µ7šGÁvé%¢ôÏ_Æ›w¥¢‚ğºODSÊç9”&[îS±eİ¾%é´j‘ºmkÇù_¤€ÛÁÍ¤âNz‰QZ0Ñ&‡D­ÁXsQ)‡Ön‡Ç`òØ­Õ€L‡¬âtºĞ*zôˆàïa¿¼(wTĞˆŞsËô3}-t3ÙzN—áAßJmƒ£Q+Ì3 “bú
ÖÁG¼ç76§•É=ZkÙ=¹Ú‹+&Ó:çDmn¥“±3÷-
•¬Êï¯±Ó4Æ±vÑçE pUaûMŞÒvİC30‹«j/Æ¦•×lª4Wj„_%¶Âtï\†?)æ(D¥“"ÓÁŠÀ „nSäBfû–•J÷r;U!`İ…ÕËƒi9Îÿe2MÏ	Îz÷5¡š!ƒ~DÑ¶„ÖŠÜ‰Ô-ış¯Ú´f8x™—_¸¬É–ÕğÂ%h·Şe	UUÖ¥¡OÒ#S¦¼uXÈ²‹hÅ>¦¿Ş@åóËËØÌlì^Ï¦’ÀL;yQE·íq¬mıë}7S…¦%½ÔÖáHÀê§ér9tÛâìß¨b†sËíÅ>P	À=@ÉvBZ+¦‘"„¬¬x«Oælé\"ÜºëÜÑêcùE%ßakrj·7b0oÓ¼¶òZ„X!£^Œô6×8vØsúK‰½q’/km6”HzR›ºçÀ¯#¸¶Q„^T‹Ü¯›‘–í¼ªfw[ŒŒC6ºKâıQJô'’@ÄÜ0(ı‘')n
ÁÇ8/l·½ú?œjñg~ëıÀ 5$ù•5Ï·­]µ²ctc¹ÆÙûi¸5À™ûü+³Sb`n'³âˆ©Ÿv/Øy#;“³	6¤N“1º•Á¦É•dU˜şHq|$3l¥ñ@ÔÓ¶#ÔÒY@Ü^—É—6Íç¸ÕğöåïÇ'€…üøtèVÇa\5&Ù,ò&ü ¯Úõ<ü×ª JN	°—É­É“Ï–^˜¿Ós¶	–I³a”T¾ºù®üd AQ‚Ã•gèpœaCU¯E\˜‘K˜$jPï¢Ya²¹’Èªµ,Œ¢ªƒâò¬W¿0ú·óİmß">Ä÷éPXk–28KtH§WÿÂyi¸XvcìÚŒ'µ3š2wÚ\h¿G•£GFÏÒ4V\÷T×XBàş¤jgèå…´!&¹ÜyÓ†ã±Ty”¤ğ¡ı€ Pcù=uÔ™—;Œ­H{ZÀÒ<àáİÏè§†À&ûPÁâŒ ØŸvVš+ç:Îƒ„šÕ–‰=ûf&)o¿‰VÙ>Ê„½"ÁYşÜ.¼Àõs7÷hıÛÇÁ”¨ÒŞÔÓ££ÍYqF£áº¾m»N; İ&É†à¥óçûî;iºYjµ–ıÓ{¯’OÜËÅ–Ñ àôl>üVÂ)±ĞÂÅöQãafoœ‰<a-P*œ™ÀVÚôoŸGmç°YiieE È¸!Ošğ—Ûp/¡òsm‡5EKmV‹¾½bíš§—ÍqS—„ë©+N=5à¹èw…}½Ë2ƒ$Tø–v²Ó’™næ£. ™hx§ØîµKáÃ;­XØr.ï÷+	OÌbê, ëÔ`FWÖ}ÕÅ}z¥B¢W¹º”…ïYË|Ê9›AK‘BÈZÇMG¢œ¿Ÿâ &ôÊåÖ c%€³¯*±.n…k ÍY¼²K@›énVÕQ›Ó>R˜\„¤ I×Q–B×òAxT%¼ñj1ê”íu%,åO¯»÷Àqùñr„ıRÉÃ»ÔÍ™©&8ûGGE³Jø	æë.í¼T‚!;³å„ÎÓûOJbyÚ=JÖA¥cK1ù}‰"dl#óºN1jäéGŞğ,OÕ	µMWÊ Ø­?&²ØíÕë¸ştJˆágíƒŸnW7İÏ®‡…™OŒ3qGõ·Q’ıH]4òŠŞAˆát“{ˆ–®8¸ºsDrÉÊ5öğíÊä]¸yF„ûy8vO)õÇÑÂjïF…ÃUF€f{‹¶xkÕXğ'#aıB™ni`…ú}÷›T#
6@aıı¶©˜ÆQ‚7ğ&!nµ¦ÿÓµBÇO]bÙŠ·en€Ìä+Ëèo0Ñ§©~å–¯ši®ÆŠ_¯ üDĞ#üŠÚm7ÂëI®ÃiÎ{@t­­ÂÆXYôÔiv³pOÏ·\œ3WDTY†ñD.¼ˆÜ\{­­]o1·Àî÷H5)q-ş[$LyEò÷Ïµ15|å¢m»^–/"Ÿ?£Q¸ O@uWô¾ÂpK¢ö¿¸ RÙZ»¢5d?lB#g÷ş=?auÛ‰—Ú'@™Õ–N'O÷vñÒÃUN½€Ö¿¶².ê¸P7›ï…uX¡GÛORqz£,;ÄÏ¦Ä<ˆÚ-¶EÚLÖ§“ôV©h1„ÖHİÅeİR›]›[Œ+ùĞHp‚¼“gµ7¬í eÕÑ‡©ÔÚ] ’ò±¼^öÄçêth›#Ù[ÇÎ)İ7o¾­Ã%Ißş4oäõ`¨1ÅÌÌT-òmL:º¥*GÍ¤/`òSšì79õœ=¤úv4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldE4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlL