Equals || isDefault;
        const aliasDecl = symbol.declarations && getDeclarationOfAliasSymbol(symbol);
        const target = aliasDecl && getTargetOfAliasDeclaration(
          aliasDecl,
          /*dontRecursivelyResolve*/
          true
        );
        if (target && length(target.declarations) && some(target.declarations, (d) => getSourceFileOfNode(d) === getSourceFileOfNode(enclosingDeclaration))) {
          const expr = aliasDecl && (isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl));
          const first2 = expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : void 0;
          const referenced = first2 && resolveEntityName(
            first2,
            -1 /* All */,
            /*ignoreErrors*/
            true,
            /*dontResolveAlias*/
            true,
            enclosingDeclaration
          );
          if (referenced || target) {
            includePrivateSymbol(referenced || target);
          }
          const prevDisableTrackSymbol = context.tracker.disableTrackSymbol;
          context.tracker.disableTrackSymbol = true;
          if (isExportAssignment