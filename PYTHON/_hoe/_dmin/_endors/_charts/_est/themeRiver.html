;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(4);\n\tvar binarySearch = __webpack_require__(8);\n\tvar ArraySet = __webpack_require__(5).ArraySet;\n\tvar base64VLQ = __webpack_require__(2);\n\tvar quickSort = __webpack_require__(9).quickSort;\n\t\n\tfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = util.parseSourceMapInput(aSourceMap);\n\t  }\n\t\n\t  return sourceMap.sections != null\n\t    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n\t    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n\t}\n\t\n\tSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n\t  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n\t}\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tSourceMapConsumer.prototype._version = 3;\n\t\n\t// `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t// are lazily instantiated, accessed via the `_generatedMappings` and\n\t// `_originalMappings` getters respectively, and we only parse the mappings\n\t// and create these arrays once queried for a source location. We jump through\n\t// these hoops because there can be many thousands of mappings, and parsing\n\t// them is expensive, so we only want to do it if we must.\n\t//\n\t// Each object in the arrays is of the form:\n\t//\n\t//     {\n\t//       generatedLine: The line number in the generated code,\n\t//       generatedColumn: The column number in the generated code,\n\t//       source: The path to the original source file that generated this\n\t//               chunk of code,\n\t//       originalLine: The line number in the original source that\n\t//                     corresponds to this chunk of generated code,\n\t//       originalColumn: The column number in the original source that\n\t//                       corresponds to this chunk of generated code,\n\t//       name: The name of the original symbol which generated this chunk of\n\t//             code.\n\t//     }\n\t//\n\t// All properties except for `generatedLine` and `generatedColumn` can be\n\t// `null`.\n\t//\n\t// `_generatedMappings` is ordered by the generated positions.\n\t//\n\t// `_originalMappings` is ordered by the original positions.\n\t\n\tSourceMapConsumer.prototype.__generatedMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.__generatedMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__generatedMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype.__originalMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t  configurable: true,\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!this.__originalMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__originalMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype._charIsMappingSeparator =\n\t  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t    var c = aStr.charAt(index);\n\t    return c === \";\" || c === \",\";\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    throw new Error(\"Subclasses must implement _parseMappings\");\n\t  };\n\t\n\tSourceMapConsumer.GENERATED_ORDER = 1;\n\tSourceMapConsumer.ORIGINAL_ORDER = 2;\n\t\n\tSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\tSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Iterate over each mapping between an original source/line/column and a\n\t * generated line/column in this source map.\n\t *\n\t * @param Function aCallback\n\t *        The function that is called with each mapping.\n\t * @param Object aContext\n\t *        Optional. If specified, this object will be the value of `this` every\n\t *        time that `aCallback` is called.\n\t * @param aOrder\n\t *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t *        iterate over the mappings sorted by the generated file's line/column\n\t *        order or the original's source/line/column order, respectively. Defaults to\n\t *        `SourceMapConsumer.GENERATED_ORDER`.\n\t */\n\tSourceMapConsumer.prototype.eachMapping =\n\t  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t    var context = aContext || null;\n\t    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\t\n\t    var mappings;\n\t    switch (order) {\n\t    case SourceMapConsumer.GENERATED_ORDER:\n\t      mappings = this._generatedMappings;\n\t      break;\n\t    case SourceMapConsumer.ORIGINAL_ORDER:\n\t      mappings = this._originalMappings;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unknown order of iteration.\");\n\t    }\n\t\n\t    var sourceRoot = this.sourceRoot;\n\t    mappings.map(function (mapping) {\n\t      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n\t      return {\n\t        source: source,\n\t        generatedLine: mapping.generatedLine,\n\t        generatedColumn: mapping.generatedColumn,\n\t        originalLine: mapping.originalLine,\n\t        originalColumn: mapping.originalColumn,\n\t        name: mapping.name === null ? null : this._names.at(mapping.name)\n\t      };\n\t    }, this).forEach(aCallback, context);\n\t  };\n\t\n\t/**\n\t * Returns all generated line and column information for the original source,\n\t * line, and column provided. If no column is provided, returns all mappings\n\t * corresponding to a either the line we are searching for or the next\n\t * closest line that has any mappings. Otherwise, returns all mappings\n\t * corresponding to the given line and either the column we are searching for\n\t * or the next closest column that has any offsets.\n\t *\n\t * The only argument is an object with the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.  The line number is 1-based.\n\t *   - column: Optional. the column number in the original source.\n\t *    The column number is 0-based.\n\t *\n\t * and an array of objects is returned, each with the following properties:\n\t *\n\t *   - line: