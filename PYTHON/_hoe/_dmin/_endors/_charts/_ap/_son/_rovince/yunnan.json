ficient color contrast of ${data.contrastRatio} (Minimum contrast is ${data.requiredContrastRatio}:1, link background color: ${data.nodeBackgroundColor}, surrounding background color: ${data.parentBackgroundColor})"
      },
      "incomplete": {
        "default": "Element's foreground contrast ratio could not be determined",
        "bgContrast": "Element's background contrast ratio could not be determined",
        "bgImage": "Element's contrast ratio could not be determined due to a background image",
        "bgGradient": "Element's contrast ratio could not be determined due to a background gradient",
        "imgNode": "Element's contrast ratio could not be determined because element contains an image node",
        "bgOverlap": "Element's contrast ratio could not be determined because of element overlap"
      }
    },
    "autocomplete-appropriate": {
      "pass": "the autocomplete value is on an appropriate element",
      "fail": "the autocomplete value is inappropriate for this type of input"
    },
    "autocomplete-valid": {
      "pass": "the autocomplete attribute is correctly formatted",
      "fail": "the autocomplete attribute is incorrectly formatted"
    },
    "accesskeys": {
      "pass": "Accesskey attribute value is unique",
      "fail": "Document has multiple elements with the same accesskey"
    },
    "focusable-content": {
      "pass": "Element contains focusable elements",
      "fail": "Element should have focusable content"
    },
    "focusable-disabled": {
      "pass": "No focusable elements contained within element",
      "incomplete": "Check if the focusable elements immediately move the focus indicator",
      "fail": "Focusable content should be disabled or be removed from the DOM"
    },
    "focusable-element": {
      "pass": "Element is focusable",
      "fail": "Element should be focusable"
    },
    "focusable-modal-open": {
      "pass": "No focusable elements while a modal is open",
      "incomplete": "Check that focusable elements are not tabbable in the current state"
    },
    "focusable-no-name": {
      "pass": "Element is not in tab order or has accessible text",
      "fail": "Element is in tab order and does not have accessible text",
      "incomplete": "Unable to determine if element has an accessible name"
    },
    "focusable-not-tabbable": {
      "pass": "No focusable elements contained within element",
      "incomplete": "Check if the focusable elements immediately move the focus indicator",
      "fail": "Focusable content should have tabindex='-1' or be removed from the DOM"
    },
    "frame-focusable-content": {
      "pass": "Element does not have focusable descendants",
      "fail": "Element has focusable descendants",
      "incomplete": "Could not determine if element has descendants"
    },
    "landmark-is-top-level": {
      "pass": "The ${data.role} landmark is at the top level.",
      "fail": "The ${data.role} landmark is contained in another landmark."
    },
    "no-focusable-content": {
      "pass": "Element does not have focusable descendants",
      "fail": {
        "default": "Element has focusable descendants",
        "notHidden": "Using a negative tabindex on an element inside an interactive control does not prevent assistive technologies from focusing the element (even with 'aria-hidden=true')"
      },
      "incomplete": "Could not determine if element has descendants"
    },
    "page-has-heading-one": {
      "pass": "Page has at least one level-one heading",
      "fail": "Page must have a level-one heading"
    },
    "page-has-main": {
      "pass": "Document has at least one main landmark",
      "fail": "Document does not have a main landmark"
    },
    "page-no-duplicate-banner": {
      "pass": "Document does not have more than one banner landmark",
      "fail": "Document has more than one banner landmark"
    },
    "page-no-duplicate-contentinfo": {
      "pass": "Document does not have more than one contentinfo landmark",
      "fail": "Document has more than one contentinfo landmark"
    },
    "page-no-duplicate-main": {
      "pass": "Document does not have more than one main landmark",
      "fail": "Document has more than one main landmark"
    },
    "tabindex": {
      "pass": "Element does not have a tabindex greater than 0",
      "fail": "Element has a tabindex greater than 0"
    },
    "alt-space-value": {
      "pass": "Element has a valid alt attribute value",
      "fail": "Element has an alt attribute containing only a space character, which is not ignored by all screen readers"
    },
    "duplicate-img-label": {
      "pass": "Element does not duplicate existing text in <img> alt text",
      "fail": "Element contains <img> element with alt text that duplicates existing text"
    },
    "explicit-label": {
      "pass": "Form element has an explicit <label>",
      "fail": "Form element does not have an explicit <label>",
      "incomplete": "Unable to determine if form element has an explicit <label>"
    },
    "help-same-as-label": {
      "pass": "Help text (title or aria-describedby) does not duplicate label text",
      "fail": "Help text (title or aria-describedby) text is the same as the label text"
    },
    "hidden-explicit-label": {
      "pass": "Form element has a visible explicit <label>",
      "fail": "Form element has explicit <label> that is hidden",
      "incomplete": "Unable to determine if form element has explicit <label> that is hidden"
    },
    "implicit-label": {
      "pass": "Form element has an implicit (wrapped) <label>",
      "fail": "Form element does not have an implicit (wrapped) <label>",
      "incomplete": "Unable to determine if form element has an implicit (wrapped} <label>"
    },
    "label-content-name-mismatch": {
      "pass": "Element contains visible text as part of it's accessible name",
      "fail": "Text inside the element is not included in the accessible name"
    },
    "multiple-label": {
      "pass": "Form field does not have multiple label elements",
      "incomplete": "Multiple label elements is not widely supported in assistive technologies. Ensure the first label contains all necessary information."
    },
    "title-only": {
      "pass": "Form element does not solely use title attribute for its label",
      "fail": "Only title used to generate label for form element"
    },
    "landmark-is-unique": {
      "pass": "Landmarks must have a unique role or role/label/title (i.e. accessible name) combination",
      "fail": "The landmark must have a unique aria-label, aria-labelledby, or title to make landmarks distinguishable"
    },
    "has-lang": {
      "pass": "The <html> element has a lang attribute",
      "fail": {
        "noXHTML": "The xml:lang attribute is not valid on HTML pages, use the lang attribute.",
        "noLang": "The <html> element does not have a lang attribute"
      }
    },
    "valid-lang": {
      "pass": "Value of lang attribute is included in the list of valid languages",
      "fail": "Value of lang attribute not included in the list of valid languages"
    },
    "xml-lang-mismatch": {
      "pass": "Lang and xml:lang attributes have the same base language",
      "fail": "Lang and xml:lang attributes do not have the same base language"
    },
    "dlitem": {
      "pass": "Description list item has a <dl> parent element",
      "fail": "Description list item does not have a <dl> parent element"
    },
    "listitem": {
      "pass": "List item has a <ul>, <ol> or role=\"list\" parent element",
      "fail": {
        "default": "List item does not have a <ul>, <ol> parent element",
        "roleNotValid": "List item does not have a <ul>, <ol> parent element without a role, or a role=\"list\""
      }
    },
    "only-dlitems": {
      "pass": "dl element only has direct children that are allowed inside; <dt>, <dd>, or <div> elements",
      "fail": "dl element has direct children that are not allowed: ${data.values}"
    },
    "only-listitems": {
      "pass": "List element only has direct children that are allowed inside <li> elements",
      "fail": "List element has direct children that are not allowed: ${data.values}"
    },
    "structured-dlitems": {
      "pass": "When not empty, element has both <dt> and <dd> elements",
      "fail": "When not empty, element does not have at least one <dt> element followed by at least one <dd> element"
    },
    "caption": {
      "pass": "The multimedia element has a captions track",
      "incomplete": "Check that captions is available for the element"
    },
    "frame-tested": {
      "pass": "The iframe was tested with axe-core",
      "fail": "The iframe could not be tested with axe-core",
      "incomplete": "The iframe still has to be tested with axe-core"
    },
    "no-autoplay-audio": {
      "pass": "<video> or <audio> does not output audio for more than allowed duration or has controls mechanism",
      "fail": "<video> or <audio> outputs audio for more than allowed duration and does not have a controls mechanism",
      "incomplete": "Check that the <video> or <audio> does not output audio for more than allowed duration or provides a controls mechanism"
    },
    "css-orientation-lock": {
      "pass": "Display is operable, and orientation lock does not exist",
      "fail": "CSS Orientation lock is applied, and makes display inoperable",
      "incomplete": "CSS Orientation lock cannot be determined"
    },
    "meta-viewport-large": {
      "pass": "<meta> tag does not prevent significant zooming on mobile devices",
      "fail": "<meta> tag limits zooming on mobile devices"
    },
    "meta-viewport": {
      "pass": "<meta> tag does not disable zooming on mobile devices",
      "fail": "${data} on <meta> tag disables zooming on mobile devices"
    },
    "target-offset": {
      "pass": "Target has sufficient offset from its closest neighbor (${data.closestOffset}px should be at least ${data.minOffset}px)",
      "fail": "Target has insufficient offset from its closest neighbor (${data.closestOffset}px should be at least ${data.minOffset}px)",
      "incomplete": {
        "default": "Element with negative tabindex has insufficient offset from its closest neighbor (${data.closestOffset}px should be at least ${data.minOffset}px). Is this a target?",
        "nonTabbableNeighbor": "Target has insufficient offset from a neighbor with negative tabindex (${data.closestOffset}px should be at least ${data.minOffset}px). Is the neighbor a target?"
      }
    },
    "target-size": {
      "pass": {
        "default": "Control has sufficient size (${data.width}px by ${data.height}px, should be at least ${data.minSize}px by ${data.minSize}px)",
        "obscured": "Control is ignored because it is fully obscured and thus not clickable"
      },
      "fail": {
        "default": "Target has insufficient size (${data.width}px by ${data.height}px, should be at least ${data.minSize}px by ${data.minSize}px)",
        "partiallyObscured": "Target has insufficient size because it is partially obscured (smallest space is ${data.width}px by ${data.height}px, should be at least ${data.minSize}px by ${data.minSize}px)"
      },
      "incomplete": {
        "default": "Element with negative tabindex has insufficient size (${data.width}px by ${data.height}px, should be at least ${data.minSize}px by ${data.minSize}px). Is this a target?",
        "contentOverflow": "Element size could not be accurately determined due to overflow content",
        "partiallyObscured": "Element with negative tabindex has insufficient size because it is partially obscured (smallest space is ${data.width}px by ${data.height}px, should be at least ${data.minSize}px by ${data.minSize}px). Is this a target?",
        "partiallyObscuredNonTabbable": "Target has insufficient size because it is partially obscured by a neighbor with negative tabindex (smallest space is ${data.width}px by ${data.height}px, should be at least ${data.minSize}px by ${data.minSize}px). Is the neighbor a target?"
      }
    },
    "header-present": {
      "pass": "Page has a heading",
      "fail": "Page does not have a heading"
    },
    "heading-order": {
      "pass": "Heading order valid",
      "fail": "Heading order invalid",
      "incomplete": "Unable to determine previous heading"
    },
    "identical-links-same-purpose": {
      "pass": "There are no other links with the same name, that go to a different URL",
      "incomplete": "Check that links have the same purpose, or are intentionally ambiguous."
    },
    "internal-link-present": {
      "pass": "Valid skip link found",
      "fail": "No valid skip link found"
    },
    "landmark": {
      "pass": "Page has a landmark region",
      "fail": "Page does not have a landmark region"
    },
    "meta-refresh-no-exceptions": {
      "pass": "<meta> tag does not immediately refresh the page",
      "fail": "<meta> tag forces timed refresh of page"
    },
    "meta-refresh": {
      "pass": "<meta> tag does not immediately refresh the page",
      "fail": "<meta> tag forces timed refresh of page (less than 20 hours)"
    },
    "p-as-heading": {
      "pass": "<p> elements are not styled as headings",
      "fail": "Heading elements should be used instead of styled <p> elements",
      "incomplete": "Unable to determine if <p> elements are styled as headings"
    },
    "region": {
      "pass": "All page content is contained by landmarks",
      "fail": "Some page content is not contained by landmarks"
    },
    "skip-link": {
      "pass": "Skip link target exists",
      "incomplete": "Skip link target should become visible on activation",
      "fail": "No skip link target"
    },
    "unique-frame-title": {
      "pass": "Element's title attribute is unique",
      "fail": "Element's title attribute is not unique"
    },
    "duplicate-id-active": {
      "pass": "Document has no active elements that share the same id attribute",
      "fail": "Document has active elements with the same id attribute: ${data}"
    },
    "duplicate-id-aria": {
      "pass": "Document has no elements referenced with ARIA or labels that share the same id attribute",
      "fail": "Document has multiple elements referenced with ARIA with the same id attribute: ${data}"
    },
    "duplicate-id": {
      "pass": "Document has no static elements that share the same id attribute",
      "fail": "Document has multiple static elements with the same id attribute: ${data}"
    },
    "aria-label": {
      "pass": "aria-label attribute exists and is not empty",
      "fail": "aria-label attribute does not exist or is empty"
    },
    "aria-labelledby": {
      "pass": "aria-labelledby attribute exists and references elements that are visible to screen readers",
      "fail": "aria-labelledby attribute does not exist, references elements that do not exist or references elements that are empty",
      "incomplete": "ensure aria-labelledby references an existing element"
    },
    "avoid-inline-spacing": {
      "pass": "No inline styles with '!important' that affect text spacing has been specified",
      "fail": {
        "singular": "Remove '!important' from inline style ${data.values}, as overriding this is not supported by most browsers",
        "plural": "Remove '!important' from inline styles ${data.values}, as overriding this is not supported by most browsers"
      }
    },
    "button-has-visible-text": {
      "pass": "Element has inner text that is visible to screen readers",
      "fail": "Element does not have inner text that is visible to screen readers",
      "incomplete": "Unable to determine if element has children"
    },
    "doc-has-title": {
      "pass": "Document has a non-empty <title> element",
      "fail": "Document does not have a non-empty <title> element"
    },
    "exists": {
      "pass": "Element does not exist",
      "incomplete": "Element exists"
    },
    "has-alt": {
      "pass": "Element has an alt attribute",
      "fail": "Element does not have an alt attribute"
    },
    "has-visible-text": {
      "pass": "Element has text that is visible to screen readers",
      "fail": "Element does not have text that is visible to screen readers",
      "incomplete": "Unable to determine if element has children"
    },
    "important-letter-spacing": {
      "pass": "Letter-   }
      });
    }
  }

  /**
   * @private
   * @returns {void}
   */
  setupWatchFiles() {
    const { watchFiles } = this.options;

    if (/** @type {WatchFiles[]} */ (watchFiles).length > 0) {
      /** @type {WatchFiles[]} */
      (watchFiles).forEach((item) => {
        this.watchFiles(item.paths, item.options);
      });
    }
  }

  /**
   * @private
   * @returns {void}
   */
  setupMiddlewares() {
    /**
     * @type {Array<Middleware>}
     */
    let middlewares = [];

    // compress is placed last and uses unshift so that it will be the first middleware used
    if (this.options.compress) {
      const compression = require("compression");

      middlewares.push({ name: "compression", middleware: compression() });
    }

    if (typeof this.options.onBeforeSetupMiddleware === "function") {
      this.options.onBeforeSetupMiddleware(this);
    }

    if (typeof this.options.headers !== "undefined") {
      middlewares.push({
        name: "set-headers",
        path: "*",
        middleware: this.setHeaders.bind(this),
      });
    }

    middlewares.push({
      name: "webpack-dev-middleware",
      middleware:
        /** @type {import("webpack-dev-middleware").Middleware<Request, Response>}*/
        (this.middleware),
    });

    if (this.options.proxy) {
      const { createProxyMiddleware } = require("http-proxy-middleware");

      /**
       * @param {ProxyConfigArrayItem} proxyConfig
       * @returns {RequestHandler | undefined}
       */
      const getProxyMiddleware = (proxyConfig) => {
        // It is possible to use the `bypass` method without a `target` or `router`.
        // However, the proxy middleware has no use in this case, and will fail to instantiate.
        if (proxyConfig.target) {
          const context = proxyConfig.context || proxyConfig.path;

          return createProxyMiddleware(
            /** @type {string} */ (context),
            proxyConfig
          );
        }

        if (proxyConfig.router) {
          return createProxyMiddleware(proxyConfig);
        }
      };

      /**
       * Assume a proxy configuration specified as:
       * proxy: [
       *   {
       *     context: "value",
       *     ...options,
       *   },
       *   // or:
       *   function() {
       *     return {
       *       context: "context",
       *       ...options,
       *     };
       *   }
       * ]
       */
      /** @type {ProxyConfigArray} */
      (this.options.proxy).forEach((proxyConfigOrCallback) => {
        /**
         * @type {RequestHandler}
         */
        let proxyMiddleware;

        let proxyConfig =
          typeof proxyConfigOrCallback === "function"
            ? proxyConfigOrCallback()
            : proxyConfigOrCallback;

        proxyMiddleware =
          /** @type {RequestHandler} */
          (getProxyMiddleware(proxyConfig));

        if (proxyConfig.ws) {
          this.webSocketProxies.push(proxyMiddleware);
        }

        /**
         * @param {Request} req
         * @param {Response} res
         * @param {NextFunction} next
         * @returns {Promise<void>}
         */
        const handler = async (req, res, next) => {
          if (typeof proxyConfigOrCallback === "function") {
            const newProxyConfig = proxyConfigOrCallback(req, res, next);

            if (newProxyConfig !== proxyConfig) {
              proxyConfig = newProxyConfig;
              proxyMiddleware =
                /** @type {RequestHandler} */
                (getProxyMiddleware(proxyConfig));
            }
          }

          // - Check if we have a bypass function defined
          // - In case the bypass function is defined we'll retrieve the
          // bypassUrl from it otherwise bypassUrl would be null
          // TODO remove in the next major in favor `context` and `router` options
          const isByPassFuncDefined = typeof proxyConfig.bypass === "function";
          const bypassUrl = isByPassFuncDefined
            ? await /** @type {ByPass} */ (proxyConfig.bypass)(
                req,
                res,
                proxyConfig
              )
            : null;

          if (typeof bypassUrl === "boolean") {
            // skip the proxy
            // @ts-ignore
            req.url = null;
            next();
          } else if (typeof bypassUrl === "string") {
            // byPass to that url
            req.url = bypassUrl;
            next();
          } else if (proxyMiddleware) {
            return proxyMiddleware(req, res, next);
          } else {
            next();
          }
        };

        middlewares.push({
          name: "http-proxy-middleware",
          middleware: handler,
        });
        // Also forward error requests to the proxy so it can handle them.
        middlewares.push({
          name: "http-proxy-middleware-error-handler",
          middleware:
            /**
             * @param {Error} error
             * @param {Request} req
             * @param {Response} res
             * @param {NextFunction} next
             * @returns {any}
             */
            (error, req, res, next) => handler(req, res, next),
        });
      });

      middlewares.push({
        name: "webpack-dev-middleware",
        middleware:
          /** @type {import("webpack-dev-middleware").Middleware<Request, Response>}*/
          (this.middleware),
      });
    }

    if (/** @type {NormalizedStatic[]} */ (this.options.static).length > 0) {
      /** @type {NormalizedStatic[]} */
      (this.options.static).forEach((staticOption) => {
        staticOption.publicPath.forEach((publicPath) => {
          middlewares.push({
            name: "express-static",
            path: publicPath,
            middleware: getExpress().static(
              staticOption.directory,
              staticOption.staticOptions
            ),
          });
        });
      });
    }

    if (this.options.historyApiFallback) {
      const connectHistoryApiFallback = require("connect-history-api-fallback");
      const { historyApiFallback } = this.options;

      if (
        typeof (
          /** @type {ConnectHistoryApiFallbackOptions} */
          (historyApiFallback).logger
        ) === "undefined" &&
        !(
          /** @type {ConnectHistoryApiFallbackOptions} */
          (historyApiFallback).verbose
        )
      ) {
        // @ts-ignore
        historyApiFallback.logger = this.logger.log.bind(
          this.logger,
          "[connect-history-api-fallback]"
        );
      }

      // Fall back to /index.html if nothing else matches.
      middlewares.push({
        name: "connect-history-api-fallback",
        middleware: connectHistoryApiFallback(
          /** @type {ConnectHistoryApiFallbackOptions} */
          (historyApiFallback)
        ),
      });

      // include our middleware to ensure
      // it is able to handle '/index.html' request after redirect
      middlewares.push({
        name: "webpack-dev-middleware",
        middleware:
          /** @type {import("webpack-dev-middleware").Middleware<Request, Response>}*/
          (this.middleware),
      });

      if (/** @type {NormalizedStatic[]} */ (this.options.static).length > 0) {
        /** @type {NormalizedStatic[]} */
        (this.options.static).forEach((staticOption) => {
          staticOption.publicPath.forEach((publicPath) => {
            middlewares.push({
              name: "express-static",
              path: publicPath,
              middleware: getExpress().static(
                staticOption.directory,
                staticOption.staticOptions
              ),
            });
          });
        });
      }
    }

    if (/** @type {NormalizedStatic[]} */ (this.options.static).length > 0) {
      const serveIndex = require("serve-index");

      /** @type {NormalizedStatic[]} */
      (this.options.static).forEach((staticOption) => {
        staticOption.publicPath.forEach((publicPath) => {
          if (staticOption.serveIndex) {
            middlewares.push({
              name: "serve-index",
              path: publicPath,
              /**
               * @param {Request} req
               * @param {Response} res
               * @param {NextFunction} next
               * @returns {void}
               */
              middleware: (req, res, next) => {
                // serve-index doesn't fallthrough non-get/head request to next middleware
                if (req.method !== "GET" && req.method !== "HEAD") {
                  return next();
                }

                serveIndex(
                  staticOption.directory,
                  /** @type {ServeIndexOptions} */
                  (staticOption.serveIndex)
                )(req, res, next);
              },
            });
          }
        });
      });
    }

    if (this.options.magicHtml) {
      middlewares.push({
        name: "serve-magic-html",
        middleware: this.serveMagicHtml.bind(this),
      });
    }

    // Register this middleware always as the last one so that it's only used as a
    // fallback when no other middleware responses.
    middlewares.push({
      name: "options-middleware",
      path: "*",
      /**
       * @param {Request} req
       * @param {Response} res
       * @param {NextFunction} next
       * @returns {void}
       */
      middleware: (req, res, next) => {
        if (req.method === "OPTIONS") {
          res.statusCode = 204;
          res.setHeader("Content-Length", "0");
          res.end();
          return;
        }
        next();
      },
    });

    if (typeof this.options.setupMiddlewares === "function") {
      middlewares = this.options.setupMiddlewares(middlewares, this);
    }

    middlewares.forEach((middleware) => {
      if (typeof middleware === "function") {
        /** @type {import("express").Application} */
        (this.app).use(middleware);
      } else if (typeof middleware.path !== "undefined") {
        /** @type {import("express").Application} */
        (this.app).use(middleware.path, middleware.middleware);
      } else {
        /** @type {import("express").Application} */
        (this.app).use(middleware.middleware);
      }
    });

    if (typeof this.options.onAfterSetupMiddleware === "function") {
      this.options.onAfterSetupMiddleware(this);
    }
  }

  /**
   * @private
   * @returns {void}
   */
  createServer() {
    const { type, options } = /** @type {ServerConfiguration} */ (
      this.options.server
    );

    /** @type {import("http").Server | undefined | null} */
    // eslint-disable-next-line import/no-dynamic-require
    this.server = require(/** @type {string} */ (type)).createServer(
      options,
      this.app
    );

    /** @type {import("http").Server} */
    (this.server).on(
      "connection",
      /**
       * @param {Socket} socket
       */
      (socket) => {
        // Add socket to list
        this.sockets.push(socket);

        socket.once("close", () => {
          // Remove socket from list
          this.sockets.splice(this.sockets.indexOf(socket), 1);
        });
      }
    );

    /** @type {import("http").Server} */
    (this.server).on(
      "error",
      /**
       * @param {Error} error
       */
      (error) => {
        throw error;
      }
    );
  }

  /**
   * @private
   * @returns {void}
   */
  // TODO: remove `--web-socket-server` in favor of `--web-socket-server-type`
  createWebSocketServer() {
    /** @type {WebSocketServerImplementation | undefined | null} */
    this.webSocketServer = new /** @type {any} */ (this.getServerTransport())(
      this
    );
    /** @type {WebSocketServerImplementation} */
    (this.webSocketServer).implementation.on(
      "connection",
      /**
       * @param {ClientConnection} client
       * @param {IncomingMessage} request
       */
      (client, request) => {
        /** @type {{ [key: string]: string | undefined } | undefined} */
        const headers =
          // eslint-disable-next-line no-nested-ternary
          typeof request !== "undefined"
            ? /** @type {{ [key: string]: string | undefined }} */
              (request.headers)
            : typeof (
                /** @type {import("sockjs").Connection} */ (client).headers
              ) !== "undefined"
            ? /** @type {import("sockjs").Connection} */ (client).headers
            : // eslint-disable-next-line no-undefined
              undefined;

        if (!headers) {
          this.logger.warn(
            'webSocketServer implementation must pass headers for the "connection" event'
          );
        }

        if (
          !headers ||
          !this.checkHeader(headers, "host") ||
          !this.checkHeader(headers, "origin")
        ) {
          this.sendMessage([client], "error", "Invalid Host/Origin header");

          // With https enabled, the sendMessage above is encrypted asynchronously so not yet sent
          // Terminate would prevent it sending, so use close to allow it to be sent
          client.close();

          return;
        }

        if (this.options.hot === true || this.options.hot === "only") {
          this.sendMessage([client], "hot");
        }

        if (this.options.liveReload) {
          this.sendMessage([client], "liveReload");
        }

        if (
          this.options.client &&
          /** @type {ClientConfiguration} */
          (this.options.client).progress
        ) {
          this.sendMessage(
            [client],
            "progress",
            /** @type {ClientConfiguration} */
            (this.options.client).progress
          );
        }

        if (
          this.options.client &&
          /** @type {ClientConfiguration} */ (this.options.client).reconnect
        ) {
          this.sendMessage(
            [client],
            "reconnect",
            /** @type {ClientConfiguration} */
            (this.options.client).reconnect
          );
        }

        if (
          this.options.client &&
          /** @type {ClientConfiguration} */
          (this.options.client).overlay
        ) {
          const overlayConfig = /** @type {ClientConfiguration} */ (
            this.options.client
          ).overlay;

          this.sendMessage(
            [client],
            "overlay",
            typeof overlayConfig === "object"
              ? {
                  ...overlayConfig,
                  errors:
                    overlayConfig.errors &&
                    encodeOverlaySettings(overlayConfig.errors),
                  warnings:
                    overlayConfig.warnings &&
                    encodeOverlaySettings(overlayConfig.warnings),
                  runtimeErrors:
                    overlayConfig.runtimeErrors &&
                    encodeOverlaySettings(overlayConfig.runtimeErrors),
                }
              : overlayConfig
          );
        }

        if (!this.stats) {
          return;
        }

        this.sendStats([client], this.getStats(this.stats), true);
      }
    );
  }

  /**
   * @private
   * @param {string} defaultOpenTarget
   * @returns {void}
   */
  openBrowser(defaultOpenTarget) {
    const open = require("open");

    Promise.all(
      /** @type {NormalizedOpen[]} */
      (this.options.open).map((item) => {
        /**
         * @type {string}
         */
        let openTarget;

        if (item.target === "<url>") {
          openTarget = defaultOpenTarget;
        } else {
          openTarget = Server.isAbsoluteURL(item.target)
            ? item.target
            : new URL(item.target, defaultOpenTarget).toString();
        }

        return open(openTarget, item.options).catch(() => {
          this.logger.warn(
            `Unable to open "${openTarget}" page${
              item.options.app
                ? ` in "${
                    /** @type {import("open").App} */
                    (item.options.app).name
                  }" app${
                    /** @type {import("open").App} */
                    (item.options.app).arguments
                      ? ` with "${
                          /** @type {import("open").App} */
                          (item.options.app).arguments.join(" ")
                        }" arguments`
                      : ""
                  }`
                : ""
            }. If you are running in a headless environvar assert = require('assert');
var jp = require('../');

var data = require('./data/store.json');

suite('query', function() {

  test('first-level member', function() {
    var results = jp.nodes(data, '$.store');
    assert.deepEqual(results, [ { path: ['$', 'store'], value: data.store } ]);
  });

  test('authors of all books in the store', function() {
    var results = jp.nodes(data, '$.store.book[*].author');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'author'], value: 'Nigel Rees' },
      { path: ['$', 'store', 'book', 1, 'author'], value: 'Evelyn Waugh' },
      { path: ['$', 'store', 'book', 2, 'author'], value: 'Herman Melville' },
      { path: ['$', 'store', 'book', 3, 'author'], value: 'J. R. R. Tolkien' }
    ]);
  });

  test('all authors', function() {
    var results = jp.nodes(data, '$..author');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'author'], value: 'Nigel Rees' },
      { path: ['$', 'store', 'book', 1, 'author'], value: 'Evelyn Waugh' },
      { path: ['$', 'store', 'book', 2, 'author'], value: 'Herman Melville' },
      { path: ['$', 'store', 'book', 3, 'author'], value: 'J. R. R. Tolkien' }
    ]);
  });

  test('all authors via subscript descendant string literal', function() {
    var results = jp.nodes(data, "$..['author']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'author'], value: 'Nigel Rees' },
      { path: ['$', 'store', 'book', 1, 'author'], value: 'Evelyn Waugh' },
      { path: ['$', 'store', 'book', 2, 'author'], value: 'Herman Melville' },
      { path: ['$', 'store', 'book', 3, 'author'], value: 'J. R. R. Tolkien' }
    ]);
  });

  test('all things in store', function() {
    var results = jp.nodes(data, '$.store.*');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book'], value: data.store.book },
      { path: ['$', 'store', 'bicycle'], value: data.store.bicycle }
    ]);
  });

  test('price of everything in the store', function() {
    var results = jp.nodes(data, '$.store..price');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'price'], value: 8.95 },
      { path: ['$', 'store', 'book', 1, 'price'], value: 12.99 },
      { path: ['$', 'store', 'book', 2, 'price'], value: 8.99 },
      { path: ['$', 'store', 'book', 3, 'price'], value: 22.99 },
      { path: ['$', 'store', 'bicycle', 'price'], value: 19.95 }
    ]);
  });

  test('last book in order via expression', function() {
    var results = jp.nodes(data, '$..book[(@.length-1)]');
    assert.deepEqual(results, [ { path: ['$', 'store', 'book', 3], value: data.store.book[3] }]);
  });

  test('first two books via union', function() {
    var results = jp.nodes(data, '$..book[0,1]');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0], value: data.store.book[0] },
      { path: ['$', 'store', 'book', 1], value: data.store.book[1] }
    ]);
  });

  test('first two books via slice', function() {
    var results = jp.nodes(data, '$..book[0:2]');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0], value: data.store.book[0] },
      { path: ['$', 'store', 'book', 1], value: data.store.book[1] }
    ]);
  });

  test('filter all books with isbn number', function() {
    var results = jp.nodes(data, '$..book[?(@.isbn)]');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 2], value: data.store.book[2] },
      { path: ['$', 'store', 'book', 3], value: data.store.book[3] }
    ]);
  });

  test('filter all books with a price less than 10', function() {
    var results = jp.nodes(data, '$..book[?(@.price<10)]');
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0], value: data.store.book[0] },
      { path: ['$', 'store', 'book', 2], value: data.store.book[2] }
    ]);
  });

  test('first ten of all elements', function() {
    var results = jp.nodes(data, '$..*', 10);
    assert.deepEqual(results, [
      { path: [ '$', 'store' ], value: data.store },
      { path: [ '$', 'store', 'book' ], value: data.store.book },
      { path: [ '$', 'store', 'bicycle' ], value: data.store.bicycle },
      { path: [ '$', 'store', 'book', 0 ], value: data.store.book[0] },
      { path: [ '$', 'store', 'book', 1 ], value: data.store.book[1] },
      { path: [ '$', 'store', 'book', 2 ], value: data.store.book[2] },
      { path: [ '$', 'store', 'book', 3 ], value: data.store.book[3] },
      { path: [ '$', 'store', 'book', 0, 'category' ], value: 'reference' },
      { path: [ '$', 'store', 'book', 0, 'author' ], value: 'Nigel Rees' },
      { path: [ '$', 'store', 'book', 0, 'title' ], value: 'Sayings of the Century' }
    ])
  });

  test('all elements', function() {
    var results = jp.nodes(data, '$..*');

    assert.deepEqual(results, [
      { path: [ '$', 'store' ], value: data.store },
      { path: [ '$', 'store', 'book' ], value: data.store.book },
      { path: [ '$', 'store', 'bicycle' ], value: data.store.bicycle },
      { path: [ '$', 'store', 'book', 0 ], value: data.store.book[0] },
      { path: [ '$', 'store', 'book', 1 ], value: data.store.book[1] },
      { path: [ '$', 'store', 'book', 2 ], value: data.store.book[2] },
      { path: [ '$', 'store', 'book', 3 ], value: data.store.book[3] },
      { path: [ '$', 'store', 'book', 0, 'category' ], value: 'reference' },
      { path: [ '$', 'store', 'book', 0, 'author' ], value: 'Nigel Rees' },
      { path: [ '$', 'store', 'book', 0, 'title' ], value: 'Sayings of the Century' },
      { path: [ '$', 'store', 'book', 0, 'price' ], value: 8.95 },
      { path: [ '$', 'store', 'book', 1, 'category' ], value: 'fiction' },
      { path: [ '$', 'store', 'book', 1, 'author' ], value: 'Evelyn Waugh' },
      { path: [ '$', 'store', 'book', 1, 'title' ], value: 'Sword of Honour' },
      { path: [ '$', 'store', 'book', 1, 'price' ], value: 12.99 },
      { path: [ '$', 'store', 'book', 2, 'category' ], value: 'fiction' },
      { path: [ '$', 'store', 'book', 2, 'author' ], value: 'Herman Melville' },
      { path: [ '$', 'store', 'book', 2, 'title' ], value: 'Moby Dick' },
      { path: [ '$', 'store', 'book', 2, 'isbn' ], value: '0-553-21311-3' },
      { path: [ '$', 'store', 'book', 2, 'price' ], value: 8.99 },
      { path: [ '$', 'store', 'book', 3, 'category' ], value: 'fiction' },
      { path: [ '$', 'store', 'book', 3, 'author' ], value: 'J. R. R. Tolkien' },
      { path: [ '$', 'store', 'book', 3, 'title' ], value: 'The Lord of the Rings' },
      { path: [ '$', 'store', 'book', 3, 'isbn' ], value: '0-395-19395-8' },
      { path: [ '$', 'store', 'book', 3, 'price' ], value: 22.99 },
      { path: [ '$', 'store', 'bicycle', 'color' ], value: 'red' },
      { path: [ '$', 'store', 'bicycle', 'price' ], value: 19.95 }
    ]);
  });

  test('all elements via subscript wildcard', function() {
    var results = jp.nodes(data, '$..*');
    assert.deepEqual(jp.nodes(data, '$..[*]'), jp.nodes(data, '$..*'));
  });

  test('object subscript wildcard', function() {
    var results = jp.query(data, '$.store[*]');
    assert.deepEqual(results, [ data.store.book, data.store.bicycle ]);
  });

  test('no match returns empty array', function() {
    var results = jp.nodes(data, '$..bookz');
    assert.deepEqual(results, []);
  });

  test('member numeric literal gets first element', function() {
    var results = jp.nodes(data, '$.store.book.0');
    assert.deepEqual(results, [ { path: [ '$', 'store', 'book', 0 ], value: data.store.book[0] } ]);
  });

  test('member numeric literal matches string-numeric key', function() {
    var data = { authors: { '1': 'Herman Melville', '2': 'J. R. R. Tolkien' } };
    var results = jp.nodes(data, '$.authors.1');
    assert.deepEqual(results, [ { path: [ '$', 'authors', 1 ], value: 'Herman Melville' } ]);
  });

  test('descendant numeric literal gets first element', function() {
    var results = jp.nodes(data, '$.store.book..0');
    assert.deepEqual(results, [ { path: [ '$', 'store', 'book', 0 ], value: data.store.book[0] } ]);
  });

  test('root element gets us original obj', function() {
    var results = jp.nodes(data, '$');
    assert.deepEqual(results, [ { path: ['$'], value: data } ]);
  });

  test('subscript double-quoted string', function() {
    var results = jp.nodes(data, '$["store"]');
    assert.deepEqual(results, [ { path: ['$', 'store'], value: data.store} ]);
  });

  test('subscript single-quoted string', function() {
    var results = jp.nodes(data, "$['store']");
    assert.deepEqual(results, [ { path: ['$', 'store'], value: data.store} ]);
  });

  test('leading member component', function() {
    var results = jp.nodes(data, "store");
    assert.deepEqual(results, [ { path: ['$', 'store'], value: data.store} ]);
  });

  test('union of three array slices', function() {
    var results = jp.query(data, "$.store.book[0:1,1:2,2:3]");
    assert.deepEqual(results, data.store.book.slice(0,3));
  });

  test('slice with step > 1', function() {
    var results = jp.query(data, "$.store.book[0:4:2]");
    assert.deepEqual(results, [ data.store.book[0], data.store.book[2]]);
  });

  test('union of subscript string literal keys', function() {
    var results = jp.nodes(data, "$.store['book','bicycle']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book'], value: data.store.book },
      { path: ['$', 'store', 'bicycle'], value: data.store.bicycle },
    ]);
  });

  test('union of subscript string literal three keys', function() {
    var results = jp.nodes(data, "$.store.book[0]['title','author','price']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'title'], value: data.store.book[0].title },
      { path: ['$', 'store', 'book', 0, 'author'], value: data.store.book[0].author },
      { path: ['$', 'store', 'book', 0, 'price'], value: data.store.book[0].price }
    ]);
  });

  test('union of subscript integer three keys followed by member-child-identifier', function() {
    var results = jp.nodes(data, "$.store.book[1,2,3]['title']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 1, 'title'], value: data.store.book[1].title },
      { path: ['$', 'store', 'book', 2, 'title'], value: data.store.book[2].title },
      { path: ['$', 'store', 'book', 3, 'title'], value: data.store.book[3].title }
    ]);
  });

  test('union of subscript integer three keys followed by union of subscript string literal three keys', function() {
    var results = jp.nodes(data, "$.store.book[0,1,2,3]['title','author','price']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'title'], value: data.store.book[0].title },
      { path: ['$', 'store', 'book', 0, 'author'], value: data.store.book[0].author },
      { path: ['$', 'store', 'book', 0, 'price'], value: data.store.book[0].price },
      { path: ['$', 'store', 'book', 1, 'title'], value: data.store.book[1].title },
      { path: ['$', 'store', 'book', 1, 'author'], value: data.store.book[1].author },
      { path: ['$', 'store', 'book', 1, 'price'], value: data.store.book[1].price },
      { path: ['$', 'store', 'book', 2, 'title'], value: data.store.book[2].title },
      { path: ['$', 'store', 'book', 2, 'author'], value: data.store.book[2].author },
      { path: ['$', 'store', 'book', 2, 'price'], value: data.store.book[2].price },
      { path: ['$', 'store', 'book', 3, 'title'], value: data.store.book[3].title },
      { path: ['$', 'store', 'book', 3, 'author'], value: data.store.book[3].author },
      { path: ['$', 'store', 'book', 3, 'price'], value: data.store.book[3].price }
    ]);
  });
  
  test('union of subscript integer four keys, including an inexistent one, followed by union of subscript string literal three keys', function() {
    var results = jp.nodes(data, "$.store.book[0,1,2,3,151]['title','author','price']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'title'], value: data.store.book[0].title },
      { path: ['$', 'store', 'book', 0, 'author'], value: data.store.book[0].author },
      { path: ['$', 'store', 'book', 0, 'price'], value: data.store.book[0].price },
      { path: ['$', 'store', 'book', 1, 'title'], value: data.store.book[1].title },
      { path: ['$', 'store', 'book', 1, 'author'], value: data.store.book[1].author },
      { path: ['$', 'store', 'book', 1, 'price'], value: data.store.book[1].price },
      { path: ['$', 'store', 'book', 2, 'title'], value: data.store.book[2].title },
      { path: ['$', 'store', 'book', 2, 'author'], value: data.store.book[2].author },
      { path: ['$', 'store', 'book', 2, 'price'], value: data.store.book[2].price },
      { path: ['$', 'store', 'book', 3, 'title'], value: data.store.book[3].title },
      { path: ['$', 'store', 'book', 3, 'author'], value: data.store.book[3].author },
      { path: ['$', 'store', 'book', 3, 'price'], value: data.store.book[3].price }
    ]);
  });
  
  test('union of subscript integer three keys followed by union of subscript string literal three keys, followed by inexistent literal key', function() {
    var results = jp.nodes(data, "$.store.book[0,1,2,3]['title','author','price','fruit']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'title'], value: data.store.book[0].title },
      { path: ['$', 'store', 'book', 0, 'author'], value: data.store.book[0].author },
      { path: ['$', 'store', 'book', 0, 'price'], value: data.store.book[0].price },
      { path: ['$', 'store', 'book', 1, 'title'], value: data.store.book[1].title },
      { path: ['$', 'store', 'book', 1, 'author'], value: data.store.book[1].author },
      { path: ['$', 'store', 'book', 1, 'price'], value: data.store.book[1].price },
      { path: ['$', 'store', 'book', 2, 'title'], value: data.store.book[2].title },
      { path: ['$', 'store', 'book', 2, 'author'], value: data.store.book[2].author },
      { path: ['$', 'store', 'book', 2, 'price'], value: data.store.book[2].price },
      { path: ['$', 'store', 'book', 3, 'title'], value: data.store.book[3].title },
      { path: ['$', 'store', 'book', 3, 'author'], value: data.store.book[3].author },
      { path: ['$', 'store', 'book', 3, 'price'], value: data.store.book[3].price }
    ]);
  });

  test('union of subscript 4 array slices followed by union of subscript string literal three keys', function() {
    var results = jp.nodes(data, "$.store.book[0:1,1:2,2:3,3:4]['title','author','price']");
    assert.deepEqual(results, [
      { path: ['$', 'store', 'book', 0, 'title'], value: data.store.book[0].title },
      { path: ['$', 'store', 'book', 0, 'author'], value: data.store.book[0].author },
      { path: ['$', 'store', 'book', 0, 'price'], value: data.store.book[0].price },
      { path: ['$', 'store', 'book', 1, 'title'], value: data.store.book[1].title },
      { path: ['$', 'store', 'book', 1, 'author'], value: data.store.book[1].author },
      { path: ['$', 'store', 'book', 1, 'price'], value: data.store.book[1].price },
      { path: ['$', 'store', 'book', 2, 'title'], value: data.store.book[2].title },
      { path: ['$', 'store', 'book', 2, 'author'], value: data.store.book[2].author },
      { path: ['$', 'store', 'book', 2, 'price'], value: data.store.book[2].price },
      { path: ['$', 'store', 'book', 3, 'title'], value: data.store.book[3].title },
      { path: ['$', 'store', 'book', 3, 'author'], value: data.store.book[3].author },
      { path: ['$', 'store', 'book', 3, 'price'], value: data.store.book[3].price }
    ]);
  });


  test('nested parentheses eval', function() {
    var pathExpression = '$..book[?( @.price && (@.price + 20 || false) )]'
    var results = jp.query(data, pathExpression);
    assert.deepEqual(results, data.store.book);
  });

  test('array indexes from 0 to 100', function() {
    var data = [];
    for (var i = 0; i <= 100; ++i)
      data[i] = Math.random();

    for (var i = 0; i <= 100; ++i) {
      var results = jp.query(data, '$[' + i.toString() +  ']');
      assert.deepEqual(results, [data[i]]);
    }
  });

  test('descendant subscript numeric literal', function() {
    var data = [ 0, [ 1, 2, 3 ], [ 4, 5, 6 ] ];
    var results = jp.query(data, '$..[0]');
    assert.deepEqual(results, [ 0, 1, 4 ]);
  });

  test('descendant subscript numeric literal', function() {
    var data = [ 0, 1, [ 2, 3, "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const patternRequired_1 = __importDefault(require("../definitions/patternRequired"));
const patternRequired = (ajv) => ajv.addKeyword((0, patternRequired_1.default)());
exports.default = patternRequired;
module.exports = patternRequired;
//# sourceMappingURL=patternRequired.js.map               Bµ8y©ôA>a'nÅžGUÙÕÕ$¿êÁtî+ÊKªT˜¿ŽÓ˜“¿ð}#jËOm—x‘ì¿SžèKâåûº4K…’~¹ƒ6KØ…×º4E×ÈVŒˆðuz¥æYr]‚[NPQ¡Ý©T}ª­ž¤
øÃ:EµÆÒEGw×ÕŠ®Ê«Fì!"Ü:TÍù.®=¯ÜÃ,õ€ˆ‰õí·ä6ÙÒÃS'I‹ß(á¿ªì´ÖÌˆ4Á³ªšpkÕ¬Ã"ÚåFÂf»h¿³m—”¿’ÌÉuðVµÙ¬µz‹=ºÔ£\Vƒz	
8oÿîÉƒ9&çìÝ—‡¥hØí*y˜8^¿´DÌžº8øú$ä
Ù4úðö6Û¶r¿VH¬$%¤gœEâÄŠ>@}	ÅEDH¡Â™ç­G’‹!óˆ8fÍùa«é“´ÂÎ ±Rå§Ú¢€lQUGæìø²QíJåaáœ»•64v½~zÉs²Â>›0ù&WEª]I‰—ìŠú)ÄdFLàÃV~¿8i‰Ýë·x-èY³¶¿A$sÓonÔfsf5ËNdãÁŒÇŸ^Œ÷^'k(¯foq²ò·=;›f7ª’ž
1‡dK|±J/òáà+³=\m_º	JäwªˆâØ`T;'UÙ®&#þ6Y‚;]—º{˜o‰K«ïVÇ®„Ü2Fn:ë˜!ž#-•¬ÙJug¾Œït|¸ º±nŒ—¸½ÝeEP÷EóÁWðÉ1¼F}ƒÄ"Þ77±‚þ)f†Ù­öY}yô"Žì8ôIKèkÐr<P'EB}áAùjìòNùµóivïL×}ŒÄ%DðT
§× Rvò)¿â‡ùèÉ‚ŸÇ“}âÛÑ‡ð›ÿ%Œ#èøØ²"‘úí±/BÑìÍ¸˜úþv–ãÁ û7?ÞdeY0ü9ñáÆM¶ñ>
O°|à©|QÔñ8°ûƒI¥Nøu–éÐYæËõ˜¯áM½ÃüÎo*íè¯Î®{3)>sp}dóa¯&Ùù`Ð¿|(Ž!KäM\F¶õ°¡}ÐN>AÐ§=ÊG®>€™½ú¯É…{cÅ¯¨R7@¶ûÑY47¸‡þ†ÔÕ·‰¿aßRÜy&¨žG€üJØaÑc…Š‹xç=x¬)æÿzÿädÿð0 ?:>½8ù÷ý×¿îïï½8èƒ¢óâ¦˜‚À§øÃuqÓêi)Â~«gV†[=µË éx¢”
´£âQò[0€½èÎdúO;%G†C¢“auæs1"Ä`ÈÀŽˆ‚1˜‹
!ö&Ÿp:7ðùÏêÂ¯Â’úÙdxª`ÝZd
fÊyÚ]=¹p‘¤z€È; ªÚ[IŽ•ú˜‘rŠÀQx¬qd¶@„Mx(éUè§üžíèˆÕrf„›¢¨%TBoÓòû23¡Çíý·sÆ[Ÿï6ø£ríou¢‘jÝÕ-hl<j¥Œ›fˆXÀ¯ýbƒÙ¤)×‹ÑÏ§#@>Þ¬§c©ðã§&®Œ.j-É©Ò|¾Réü*«P“ö ¢ø]ª*”\¿‡J9¨+“i¶…ùQÏk4"ô®«sØ Æ­J!dQzœçºü¼Ýµ#¹Ú?¸#’jC^–ŒéZß¿«l»ªï“:DãèÃ¸ëD«õj§ë[–“‘Û”ö•p‚Ð úÝÄd¼%9ƒ.ÏAmîµO&	(‘¤'<
[v,1‰OíæÈvpƒ^½ˆcBôd—ÙH¤ÜdïsXá³Ñý]v_­›—Ž(Î&ã1DœG‘íG`Ò3š{VÊG=ºZÂC+¦Hmw¶SÁuuT{ÕëÁ{ÍwK+œÊ½Ã±,m^S)VucüJ…ÊCòÜ1h²IÞ®ŽÐ)„’+K,Ã0ÿ‘ÎM\ÒÛs‡jŸ½îÿÒÿ_îžµ¹Éïúpâ*‘M%›ûDž¢“e9ÑÆ–]–\¹-K‘#iÖ$GÅ!¥(*þ÷EwãÆÌHöV6Ç*ËäÐh4€F£Ñ³ãýw‡'öOŒ˜?n®i»áªøðhØyºwêå2ÏÿÈaT¦”ÙŒma+¬ÏU9V`v1Ú:z"ŠjÝrH«”kj'JÎM¾ª³yIŒÑT-ägÞ°ô/‹™œqÎèÌ¸c|ý+á¹ÕŸg7²0æ°f¼3±')§Â¼›ÉÂ®Ç8g|øDsð9‡(+Ïˆ…—÷D¯_óû£Ëã<ÇÜÀÐÕ±Ó…¿ðGµöüAãVÀ\Ö­°þæ<B¡6Â‘j$ kMK4W½¬fC½¨®‹ËUgD±£ÏÏÎn–åª<; vððÜM%ƒ¡Ë×«›õŠ!‰4j
¡RB¡£&õH­‰q‘Uù íäÀ…ÇÅâ)ŒBÙÏ°9gèÅÁ‚‰hçËOm¨H'¦Ëç;/¾=;ûðéãáÙÙ‹çI~´é< Z›PrôüA¹ÿÏ²XtÎ±Äyw3îž‡Ü*qÆÁ=×ùLb‰Ë°ÓbaOðwlò³ª«ìs.÷ü%ÊˆÈ±à¶?[LÅÊ
ìÑŠT|,¤~5[¡ Gšžè Ðwî‘ÿ°çø@Ìüênºçu‹ð%Vüxt©žE3ÝÒf+ü¸)UÇóØ6’U ä»ðÇ 1<÷×cG ‚WÚ—9bH®ìŽ›+k+4öìªkŽlwí®hùÆ9MrÜÞ­^Ávæ/âN¸ª]°)Vø(ÚQÜ8ü=Ÿèüðáì_"q ³ª#Xbú‰ç_ZxÃÝÞSBK¬#¨ÃIü÷nØ•°Ñ-oLva³ì×ÝF*Í>n »»M3JzÂœ-Ÿ í	ÚãÄ*‘ðž9‘NZ^1úE
KS*Æ¬²¢‡î’öðºÞ°!,åïäAÿ¸Ú:*W‡W­1_GpøIU®›œ.ãQH¤ÕNbSæ/ýMzHjV–é’J·²iM†Ç“iÞýY;%DJðnÍ¤?N$éJÌÓV‰®Žù]:nD›æòí¤Åúè!‘€Nç_õ ÎÇOg˜a°·’)¾ÆùsŒL1ŒP©/®o¶¶¤P-^­‹Ùôƒ”?äé‹ÌŽ}¬áÛ'#çë7oßï¿>Û?~±gO¿}(˜EøbXdÿxÿí?TíàyR[íçÃãÃû§TïoðÇ>nmºN/àüéþÜ›n×Ü‹Våz9Éße7ÙäZçmùM.zù†tçÅ‹-ñB)æfy¶¬0	d°¬dP<¿Ìf³J®–Égð¡L¾ 2t4E5D``“òœ#ä¿ùª"0¤ù»ÈÅm¾¼3†¯Ë˜1‹r¡ ÏQœ™•‹«|	 W×„•¨ÃÎ ržM+(}SÊ’×¹lk½*fÊ*°Ø±F¸Ë¼ÊWØýÓòpîLà§ž ÀºðA_uéÆ˜¨‰œ
B.›æ^1w¢&à(buøúî’`Kˆ]7é&è›!8v²#¿ôDež=ÛSù,V.MÔìð§0,ï <âéOšÊ¡°¾1¨<ã±†ñ¹„qD\˜[xÅª­úÙW—þÝ­z·«Í¸8Wc
»äÄ.Áï =¶ÒC'R7løNüýäý1¥Íö°q›êÏ™9¨ZõÇGˆÑØ×4ódu™·9^ˆÄv`]Ü|YÆ™Â.¾C§hQíSŽ¤×Šëì’užÚñÿN«;ÜŠ§®ín°xq{1zƒ0D2|òE3$ËT¢Š‹­ÅÍC¹ßÊØ†wvÄ«{yŽºÆhØèE~)á³…R/ƒ³Ó]Žl@J\¨”Íå)¹!.œ‰Ü*úÝµ<y³µÐ/Á¸†ø¬bå1»7ªì>íà”‚ÛD)®àÆQ–XæÓõ$wÁ`p‹‘¬yê-U" ô
’MæËy¯/ÊÕµÂY"UÌic˜çóR2ûu•]å}ô¡ç'Œ7òè`°åSB¥êßÑe8ËÄ´Ì«Å6Ü= |…Û Å,êsÊ3¼«&ùBŠQ¥BŒû¨yrXŠK=š!xÄÄ]VÙC«¬q¹,çøÐMO&›ØÑ KSË@8n9Ü!t-)ë‹#Ùí¼^pÎ‘e7êaâ@"Âëbå"µññTØSó7¤œuí}êvæ ¹÷ã&‡ÚÑèA°yB..[±'ÜÝPA·¯‡^X<I £ig®'­*=ÇœÐA9}0„$ŒhWâïŠ”‡^h`Ä‡è&ÅÙÈ°´‘ ôsãbã‰Ý¸ÍKýÂ‹us é|k	½º+¸ÒF˜¨~SÞÄ7K8Õœn˜g¤	ÑÇ"/ÅÁ­-<æõcºý·
ZÂäW ¥D²¨ï®	ÎGhXTìzÀGîÆÇT‰Ð¦;uÃ~E:»‹ŸvÍÔg¹ÙzŽ¼TÇsðà£!x›Yø!è{ôã¸—,´µ%åÑç;ñ[x3dká.˜‰O±¼À¤@x^¢„žßdÀ¼¤°XÎns³×[È1À„ ýo<YM­^]lh=öOO?½útzxöëá?~{ÿñõ‰“=w´É]w	0·ï$GÝ†«/wåSñêdæ¡Ù7º»ùkþRD\}¯ãB~åáfåÕgúN:Ž g›ë†â7s_5™H"˜ÂUG‹ÛlV˜Æ4hÚUhG‡‡ðgñý«¿œÆr*YkIìewÿ†9&™v:êÁ=.õxèðªÃQ¸üšßÛ*Ýî^ÿî‘²ú-»„j@œÅ¯Þzl1 *lÚþ2ýAõ7 qÂì÷Å!½Š÷¦7f”~¬9NŠþÃ­6Ž¡[©*¦Ð öo¼µv=`Óck¹ÙúõW†i:1DNÖ/{d5›7ÝŸ=HY€'¨3ˆ‰½\µd®7Ëù¡2ôp+sìÒŸ?Å1ýñ•î£ù°ÙgiÈŸžèÕ÷àŽgJ¨óêyà-ªIaO„ï”9F"ºiÅ„}§NfJ"}¡‘éöXª™ò¸ ˆˆ¸ÿþ$F>qìK9Ìwo:¨ƒˆàVåQÚN¾../åä0àöÐ¯º!ý«}kà?zÝh0ª}E´™ck½êê"Î=U­ÊyP€¶4‰Cx>Ã‘ÜÚ‚{'8n.+µñ*­¨;Â@ÝQ­Tf,JŠÕ£LÏºÃºëˆŽ÷)Ù<8ÿV<@pöB+ÿ-Y¹Míµ±WKeÝN5úüa[ˆí>xlf+ê®Oÿ«»y™FÆSŸ±O€É•âÓRÀšt”Ål·‰ú®^YÜ;RàªÅóú¤Cø*„N·šâOU>jžh>!×¨±aí/Ê»Ž×N±«&êFÝiÀUWkìNU³¢šÐŸÌ„ì@|ïËÇNß˜€ºÿš‰€¬ÊU6{§°cäñÞÀ¸ñíû¤u~¹‚Š’æûŸ‡‹é×ž­ÇçYj|Gzìd²dPj«ïvH/cz†UQõõ3ýÊ–®NU;¾çw`¨;Ï~ïD/{>VœŽÌŸŠ¹§_SFFùz×LÃ­à0:Ò³ZÍäâÖsçžØŒáœDcäÒÞÂ&(pé5¢ê˜3f$x»fíÈm Twy\®®1ˆŒ~E±mœÔ‹Ó£w‡¯Ï>¼ýôóÑñÙ/ïßÿ
§22ÛÜÎÖx0=€<ý¿dÕõ6-²í¸€“ð¼ßØ´~r•/ ¨UþjéõÓY™™:$º} }¿y¦#æ'7½÷’}¢ä?z}/%˜bBB‰ÿÊCMhÅñÝ›b–ZÎ‚§GÓðÖG_ý‚”~§ËlQÁŒFÍØ”nˆu‘•~©`,%E§­q°ÏÖòÔñ-Oq
unðY=K#Xëô¢vUX4º•¡4‘ÂÂÆF(˜á×eùæo<GÂó/–,t+áÁoŸ;§rrÅŽlœm4èPx5®?80ªçNSB®2ìçÐƒE•çsWØ{õ~®ªdK«`a»Mà´ëØÆzRvF%©9¥¤$"Û <´W=á@Û‚žpÚ²ÍA¨¦ÆÔd Ö£1sq‰GH‘ì#(;ÖéNéÀ¨ÉÅºÓ¹°Å.%FŸoK¨ouCìõ-°¨o½¹U-2kÐÙ}lµÂ‹…åyîwŸ÷aÇt‰ÊIõê•·-x©_„¶õÍí7}¨Ä.ûÏiãj’»˜}+F.xéçÖ™gËÏÄi÷ÿ5ä/€P+ùb"Ï’ûhÂi¨¤&¡}Ò/L9)ºF«èQh«ŒÝ·EU¬4Ë¯ýfw]ë“ý"ÜSiM”L@õâÊ‚+£ÒzLî¡£Ö†ÈÁ+&ÅjvÿVî·ù”RR¹ËÃgºgÉA&²™&—EÃÖt‰ÆWwK‚{#áyRLså|j‡ZäQÛhÁtyŒ|âu@IÄñ!¾)ÛÜ 	Èí7W¡Ž)Wx§M|cSìáõáÉÁÇ£à¼g.#¬%óÀñ°EüìÆµQ#BM6p{S.m ª³{&c\  ”/!pŒUù\EfØŸÍNòl9¹† …ð¿²ß_+Y—/…ë
¶`Ó8˜ßAe9ñgõ,š*ŠƒG={ýwÆb@×!YyuP,'ëY¶Ô^Ä"Æ‰8†[Àù6À&U©ãž)jT¹nÖ\±°±ï³¨;	·ÔÈ+P¶ÙÄÛ÷ÑÐ7aL8u‡ÁÙL8D«tÛŒªà¤Ö£5Lœ°¼r›Zç¸b8¶˜»]¸‡¶ØÙŽó»“Üø}‚”¤N˜Ž•­+‘Ð±Öÿ®¡› ˆvüR7ÊÀŒâ£;Ü©ƒb7D%2‰P5o¸·M¦Ý«Û‹{],ó	cÑÕ„µÛUGx\bë\¶âÀ¹)0ûd 6,f@‘E#N¡ÛõÏ´u£)ŽåƒiÙè«\wÞ'Sãº€¡­A¨Æ4ƒ•‡ZÔK÷~vZ4Iå›N¸lEyÁ\-³ˆ'0un”%Ë[¬@sÉ7=ÁFt ]Ï*ë‰ø¾>hQŽí ã‚ÿ‡þ»bŠîKÁS…N:WïE»•ÜÅõöÄìÁA¥	¨[@+è3b­_PŠcÝOfµÕ]‘¶®én^?ªô‘Ú±XÌ¼2l‰ÜqU;Z`ô´û H(»bnÜÄxY·¾ráj²,hpkÆ¬0Ú)¶?jŸÂEÞqiò—æ‹Dt©¢Ž|ÚýµKÆ†²–ÖÉîºò8‹Sõ©‚@Ø¨ÚÆÅ÷¡,¸ô!X:Æ•jâ{5W6Äpêµwˆ5å3íA/Æ.«Vü‹\‹Wvõ2sV‹`„Y­YÖº–½ r7Ž,GÎ°lý:Â_j†çÕý1\O§«,UÉ–‹c™ÏòÛl±rÇ˜ï­áÜ‡hÇÒ¨€ƒÖGc®`á²ê*5$¸¦`-Ÿ8–„;ÿ÷ý0îx'ÓÀ½R› Ñ¶u@Ï™``“/oåÆv%÷5r*|¡è¸M)gÚÙy5“+ôå´¨`~¼„°÷/ÑBñ@Hc÷’
í,Ê— ÿe6+2kãI„Á0xù |~ÞáÐáÚÐOªž`ùxOðìÚž~1C<{‚ç›yÅ/ËÈ¾Pr5Ã
þs0³åÊƒ%²¢Øº+jL¦áBcèv8QKIJ>U£RÂ„y&£÷MU”®Ø<‘´öG]¬HŒª‘.;ŽO
®åÎ«²œåYT®eÇùîîìˆßÐÑ`Q®ÄºÊÓRÇE>Ét°KW	858¸ˆqSÞ¬!vé´í5™‹©"°\®Æ–©˜ªGâq‹ÖÄ1ë£õ,€»ç0>Z¢ìU±˜²îÂ,`*ªÂrÛýíj?Õ2%c™î8¼·/i•âB-Bu!Ë­Søt|dFh,öö€cwI¯—«¶©C ¡mÀ‹¾•íÛ­0Q£éƒl9ˆUçÑ1¢‘ë¥ŠqƒÓTÇNKÅ1-\@”¨î¸±·ò<¯t´û§¸º
Š‚×:ù¸ ¹¢Èð  ¾m’ÆQ}T0((=×kÆØjx\¢)(¶•ÙÓv—Ôµýbµd*¦1ÙØôý"™"`R,X/ŠI¹\ìÜ väe…‘¦SEÿ9´ ì$öpt5é¶åXüŽÿ§õšB'ZîòÿŽ>°²^ÍšîþÄ	 Š»u½ÓOÛÞ¿l_o¿¡ÿg’y¯_LŸLêz¡xŒ¤ µháCu#9 C;ƒ‰IìÎ¢L•hý Vq6Ž@_Çø·0_µÚ¾ƒ:üUà.W~^GzEï5«cä–áöz†ø ©ä‚Â*˜¸6¼Ã ÑVù¢"³	ù=QV"ûœ¿Í¯²YÇVÛÃ6T|Íï{â¥y¥³ÖŠñ®«.Š…BîÏ:­/éC?úÝÌYG‹ž\ž±²5›Nµ_áiù¶¼óò*ªu.îµ¼³#ªõ\¬oÐ_UÙsÃIBÄ©4.„"[!×ÐÊ1ÂºZRž#þ‡?R”
í‚tða‰!¡Yyé&1 É`±™ïÈIJå=Æ¯h™Læ­ø›Q±ÿ†XÚ÷”_|%_A–¸’eJL˜bîý›ŽÈ¨&6tPªïê’÷¬¾ŽU¥ÆÃ¯“èÞƒœ¿xþ`Üc6çÌ‘`Ò"!/êZe†0ÅwM k+RFåDMW˜Ã7×h[Ÿ–¶õI¹^ _ºe‹6D£ Op9®à’^iÀåûZ²VQ¬\ˆè9áZïEe4Zè¯o¡•è½Qm1ÆqØ¥tLïZÇ*ŽÓ\®}ÍhÓ¡Â¹Ð´\ÌÊtu§å«œÝWècJ“šˆÆ•n©š×j^ê89m+d³»ì¾:¸Î'ŸóiÛJÖp‡»¾ç.6ºÃ˜X8dJÂ	£³Õ^¤8gl=3<w*êwæÂ½:‹ß^h#4„çGÊ·ÜÒ¯?N«yFaÈø±Ò‰¦íP,"G+˜(ö{µÛ›ð,Àü{÷(~“äÇ1%¤!ì×&
nyÉµ"Ú°ó‰ÔêŠþ–ÇHÅ×1Inkí«Ã'¹êÒ·ö¢†ÂBõáö+à³Š½øÄ~ÈÔþãeñ¼ý’¨ˆ	4bË™:TXnˆ$60#Z[¨¢¼;•¾]¾I˜pâN76ºÂvØÇ¤MktükÖîfA!° såÿªvn§w¼Oø^zÚ³ôO’ˆ…’é	$Úl=n—6B‚eÉÃá%öj¹N˜g+p8‡{Sã5}rGÃv[ˆ´ÀÉGlãkìYH"Ø“G b7xðx&BlÀŠðy ïÊÂÅi’r¢åáDdQ­L®;}°³47D1fD€†L1º€±M7oXñ*B¼'F¶è¸×ÓÎçé%–"[—]ûþ™]AOœ£ÇGhä8c÷PÇ/˜â·€à`¥
WWn3žA²…XÃ˜(ûmq®Î†/èø¿6cDªáÀŒCÛþÚ·Þ‘¡F«ð§*4^mT	­f5£Gp<Y˜c„}SÔ1ˆ¨w­®nTb*8×™Õ¸­pNÕª¿vvèqŠÖÓúÚu„¨ÚL¢æõPÙaç¨g³húyí$¦è¼¼M©ß6ý¥ÎdF·_¾[vn£#Ø‹:7ºÒ­aÊÑX>•{øM0†'‘ÍÏÒ8Û°]eá”¯·%Kï%j4Óú	Zªh¡ì5Ujì"Ë˜ç‡¿“b‚ÉÆÎNê³ˆP7?+¯¸3a)…uÃO™öšzÕm”¢³ðc¢VáTåR0íbgnØ—dnŠÂ]JQè¾v‹x9èÂBú~ÓÛ6·û;%ÄÈŒçŽ–|Vm¦z®¶3<c&HÖôjk‘òÍÑÔøŒ¥2uúyÉ1r%D…ìƒd¢¥Ø¤âË	N0%:+)oB¦Wnvúcà*bö8ÔûÆõ0í!H—¹©)ËçÏ4Ê¼ØbWŸYùïÜTØ<ÍêçÊ¹ÑÆ¸÷aà1Á¬xRpÝ©à<j¼5¨ùòèòà~"g«ÙÓÔ]ùÖ×.5ªœ”˜å:Ïñ->Ù™±¶)AÌåf7i	˜•E/’‹©q)±…;68îÖÌà‘ƒ™kO_ËñzWÔÌò!SËÑ=jqÖ&Šœ?Û:¶ñøÔŸMwø¸Tþ„9ÿ„´re€„0DŽÊ) Ì	ŠÝ4.åñÃJMú´#vë]7ìò{{™#)œ’"HX?=„í6‘z,­×4ßMf’òGßkÖ7_§Y‡ãsîVi¢õØ×Nm_^5‡¢YÐ¢Þ¢æbEYlT+å@¢kããÄA©ëŸÑÙ©	ÑûáV‚ße¼§§Üß¢’œ±"½Í]ŽGã®+ïöþfY^€BÇHŒJöÃ­y¸Ï"é³,_;7"Ðª'Sðzø¨X¸¹<ŽÝo¶j3½´ÉŒ9ÍÜãînPƒ«‡$`ŠdeÀ7åR"Na]ŒhÀÐ tmÚÇ(ØjMƒFË±<0Ù–=ê™òUL‰•–N‚eõÄLGÊâë¦=pZWÄp°ÛÇax½s*AïDí…)'Íð?ÞM¦Ëþ•t+Ñ{wžÉNßžß¤eŠ6/¹xk¹_0~½öÀÔ‚ÚrÚ1‚~·QàÎÍlš˜ä˜ üÓñ¯Çï;>û°úK·ïF3ÂÈO/–º½­”ŒÒñÕ­_¬°cøš{Âÿ‹TÝ¨½ÁJ`\¹›C|M€¡æQ­Y½!i—ÛÕ%’d`?ç«ýé´€.›E…cWÈ\ÉÐÛb>ØzH§¬³î${?t…9’ÿ*n–Ã{ª3+;ê«x<#^°,øÿÁböÙY@Ë‘ü°ó#_±
7SŽC3=zþ˜ÿ•6ïT!%ku¸2™µT¨‚¢*EŽGosq‘çlÅm‘QAø&´ÙÒK£WY÷r\®!—
DIš®ÁØŒyïµ×Î…5•ïór€M$Î¼HIŠ˜¶EÓ4R5bAßN«ÍŠÅgeMÊ0Ô©>áž–GópªvÜ</×áã¡pKÁ£¥PÚëãR°þ¯ØJ“l{…>¾b\œ|×”/¹Ou–î#»Çµø´¨‡»ÙjQ=cytýÉV^QŒûžøÚŽ2Þù¹\¼åZòp¡[W.«Ž7uÔ,˜gWÅä„2²MfåÂ³n2k^Á¤ª&l“S’Þô%œylÿý Ž‚rÜ¼Ä÷ï²b…jÖÃ?ÐÆUäö¢é@ÎÂ¤qË«íÔ«ê¾ZåóHwTf”7XSþõšµ—š~µw˜Úe¾ÇõÜ¬Lž'Âä…àÕª‡A( üzµ*ç~Dìž‰ðu€eô/º¤'œÕfwí	6~ŠóU¹QUŒZ±	EÁ‰ñdBÏÉÎö·ÏþÅÞ³6·qäøùô+ÚŽ+$†r’·%•V§ØÊ®·Ù%ÛÙºÒ©HŠIc‘3‡´¬hç¿_èú5Êö&Wu¬²LÎôF£4è$ô¡ê:»ƒ:9}]V¸‚YƒnOM³¯.»ÿ)ü«ÒˆvUS§ƒÆú‘£³aI› ê€ßN_üÈÊ[%:Q}y¯9ÒYšógNIºD²+ÚàššŸS_Ç\¬Af¥ä¸;ß‚0p}7]ŽMÖÅ÷\‡§˜w~´çñNQZÀ+rãßïD[¿¨:“²¸Ì¯¤(>ˆÓüê®¸Ýâ°DNy(áòý®èÞa3àÙ hí°Ë¼Ž¸qZÎfk•)Z)Üë+§¾çÞ˜G¸?¨ôž¦ÔéøÖ–ˆ#›‡ã	²é…ü­6ä+T)y_-•µµü·ÎW(Çb/„…¿ç|ÒNÊ9ÔÃµ³ˆø§Q¹Í­Iâ›É°y›»í2ûŽ2R
’KQÁ´SÆƒAc‚â8Rû14ùVE‡-D%i·puçAtY6rŠ>÷¦6ÆaÝF{5×‹éx¥™Z×aqÁ¶Eo0ˆHÄ‡‡¢;F®p‡Ž€…;Z€ŠºÝÌt,kËY¹û=É™;—€ð_‡&ñº^¼J¬N¤úb”OG@k°Ä/!4*:oˆgˆ5Ýð’.è¡Ú±tò CîàÉµäº^¹í‹à`+¼Ÿ‰_‹
©˜E¾BY:RÒ†éÏÃñ¥Š‹¨¥ $#“OŒ[ºy‚›¸
M³¹›ŽïuˆÞcbÏ ÐëÃé¨D)*ä¼\o³àE~5‹Åév±buüQ™dNG˜ÛÒ~D¨zf,ü.üã©{ƒmOÕðÓMmxåEv‘?º?nªáwµ¹›ÀÃ¯Ï’5iÆ$ª_‡¦
Ä2Í.ÖWW~Œc!y9žÜ@ˆn¦ÀDK¸}¢ §*á÷$tšÂÜíxY˜,ÝúcýkUÛöA²Y„ô‡csOtúi¢Ö	Ò5ÕAšº:‘È~VšÈ«{‚0x$é¾ª0ÖÓ9aøoïŠ)0ÐXÐƒ±…+¨ø£$d¡f­j‡/¼Š¾5ÓA^hëD‹h´‰Ø
‹½JÁ5§½(h‚Ü¦ü·ÉÖfå•ª)¿%K1^¨J³'~Ñb=ž½–BŸÎÐQ9«fÁßÄ"ePéØÅ·TsúØÐ)X:³ZÆ¦r™ý¶Îª•gãÕóÙmgöðƒŽ74÷œÔÛÙm#Mé
jÎ³ä$
ŸŠºb÷o+ÀL»zo£ãexÂQ€EúþÎáï)Æî¦36Ê”›AdSRU_/KÙó¼kD ¾Í¼çÃÑG…aOtú¤
¶#så‘£
"ˆ£7o•w¾ÜòK8~7w‚¤Š„AÀÉ3ëT’Iö{¢ÅtY.P¶ IÚ|•¬29Y#žÂ%ÂªcêÖt)›G'ÒÛœ¤•Ê0sˆ üìõ;”€¨}%y«„Ÿ¶·“š®ÌQ¿¶Pÿ`|ÀIJÌ¨j®~cbrä:Ç7JÑ(1É‘xyúN|E®Ë+ÀŸ„Ó„’É^'µŽ1}Ñ!944ÜÉ%¤×gøÒñC ª•í¼\®Ñîo¤¬Ô…°¶“°°Kšö£õëèÓù‡DÐ¦Q#1ßì»‰¾„ +dß6ÚÛß4^S´íÈ¼ã™¤åU¸rAWå?Þ¼:‰9¼xiµÚsI×“MÔ,§Xc€U[nÈ1=NÕˆšÄv>_„0~“z	ÃÞù[JÎ¦
P?´ßÜ
Ê8jŒ^ï–ð]‹œâþK·.·G©jŽ™0ZØhC{"a!pª1ÍSU`OÜ¢®MA•vzbÞ1|üñ NQÃj#nõŒWG³…_Úuæ¬¢˜»ï67Prç„Xº%³¨v×èãÝ¤o¶S7a!wÊÄØˆíâ %Ï§ 	JÆ-É¸i›Œ-A¥ g‹nž×c‡UêÉ×_Gš S×y„EkÙ
`. ud gSë]Þî	ë¨Ÿ 7åÞ«¥”m¨/rØ÷hšväín¤àÖ,ÓA'Þ	kl¾)¢ aàÆh7Lm]á½J3òß8Ï
ÏIBÑGWSN¦! ±!Aq°6ö™¸¼eªoÀUª+%w’$Î±~åß„…oøÂ¸{¼uðþ±ÁÑÑ~¡6—Ç˜2Œ¼Íæˆ4ú2—«f Í«~[«¼r®ðëðÞŸ==W™ó'eywÊaÐn¨"sOKHOÀô¢ÈS/1ÔbPb­¤Mß‰n®ŽÐm8û>JGY'ITbP]zîå§LüïŠü·uæiìÔÐý—pNR<pKß$—™=_Ã‘ñJAsŒÏ¨ÇáI’ññÇ(ýæ*–d2~IÃ*{IR™ùáªä~8„*Ù]b™Òã­>AËa•BÒv)B“<iÿ6ÂàIÐ^ÞEÓY¥Ç,…86å¦×€IÏ9‚qŸèsåPÇöú´jEvN
 Š@Ä¿˜;®È/‘Ývå·]£7ÖœbàÐ-¢Vÿž÷´n¸	3ÖMkÑ¶#"ø¤—Ÿ½9¢Æ§‡o:ýhÚ 5è“ùl†ÈÀà—ñZjââï`{la¥êF1Éñ“®xG}»ðîÁÝÛb{`!4_¹'«›`ýRk‡9¼Ý›}"‡>Í¨Ñ{\dä<÷*
Z/ÍK%X%Ÿ¼@¾è’À¯ñ‘à+3ú…­þ;—ÐË&E·ÓM|{êÜMöë„™½ä˜ÓÓótîê»…'è‹‹ñUöÁ`°¡D38ßS•ñƒ^ËŽ@)—ýÒ^Jfß£ï5d(†²¦€ÙÂlÈäòo»J%|nCñ,"€Ó`r_H
¬¥û0C3PÝÚ*\
¿6©uaÁl¶ï£úÀ™±ü!„aÁk+…ÐÏ‡ÈäÊLïz-ÀŸßEæçŠ‹kÞÚš‘cg“lA>&&|“†˜¯+tqâ…i‹y²Ìq?QZCz’ÞCl|ÁMgÏÛV¶#Þ·ÅY{
Ð5>}&¡·—ÚIŒje´ •pŠMÙAj²akˆQAA4MYe2°Nù%} Bò4c«úX=ÕÕûÌ›­_Ž cª;Tª FÅê.Ày˜P¾†¡jhùDÛAÓm«ö¿éDß°ÖŠSË,¹™FšÀ	OÖˆu[ª©‰÷íÎ¶âUP!.©¥ä-¤>|°Am¦¿ŽëV°žýŒ¸d×a‹Ô4Òâbk×¾¢tÌÊ¼+ «Êò¯}‹éãÉÛZ]×mË”`ˆ_3å6([Ãj——rê^æ…œšïE9&‰‰Ð;¸DÌÖó¢/ðt±Ö'D¬é¡©ÏÂÍjd*†äùñûuc—±9vâë"äãÕäZt‘=ýA'î£¼|õ·—Ç¿¿þóèô¤/ì
s’gÐ¢j—üù(ˆB™Ûx}¦D…Á%“-ú*…ê/MÿM¹§R»SP‰xIòÒ8å£ÔÓåÜÀ²+ñé]1µ¯ÛÜïjÂÁ† ÞŸ)vw )\áÖsël /¤Bûw%U9*pöyÄc%+<^ß­¬YCnÜým‹I*~™MDU–X7aÛ…‚/Î¾%„Û…BçŸmÆ†ÇŠ¬ÉÔù×¿þÕÁÑç@: Æ(#yÁ càó02,f“«„uãæH
ýû;›EŽ“h.]kS€"Tæ ÇŸ‹'‘‡£ó.“×‡,¦1nbþKÒ®ŠN'ˆ‚x.A`¼Å6gáÒmÙØ	ä´´ïŸçËHÅ~0ð´ò1KlÚ0:Ù®Ü`	A¶­Vöµlj¶[gª6è.†äV¹!D‰½îKEKc@ƒ|ˆ‘ÊLì.'Â¡—¯Ê¿(ˆ¿°â‰¼ù¬ÒñÇd%o}x<t©°˜±Ø^• €Säv
9À«Ü`u0ê!¨¤
f}$6EQ†ª	ËþÆ›á^`9µ9kÌµsÂÑ[›É\ÓûÂGÞ?)Ì^Õ7ç±jÆ´Ã«[žUfâB(”]P~i‘W~“F7^]/ËõÕµ˜"w€3{3A,ÀùxªáC7Œùò¶T3t–"ñ€=ÒGwl“”ì¤àÙ|ä–¦ÔF(œ$×pj{oZôW:ý©·T¬ë$ï@þhéž&«ÎuxÆx£‰´gŒ'±ò/ój¥"ú'›<ß4´®²©‹ÂXÓgOÏ£wbe7FàÖ!½®£Ç¶Ò‰Í.ó¬,.gùDŸïU8
.¦a?ÓóvÞc‰ˆáŒÆ›HH§þêù+Òq!“)æ +äÒØd2p%3_iþ}‘á5òY~#Y¸	–ÿxûX¨éeüiDsüñsÍvó×8½´šû£ùE~µ.×&³!†Ê§z¥5ˆsúùWGæJÓJZ¯{ÚÌšçºwÔÍ'+l®³ul¦@;È‚	h²5„i¶«04)ÆÒˆ
XAÛüu”p£‡f" Šƒ-ƒïëß’	>)Kß©R@º4ôc±Û¦fbwÜ(D¦QN³ƒºXøÝp0a#B[ØL«¾ZVŽíô,ýTXŸè7œ¨ØrlvÓ%T[—Oqu½„{•Î3diÎ¥\hšTèc`Ûtµkû<tú÷‰Á–Mç‘ÅsU¸F¦…qÄ‘8p78˜Jå™‡¹ƒe/ó¼ E[÷ª<3Â|L{©„6ö6…ªì4>Z/ú£ÛÂÆõ×¦ÿ^v3aÒßdÐÂ€®ôs9Ä‹êRÆÆÐ‰¼PÓ½¯ŒŽùÃ9¡HŠ)˜=Lí