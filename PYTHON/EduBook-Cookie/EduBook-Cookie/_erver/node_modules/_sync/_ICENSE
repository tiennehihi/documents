n*/
        false
      ), indexInfos);
    }
    setStructuredTypeMembers(type, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray);
  }
  function appendSignatures(signatures, newSignatures) {
    for (const sig of newSignatures) {
      if (!signatures || every(signatures, (s) => !compareSignaturesIdentical(
        s,
        sig,
        /*partialMatch*/
        false,
        /*ignoreThisTypes*/
        false,
        /*ignoreReturnTypes*/
        false,
        compareTypesIdentical
      ))) {
        signatures = append(signatures, sig);
      }
    }
    return signatures;
  }
  function appendIndexInfo(indexInfos, newInfo, union) {
    if (indexInfos) {
      for (let i = 0; i < indexInfos.length; i++) {
        const info = indexInfos[i];
        if (info.keyType === newInfo.keyType) {
          indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly :