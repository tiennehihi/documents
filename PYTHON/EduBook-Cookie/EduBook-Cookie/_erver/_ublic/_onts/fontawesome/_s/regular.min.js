tion transformClassMembers(node) {
    const shouldTransformPrivateStaticElementsInClass = !!(getInternalEmitFlags(node) & 32 /* TransformPrivateStaticElements */);
    if (shouldTransformPrivateElementsOrClassStaticBlocks || shouldTransformPrivateStaticElementsInFile) {
      for (const member of node.members) {
        if (isPrivateIdentifierClassElementDeclaration(member)) {
          if (shouldTransformClassElementToWeakMap(member)) {
            addPrivateIdentifierToEnvironment(member, member.name, addPrivateIdentifierClassElementToEnvironment);
          } else {
            const privateEnv = getPrivateIdentifierEnvironment();
            setPrivateIdentifier(privateEnv, member.name, { kind: "untransformed" });
          }
        }
      }
      if (shouldTransformPrivateElementsOrClassStaticBlocks) {
        if (some(getPrivateInstanceMethodsAndAccessors(node))) {
          createBrandCheckWeakSetForPrivateMethods();
        }
      }
      if (shouldTransformAutoAccessorsInCurrentClass()) {
        for (const member of node.members) {
          if (isAutoAccessorPropertyDeclaration(member)) {
            const storageName = factory2.getGeneratedPrivateNameForNode(
              member.name,
              /*prefix*/
              void 0,
              "_accessor_storage"
            );
            if (shouldTransformPrivateElementsOrClassStaticBlocks || shouldTransformPrivateStaticElementsInClass && hasStaticModifier(member)) {
              addPrivateIdentifierToEnvironment(member, storageName, addPrivateIdentifierPropertyDeclarationToEnvironment);
            } else {
              const privateEnv = getPrivateIdentifierEnvironment();
              setPrivateIdentifier(privateEnv, storageName, { kind: "untransformed" });
            }
          }
        }
      }
    }
    let members = visitNodes2(node.members, classElementVisitor, isClassElement);
    let syntheticConstructor;
    if (!some(members, isConstructorDeclaration)) {
      syntheticConstructor = transformConstructor(
        /*constructor*/
        void 0,
        node
      );
    }
    let prologue;
    let syntheticStaticBlock;
    if (!shouldTransformPrivateElementsOrClassStaticBlocks && some(pendingExpressions)) {
      let statement = factory2.createExpressionStatement(factory2.inlineExpressions(pendingExpressions));
      if (statement.transformFlags & 134234112 /* ContainsLexicalThisOrSuper */) {
        const temp = factory2.createTempVariable(hoistVariableDeclaration);
        const arrow = factory2.createArrowFunction(
          /*modifiers*/
          void 0,
          /*typeParameters*/
          void 0,
          /*parameters*/
          [],
          /*type*/
          void 0,
          /*equalsGreaterThanToken*/
          void 0,
          factory2.createBlock([statement])
        );
        prologue = factory2.createAssignment(temp, arrow);
        statement = factory2.createExpressionStatement(factory2.createCallExpression(
          temp,
          /*typeArguments*/
          void 0,
          []
        ));
      }
      const block = factory2.createBlock([statement]);
      syntheticStaticBlock = factory2.createClassStaticBlockDeclaration(block);
      pendingExpressions = void 0;
    }
    if (syntheticConstructor || syntheticStaticBlock) {
      let membersArray;
      const classThisAssignmentBlock = find(members, isClassThisAssignmentBlock);
      const classNamedEvaluationHelperBlock = find(members, isClassNamedEvaluationHelperBlock);
      membersArray = append(membersArray, classThisAssignmentBlock);
      membersArray = append(membersArray, classNamedEvaluationHelperBlock);
      membersArray = append(membersArray, syntheticConstructor);
      membersArray = append(membersArray, syntheticStaticBlock);
      const remainingMembers = classThisAssignmentBlock || classNamedEvaluationHelperBlock ? filter(members, (member) => member !== classThisAssignmentBlock && member !== classNamedEvaluationHelperBlock) : members;
      membersArray = addRange(membersArray, remainingMembers);
      members = setTextRange(
        factory2.createNodeArray(membersArray),
        /*location*/
        node.members
      );
    }
    return { members, prologue };
  }
  function createBrandCheckWeakSetForPrivateMethods() {
    const { weakSetName } = getPrivateIdentifierEnvironment().data;
    Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
    getPendingExpressions().push(
      factory2.createAssignment(
        weakSetName,
        factory2.createNewExpression(
          factory2.createIdentifier("WeakSet"),
          /*typeArguments*/
          void 0,
          []
        )
      )
    );
  }
  function transformConstructor(constructor, container) {
    constructor = visitNode(constructor, visitor, isConstructorDeclaration);
    if (!(lexicalEnvironment == null ? void 0 : lexicalEnvironment.data) || !(lexicalEnvironment.data.facts & 16 /* WillHoistInitializersToConstructor */)) {
      return constructor;
    }
    const extendsClauseElement = getEffectiveBaseTypeNode(container);
    const isDerivedClass = !!(extendsClauseElement && skipOuterExpressions(extendsClauseElement.expression).kind !== 106 /* NullKeyword */);
    const parameters = visitParameterList(constructor ? constructor.parameters : void 0, visitor, context);
    const body = transformConstructorBody(container, constructor, isDerivedClass);
    if (!body) {
      return constructor;
    }
    if (constructor) {
      Debug.assert(parameters);
      return factory2.updateConstructorDeclaration(
        constructor,
        /*modifiers*/
        void 0,
        parameters,
        body
      );
    }
    return startOnNewLine(
      setOriginalNode(
        setTextRange(
          factory2.createConstructorDeclaration(
            /*modifiers*/
            void 0,
            parameters ?? [],
            body
          ),
          constructor || container
        ),
        constructor
      )
    );
  }
  function transformConstructorBodyWorker(statementsOut, statementsIn, statementOffset, superPath, superPathDepth, initializerStatements, constructor) {
    const superStatementIndex = superPath[superPathDepth];
    const superStatement = statementsIn[superStatementIndex];
    addRange(statementsOut, visitNodes2(statementsIn, visitor, isStatement, statementOffset, superStatementIndex - statementOffset));
    statementOffset = superStatementIndex + 1;
    if (isTryStatement(superStatement)) {
      const tryBlockStatements = [];
      transformConstructorBodyWorker(
        tryBlockStatements,
        superStatement.tryBlock.statements,
        /*statementOffset*/
        0,
        superPath,
        superPathDepth + 1,
        initializerStatements,
        constructor
      );
      const tryBlockStatementsArray = factory2.createNodeArray(tryBlockStatements);
      setTextRange(tryBlockStatementsArray, superStatement.tryBlock.statements);
      statementsOut.push(factory2.updateTryStatement(
        superStatement,
        factory2.updateBlock(superStatement.tryBlock, tryBlockStatements),
        visitNode(superStatement.catchClause, visitor, isCatchClause),
        visitNode(superStatement.finallyBlock, visitor, isBlock)
      ));
    } else {
      addRange(statementsOut, visitNodes2(statementsIn, visitor, isStatement, superStatementIndex, 1));
      while (statementOffset < statementsIn.length) {
        const statement = statementsIn[statementOffset];
        if (isParameterPropertyDeclaration(getOriginalNode(statement), constructor)) {
          statementOffset++;
        } else {
          break;
        }
      }
      addRange(statementsOut, initializerStatements);
    }
    addRange(statementsOut, visitNodes2(statementsIn, visitor, isStatement, statementOffset));
  }
  function transformConstructorBody(node, constructor, isDerivedClass) {
    const instanceProperties = getProperties(
      node,
      /*requireInitializer*/
      false,
      /*isStatic*/
      false
    );
    let properties = instanceProperties;
    if (!useDefineForClassFields) {
      properties = filter(properties, (property) => !!property.initializer || isPrivateIdentifier(property.name) || hasAccessorModifier(property));
    }
    const privateMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
    const needsConstructorBody = some(properties) || some(privateMethodsAndAccessors);
    if (!constructor && !needsConstructorBody) {
      return visitFunctionBody(
        /*node*/
        void 0,
        visitor,
        context
      );
    }
    resumeLexicalEnvironment();
    const needsSyntheticConstructor = !constructor && isDerivedClass;
    let statementOffset = 0;
    let statements = [];
    const initializerStatements = [];
    const receiver = factory2.createThis();
    addInstanceMethodStatements(initializerStatements, privateMethodsAndAccessors, receiver);
    if (constructor) {
      const parameterProperties = filter(instanceProperties, (prop) => isParameterPropertyDeclaration(getOriginalNode(prop), constructor));
      const nonParameterProperties = filter(properties, (prop) => !isParameterPropertyDeclaration(getOriginalNode(prop), constructor));
      addPropertyOrClassStaticBlockStatements(initializerStatements, parameterProperties, receiver);
      addPropertyOrClassStaticBlockStatements(initializerStatements, nonParameterProperties, receiver);
    } else {
      addPropertyOrClassStaticBlockStatements(initializerStatements, properties, receiver);
    }
    if (constructor == null ? void 0 : constructor.body) {
      statementOffset = factory2.copyPrologue(
        constructor.body.statements,
        statements,
        /*ensureUseStrict*/
        false,
        visitor
      );
      const superStatementIndices = findSuperStatementIndexPath(constructor.body.statements, statementOffset);
      if (superStatementIndices.length) {
        transformConstructorBodyWorker(
          statements,
          constructor.body.statements,
          statementOffset,
          superStatementIndices,
          /*superPathDepth*/
          0,
          initializerStatements,
          constructor
        );
      } else {
        while (statementOffset < constructor.body.statements.length) {
          const statement = constructor.body.statements[statementOffset];
          if (isParameterPropertyDeclaration(getOriginalNode(statement), constructor)) {
            statementOffset++;
          } else {
            break;
          }
        }
        addRange(statements, initializerStatements);
        addRange(statements, visitNodes2(constructor.body.statements, visitor, isStatement, statementOffset));
      }
    } else {
      if (needsSyntheticConstructor) {
        statements.push(
          factory2.createExpressionStatement(
            factory2.createCallExpression(
              factory2.createSuper(),
              /*typeArguments*/
              void 0,
              [factory2.createSpreadElement(factory2.createIdentifier("arguments"))]
            )
          )
        );
      }
      addRange(statements, initializerStatements);
    }
    statements = factory2.mergeLexicalEnvironment(statements, endLexicalEnvironment());
    if (statements.length === 0 && !constructor) {
      return void 0;
    }
    const multiLine = (constructor == null ? void 0 : constructor.body) && constructor.body.statements.length >= statements.length ? constructor.body.multiLine ?? statements.length > 0 : statements.length > 0;
    return setTextRange(
      factory2.createBlock(
        setTextRange(
          factory2.createNodeArray(statements),
          /*location*/
          constructor ? constructor.body.statements : node.members
        ),
        multiLine
      ),
      /*location*/
      constructor ? constructor.body : void 0
    );
  }
  function addPropertyOrClassStaticBlockStatements(statements, properties, receiver) {
    for (const property of properties) {
      if (isStatic(property) && !shouldTransformPrivateElementsOrClassStaticBlocks) {
        continue;
      }
      const statement = transformPropertyOrClassStaticBlock(property, receiver);
      if (!statement) {
        continue;
      }
      statements.push(statement);
    }
  }
  function transformPropertyOrClassStaticBlock(property, receiver) {
    const expression = isClassStaticBlockDeclaration(property) ? setCurrentClassElementAnd(property, transformClassStaticBlockDeclaration, property) : transformProperty(property, receiver);
    if (!expression) {
      return void 0;
    }
    const statement = factory2.createExpressionStatement(expression);
    setOriginalNode(statement, property);
    addEmitFlags(statement, getEmitFlags(property) & 3072 /* NoComments */);
    setCommentRange(statement, property);
    const propertyOriginalNode = getOriginalNode(property);
    if (isParameter(propertyOriginalNode)) {
      setSourceMapRange(statement, propertyOriginalNode);
      removeAllComments(statement);
    } else {
      setSourceMapRange(statement, moveRangePastModifiers(property));
    }
    setSyntheticLeadingComments(expression, void 0);
    setSyntheticTrailingComments(expression, void 0);
    if (hasAccessorModifier(propertyOriginalNode)) {
      addEmitFlags(statement, 3072 /* NoComments */);
    }
    return statement;
  }
  function generateInitializedPropertyExpressionsOrClassStaticBlock(propertiesOrClassStaticBlocks, receiver) {
    const expressions = [];
    for (const property of propertiesOrClassStaticBlocks) {
      const expression = isClassStaticBlockDeclaration(property) ? setCurrentClassElementAnd(property, transformClassStaticBlockDeclaration, property) : setCurrentClassElementAnd(
        property,
        () => transformProperty(property, receiver),
        /*arg*/
        void 0
      );
      if (!expression) {
        continue;
      }
      startOnNewLine(expression);
      setOriginalNode(expression, property);
      addEmitFlags(expression, getEmitFlags(property) & 3072 /* NoComments */);
      setSourceMapRange(expression, moveRangePastModifiers(property));
      setCommentRange(expression, property);
      expressions.push(expression);
    }
    return expressions;
  }
  function transformProperty(property, receiver) {
    var _a;
    const savedCurrentClassElement = currentClassElement;
    const transformed = transformPropertyWorker(property, receiver);
    if (transformed && hasStaticModifier(property) && ((_a = lexicalEnvironment == null ? void 0 : lexicalEnvironment.data) == null ? void 0 : _a.facts)) {
      setOriginalNode(transformed, property);
      addEmitFlags(transformed, 4 /* AdviseOnEmitNode */);
      setSourceMapRange(transformed, getSourceMapRange(property.name));
      lexicalEnvironmentMap.set(getOriginalNode(property), lexicalEnvironment);
    }
    currentClassElement = savedCurrentClassElement;
    return transformed;
  }
  function transformPropertyWorker(property, receiver) {
    const emitAssignment = !useDefineForClassFields;
    if (isNamedEvaluation(property, isAnonymousClassNeedingAssignedName)) {
      property = transformNamedEvaluation(context, property);
    }
    const propertyName = hasAccessorModifier(property) ? factory2.getGeneratedPrivateNameForNode(property.name) : isComputedPropertyName(property.name) && !isSimpleInlineableExpression(property.name.expression) ? factory2.updateComputedPropertyName(property.name, factory2.getGeneratedNameForNode(property.name)) : property.name;
    if (hasStaticModifier(property)) {
      currentClassElement = property;
    }
    if (isPrivateIdentifier(propertyName) && shouldTransformClassElementToWeakMap(property)) {
      const privateIdentifierInfo = accessPrivateIdentifier2(propertyName);
      if (privateIdentifierInfo) {
        if (privateIdentifierInfo.kind === "f" /* Field */) {
          if (!privateIdentifierInfo.isStatic) {
            return createPrivateInstanceFieldInitializer(
              factory2,
              receiver,
              visitNode(property.initializer, visitor, isExpression),
              privateIdentifierInfo.brandCheckIdentifier
            );
          } else {
            return createPrivateStaticFieldInitializer(
              factory2,
              privateIdentifierInfo.variableName,
              visitNode(property.initializer, visitor, isExpression)
            );
          }
        } else {
          return void 0;
        }
      } else {
        Debug.fail("Undeclared private name for property declaration.");
      }
    }
    if ((isPrivateIdentifier(propertyName) || hasStaticModifier(property)) && !property.initializer) {
      return void 0;
    }
    const propertyOriginalNode = getOriginalNode(property);
    if (hasSyntacticModifier(propertyOriginalNode, 64 /* Abstract */)) {
      return void 0;
    }
    let initializer = visitNode(property.initializer, visitor, isExpression);
    if (isParameterPropertyDeclaration(propertyOriginalNode, propertyOriginalNode.parent) && isIdentifier(propertyName)) {
      const localName = factory2.cloneNode(propertyName);
      if (initializer) {
        if (isParenthesizedExpression(initializer) && isCommaExpression(initializer.expression) && isCallToHelper(initializer.expression.left, "___runInitializers") && isVoidExpression(initializer.expression.right) && isNumericLiteral(initializer.expression.right.expression)) {
          initializer = initializer.expression.left;
        }
        initializer = factory2.inlineExpressions([initializer, localName]);
      } else {
        initializer = localName;
      }
      setEmitFlags(propertyName, 3072 /* NoComments */ | 96 /* NoSourceMap */);
      setSourceMapRange(localName, propertyOriginalNode.name);
      setEmitFlags(localName, 3072 /* NoComments */);
    } else {
      initializer ?? (initializer = factory2.createVoidZero());
    }
    if (emitAssignment || isPrivateIdentifier(propertyName)) {
      const memberAccess = createMemberAccessForPropertyName(
        factory2,
        receiver,
        propertyName,
        /*location*/
        propertyName
      );
      addEmitFlags(memberAccess, 1024 /* NoLeadingComments */);
      const expression = factory2.createAssignment(memberAccess, initializer);
      return expression;
    } else {
      const name = isComputedPropertyName(propertyName) ? propertyName.expression : isIdentifier(propertyName) ? factory2.createStringLiteral(unescapeLeadingUnderscores(propertyName.escapedText)) : propertyName;
      const descriptor = factory2.createPropertyDescriptor({ value: initializer, configurable: true, writable: true, enumerable: true });
      return factory2.createObjectDefinePropertyCall(receiver, name, descriptor);
    }
  }
  function enableSubstitutionForClassAliases() {
    if ((enabledSubstitutions & 1 /* ClassAliases */) === 0) {
      enabledSubstitutions |= 1 /* ClassAliases */;
      context.enableSubstitution(80 /* Identifier */);
      classAliases = [];
    }
  }
  function enableSubstitutionForClassStaticThisOrSuperReference() {
    if ((enabledSubstitutions & 2 /* ClassStaticThisOrSuperReference */) === 0) {
      enabledSubstitutions |= 2 /* ClassStaticThisOrSuperReference */;
      context.enableSubstitution(110 /* ThisKeyword */);
      context.enableEmitNotification(262 /* FunctionDeclaration */);
      context.enableEmitNotification(218 /* FunctionExpression */);
      context.enableEmitNotification(176 /* Constructor */);
      context.enableEmitNotification(177 /* GetAccessor */);
      context.enableEmitNotification(178 /* SetAccessor */);
      context.enableEmitNotification(174 /* MethodDeclaration */);
      context.enableEmitNotification(172 /* PropertyDeclaration */);
      context.enableEmitNotification(167 /* ComputedPropertyName */);
    }
  }
  function addInstanceMethodStatements(statements, methods, receiver) {
    if (!shouldTransformPrivateElementsOrClassStaticBlocks || !some(methods)) {
      return;
    }
    const { weakSetName } = getPrivateIdentifierEnvironment().data;
    Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
    statements.push(
      factory2.createExpressionStatement(
        createPrivateInstanceMethodInitializer(factory2, receiver, weakSetName)
      )
    );
  }
  function visitInvalidSuperProperty(node) {
    return isPropertyAccessExpression(node) ? factory2.updatePropertyAccessExpression(
      node,
      factory2.createVoidZero(),
      node.name
    ) : factory2.updateElementAccessExpression(
      node,
      factory2.createVoidZero(),
      visitNode(node.argumentExpression, visitor, isExpression)
    );
  }
  function getPropertyNameExpressionIfNeeded(name, shouldHoist) {
    if (isComputedPropertyName(name)) {
      const cacheAssignment = findComputedPropertyNameCacheAssignment(name);
      const expression = visitNode(name.expression, visitor, isExpression);
      const innerExpression = skipPartiallyEmittedExpressions(expression);
      const inlinable = isSimpleInlineableExpression(innerExpression);
      const alreadyTransformed = !!cacheAssignment || isAssignmentExpression(innerExpression) && isGeneratedIdentifier(innerExpression.left);
      if (!alreadyTransformed && !inlinable && shouldHoist) {
        const generatedName = factory2.getGeneratedNameForNode(name);
        if (resolver.getNodeCheckFlags(name) & 32768 /* BlockScopedBindingInLoop */) {
          addBlockScopedVariable(generatedName);
        } else {
          hoistVariableDeclaration(generatedName);
        }
        return factory2.createAssignment(generatedName, expression);
      }
      return inlinable || isIdentifier(innerExpression) ? void 0 : expression;
    }
  }
  function startClassLexicalEnvironment() {
    lexicalEnvironment = { previous: lexicalEnvironment, data: void 0 };
  }
  function endClassLexicalEnvironment() {
    lexicalEnvironment = lexicalEnvironment == null ? void 0 : lexicalEnvironment.previous;
  }
  function getClassLexicalEnvironment() {
    Debug.assert(lexicalEnvironment);
    return lexicalEnvironment.data ?? (lexicalEnvironment.data = {
      facts: 0 /* None */,
      classConstructor: void 0,
      classThis: void 0,
      superClassReference: void 0
      // privateIdentifierEnvironment: undefined,
    });
  }
  function getPrivateIdentifierEnvironment() {
    Debug.assert(lexicalEnvironment);
    return lexicalEnvironment.privateEnv ?? (lexicalEnvironment.privateEnv = newPrivateEnvironment({
      className: void 0,
      weakSetName: void 0
    }));
  }
  function getPendingExpressions() {
    return pendingExpressions ?? (pendingExpressions = []);
  }
  function addPrivateIdentifierClassElementToEnvironment(node, name, lex, privateEnv, isStatic2, isValid, previousInfo) {
    if (isAutoAccessorPropertyDeclaration(node)) {
      addPrivateIdentifierAutoAccessorPropertyDeclarationToEnvironment(node, name, lex, privateEnv, isStatic2, isValid, previousInfo);
    } else if (isPropertyDeclaration(node)) {
      addPrivateIdentifierPropertyDeclarationToEnvironment(node, name, lex, privateEnv, isStatic2, isValid, previousInfo);
    } else if (isMethodDeclaration(node)) {
      addPrivateIdentifierMethodDeclarationToEnvironment(node, name, lex, privateEnv, isStatic2, isValid, previousInfo);
    } else if (isGetAccessorDeclaration(node)) {
      addPrivateIdentifierGetAccessorDeclarationToEnvironment(node, name, lex, privateEnv, isStatic2, isValid, previousInfo);
    } else if (isSetAccessorDeclaration(node)) {
      addPrivateIdentifierSetAccessorDeclarationToEnvironment(node, name, lex, privateEnv, isStatic2, isValid, previousInfo);
    }
  }
  function addPrivateIdentifierPropertyDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic2, isValid, _previousInfo) {
    if (isStatic2) {
      const brandCheckIdentifier = Debug.checkDefined(lex.classThis ?? lex.classConstructor, "classConstructor should be set in private identifier environment");
      const variableName = createHoistedVariableForPrivateName(name);
      setPrivateIdentifier(privateEnv, name, {
        kind: "f" /* Field */,
        isStatic: true,
        brandCheckIdentifier,
        variableName,
        isValid
      });
    } else {
      const weakMapName = createHoistedVariableForPrivateName(name);
      setPrivateIdentifier(privateEnv, name, {
        kind: "f" /* Field */,
        isStatic: false,
        brandCheckIdentifier: weakMapName,
        isValid
      });
      getPendingExpressions().push(factory2.createAssignment(
        weakMapName,
        factory2.createNewExpression(
          factory2.createIdentifier("WeakMap"),
          /*typeArguments*/
          void 0,
          []
        )
      ));
    }
  }
  function addPrivateIdentifierMethodDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic2, isValid, _previousInfo) {
    const methodName = createHoistedVariableForPrivateName(name);
    const brandCheckIdentifier = isStatic2 ? Debug.checkDefined(lex.classThis ?? lex.classConstructor, "classConstructor should be set in private identifier environment") : Debug.checkDefined(privateEnv.data.weakSetName, "weakSetName should be set in private identifier environment");
    setPrivateIdentifier(privateEnv, name, {
      kind: "m" /* Method */,
      methodName,
      brandCheckIdentifier,
      isStatic: isStatic2,
      isValid
    });
  }
  function addPrivateIdentifierGetAccessorDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic2, isValid, previousInfo) {
    const getterName = createHoistedVariableForPrivateName(name, "_get");
    const brandCheckIdentifier = isStatic2 ? Debug.checkDefined(lex.classThis ?? lex.classConstructor, "classConstructor should be set in private identifier environment") : Debug.checkDefined(privateEnv.data.weakSetName, "weakSetName should be set in private identifier environment");
    if ((previousInfo == null ? void 0 : previousInfo.kind) === "a" /* Accessor */ && previousInfo.isStatic === isStatic2 && !previousInfo.getterName) {
      previousInfo.getterName = getterName;
    } else {
      setPrivateIdentifier(privateEnv, name, {
        kind: "a" /* Accessor */,
        getterName,
        setterName: void 0,
        brandCheckIdentifier,
        isStatic: isStatic2,
        isValid
      });
    }
  }
  function addPrivateIdentifierSetAccessorDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic2, isValid, previousInfo) {
    const setterName = createHoistedVariableForPrivateName(name, "_set");
    const brandCheckIdentifier = isStatic2 ? Debug.checkDefined(lex.classThis ?? lex.classConstructor, "classConstructor should be set in private identifier environment") : Debug.checkDefined(privateEnv.data.weakSetName, "weakSetName should be set in private identifier environment");
    if ((previousInfo == null ? void 0 : previousInfo.kind) === "a" /* Accessor */ && previousInfo.isStatic === isStatic2 && !previousInfo.setterName) {
      previousInfo.setterName = setterName;
    } else {
      setPrivateIdentifier(privateEnv, name, {
        kind: "a" /* Accessor */,
        getterName: void 0,
        setterName,
        brandCheckIdentifier,
        isStatic: isStatic2,
        isValid
      });
    }
  }
  function addPrivateIdentifierAutoAccessorPropertyDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic2, isValid, _previousInfo) {
    const getterName = createHoistedVariableForPrivateName(name, "_get");
    const setterName = createHoistedVariableForPrivateName(name, "_set");
    const brandCheckIdentifier = isStatic2 ? Debug.checkDefined(lex.classThis ?? lex.classConstructor, "classConstructor should be set in private identifier environment") : Debug.checkDefined(privateEnv.data.weakSetName, "weakSetName should be set in private identifier environment");
    setPrivateIdentifier(privateEnv, name, {
      kind: "a" /* Accessor */,
      getterName,
      setterName,
      brandCheckIdentifier,
      isStatic: isStatic2,
      isValid
    });
  }
  function addPrivateIdentifierToEnvironment(node, name, addDeclaration) {
    const lex = getClassLexicalEnvironment();
    const privateEnv = getPrivateIdentifierEnvironment();
    const previousInfo = getPrivateIdentifier(privateEnv, name);
    const isStatic2 = hasStaticModifier(node);
    const isValid = !isReservedPrivateName(name) && previousInfo === void 0;
    addDeclaration(node, name, lex, privateEnv, isStatic2, isValid, previousInfo);
  }
  function createHoistedVariableForClass(name, node, suffix) {
    const { className } = getPrivateIdentifierEnvironment().data;
    const prefix = className ? { prefix: "_", node: className, suffix: "_" } : "_";
    const identifier = typeof name === "object" ? factory2.getGeneratedNameForNode(name, 16 /* Optimistic */ | 8 /* ReservedInNestedScopes */, prefix, suffix) : typeof name === "string" ? factory2.createUniqueName(name, 16 /* Optimistic */, prefix, suffix) : factory2.createTempVariable(
      /*recordTempVariable*/
      void 0,
      /*reservedInNestedScopes*/
      true,
      prefix,
      suffix
    );
    if (resolver.getNodeCheckFlags(node) & 32768 /* BlockScopedBindingInLoop */) {
      addBlockScopedVariable(identifier);
    } else {
      hoistVariableDeclaration(identifier);
    }
    return identifier;
  }
  function createHoistedVariableForPrivateName(name, suffix) {
    const text = tryGetTextOfPropertyName(name);
    return createHoistedVariableForClass((text == null ? void 0 : text.substring(1)) ?? name, name, suffix);
  }
  function accessPrivateIdentifier2(name) {
    const info = accessPrivateIdentifier(lexicalEnvironment, name);
    return (info == null ? void 0 : info.kind) === "untransformed" ? void 0 : info;
  }
  function wrapPrivateIdentifierForDestructuringTarget(node) {
    const parameter = factory2.getGeneratedNameForNode(node);
    const info = accessPrivateIdentifier2(node.name);
    if (!info) {
      return visitEachChild(node, visitor, context);
    }
    let receiver = node.expression;
    if (isThisProperty(node) || isSuperProperty(node) || !isSimpleCopiableExpression(node.expression)) {
      receiver = factory2.createTempVariable(
        hoistVariableDeclaration,
        /*reservedInNestedScopes*/
        true
      );
      getPendingExpressions().push(factory2.createBinaryExpression(receiver, 64 /* EqualsToken */, visitNode(node.expression, visitor, isExpression)));
    }
    return factory2.createAssignmentTargetWrapper(
      parameter,
      createPrivateIdentifierAssignment(
        info,
        receiver,
        parameter,
        64 /* EqualsToken */
      )
    );
  }
  function visitDestructuringAssignmentTarget(node) {
    if (isObjectLiteralExpression(node) || isArrayLiteralExpression(node)) {
      return visitAssignmentPattern(node);
    }
    if (isPrivateIdentifierPropertyAccessExpression(node)) {
      return wrapPrivateIdentifierForDestructuringTarget(node);
    } else if (shouldTransformSuperInStaticInitializers && currentClassElement && isSuperProperty(node) && isStaticPropertyDeclarationOrClassStaticBlock(currentClassElement) && (lexicalEnvironment == null ? void 0 : lexicalEnvironment.data)) {
      const { classConstructor, superClassReference, facts } = lexicalEnvironment.data;
      if (facts & 1 /* ClassWasDecorated */) {
        return visitInvalidSuperProperty(node);
      } else if (classConstructor && superClassReference) {
        const name = isElementAccessExpression(node) ? visitNode(node.argumentExpression, visitor, isExpression) : isIdentifier(node.name) ? factory2.createStringLiteralFromNode(node.name) : void 0;
        if (name) {
          const temp = factory2.createTempVariable(
            /*recordTempVariable*/
            void 0
          );
          return factory2.createAssignmentTargetWrapper(
            temp,
            factory2.createReflectSetCall(
              superClassReference,
              name,
              temp,
              classConstructor
            )
          );
        }
      }
    }
    return visitEachChild(node, visitor, context);
  }
  function visitAssignmentElement(node) {
    if (isNamedEvaluation(node, isAnonymousClassNeedingAssignedName)) {
      node = transformNamedEvaluation(context, node);
    }
    if (isAssignmentExpression(
      node,
      /*excludeCompoundAssignment*/
      true
    )) {
      const left = visitDestructuringAssignmentTarget(node.left);
      const right = visitNode(node.right, visitor, isExpression);
      return factory2.updateBinaryExpression(node, left, node.operatorToken, right);
    }
    return visitDestructuringAssignmentTarget(node);
  }
  function visitAssignmentRestElement(node) {
    if (isLeftHandSideExpression(node.expression)) {
      const expression = visitDestructuringAssignmentTarget(node.expression);
      return factory2.updateSpreadElement(node, expression);
    }
    return visitEachChild(node, visitor, context);
  }
  function visitArrayAssignmentElement(node) {
    if (isArrayBindingOrAssignmentElement(node)) {
      if (isSpreadElement(node))
        return visitAssignmentRestElement(node);
      if (!isOmittedExpression(node))
        return visitAssignmentElement(node);
    }
    return visitEachChild(node, visitor, context);
  }
  function visitAssignmentProperty(node) {
    const name = visitNode(node.name, visitor, isPropertyName);
    if (isAssignmentExpression(
      node.initializer,
      /*excludeCompoundAssignment*/
      true
    )) {
      const assignmentElement = visitAssignmentElement(node.initializer);
      return factory2.updatePropertyAssignment(node, name, assignmentElement);
    }
    if (isLeftHandSideExpression(node.initializer)) {
      const assignmentElement = visitDestructuringAssignmentTarget(node.initializer);
      return factory2.updatePropertyAssignment(node, name, assignmentElement);
    }
    return visitEachChild(node, visitor, context);
  }
  function visitShorthandAssignmentProperty(node) {
    if (isNamedEvaluation(node, isAnonymousClassNeedingAssignedName)) {
      node = transformNamedEvaluation(context, node);
    }
    return visitEachChild(node, visitor, context);
  }
  function visitAssignmentRestProperty(node) {
    if (isLeftHandSideExpression(node.expression)) {
      const expression = visitDestructuringAssignmentTarget(node.expression);
      return factory2.updateSpreadAssignment(node, expression);
    }
    return visitEachChild(node, visitor, context);
  }
  function visitObjectAssignmentElement(node) {
    Debug.assertNode(node, isObjectBindingOrAssignmentElement);
    if (isSpreadAssignment(node))
      return visitAssignmentRestProperty(node);
    if (isShorthandPropertyAssignment(node))
      return visitShorthandAssignmentProperty(node);
    if (isPropertyAssignment(node))
      return visitAssignmentProperty(node);
    return visitEachChild(node, visitor, context);
  }
  function visitAssignmentPattern(node) {
    if (isArrayLiteralExpression(node)) {
      return factory2.updateArrayLiteralExpression(
        node,
        visitNodes2(node.elements, visitArrayAssignmentElement, isExpression)
      );
    } else {
      return factory2.updateObjectLiteralExpression(
        node,
        visitNodes2(node.properties, visitObjectAssignmentElement, isObjectLiteralElementLike)
      );
    }
  }
  function onEmitNode(hint, node, emitCallback) {
    const original = getOriginalNode(node);
    const lex = lexicalEnvironmentMap.get(original);
    if (lex) {
      const savedLexicalEnvironment = lexicalEnvironment;
      const savedPreviousShouldSubstituteThisWithClassThis = previousShouldSubstituteThisWithClassThis;
      lexicalEnvironment = lex;
      previousShouldSubstituteThisWithClassThis = shouldSubstituteThisWithClassThis;
      shouldSubstituteThisWithClassThis = !isClassStaticBlockDeclaration(original) || !(getInternalEmitFlags(original) & 32 /* TransformPrivateStaticElements */);
      previousOnEmitNode(hint, node, emitCallback);
      shouldSubstituteThisWithClassThis = previousShouldSubstituteThisWithClassThis;
      previousShouldSubstituteThisWithClassThis = savedPreviousShouldSubstituteThisWithClassThis;
      lexicalEnvironment = savedLexicalEnvironment;
      return;
    }
    switch (node.kind) {
      case 218 /* FunctionExpression */:
        if (isArrowFunction(original) || getEmitFlags(node) & 524288 /* AsyncFunctionBody */) {
          break;
        }
      case 262 /* FunctionDeclaration */:
      case 176 /* Constructor */:
      case 177 /* GetAccessor */:
      case 178 /* SetAccessor */:
      case 174 /* MethodDeclaration */:
      case 172 /* PropertyDeclaration */: {
        const savedLexicalEnvironment = lexicalEnvironment;
        const savedPreviousShouldSubstituteThisWithClassThis = previousShouldSubstituteThisWithClassThis;
        lexicalEnvironment = void 0;
        previousShouldSubstituteThisWithClassThis = shouldSubstituteThisWithClassThis;
        shouldSubstituteThisWithClassThis = false;
        previousOnEmitNode(hint, node, emitCallback);
        shouldSubstituteThisWithClassThis = previousShouldSubstituteThisWithClassThis;
        previousShouldSubstituteThisWithClassThis = savedPreviousShouldSubstituteThisWithClassThis;
        lexicalEnvironment = savedLexicalEnvironment;
        return;
      }
      case 167 /* ComputedPropertyName */: {
        const savedLexicalEnvironment = lexicalEnvironment;
        const savedShouldSubstituteThisWithClassThis = shouldSubstituteThisWithClassThis;
        lexicalEnvironment = lexicalEnvironment == null ? void 0 : lexicalEnvironment.previous;
        shouldSubstituteThisWithClassThis = previousShouldSubstituteThisWithClassThis;
        previousOnEmitNode(hint, node, emitCallback);
        shouldSubstituteThisWithClassThis = savedShouldSubstituteThisWithClassThis;
        lexicalEnvironment = savedLexicalEnvironment;
        return;
      }
    }
    previousOnEmitNode(hint, node, emitCallback);
  }
  function onSubstituteNode(hint, node) {
    node = previousOnSubstituteNode(hint, node);
    if (hint === 1 /* Expression */) {
      return substituteExpression(node);
    }
    return node;
  }
  function substituteExpression(node) {
    switch (node.kind) {
      case 80 /* Identifier */:
        return substituteExpressionIdentifier(node);
      case 110 /* ThisKeyword */:
        return substituteThisExpression(node);
    }
    return node;
  }
  function substituteThisExpression(node) {
    if (enabledSubstitutions & 2 /* ClassStaticThisOrSuperReference */ && (lexicalEnvironment == null ? void 0 : lexicalEnvironment.data) && !noSubstitution.has(node)) {
      const { facts, classConstructor, classThis } = lexicalEnvironment.data;
      const substituteThis = shouldSubstituteThisWithClassThis ? classThis ?? classConstructor : classConstructor;
      if (substituteThis) {
        return setTextRange(
          setOriginalNode(
            factory2.cloneNode(substituteThis),
            node
          ),
          node
        );
      }
      if (facts & 1 /* ClassWasDecorated */ && legacyDecorators) {
        return factory2.createParenthesizedExpression(factory2.createVoidZero());
      }
    }
    return node;
  }
  function substituteExpressionIdentifier(node) {
    return trySubstituteClassAlias(node) || node;
  }
  function trySubstituteClassAlias(node) {
    if (enabledSubstitutions & 1 /* ClassAliases */) {
      if (resolver.getNodeCheckFlags(node) & 536870912 /* ConstructorReference */) {
        const declaration = resolver.getReferencedValueDeclaration(node);
        if (declaration) {
          const classAlias = classAliases[declaration.id];
          if (classAlias) {
            const clone2 = factory2.cloneNode(classAlias);
            setSourceMapRange(clone2, node);
            setCommentRange(clone2, node);
            return clone2;
          }
        }
      }
    }
    return void 0;
  }
}
function createPrivateStaticFieldInitializer(factory2, variableName, initializer) {
  return factory2.createAssignment(
    variableName,
    factory2.createObjectLiteralExpression([
      factory2.createPropertyAssignment("value", initializer || factory2.createVoidZero())
    ])
  );
}
function createPrivateInstanceFieldInitializer(factory2, receiver, initializer, weakMapName) {
  return factory2.createCallExpression(
    factory2.createPropertyAccessExpression(weakMapName, "set"),
    /*typeArguments*/
    void 0,
    [receiver, initializer || factory2.createVoidZero()]
  );
}
function createPrivateInstanceMethodInitializer(factory2, receiver, weakSetName) {
  return factory2.createCallExpression(
    factory2.createPropertyAccessExpression(weakSetName, "add"),
    /*typeArguments*/
    void 0,
    [receiver]
  );
}
function isReservedPrivateName(node) {
  return !isGeneratedPrivateIdentifier(node) && node.escapedText === "#constructor";
}
function isPrivateIdentifierInExpression(node) {
  return isPrivateIdentifier(node.left) && node.operatorToken.kind === 103 /* InKeyword */;
}
function isStaticPropertyDeclaration2(node) {
  return isPropertyDeclaration(node) && hasStaticModifier(node);
}
function isStaticPropertyDeclarationOrClassStaticBlock(node) {
  return isClassStaticBlockDeclaration(node) || isStaticPropertyDeclaration2(node);
}

// src/compiler/transformers/typeSerializer.ts
function createRuntimeTypeSerializer(context) {
  const {
    factory: factory2,
    hoistVariableDeclaration
  } = context;
  const resolver = context.getEmitResolver();
  const compilerOptions = context.getCompilerOptions();
  const languageVersion = getEmitScriptTarget(compilerOptions);
  const strictNullChecks = getStrictOptionValue(compilerOptions, "strictNullChecks");
  let currentLexicalScope;
  let currentNameScope;
  return {
    serializeTypeNode: (serializerContext, node) => setSerializerContextAnd(serializerContext, serializeTypeNode, node),
    serializeTypeOfNode: (serializerContext, node) => setSerializerContextAnd(serializerContext, serializeTypeOfNode, node),
    serializeParameterTypesOfNode: (serializerContext, node, container) => setSerializerContextAnd(serializerContext, serializeParameterTypesOfNode, node, container),
    serializeReturnTypeOfNode: (serializerContext, node) => setSerializerContextAnd(serializerContext, serializeReturnTypeOfNode, node)
  };
  function setSerializerContextAnd(serializerContext, cb, node, arg) {
    const savedCurrentLexicalScope = currentLexicalScope;
    const savedCurrentNameScope = currentNameScope;
    currentLexicalScope = serializerContext.currentLexicalScope;
    currentNameScope = serializerContext.currentNameScope;
    const result = arg === void 0 ? cb(node) : cb(node, arg);
    currentLexicalScope = savedCurrentLexicalScope;
    currentNameScope = savedCurrentNameScope;
    return result;
  }
  function getAccessorTypeNode(node) {
    const accessors = resolver.getAllAccessorDeclarations(node);
    return accessors.setAccessor && getSetAccessorTypeAnnotationNode(accessors.setAccessor) || accessors.getAccessor && getEffectiveReturnTypeNode(accessors.getAccessor);
  }
  function serializeTypeOfNode(node) {
    switch (node.kind) {
      case 172 /* PropertyDeclaration */:
      case 169 /* Parameter */:
        return serializeTypeNode(node.type);
      case 178 /* SetAccessor */:
      case 177 /* GetAccessor */:
        return serializeTypeNode(getAccessorTypeNode(node));
      case 263 /* ClassDeclaration */:
      case 231 /* ClassExpression */:
      case 174 /* MethodDeclaration */:
        return factory2.createIdentifier("Function");
      default:
        return factory2.createVoidZero();
    }
  }
  function serializeParameterTypesOfNode(node, container) {
    const valueDeclaration = isClassLike(node) ? getFirstConstructorWithBody(node) : isFunctionLike(node) && nodeIsPresent(node.body) ? node : void 0;
    const expressions = [];
    if (valueDeclaration) {
      const parameters = getParametersOfDecoratedDeclaration(valueDeclaration, container);
      const numParameters = parameters.length;
      for (let i = 0; i < numParameters; i++) {
        const parameter = parameters[i];
        if (i === 0 && isIdentifier(parameter.name) && parameter.name.escapedText === "this") {
          continue;
        }
        if (parameter.dotDotDotToken) {
          expressions.push(serializeTypeNode(getRestParameterElementType(parameter.type)));
        } else {
          expressions.push(serializeTypeOfNode(parameter));
        }
      }
    }
    return factory2.createArrayLiteralExpression(expressions);
  }
  function getParametersOfDecoratedDeclaration(node, container) {
    if (container && node.kind === 177 /* GetAccessor */) {
      const { setAccessor } = getAllAccessorDeclarations(container.members, node);
      if (setAccessor) {
        return setAccessor.parameters;
      }
    }
    return node.parameters;
  }
  function serializeReturnTypeOfNode(node) {
    if (isFunctionLike(node) && node.type) {
      return serializeTypeNode(node.type);
    } else if (isAsyncFunction(node)) {
      return factory2.createIdentifier("Promise");
    }
    return factory2.createVoidZero();
  }
  function serializeTypeNode(node) {
    if (node === void 0) {
      return factory2.createIdentifier("Object");
    }
    node = skipTypeParentheses(node);
    switch (node.kind) {
      case 116 /* VoidKeyword */:
      case 157 /* UndefinedKeyword */:
      case 146 /* NeverKeyword */:
        return factory2.createVoidZero();
      case 184 /* FunctionType */:
      case 185 /* ConstructorType */:
        return factory2.createIdentifier("Function");
      case 188 /* ArrayType */:
      case 189 /* TupleType */:
        return factory2.createIdentifier("Array");
      case 182 /* TypePredicate */:
        return node.assertsModifier ? factory2.createVoidZero() : factory2.createIdentifier("Boolean");
      case 136 /* BooleanKeyword */:
        return factory2.createIdentifier("Boolean");
      case 203 /* TemplateLiteralType */:
      case 154 /* StringKeyword */:
        return factory2.createIdentifier("String");
      case 151 /* ObjectKeyword */:
        return factory2.createIdentifier("Object");
      case 201 /* LiteralType */:
        return serializeLiteralOfLiteralTypeNode(node.literal);
      case 150 /* NumberKeyword */:
        return factory2.createIdentifier("Number");
      case 163 /* BigIntKeyword */:
        return getGlobalConstructor("BigInt", 7 /* ES2020 */);
      case 155 /* SymbolKeyword */:
        return getGlobalConstructor("Symbol", 2 /* ES2015 */);
      case 183 /* TypeReference */:
        return serializeTypeReferenceNode(node);
      case 193 /* IntersectionType */:
        return serializeUnionOrIntersectionConstituents(
          node.types,
          /*isIntersection*/
          true
        );
      case 192 /* UnionType */:
        return serializeUnionOrIntersectionConstituents(
          node.types,
          /*isIntersection*/
          false
        );
      case 194 /* ConditionalType */:
        return serializeUnionOrIntersectionConstituents(
          [node.trueType, node.falseType],
          /*isIntersection*/
          false
        );
      case 198 /* TypeOperator */:
        if (node.operator === 148 /* ReadonlyKeyword */) {
          return serializeTypeNode(node.type);
        }
        break;
      case 186 /* TypeQuery */:
      case 199 /* IndexedAccessType */:
      case 200 /* MappedType */:
      case 187 /* TypeLiteral */:
      case 133 /* AnyKeyword */:
      case 159 /* UnknownKeyword */:
      case 197 /* ThisType */:
      case 205 /* ImportType */:
        break;
      case 319 /* JSDocAllType */:
      case 320 /* JSDocUnknownType */:
      case 324 /* JSDocFunctionType */:
      case 325 /* JSDocVariadicType */:
      case 326 /* JSDocNamepathType */:
        break;
      case 321 /* JSDocNullableType */:
      case 322 /* JSDocNonNullableType */:
      case 323 /* JSDocOptionalType */:
        return serializeTypeNode(node.type);
      default:
        return Debug.failBadSyntaxKind(node);
    }
    return factory2.createIdentifier("Object");
  }
  function serializeLiteralOfLiteralTypeNode(node) {
    switch (node.kind) {
      case 11 /* StringLiteral */:
      case 15 /* NoSubstitutionTemplateLiteral */:
        return factory2.createIdentifier("String");
      case 224 /* PrefixUnaryExpression */: {
        const operand = node.operand;
        switch (operand.kind) {
          case 9 /* NumericLiteral */:
          case 10 /* BigIntLiteral */:
            return serializeLiteralOfLiteralTypeNode(operand);
          default:
            return Debug.failBadSyntaxKind(operand);
        }
      }
      case 9 /* NumericLiteral */:
        return factory2.createIdentifier("Number");
      case 10 /* BigIntLiteral */:
        return getGlobalConstructor("BigInt", 7 /* ES2020 */);
      case 112 /* TrueKeyword */:
      case 97 /* FalseKeyword */:
        return factory2.createIdentifier("Boolean");
      case 106 /* NullKeyword */:
        return factory2.createVoidZero();
      default:
        return Debug.failBadSyntaxKind(node);
    }
  }
  function serializeUnionOrIntersectionConstituents(types, isIntersection) {
    let serializedType;
    for (let typeNode of types) {
      typeNode = skipTypeParentheses(typeNode);
      if (typeNode.kind === 146 /* NeverKeyword */) {
        if (isIntersection)
          return factory2.createVoidZero();
        continue;
      }
      if (typeNode.kind === 159 /* UnknownKeyword */) {
        if (!isIntersection)
          return factory2.createIdentifier("Object");
        continue;
      }
      if (typeNode.kind === 133 /* AnyKeyword */) {
        return factory2.createIdentifier("Object");
      }
      if (!strictNullChecks && (isLiteralTypeNode(typeNode) && typeNode.literal.kind === 106 /* NullKeyword */ || typeNode.kind === 157 /* UndefinedKeyword */)) {
        continue;
      }
      const serializedConstituent = serializeTypeNode(typeNode);
      if (isIdentifier(serializedConstituent) && serializedConstituent.escapedText === "Object") {
        return serializedConstituent;
      }
      if (serializedType) {
        if (!equateSerializedTypeNodes(serializedType, serializedConstituent)) {
          return factory2.createIdentifier("Object");
        }
      } else {
        serializedType = serializedConstituent;
      }
    }
    return serializedType ?? factory2.createVoidZero();
  }
  function equateSerializedTypeNodes(left, right) {
    return (
      // temp vars used in fallback
      isGeneratedIdentifier(left) ? isGeneratedIdentifier(right) : (
        // entity names
        isIdentifier(left) ? isIdentifier(right) && left.escapedText === right.escapedText : isPropertyAccessExpression(left) ? isPropertyAccessExpression(right) && equateSerializedTypeNodes(left.expression, right.expression) && equateSerializedTypeNodes(left.name, right.name) : (
          // `void 0`
          isVoidExpression(left) ? isVoidExpression(right) && isNumericLiteral(left.expression) && left.expression.text === "0" && isNumericLiteral(right.expression) && right.expression.text === "0" : (
            // `"undefined"` or `"function"` in `typeof` checks
            isStringLiteral(left) ? isStringLiteral(right) && left.text === right.text : (
              // used in `typeof` checks for fallback
              isTypeOfExpression(left) ? isTypeOfExpression(right) && equateSerializedTypeNodes(left.expression, right.expression) : (
                // parens in `typeof` checks with temps
                isParenthesizedExpression(left) ? isParenthesizedExpression(right) && equateSerializedTypeNodes(left.expression, right.expression) : (
                  // conditionals used in fallback
                  isConditionalExpression(left) ? isConditionalExpression(right) && equateSerializedTypeNodes(left.condition, right.condition) && equateSerializedTypeNodes(left.whenTrue, right.whenTrue) && equateSerializedTypeNodes(left.whenFalse, right.whenFalse) : (
                    // logical binary and assignments used in fallback
                    isBinaryExpression(left) ? isBinaryExpression(right) && left.operatorToken.kind === right.operatorToken.kind && equateSerializedTypeNodes(left.left, right.left) && equateSerializedTypeNodes(left.right, right.right) : false
                  )
                )
              )
            )
          )
        )
      )
    );
  }
  function serializeTypeReferenceNode(node) {
    const kind = resolver.getTypeReferenceSerializationKind(node.typeName, currentNameScope ?? currentLexicalScope);
    switch (kind) {
      case 0 /* Unknown */:
        if (findAncestor(node, (n) => n.parent && isConditionalTypeNode(n.parent) && (n.parent.trueType === n || n.parent.falseType === n))) {
          return factory2.createIdentifier("Object");
        }
        const serialized = serializeEntityNameAsExpressionFallback(node.typeName);
        const temp = factory2.createTempVariable(hoistVariableDeclaration);
        return factory2.createConditionalExpression(
          factory2.createTypeCheck(factory2.createAssignment(temp, serialized), "function"),
          /*questionToken*/
          void 0,
          temp,
          /*colonToken*/
          void 0,
          factory2.createIdentifier("Object")
        );
      case 1 /* TypeWithConstructSignatureAndValue */:
        return serializeEntityNameAsExpression(node.typeName);
      case 2 /* VoidNullableOrNeverType */:
        return factory2.createVoidZero();
      case 4 /* BigIntLikeType */:
        return getGlobalConstructor("BigInt", 7 /* ES2020 */);
      case 6 /* BooleanType */:
        return factory2.createIdentifier("Boolean");
      case 3 /* NumberLikeType */:
        return factory2.createIdentifier("Number");
      case 5 /* StringLikeType */:
        return factory2.createIdentifier("String");
      case 7 /* ArrayLikeType */:
        return factory2.createIdentifier("Array");
      case 8 /* ESSymbolType */:
        return getGlobalConstructor("Symbol", 2 /* ES2015 */);
      case 10 /* TypeWithCallSignature */:
        return factory2.createIdentifier("Function");
      case 9 /* Promise */:
        return factory2.createIdentifier("Promise");
      case 11 /* ObjectType */:
        return factory2.createIdentifier("Object");
      default:
        return Debug.assertNever(kind);
    }
  }
  function createCheckedValue(left, right) {
    return factory2.createLogicalAnd(
      factory2.createStrictInequality(factory2.createTypeOfExpression(left), factory2.createStringLiteral("undefined")),
      right
    );
  }
  function serializeEntityNameAsExpressionFallback(node) {
    if (node.kind === 80 /* Identifier */) {
      const copied = serializeEntityNameAsExpression(node);
      return createCheckedValue(copied, copied);
    }
    if (node.left.kind === 80 /* Identifier */) {
      return createCheckedValue(serializeEntityNameAsExpression(node.left), serializeEntityNameAsExpression(node));
    }
    const left = serializeEntityNameAsExpressionFallback(node.left);
    const temp = factory2.createTempVariable(hoistVariableDeclaration);
    return factory2.createLogicalAnd(
      factory2.createLogicalAnd(
        left.left,
        factory2.createStrictInequality(factory2.createAssignment(temp, left.right), factory2.createVoidZero())
      ),
      factory2.createPropertyAccessExpression(temp, node.right)
    );
  }
  function serializeEntityNameAsExpression(node) {
    switch (node.kind) {
      case 80 /* Identifier */:
        const name = setParent(setTextRange(parseNodeFactory.cloneNode(node), node), node.parent);
        name.original = void 0;
        setParent(name, getParseTreeNode(currentLexicalScope));
        return name;
      case 166 /* QualifiedName */:
        return serializeQualifiedNameAsExpression(node);
    }
  }
  function serializeQualifiedNameAsExpression(node) {
    return factory2.createPropertyAccessExpression(serializeEntityNameAsExpression(node.left), node.right);
  }
  function getGlobalConstructorWithFallback(name) {
    return factory2.createConditionalExpression(
      factory2.createTypeCheck(factory2.createIdentifier(name), "function"),
      /*questionToken*/
      void 0,
      factory2.createIdentifier(name),
      /*colonToken*/
      void 0,
      factory2.createIdentifier("Object")
    );
  }
  function getGlobalConstructor(name, minLanguageVersion) {
    return languageVersion < minLanguageVersion ? getGlobalConstructorWithFallback(name) : factory2.createIdentifier(name);
  }
}

// src/compiler/transformers/legacyDecorators.ts
function transformLegacyDecorators(context) {
  const {
    factory: factory2,
    getEmitHelperFactory: emitHelpers,
    hoistVariableDeclaration
  } = context;
  const resolver = context.getEmitResolver();
  const compilerOptions = context.getCompilerOptions();
  const languageVersion = getEmitScriptTarget(compilerOptions);
  const previousOnSubstituteNode = context.onSubstituteNode;
  context.onSubstituteNode = onSubstituteNode;
  let classAliases;
  return chainBundle(context, transformSourceFile);
  function transformSourceFile(node) {
    const visited = visitEachChild(node, visitor, context);
    addEmitHelpers(visited, context.readEmitHelpers());
    return visited;
  }
  function modifierVisitor(node) {
    return isDecorator(node) ? void 0 : node;
  }
  function visitor(node) {
    if (!(node.transformFlags & 33554432 /* ContainsDecorators */)) {
      return node;
    }
    switch (node.kind) {
      case 170 /* Decorator */:
        return void 0;
      case 263 /* ClassDeclaration */:
        return visitClassDeclaration(node);
      case 231 /* ClassExpression */:
        return visitClassExpression(node);
      case 176 /* Constructor */:
        return visitConstructorDeclaration(node);
      case 174 /* MethodDeclaration */:
        return visitMethodDeclaration(node);
      case 178 /* SetAccessor */:
        return visitSetAccessorDeclaration(node);
      case 177 /* GetAccessor */:
        return visitGetAccessorDeclaration(node);
      case 172 /* PropertyDeclaration */:
        return visitPropertyDeclaration(node);
      case 169 /* Parameter */:
        return visitParameterDeclaration(node);
      default:
        return visitEachChild(node, visitor, context);
    }
  }
  function visitClassDeclaration(node) {
    if (!(classOrConstructorParameterIsDecorated(
      /*useLegacyDecorators*/
      true,
      node
    ) || childIsDecorated(
      /*useLegacyDecorators*/
      true,
      node
    ))) {
      return visitEachChild(node, visitor, context);
    }
    const statements = classOrConstructorParameterIsDecorated(
      /*useLegacyDecorators*/
      true,
      node
    ) ? transformClassDeclarationWithClassDecorators(node, node.name) : transformClassDeclarationWithoutClassDecorators(node, node.name);
    return singleOrMany(statements);
  }
  function decoratorContainsPrivateIdentifierInExpression(decorator) {
    return !!(decorator.transformFlags & 536870912 /* ContainsPrivateIdentifierInExpression */);
  }
  function parameterDecoratorsContainPrivateIdentifierInExpression(parameterDecorators) {
    return some(parameterDecorators, decoratorContainsPrivateIdentifierInExpression);
  }
  function hasClassElementWithDecoratorContainingPrivateIdentifierInExpression(node) {
    for (const member of node.members) {
      if (!canHaveDecorators(member))
        continue;
      const allDecorators = getAllDecoratorsOfClassElement(
        member,
        node,
        /*useLegacyDecorators*/
        true
      );
      if (some(allDecorators == null ? void 0 : allDecorators.decorators, decoratorContainsPrivateIdentifierInExpression))
        return true;
      if (some(allDecorators == null ? void 0 : allDecorators.parameters, parameterDecoratorsContainPrivateIdentifierInExpression))
        return true;
    }
    return false;
  }
  function transformDecoratorsOfClassElements(node, members) {
    let decorationStatements = [];
    addClassElementDecorationStatements(
      decorationStatements,
      node,
      /*isStatic*/
      false
    );
    addClassElementDecorationStatements(
      decorationStatements,
      node,
      /*isStatic*/
      true
    );
    if (hasClassElementWithDecoratorContainingPrivateIdentifierInExpression(node)) {
      members = setTextRange(
        factory2.createNodeArray([
          ...members,
          factory2.createClassStaticBlockDeclaration(
            factory2.createBlock(
              decorationStatements,
              /*multiLine*/
              true
            )
          )
        ]),
        members
      );
      decorationStatements = void 0;
    }
    return { decorationStatements, members };
  }
  function transformClassDeclarationWithoutClassDecorators(node, name) {
    const modifiers = visitNodes2(node.modifiers, modifierVisitor, isModifier);
    const heritageClauses = visitNodes2(node.heritageClauses, visitor, isHeritageClause);
    let members = visitNodes2(node.members, visitor, isClassElement);
    let decorationStatements = [];
    ({ members, decorationStatements } = transformDecoratorsOfClassElements(node, members));
    const updated = factory2.updateClassDeclaration(
      node,
      modifiers,
      name,
      /*typeParameters*/
      void 0,
      heritageClauses,
      members
    );
    return addRange([updated], decorationStatements);
  }
  function transformClassDeclarationWithClassDecorators(node, name) {
    const isExport = hasSyntacticModifier(node, 32 /* Export */);
    const isDefault = hasSyntacticModifier(node, 2048 /* Default */);
    const modifiers = visitNodes2(node.modifiers, (node2) => isExportOrDefaultModifier(node2) || isDecorator(node2) ? void 0 : node2, isModifierLike);
    const location = moveRangePastModifiers(node);
    const classAlias = getClassAliasIfNeeded(node);
    const declName = languageVersion < 2 /* ES2015 */ ? factory2.getInternalName(
      node,
      /*allowComments*/
      false,
      /*allowSourceMaps*/
      true
    ) : factory2.getLocalName(
      node,
      /*allowComments*/
      false,
      /*allowSourceMaps*/
      true
    );
    const heritageClauses = visitNodes2(node.heritageClauses, visitor, isHeritageClause);
    let members = visitNodes2(node.members, visitor, isClassElement);
    let decorationStatements = [];
    ({ members, decorationStatements } = transformDecoratorsOfClassElements(node, members));
    const assignClassAliasInStaticBlock = languageVersion >= 9 /* ES2022 */ && !!classAlias && some(members, (member) => isPropertyDeclaration(member) && hasSyntacticModifier(member, 256 /* Static */) || isClassStaticBlockDeclaration(member));
    if (assignClassAliasInStaticBlock) {
      members = setTextRange(
        factory2.createNodeArray([
          factory2.createClassStaticBlockDeclaration(
            factory2.createBlock([
              factory2.createExpressionStatement(
                factory2.createAssignment(classAlias, factory2.createThis())
              )
            ])
          ),
          ...members
        ]),
        members
      );
    }
    const classExpression = factory2.createClassExpression(
      modifiers,
      name && isGeneratedIdentifier(name) ? void 0 : name,
      /*typeParameters*/
      void 0,
      heritageClauses,
      members
    );
    setOriginalNode(classExpression, node);
    setTextRange(classExpression, location);
    const varInitializer = classAlias && !assignClassAliasInStaticBlock ? factory2.createAssignment(classAlias, classExpression) : classExpression;
    const varDecl = factory2.createVariableDeclaration(
      declName,
      /*exclamationToken*/
      void 0,
      /*type*/
      void 0,
      varInitializer
    );
    setOriginalNode(varDecl, node);
    const varDeclList = factory2.createVariableDeclarationList([varDecl], 1 /* Let */);
    const varStatement = factory2.createVariableStatement(
      /*modifiers*/
      void 0,
      varDeclList
    );
    setOriginalNode(varStatement, node);
    setTextRange(varStatement, location);
    setCommentRange(varStatement, node);
    const statements = [varStatement];
    addRange(statements, decorationStatements);
    addConstructorDecorationStatement(statements, node);
    if (isExport) {
      if (isDefault) {
        const exportStatement = factory2.createExportDefault(declName);
        statements.push(exportStatement);
      } else {
        const exportStatement = factory2.createExternalModuleExport(factory2.getDeclarationName(node));
        statements.push(exportStatement);
      }
    }
    return statements;
  }
  function visitClassExpression(node) {
    return factory2.updateClassExpression(
      node,
      visitNodes2(node.modifiers, modifierVisitor, isModifier),
      node.name,
      /*typeParameters*/
      void 0,
      visitNodes2(node.heritageClauses, visitor, isHeritageClause),
      visitNodes2(node.members, visitor, isClassElement)
    );
  }
  function visitConstructorDeclaration(node) {
    return factory2.updateConstructorDeclaration(
      node,
      visitNodes2(node.modifiers, modifierVisitor, isModifier),
      visitNodes2(node.parameters, visitor, isParameter),
      visitNode(node.body, visitor, isBlock)
    );
  }
  function finishClassElement(updated, original) {
    if (updated !== original) {
      setCommentRange(updated, original);
      setSourceMapRange(updated, moveRangePastModifiers(original));
    }
    return updated;
  }
  function v"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAccessor = isAccessor;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassAccessorProperty = isClassAccessorProperty;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportExpression = isImportExpression;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportOrExportDeclaration = isImportOrExportDeclaration;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInstantiationExpression = isTSInstantiationExpression;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require("../../utils/shallowEqual.js");
var _deprecationWarning = require("../../utils/deprecationWarning.js");
function isArrayExpression(node, opts) {
  if (!node) return false;
  if (node.type !== "ArrayExpression") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isAssignmentExpression(node, opts) {
  if (!node) return false;
  if (node.type !== "AssignmentExpression") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBinaryExpression(node, opts) {
  if (!node) return false;
  if (node.type !== "BinaryExpression") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isInterpreterDirective(node, opts) {
  if (!node) return false;
  if (node.type !== "InterpreterDirective") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDirective(node, opts) {
  if (!node) return false;
  if (node.type !== "Directive") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  if (node.type !== "DirectiveLiteral") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBlockStatement(node, opts) {
  if (!node) return false;
  if (node.type !== "BlockStatement") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isBreakStatement(node, opts) {
  if (!node) return false;
  if (node.type !== "BreakStatement") return false;
  return opts == null || (0, _shallowEqual.default)(node, opts);
}
function isCallExpression(no{"version":3,"file":"const.js","sourceRoot":"","sources":["../../../lib/vocabularies/validation/const.ts"],"names":[],"mappings":";;AAEA,mDAAuC;AACvC,6CAA0C;AAC1C,+CAAuC;AAIvC,MAAM,KAAK,GAA2B;IACpC,OAAO,EAAE,2BAA2B;IACpC,MAAM,EAAE,CAAC,EAAC,UAAU,EAAC,EAAE,EAAE,CAAC,IAAA,WAAC,EAAA,kBAAkB,UAAU,GAAG;CAC3D,CAAA;AAED,MAAM,GAAG,GAA0B;IACjC,OAAO,EAAE,OAAO;IAChB,KAAK,EAAE,IAAI;IACX,KAAK;IACL,IAAI,CAAC,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,MAAM,EAAC,GAAG,GAAG,CAAA;QAClD,IAAI,KAAK,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM,IAAI,QAAQ,CAAC,EAAE;YAClD,GAAG,CAAC,SAAS,CAAC,IAAA,WAAC,EAAA,IAAI,IAAA,cAAO,EAAC,GAAG,EAAE,eAAK,CAAC,IAAI,IAAI,KAAK,UAAU,GAAG,CAAC,CAAA;SAClE;aAAM;YACL,GAAG,CAAC,IAAI,CAAC,IAAA,WAAC,EAAA,GAAG,MAAM,QAAQ,IAAI,EAAE,CAAC,CAAA;SACnC;IACH,CAAC;CACF,CAAA;AAED,kBAAe,GAAG,CAAA"}                                                                                                                                                                                                                                 eact-app/node_modules/caniuse-lite/data/features/viewport-units.js
           Kc hUc KcPK     SXce@  S  C $           0CNWEB/react-app/node_modules/caniuse-lite/data/features/wai-aria.js
          QKc hUcF%KcPK     SX:tX  ~  D $           0CNWEB/react-app/node_modules/caniuse-lite/data/features/wake-lock.js
          QKc hUc`a+KcPK     SXpAg    ? $           \0CNWEB/react-app/node_modules/caniuse-lite/data/features/wasm.js
          QKc hUc3KcPK     SXqz
9  R  > $            !0CNWEB/react-app/node_modules/caniuse-lite/data/features/wav.js
          QKc hUc:KcPK     SXJ  h  F $           #0CNWEB/react-app/node_modules/caniuse-lite/data/features/wbr-element.js
          QKc hUc7?KcPK     SXd    H $           c&0CNWEB/react-app/node_modules/caniuse-lite/data/features/web-animation.js
          QKc hUcFKcPK     SX(i  r  K $           W)0CNWEB/react-app/node_modules/caniuse-lite/data/features/web-app-manifest.js
          QKc hUcyNKcPK     SXRh[}[    H $           ),0CNWEB/react-app/node_modules/caniuse-lite/data/features/web-bluetooth.js
          QKc hUcSKcPK     SX)RJD  Q  E $           .0CNWEB/react-app/node_modules/caniuse-lite/data/features/web-serial.js
          QKc hUc ]KcPK     SX~e    D $           10CNWEB/react-app/node_modules/caniuse-lite/data/features/web-share.js
          QKc hUcfKcPK     SXHw    C $           X40CNWEB/react-app/node_modules/caniuse-lite/data/features/webauthn.js
          QKc hUc@lKcPK     SX%B  ]  D $           070CNWEB/react-app/node_modules/caniuse-lite/data/features/webcodecs.js
          QKc hUcsKcPK     SXArh    @ $           90CNWEB/react-app/node_modules/caniuse-lite/data/features/webgl.js
          QKc hUczKcPK     SX-h    A $           <0CNWEB/react-app/node_modules/caniuse-lite/data/features/webgl2.js
          QKc hUc [KcPK     SX0#a    A $           a?0CNWEB/react-app/node_modules/caniuse-lite/data/features/webgpu.js
          QKc hUcKcPK     SXp@  M  A $           !B0CNWEB/react-app/node_modules/caniuse-lite/data/features/webhid.js
          QKc hUc#KcPK     SXPE  S  K $           D0CNWEB/react-app/node_modules/caniuse-lite/data/features/webkit-user-drag.js
          QKc hUc KcPK     SX fT    ? $           nG0CNWEB/react-app/node_modules/caniuse-lite/data/features/webm.js
          QKc hUcKcPK     SXZ}46  =  A $           PJ0CNWEB/react-app/node_modules/caniuse-lite/data/features/webnfc.js
          QKc hUc KcPK     SXn    ? $           L0CNWEB/react-app/node_modules/caniuse-lite/data/features/webp.js
          QKc hUcKcPK     SXHS    E $           O0CNWEB/react-app/node_modules/caniuse-lite/data/features/websockets.js
          QKc hUcKcPK     SXVM  Y  G $           fR0CNWEB/react-app/node_modules/caniuse-lite/data/features/webtransport.js
          QKc hUc KcPK     SX?  N  A $           U0CNWEB/react-app/node_modules/caniuse-lite/data/features/webusb.js
          QKc hUcKcPK     SXV  \  @ $           W0CNWEB/react-app/node_modules/caniuse-lite/data/features/webvr.js
          QKc hUcKcPK     SXd    A $           jZ0CNWEB/react-app/node_modules/caniuse-lite/data/features/webvtt.js
          QKc hUc@KcPK     SX%*2  ]  E $           -]0CNWEB/react-app/node_modules/caniuse-lite/data/features/webworkers.js
          QKc hUcKcPK     SXsV  ~  @ $           _0CNWEB/react-app/node_modules/caniuse-lite/data/features/webxr.js
          QKc hUcaKcPK     SX4	L  l  F $           vb0CNWEB/react-app/node_modules/caniuse-lite/data/features/will-change.js
          QKc hUc KcPK     SXH  o  ? $           &e0CNWEB/react-app/node_modules/caniuse-lite/data/features/woff.js
          QKc hUcKcPK     SX{+>R  s  @ $           g0CNWEB/react-app/node_modules/caniuse-lite/data/features/woff2.js
          QKc hUc mKcPK     SX'LG  [  E $           {j0CNWEB/react-app/node_modules/caniuse-lite/data/features/word-break.js
          QKc hUcKcPK     SXiI  v  C $           %m0CNWEB/react-app/node_modules/caniuse-lite/data/features/wordwrap.js
          QKc hUc KcPK     SXA  V  J $           o0CNWEB/react-app/node_modules/caniuse-lite/data/features/x-doc-messaging.js
          QKc hUcKcPK     SXS*a    J $           xr0CNWEB/react-app/node_modules/caniuse-lite/data/features/x-frame-options.js
          QKc hUc`KcPK     SX+N{    ? $           Au0CNWEB/react-app/node_modules/caniuse-lite/data/features/xhr2.js
          QKc hUc%KcPK     SX[;  G  @ $           x0CNWEB/react-app/node_modules/caniuse-lite/data/features/xhtml.js
          QKc hUc.KcPK     SX2!54  <  D $           z0CNWEB/react-app/node_modules/caniuse-lite/data/features/xhtmlsmil.js
          QKc hUc 4KcPK     SX`    I $           H}0CNWEB/react-app/node_modules/caniuse-lite/data/features/xml-serializer.js
          QKc hUc?KcPK     SXtB  M  ? $           0CNWEB/react-app/node_modules/caniuse-lite/data/features/zstd.js
          Kc hUc@"aKcPK 
     hSX            7 $          0CNWEB/react-app/node_modules/caniuse-lite/data/regions/
          xKc hb@wKcPK     kSXbtE  V  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AD.js
          yM|Kc hUc@XyKcPK     rSXK    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AE.js
          Kc hUc%KcPK     tSX  #  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AF.js
          Kc hUc KcPK     vSXN    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AG.js
          hjKc hUc KcPK     }SX
cx    < $           "0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AI.js
          Kc hUc KcPK     SX>,  e  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AL.js
          $Kc hUc@|KcPK     SX3An    @ $           z0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-af.js
          Kc hUc KcPK     SX2=  	  @ $           F0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-an.js
          Kc hUc ZKcPK     SX    @ $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-as.js
          Kc hUc GKcPK     SX  Q  @ $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-eu.js
          LKc hUc1KcPK     SXwZ  N  @ $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-na.js
          8}Kc hUc)KcPK     SXz  3  @ $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-oc.js
          8}Kc hUc# KcPK     SX5  n  @ $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-sa.js
          eKc hUc@KcPK     SX)?^5    @ $           J0CNWEB/react-app/node_modules/caniuse-lite/data/regions/alt-ww.js
          Kc hUc\"KcPK     SXR    < $           o0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AM.js
          AKc hUc KcPK     SXt`5  |  < $           _0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AO.js
          sKc hUc KcPK     SXzY    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AR.js
          FKc hUcKcPK     SX8&    < $           e0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AS.js
          hKc hUc@kKcPK     SX|k<  W  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AT.js
          TKc hUc`}KcPK     SX     < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AU.js
          -Kc hUcKcPK     SXy0^    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AW.js
          bKc hUcKcPK     SX1n  {  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AX.js
          bKc hUc`*RKcPK     SXKYR  Z  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/AZ.js
          bKc hUc!KcPK     SX6_h    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BA.js
          #Kc hUc5KcPK     SXD    < $           |0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BB.js
          Kc hUc JaKcPK     SX8    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BD.js
          Kc hUc`kKcPK     SXI"!  L  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BE.js
          Kc hUc*KcPK     SXM    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BF.js
          CKc hUc 1nKcPK     SXBE  b  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BG.js
          pKc hUc@KcPK     SXvK    < $           #0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BH.js
          pKc hUcf+KcPK     SXF_B    < $           C)0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BI.js
          pKc hUcsKcPK     SXw    < $           .0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BJ.js
          JKc hUcUKcPK     SXr|I  c  < $           40CNWEB/react-app/node_modules/caniuse-lite/data/regions/BM.js
          JKc hUc'KcPK     SX@    < $           80CNWEB/react-app/node_modules/caniuse-lite/data/regions/BN.js
          {Kc hUc VKcPK     SXrj    < $           >0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BO.js
          {Kc hUc`KcPK     SXxL    < $           D0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BR.js
          Kc hUcuKcPK     SXWQ    < $           J0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BS.js
          ~@Kc hUc@yKcPK     SXX    < $           O0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BT.js
          qKc hUc@!+KcPK     SX	  t  < $           U0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BW.js
          qKc hUcOKcPK     SX  N  < $           [0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BY.js
          qKc hUc!KcPK     SXa    < $           a0CNWEB/react-app/node_modules/caniuse-lite/data/regions/BZ.js
          qKc hUc #KcPK     SXp  K  < $           g0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CA.js
          Kc hUc LyKcPK     SX=H#    < $           m0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CD.js
          Kc hUc@KcPK     SXIS    < $           <s0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CF.js
          Kc hUc&KcPK     SX <9    < $           `x0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CG.js
          Kc hUc 3KcPK     SXK    < $           9}0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CH.js
          2Kc hUcKcPK     SXs	r  s  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CI.js
          _6Kc hUc/KcPK     SXdKR  5  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CK.js
          _6Kc hUc zKcPK     SX`    < $           V0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CL.js
          _6Kc hUc2KcPK     SX2  K  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CM.js
          gKc hUcKcPK     SXFX@  J  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CN.js
          gKc hUc*KcPK     SX"5    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CO.js
          gKc hUc`]KcPK     SX<    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CR.js
          Kc hUcKcPK     SX9\    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CU.js
          \zKc hUcsKcPK     SX_    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CV.js
          \zKc hUc KcPK     SXC  	  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CX.js
          \zKc hUc AKcPK     SX(!  .  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CY.js
          \zKc hUc KcPK     SXk'8[  e  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/CZ.js
          \zKc hUcKcPK     SX~tY  o  < $           N0CNWEB/react-app/node_modules/caniuse-lite/data/regions/DE.js
          \zKc hUcKcPK     SXS  N  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/DJ.js
          Kc hUcLKcPK     SXA  @  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/DK.js
          Kc hUc KcPK     SXDd|    < $           ;0CNWEB/react-app/node_modules/caniuse-lite/data/regions/DM.js
          Kc hUcKcPK     SX    < $           U0CNWEB/react-app/node_modules/caniuse-lite/data/regions/DO.js
          Kc hUcKcPK     SX(    < $           20CNWEB/react-app/node_modules/caniuse-lite/data/regions/DZ.js
          Kc hUc KcPK     SX4M  1  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/EC.js
          Kc hUcKcPK     SXjMx0  |  < $     import { createNode } from '../doc/createNode.js';
import { stringifyCollection } from '../stringify/stringifyCollection.js';
import { Collection } from './Collection.js';
import { SEQ, isScalar } from './identity.js';
import { isScalarValue } from './Scalar.js';
import { toJS } from './toJS.js';

class YAMLSeq extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

export { YAMLSeq };
           ules/caniuse-lite/data/regions/GT.js
          =pKc hUcuKcPK     SXO,    < $           |0CNWEB/react-app/node_modules/caniuse-lite/data/regions/GU.js
          =pKc hUc |KcPK     SX[3hj    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/GW.js
          =pKc hUc@KcPK     SX .    < $           v0CNWEB/react-app/node_modules/caniuse-lite/data/regions/GY.js
          =pKc hUchKcPK     SX  ]  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/HK.js
          =pKc hUc|KcPK     SX=vV    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/HN.js
          =pKc hUc`KcPK     SX@~    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/HR.js
          =pKc hUc `KcPK     SX@RU    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/HT.js
          =pKc hUcKcPK     SX'R    < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/HU.js
          =pKc hUcCKcPK     SXnXi    < $           t0CNWEB/react-app/node_modules/caniuse-lite/data/regions/ID.js
          =pKc hUc KKcPK     SXDuc  *  < $           0CNWEB/react-app/node_modules/caniuse-lite/data/regions/IE.js
          =pKc hUc`LVKcPK 