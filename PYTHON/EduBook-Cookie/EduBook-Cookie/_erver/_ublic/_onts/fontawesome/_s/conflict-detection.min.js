  this.inner.trackExternalModuleSymbolOfImportTypeNode(symbol);
    }
  }
  reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol) {
    var _a;
    if ((_a = this.inner) == null ? void 0 : _a.reportNonlocalAugmentation) {
      this.onDiagnosticReported();
      this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);
    }
  }
  reportNonSerializableProperty(propertyName) {
    var _a;
    if ((_a = this.inner) == null ? void 0 : _a.reportNonSerializableProperty) {
      this.onDiagnosticReported();
      this.inner.reportNonSerializableProperty(propertyName);
    }
  }
  onDiagnosticReported() {
    this.context.reportedDiagnostic = true;
  }
};

// src/compiler/visitorPublic.ts
function visitNode(node, visitor, test, lift) {
  if (node === void 0) {
    return node;
  }
  const visited = visitor(node);
  let visitedNode;
  if (visited === void 0) {
    return void 0;
  } else if (isArray(visited)) {
    visitedNode = (lift || extractSingleNode)(visited);
  } else {
    visitedNode = visited;
  }
  Debug.assertNode(visitedNode, test);
  return visitedNode;
}
function visitNodes2(nodes, visitor, test, start2, count) {
  if (nodes === void 0) {
    return nodes;
  }
  const length2 = nodes.length;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (count === void 0 || count > length2 - start2) {
    count = length2 - start2;
  }
  let hasTrailingComma;
  let pos = -1;
  let end = -1;
  if (start2 > 0 || count < length2) {
    hasTrailingComma = nodes.hasTrailingComma && start2 + count === length2;
  } else {
    pos = nodes.pos;
    end = nodes.end;
    hasTrailingComma = nodes.hasTrailingComma;
  }
  const updated = visitArrayWorker(nodes, visitor, test, start2, count);
  if (updated !== nodes) {
    const updatedArray = factory.createNodeArray(updated, hasTrailingComma);
    setTextRangePosEnd(updatedArray, pos, end);
    return updatedArray;
  }
  return nodes;
}
function visitArray(nodes, visitor, test, start2, count) {
  if (nodes === void 0) {
    return nodes;
  }
  const length2 = nodes.length;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (count === void 0 || count > length2 - start2) {
    count = length2 - start2;
  }
  return visitArrayWorker(nodes, visitor, test, start2, count);
}
function visitArrayWorker(nodes, visitor, test, start2, count) {
  let updated;
  const length2 = nodes.length;
  if (start2 > 0 || count < length2) {
    updated = [];
  }
  for (let i = 0; i < count; i++) {
    const node = nodes[i + start2];
    const visited = node !== void 0 ? visitor ? visitor(node) : node : void 0;
    if (updated !== void 0 || visited === void 0 || visited !== node) {
      if (updated === void 0) {
        updated = nodes.slice(0, i);
        Debug.assertEachNode(updated, test);
      }
      if (visited) {
        if (isArray(visited)) {
          for (const visitedNode of visited) {
            Debug.assertNode(visitedNode, test);
            updated.push(visitedNode);
          }
        } else {
          Debug.assertNode(visited, test);
          updated.push(visited);
        }
      }
    }
  }
  if (updated) {
    return updated;
  }
  Debug.assertEachNode(nodes, test);
  return nodes;
}
function visitLexicalEnvironment(statements, visitor, context, start2, ensureUseStrict, nodesVisitor = visitNodes2) {
  context.startLexicalEnvironment();
  statements = nodesVisitor(statements, visitor, isStatement, start2);
  if (ensureUseStrict)
    statements = context.factory.ensureUseStrict(statements);
  return factory.mergeLexicalEnvironment(statements, context.endLexicalEnvironment());
}
function visitParameterList(nodes, visitor, context, nodesVisitor = visitNodes2) {
  let updated;
  context.startLexicalEnvironment();
  if (nodes) {
    context.setLexicalEnvironmentFlags(1 /* InParameters */, true);
    updated = nodesVisitor(nodes, visitor, isParameter);
    if (context.getLexicalEnvironmentFlags() & 2 /* VariablesHoistedInParameters */ && getEmitScriptTarget(context.getCompilerOptions()) >= 2 /* ES2015 */) {
      updated = addDefaultValueAssignmentsIfNeeded(updated, context);
    }
    context.setLexicalEnvironmentFlags(1 /* InParameters */, false);
  }
  context.suspendLexicalEnvironment();
  return updated;
}
function addDefaultValueAssignmentsIfNeeded(parameters, context) {
  let result;
  for (let i = 0; i < parameters.length; i++) {
    const parameter = parameters[i];
    const updated = addDefaultValueAssignmentIfNeeded(parameter, context);
    if (result || updated !== parameter) {
      if (!result)
        result = parameters.slice(0, i);
      result[i] = updated;
    }
  }
  if (result) {
    return setTextRange(context.factory.createNodeArray(result, parameters.hasTrailingComma), parameters);
  }
  return parameters;
}
function addDefaultValueAssignmentIfNeeded(parameter, context) {
  return parameter.dotDotDotToken ? parameter : isBindingPattern(parameter.name) ? addDefaultValueAssignmentForBindingPattern(parameter, context) : parameter.initializer ? addDefaultValueAssignmentForInitializer(parameter, parameter.name, parameter.initializer, context) : parameter;
}
function addDefaultValueAssignmentForBindingPattern(parameter, context) {
  const { factory: factory2 } = context;
  context.addInitializationStatement(
    factory2.createVariableStatement(
      /*modifiers*/
      void 0,
      factory2.createVariableDeclarationList([
        factory2.createVariableDeclaration(
          parameter.name,
          /*exclamationToken*/
          void 0,
          parameter.type,
          parameter.initializer ? factory2.createConditionalExpression(
            factory2.createStrictEquality(
              factory2.getGeneratedNameForNode(parameter),
              factory2.createVoidZero()
            ),
            /*questionToken*/
            void 0,
            parameter.initializer,
            /*colonToken*/
            void 0,
            factory2.getGeneratedNameForNode(parameter)
          ) : factory2.getGeneratedNameForNode(parameter)
        )
      ])
    )
  );
  return factory2.updateParameterDeclaration(
    parameter,
    parameter.modifiers,
    parameter.dotDotDotToken,
    factory2.getGeneratedNameForNode(parameter),
    parameter.questionToken,
    parameter.type,
    /*initializer*/
    void 0
  );
}
function addDefaultValueAssignmentForInitializer(parameter, name, initializer, context) {
  const factory2 = context.factory;
  context.addInitializationStatement(
    factory2.createIfStatement(
      factory2.createTypeCheck(factory2.cloneNode(name), "undefined"),
      setEmitFlags(
        setTextRange(
          factory2.createBlock([
            factory2.createExpressionStatement(
              setEmitFlags(
                setTextRange(
                  factory2.createAssignment(
                    setEmitFlags(factory2.cloneNode(name), 96 /* NoSourceMap */),
                    setEmitFlags(initializer, 96 /* NoSourceMap */ | getEmitFlags(initializer) | 3072 /* NoComments */)
                  ),
                  parameter
                ),
                3072 /* NoComments */
              )
            )
          ]),
          parameter
        ),
        1 /* SingleLine */ | 64 /* NoTrailingSourceMap */ | 768 /* NoTokenSourceMaps */ | 3072 /* NoComments */
      )
    )
  );
  return factory2.updateParameterDeclaration(
    parameter,
    parameter.modifiers,
    parameter.dotDotDotToken,
    parameter.name,
    parameter.questionToken,
    parameter.type,
    /*initializer*/
    void 0
  );
}
function visitFunctionBody(node, visitor, context, nodeVisitor = visitNode) {
  context.resumeLexicalEnvironment();
  const updated = nodeVisitor(node, visitor, isConciseBody);
  const declarations = context.endLexicalEnvironment();
  if (some(declarations)) {
    if (!updated) {
      return context.factory.createBlock(declarations);
    }
    const block = context.factory.converters.convertToFunctionBlock(updated);
    const statements = factory.mergeLexicalEnvironment(block.statements, declarations);
    return context.factory.updateBlock(block, statements);
  }
  return updated;
}
function visitIterationBody(body, visitor, context, nodeVisitor = visitNode) {
  context.startBlockScope();
  const updated = nodeVisitor(body, visitor, isStatement, context.factory.liftToBlock);
  Debug.assert(updated);
  const declarations = context.endBlockScope();
  if (some(declarations)) {
    if (isBlock(updated)) {
      declarations.push(...updated.statements);
      return context.factory.updateBlock(updated, declarations);
    }
    declarations.push(updated);
    return context.factory.createBlock(declarations);
  }
  return updated;
}
function visitCommaListElements(elements, visitor, discardVisitor = visitor) {
  if (discardVisitor === visitor || elements.length <= 1) {
    return visitNodes2(elements, visitor, isExpression);
  }
  let i = 0;
  const length2 = elements.length;
  return visitNodes2(elements, (node) => {
    const discarded = i < length2 - 1;
    i++;
    return discarded ? discardVisitor(node) : visitor(node);
  }, isExpression);
}
function visitEachChild(node, visitor, context = nullTransformationContext, nodesVisitor = visitNodes2, tokenVisitor, nodeVisitor = visitNode) {
  if (node === void 0) {
    return void 0;
  }
  const fn = visitEachChildTable[node.kind];
  return fn === void 0 ? node : fn(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor);
}
var visitEachChildTable = {
  [166 /* QualifiedName */]: function visitEachChildOfQualifiedName(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
    return context.factory.updateQualifiedName(
      node,
      Debug.checkDefined(nodeVisitor(node.left, visitor, isEntityName)),
      Debug.checkDefined(nodeVisitor(node.right, visitor, isIdentifier))
    );
  },
  [167 /* ComputedPropertyName */]: function visitEachChildOfComputedPropertyName(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
    return context.factory.updateComputedPropertyName(
      node,
      Debug.checkDefined(nodeVisitor(node.expression, visitor, isExpression))
    );
  },
  // Signature elements
  [168 /* TypeParameter */]: function visitEachChildOfTypeParameterDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
    return context.factory.updateTypeParameterDeclaration(
      node,
      nodesVisitor(node.modifiers, visitor, isModifier),
      Debug.checkDefined(nodeVisitor(node.name, visitor, isIdentifier)),
      nodeVisitor(node.constraint, visitor, isTypeNode),
      nodeVisitor(node.default, visitor, isTypeNode)
    );
  },
  [169 /* Parameter */]: function visitEachChildOfParameterDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
    return context.factory.updateParameterDeclaration(
      node,
      nodesVisitor(node.modifiers, visitor, isModifierLike),
      tokenVisitor ? nodeVisitor(node.dotDotDotToken, tokenVisitor, isDotDotDotToken) : node.dotDotDotToken,
      Debug.checkDefined(nodeVisitor(node.name, visitor, isBindingName)),
      tokenVisitor ? nodeVisitor(node.questionToken, tokenVisitor, isQuestionToken) : node.questionToken,
      nodeVisitor(node.type, visitor, isTypeNode),
      nodeVisitor(node.initializer, visitor, isExpression)
    );
  },
  [170 /* Decorator */]: function visitEachChildOfDecorator(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
    return context.factory.updateDecorator(
      node,
      Debug.checkDefined(nodeVisitor(node.expression, visitor, isExpression))
    );
  },
  // Type elements
  [171 /* PropertySignature */]: function visitEachChildOfPropertySignature(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
    return context.factory.updatePropertySignature(
      node,
      nodesVisitor(node.modifiers, visitor, isModifier),
      Debug.checkDefined(nodeVisitor(node.name, visitor, isPropertyName)),
      tokenVisitor ? nodeVisitor(node.questionToken, tokenVisitor, isQuestionToken) : node.questionToken,
      nodeVisitor(node.type, visitor, isTypeNode)
    );
  },
  [172 /* PropertyDeclaration */]: function visitEachChildOfPropertyDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
    return context.factory.updatePropertyDeclaration(
      node,
      nodesVisitor(node.modifiers, visitor, isModifierLike),
      Debug.checkDefined(nodeVisitor(node.name, visitor, isPropertyName)),
      // QuestionToken and ExclamationToken are mutually exclusive in PropertyDeclaration
      tokenVisitor ? nodeVisitor(node.questionToken ?? node.exclamationToken, tokenVisitor, isQuestionOrExclamationToken) : node.questionToken ?? node.exclamationToken,
      nodeVisitor(node.type, visitor, isTypeNode),
      nodeVisitor(node.initializer, visitor, isExpression)
    );
  },
  [173 /* MethodSignature */]: function visitEachChildOfMethodSignature(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
    return context.factory.updateMethodSignature(
      node,
      nodesVisitor(node.modifiers, visitor, isModifier),
      Debug.checkDefined(nodeVisitor(node.name, visitor, isPropertyName)),
      tokenVisitor ? nodeVisitor(node.questionToken, tokenVisitor, isQuestionToken) : node.questionToken,
      nodesVisitor(node.typeParameters, visitor, isTypeParameterDeclaration),
      nodesVisitor(node.parameters, visitor, isParameter),
      nodeVisitor(node.type, visitor, isTyp