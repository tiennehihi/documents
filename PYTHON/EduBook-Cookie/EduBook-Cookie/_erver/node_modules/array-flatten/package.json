 return cleanup(
                /*result*/
                void 0
              );
            }
            let introducesError;
            ({ introducesError, node: expr } = trackExistingEntityName(expr, context, includePrivateSymbol));
            if (introducesError) {
              return cleanup(
                /*result*/
                void 0
              );
            }
          }
          return cleanup(factory.createExpressionWithTypeArguments(
            expr,
            map(e.typeArguments, (a) => serializeExistingTypeNode(context, a, includePrivateSymbol, bundled) || typeToTypeNodeHelper(getTypeFromTypeNode(a), context))
          ));
          function cleanup(result2) {
            context.enclosingDeclaration = oldEnclosing;
            return result2;
          }
        });
        if (result.length === clauses.length) {
          return result;
        }
        return void 0;
      }
      function serializeAsClass(symbol, localName, modifierFlags) {
        var _a2, _b;
        const originalDecl = (_a2 = symbol.declarations) == null ? void 0 : _a2.find(isClassLike);
        const oldEnclosing = context.enclosingDeclaration;
        context.enclosingDeclaration = originalDecl || oldEnclosing;
        const localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
        const typeParamDecls = map(localParams, (p) => typeParameterToDeclaration(p, context));
        const classType = getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol));
        const baseTypes = getBaseTypes(classType);
        const originalImplements = originalDecl && getEffectiveImplementsTypeNodes(originalDecl);
        const implementsExpressions = originalImplements && sanitizeJS