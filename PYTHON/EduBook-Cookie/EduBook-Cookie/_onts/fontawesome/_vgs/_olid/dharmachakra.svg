import * as ts from 'typescript';
import { TSError } from './node-utils';
import { ParserWeakMap, ParserWeakMapESTreeToTSNode } from './parser-options';
import { SemanticOrSyntacticError } from './semantic-or-syntactic-errors';
import { TSESTree, TSNode } from './ts-estree';
interface ConverterOptions {
    errorOnUnknownASTType: boolean;
    shouldPreserveNodeMaps: boolean;
}
/**
 * Extends and formats a given error object
 * @param error the error object
 * @returns converted error object
 */
export declare function convertError(error: ts.DiagnosticWithLocation | SemanticOrSyntacticError): TSError;
export interface ASTMaps {
    esTreeNodeToTSNodeMap: ParserWeakMapESTreeToTSNode;
    tsNodeToESTreeNodeMap: ParserWeakMap<TSNode, TSESTree.Node>;
}
export declare class Converter {
    private readonly ast;
    private readonly options;
    private readonly esTreeNodeToTSNodeMap;
    private readonly tsNodeToESTreeNodeMap;
    private allowPattern;
    private inTypeMode;
    /**
     * Converts a TypeScript node into an ESTree node
     * @param ast the full TypeScript AST
     * @param options additional options for the conversion
     * @returns the converted ESTreeNode
     */
    constructor(ast: ts.SourceFile, options: ConverterOptions);
    getASTMaps(): ASTMaps;
    convertProgram(): TSESTree.Program;
    /**
     * Converts a TypeScript node into an ESTree node.
     * @param node the child ts.Node
     * @param parent parentNode
     * @param inTypeMode flag to determine if we are in typeMode
     * @param allowPattern flag to determine if patterns are allowed
     * @returns the converted ESTree node
     */
    private converter;
    /**
     * Fixes the exports of the given ts.Node
     * @param node the ts.Node
     * @param result result
     * @returns the ESTreeNode with fixed exports
     */
    private fixExports;
    /**
     * Register specific TypeScript node into map with first ESTree node provided
     */
    private registerTSN